/** \brief AUTOSAR Icu Driver
 **
 ** This file contains the implementation of the AUTOSAR module Icu
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */
/*==================[inclusions]=============================================*/
#include <Icu.h>
#include <SchM_Icu.h>
#include <Icu_Channel.h>
#include <Icu_Internal.h>
#include <Icu_Channel_EdgeCount.h>
#include <Icu_Channel_SignalEdgeDetection.h>
#include <Icu_Channel_SignalMeasurement.h>
#include <Icu_Channel_TimeStamp.h>
#include <Icu_Det.h>
#if ICU_DEM_E_HW_ERROR == STD_ON
#include <Dem.h>
#endif /* #if ICU_DEM_E_HW_ERROR == STD_ON */
#include <Icu_Cfg_Include.h>  /* External include file */

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/
#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>

#if (ICU_SET_MODE_API == STD_ON)
/** \brief Icu_CheckDriverBusy
 **
 ** This function checks whether driver is busy or not.
 **
 **
 ** \param[in] ConfigPtr Configuration pointer to config data.
 **
 ** \return    The return value TRUE or FALSE.
 **            TRUE        Driver is busy.
 **            FALSE       Driver is not busy.
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckDriverBusy
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr
);
#endif

/** \brief Icu_Channel_InterruptEvent_Internal
 **
 ** Internal function of the ISRs is based on different mode to call interrupt event.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntrFlag     Interrupt request flag of channel.
 ** \param[in] Mode         Icu wakeup mode, sleep or normal.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Channel_InterruptEvent_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                     IntrFlag,
  VAR(Icu_ModeType, AUTOMATIC)                              Mode
);

#if (ICU_REPORT_WAKEUP_SOURCE == STD_ON)
/** \brief Icu_ReportWakeupSource
 **
 ** The function reports wakeup sources to the Ecu Manager
 ** if wakeup capability configured.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_ReportWakeupSource
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
);
#endif

/** \brief Icu_GetConfigPtr
 **
 ** This function implements to get the pointer to ICU config.
 **
 ** \param[in] None.
 **
 ** \return    Return pointer to the ICU configuration.
 ** */
static FUNC_P2CONST(Icu_ConfigType, ICU_APPL_CONST, ICU_CODE) Icu_GetConfigPtr(void);


#if (ICU_TIMESTAMP_API == STD_ON)
/** \brief Icu_CheckStartTimeStamp
 **
 ** This function checks Icu_StartTimeStamp whether occur DET error.
 **
 **
 ** \param[in] ChannelPtr     Pointer to the channel configuration.
 ** \param[in/out] BufferPtr  Pointer to the buffer-array where the timestamp
 **                           values shall be placed.
 ** \param[in] BufferSize     Size of the external buffer (number of entries).
 ** \param[in] NotifyInterval Notification interval (number of events).
 **                           This parameter cannot be checked in a reasonable way.
 **
 ** \return    The return value TRUE or FALSE.
 **            TRUE:  Start timestamp without DET error.
 **            FALSE: Start timestamp with error.
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckStartTimeStamp
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  P2CONST(Icu_ValueType, AUTOMATIC, ICU_APPL_CONST)         BufferPtr,
  VAR(uint16, AUTOMATIC)                                    BufferSize,
  VAR(uint16, AUTOMATIC)                                    NotifyInterval
);
#endif

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[external constants]=====================================*/

/*==================[internal constants]=====================================*/

/*==================[external data]==========================================*/

/*==================[internal data]==========================================*/
#define ICU_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/* The status of ICU driver */
static VAR(Icu_DriverStatusType, ICU_VAR_INIT) Icu_DriverStatus = ICU_S_UNINITIALIZED;

/** This data is pointer to actually used configuration set */
static P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) Icu_ConfigPtr = NULL_PTR;

#define ICU_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[external function definitions]==========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/** \brief Icu_Init
 **
 ** This function initializes the ICU driver.
 ** 
 ** Preconditions:
 ** - No Init call should be done before.
 **
 ** \param[in] ConfigPtr Configuration pointer to config data.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Init
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr
)
{
  if (Icu_DriverStatus == ICU_S_INITIALIZED)
  {
    /* Icu_Init has already been called before or Icu_DeInit is not done (no REQ) */
    Icu_ReportError(ICU_API_INIT, ICU_E_ALREADY_INITIALIZED);
  }
  /* Check ConfigPtr parameter */
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    Icu_ReportError(ICU_API_INIT, ICU_E_INIT_FAILED);
  }
  else /* Call Icu_Init_Internal function */
  {
    Icu_Init_Internal(ConfigPtr);
    /* Set configuration pointer */
    Icu_ConfigPtr = ConfigPtr;
    /* Set Driver status to initialized */
    Icu_DriverStatus = ICU_S_INITIALIZED;
  }
}


#if (ICU_DE_INIT_API == STD_ON)
/** \brief Icu_DeInit
 ** 
 ** This function de-initializes the ICU driver.
 ** It checks if error detect is enabled
 ** for init was already done.
 ** It calls the function Icu_DeInit_Internal() and
 ** disable all interrupts.
 ** It sets the module variables to default and sets the internal
 ** variable Icu_DriverStatus = ICU_S_UNINITIALIZED.
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] None.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_DeInit(void)
{
  /* Get configuration pointer */
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();
  if (Icu_DriverStatus == ICU_S_UNINITIALIZED)
  {
    /* No Icu_Init was done before or Icu_DeInit already called */
    Icu_ReportError(ICU_API_DE_INIT, ICU_E_UNINIT);
  }
  else if (Icu_DriverStatus == ICU_S_LOCKED)
  {
    /* Channel is locked */
    Icu_ReportError(ICU_API_DE_INIT, ICU_E_BUSY_OPERATION);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_DriverStatus = ICU_S_UNINITIALIZED;
    Icu_ReportError(ICU_API_DE_INIT, ICU_E_UNINIT);
  }
  else /* Call Icu_DeInit_Internal function */
  {
    Icu_EnterCritiSec();

    Icu_DeInit_Internal(ConfigPtr);
    /* Set Driver status to uninitialized */
    Icu_DriverStatus = ICU_S_UNINITIALIZED;

    Icu_ExitCritiSec();
  }
}
#endif


#if (ICU_SET_MODE_API == STD_ON)
/** \brief Icu_SetMode
 **
 ** This function sets the ICU mode.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Mode ICU_MODE_NORMAL: Normal operation, all used interrupts are
 **                                  enabled according to the notification requests.
 **                 ICU_MODE_SLEEP: Reduced power mode. In sleep mode only those
 **                                 notifications are available which are configured as wakeup capable.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_SetMode
(
  VAR(Icu_ModeType, AUTOMATIC) Mode
)
{ 
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_SET_MODE, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_SET_MODE, ICU_E_UNINIT);
  }
  else if ((Mode != ICU_MODE_NORMAL) &&
           (Mode != ICU_MODE_SLEEP))
  {
    /* Parameter Mode is invalid */
    Icu_ReportError(ICU_API_SET_MODE, ICU_E_PARAM_MODE);
  }
  else
  {
    Icu_EnterCritiSec();

    /* Lock driver against all other services */
    Icu_DriverStatus = ICU_S_LOCKED;

    if (Icu_CheckDriverBusy(ConfigPtr) == TRUE)
    {
      /* Unlock driver, it's now save for other services to run */
      /* Note: driver was initialized before locking, so unlock means initialized */
      Icu_DriverStatus = ICU_S_INITIALIZED;

      Icu_ExitCritiSec();

      Icu_ReportError(ICU_API_SET_MODE, ICU_E_BUSY_OPERATION);
    }
    else if (Icu_CheckWaitTrigger(ConfigPtr) == TRUE)
    {
      /* Unlock driver, it's now save for other services to run */
      /* Note: driver was initialized before locking, so unlock means initialized */
      Icu_DriverStatus = ICU_S_INITIALIZED;

      Icu_ExitCritiSec();
      /* Wait start or stop trigger */
      Icu_ReportError(ICU_API_SET_MODE, ICU_E_WAITING_TRIGGER);
    }
    else /* Call Icu_SetMode_Internal function */
    {
      Icu_SetMode_Internal(ConfigPtr, Mode, ICU_WAKEUP_ACCEPTANCE_IN_SETMODE);

      /* Unlock driver, it's now save for other services to run */
      /* Note: driver was initialized before locking, so unlock means initialized */
      Icu_DriverStatus = ICU_S_INITIALIZED;

      Icu_ExitCritiSec();
    }

  }
}
#endif


#if (ICU_DISABLE_WAKEUP_API == STD_ON)
/** \brief Icu_DisableWakeup
 **
 ** This function disables the wakeup capability of a single ICU channel.
 ** 
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_DisableWakeup
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_DISABLE_WAKEUP, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_DISABLE_WAKEUP, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
  /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_DISABLE_WAKEUP, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_DISABLE_WAKEUP, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->WakeupCapability != TRUE)
    {
      /* ICU channel not configured for wakeup */
      Icu_ReportError(ICU_API_DISABLE_WAKEUP, ICU_E_PARAM_CHANNEL);
    }
    else /* Call Icu_SetWakeup_Internal function */
    {
      Icu_SetWakeup_Internal(ChPtr, FALSE);
    }
  }
}
#endif


#if (ICU_ENABLE_WAKEUP_API == STD_ON)
/** \brief Icu_EnableWakeup
 **
 ** This function (re-)enables the wakeup capability of the given ICU channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_EnableWakeup
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_ENABLE_WAKEUP, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_ENABLE_WAKEUP, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_ENABLE_WAKEUP, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_ENABLE_WAKEUP, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->WakeupCapability != TRUE)
    {
      /* ICU channel not configured for wakeup */
      Icu_ReportError(ICU_API_ENABLE_WAKEUP, ICU_E_PARAM_CHANNEL);
    }
    else /* Call Icu_SetWakeup_Internal function */
    {
      Icu_SetWakeup_Internal(ChPtr, TRUE);
    }
  }
}
#endif


#if (ICU_WAKEUP_FUNCTIONALITY_API == STD_ON)
#if (ICU_REPORT_WAKEUP_SOURCE == STD_ON)
/** \brief Icu_CheckWakeup
 **
 **  This function checks if a wakeup capable ICU channel is the
 **  source for a wakeup event and calls the ECU state manager
 **  service EcuM_SetWakeupEvent in case of a valid ICU channel wakeup event. 
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 **
 ** \param[in] WakeupSource Information on wakeup source to be checked. 
 **                         The associated ICU channel can be determined from
 **                         configuration data.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_CheckWakeup
(
  VAR(EcuM_WakeupSourceType, AUTOMATIC) WakeupSource
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_CHECK_WAKEUP, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_CHECK_WAKEUP, ICU_E_UNINIT);
  }
  else
  {
    Icu_ChannelType Channel;

    for (Channel = 0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
    {
      if ((EcuM_WakeupSourceType)ConfigPtr->WakeupSourcePtr[Channel] == WakeupSource)
      {
        P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

        if (TRUE == Icu_CheckWakeup_Internal(ConfigPtr, ChPtr))
        {
          EcuM_SetWakeupEvent(WakeupSource);
        }
        
        break;
      }
    }
  }
}
#endif
#endif


/** \brief Icu_SetActivationCondition
 **
 ** This function sets the activation-edge for the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel    Numeric identifier of the ICU channel.
 ** \param[in] Activation Type of activation.
 **                       - ICU_RISING_EDGE
 **                       - ICU_FALLING_EDGE
 **                       - ICU_BOTH_EDGES
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_SetActivationCondition
(
  VAR(Icu_ChannelType, AUTOMATIC)    Channel,
  VAR(Icu_ActivationType, AUTOMATIC) Activation
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_PARAM_CHANNEL);
  }
  else if ((Activation != ICU_RISING_EDGE)  &&
           (Activation != ICU_FALLING_EDGE) &&
           (Activation != ICU_BOTH_EDGES))
  {
    /* Invalid activation mode for specified channel */
    Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_PARAM_ACTIVATION);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if ((ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP)    &&
        (ChPtr->MeasurementMode != ICU_MODE_EDGE_COUNTER) &&
        (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_EDGE_DETECT))
    {
      /* Invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_PARAM_CHANNEL);
    }
    else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      /* Wait start or stop trigger */
      Icu_ReportError(ICU_API_SET_ACTIVATION_CONDITION, ICU_E_WAITING_TRIGGER);
    }
    else /* Call Icu_SetActivationCondition_Internal function */
    {
      Icu_SetActivationCondition_Internal(ChPtr, Activation);
    }
  }
}


/** \brief Icu_DisableNotification
 **
 ** This function disables the notification of a channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 ** - Notification should have been enabled.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_DisableNotification
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_DISABLE_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_DISABLE_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_DISABLE_NOTIFICATION, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if ((ChPtr->MeasurementMode != ICU_MODE_SIGNAL_EDGE_DETECT) &&
        (ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP))
    {
      /* ICU channel not configured for edge detection mode */
      Icu_ReportError(ICU_API_DISABLE_NOTIFICATION, ICU_E_PARAM_CHANNEL);
    }
    else
    {
#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
      {
        Icu_EnterCritiSec();

        Icu_SetEdgeDetectNotification(ChPtr, FALSE, ConfigPtr->StatePtr->WakeupMode);
#if (ICU_DISABLE_NOTIAPI_CAPABLE_WAKEUP == STD_ON)
        if (ConfigPtr->StatePtr->WakeupMode != ICU_MODE_SLEEP)
        {
          if (ChPtr->WakeupCapability == TRUE)
          {
            Icu_SetWakeup_Internal(ChPtr, FALSE);
          }
        }
#endif
        Icu_ExitCritiSec();
      }
#endif
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
      {
        Icu_SetTimeStampNotification(ChPtr, FALSE);
      }
#endif
    }
  }
}


/** \brief Icu_EnableNotification
 **
 ** This function enables the notification on the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_EnableNotification
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_ENABLE_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_ENABLE_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_ENABLE_NOTIFICATION, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if ((ChPtr->MeasurementMode != ICU_MODE_SIGNAL_EDGE_DETECT) &&
        (ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP))
    {
      /* ICU channel not configured for edge detection mode */
      Icu_ReportError(ICU_API_ENABLE_NOTIFICATION, ICU_E_PARAM_CHANNEL);
    }
    else
    {
#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
      {
        Icu_EnterCritiSec();

        Icu_SetEdgeDetectNotification(ChPtr, TRUE, ConfigPtr->StatePtr->WakeupMode);
#if (ICU_ENABLE_NOTIAPI_CAPABLE_WAKEUP == STD_ON)
        if (ConfigPtr->StatePtr->WakeupMode != ICU_MODE_SLEEP)
        {
          if (ChPtr->WakeupCapability == TRUE)
          {
            Icu_SetWakeup_Internal(ChPtr, TRUE);
          }
        }
#endif
        Icu_ExitCritiSec();
      }
#endif
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
      {
        Icu_SetTimeStampNotification(ChPtr, TRUE);
      }
#endif
    }
  }
}


#if (ICU_GET_INPUT_STATE_API == STD_ON)
/** \brief Icu_GetInputState.
 **
 ** This function gets the input state of a channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 ** 
 ** \return    ICU_ACTIVE: An activation edge has been detected.
 **            ICU_IDLE: No activation edge has been detected since
 **            the last call of Icu_GetInputState () or Icu_Init ().
 **
 ** */
FUNC(Icu_InputStateType, ICU_CODE) Icu_GetInputState
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();
  Icu_InputStateType InState = ICU_IDLE;

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_GET_INPUT_STATE, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_GET_INPUT_STATE, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_GET_INPUT_STATE, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if ((ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT) &&
        (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_EDGE_DETECT))
    {
      /* Invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_GET_INPUT_STATE, ICU_E_PARAM_CHANNEL);
    }
    else
    {
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
      {
        InState = Icu_GetMeasurementInputState(ChPtr);
      }
#endif
#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
      {
        InState = Icu_GetEdgeDetectInputState(ChPtr, ConfigPtr->StatePtr->WakeupMode);
      }
#endif
    }
  }
  return InState;
}

#endif


#if (ICU_TIMESTAMP_API == STD_ON)
/** \brief Icu_StartTimestamp.
 **
 ** This function starts the capturing of timer values on the edges.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 ** - Icu_StartTimestamp may only be called multiple times if Icu_StopTimestamp
 **   has been called (at least once) between two calls of Icu_StartTimestamp.
 **
 ** \param[in] Channel        Numeric identifier of the ICU channel.
 ** \param[in/out] BufferPtr  Pointer to the buffer-array where the timestamp
 **                           values shall be placed.
 ** \param[in] BufferSize     Size of the external buffer (number of entries).
 ** \param[in] NotifyInterval Notification interval (number of events).
 **                           This parameter cannot be checked in a reasonable way.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_StartTimestamp
(
  VAR(Icu_ChannelType, AUTOMATIC)                Channel,
  P2VAR(Icu_ValueType, AUTOMATIC, ICU_APPL_DATA) BufferPtr,
  VAR(uint16, AUTOMATIC)                         BufferSize,
  VAR(uint16, AUTOMATIC)                         NotifyInterval
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (BufferPtr == NULL_PTR)
  {
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_POINTER);
  }
  else if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;

    if (Icu_CheckStartTimeStamp(ChPtr, BufferPtr, BufferSize, NotifyInterval) == TRUE)
    {
      if (ChExtCfgPtr->UseDMA != TRUE)
      {
         Icu_StartTimestamp_Internal(ChPtr, BufferPtr, BufferSize, NotifyInterval, ICU_CHSTART);
      }
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
      else
      {
        Icu_StartTimestampDma_Internal(ChPtr, BufferPtr, BufferSize, NotifyInterval, ICU_CHSTART);
      }
#endif
    }
  }
}
#endif


#if (ICU_TIMESTAMP_API == STD_ON)
/** \brief Icu_StopTimestamp.
 **
 ** This function stops the timestamp measurement of the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_StopTimestamp
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_STOP_TIMESTAMP, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_STOP_TIMESTAMP, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_STOP_TIMESTAMP, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP)
    {
      /* Invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_STOP_TIMESTAMP, ICU_E_PARAM_CHANNEL);
    }
    else
    {
      if (ChPtr->StatePtr->Status != ICU_RUNNING)
      {
        /* Icu_StartTimestamp not called before or Icu_StopTimestamp already called */
        Icu_ReportError(ICU_API_STOP_TIMESTAMP, ICU_E_NOT_STARTED);
      }
      else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
      {
        /* Wait start or stop trigger */
        Icu_ReportError(ICU_API_STOP_TIMESTAMP, ICU_E_WAITING_TRIGGER);
      }
      else /* Call Icu_StopTimestamp_Internal function */
      {
        P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
           Justification: It is a necessary for Extension State access. */
        /* PRQA S 316 1 */
        ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;
        if (ChExtCfgPtr->UseDMA != TRUE)
        {
          Icu_StopTimestamp_Internal(ChPtr, ICU_CHSTOP);
        }
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
        else
        {
          Icu_StopTimestampDma_Internal(ChPtr, ICU_CHSTOP);
        }
#endif
      }
    }
  }
}
#endif


#if (ICU_TIMESTAMP_API == STD_ON)
/** \brief Icu_GetTimestampIndex
 **
 ** This function gets timestamp index.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    Timestamp index of the given channel.
 **
 ** */
FUNC(Icu_IndexType, ICU_CODE) Icu_GetTimestampIndex
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  /* return 0 if DET is activated and an error is detected */
  Icu_IndexType TimestampIndex = 0U;

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_GET_TIMESTAMP_INDEX, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_GET_TIMESTAMP_INDEX, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_GET_TIMESTAMP_INDEX, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP)
    {
      /* invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_GET_TIMESTAMP_INDEX, ICU_E_PARAM_CHANNEL);
    }
    else
    {
      if ((ChPtr->StatePtr->Status != ICU_RUNNING) &&
          (ChPtr->StatePtr->Status != ICU_STOPPED))
      {
        /* No Icu_StartTimestamp was done before, return 0 */
      }
      else 
      {
        P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
           Justification: It is a necessary for Extension State access. */
        /* PRQA S 316 1 */
        ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;
        if (ChExtCfgPtr->UseDMA != TRUE)
        {
          TimestampIndex = Icu_GetTimestampIndex_Internal(ChPtr);
        }
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
        else
        {
          TimestampIndex = Icu_GetTimestampIndexDma_Internal(ChPtr);
        }
#endif
      }
    }
  }

  return TimestampIndex;
}
#endif


#if (ICU_EDGE_COUNT_API == STD_ON)
/** \brief Icu_ResetEdgeCount
 **
 ** This function resets the value of the counted edges to zero.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_ResetEdgeCount
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_RESET_EDGE_COUNT, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_RESET_EDGE_COUNT, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_RESET_EDGE_COUNT, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_EDGE_COUNTER)
    {
      /* ICU channel not configured for edge counter mode */
      Icu_ReportError(ICU_API_RESET_EDGE_COUNT, ICU_E_PARAM_CHANNEL);
    }
    else
    {
      P2VAR(Icu_EdgeCountChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
      /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
         Justification: It is a necessary for Extension State access. */
      /* PRQA S 316 1 */
      ChExtStatePtr = (P2VAR(Icu_EdgeCountChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
      
      ChExtStatePtr->EdgeNumber = 0U;
    }
  }
}
#endif


#if (ICU_EDGE_COUNT_API == STD_ON)
/** \brief Icu_EnableEdgeCount
 **
 ** This function enables the counting of edges of the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_EnableEdgeCount
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_ENABLE_EDGE_COUNT, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_ENABLE_EDGE_COUNT, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_ENABLE_EDGE_COUNT, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_ENABLE_EDGE_COUNT, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_EDGE_COUNTER)
    {
      /* ICU channel not configured for edge counter mode */
      Icu_ReportError(ICU_API_ENABLE_EDGE_COUNT, ICU_E_PARAM_CHANNEL);
    }
    else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      /* Wait start or stop trigger */
      Icu_ReportError(ICU_API_ENABLE_EDGE_COUNT, ICU_E_WAITING_TRIGGER);
    }
    else /* Call Icu_EnableEdgeCount_Internal function */
    {
      Icu_EnableEdgeCount_Internal(ChPtr, ICU_CHSTART);
    }
  }
}
#endif


#if (ICU_EDGE_COUNT_API == STD_ON)
/** \brief Icu_DisableEdgeCount
 **
 ** This function disables the counting of edges of the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_DisableEdgeCount
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
   P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_DISABLE_EDGE_COUNT, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_DISABLE_EDGE_COUNT, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_DISABLE_EDGE_COUNT, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_DISABLE_EDGE_COUNT, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_EDGE_COUNTER)
    {
      /* ICU channel not configured for edge counter mode [ICU024] */
      Icu_ReportError(ICU_API_DISABLE_EDGE_COUNT, ICU_E_PARAM_CHANNEL);
    }
    else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      /* Wait start or stop trigger */
      Icu_ReportError(ICU_API_DISABLE_EDGE_COUNT, ICU_E_WAITING_TRIGGER);
    }
    else /* Call Icu_DisableEdgeCount_Internal function */
    {
      Icu_DisableEdgeCount_Internal(ChPtr, ICU_CHSTOP);
    }
  }
}
#endif


#if (ICU_EDGE_COUNT_API == STD_ON)
/** \brief Icu_GetEdgeNumbers
 **
 ** This function gets number of edges occurred.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    The number of counted edges.
 **
 ** */
FUNC(Icu_EdgeNumberType, ICU_CODE) Icu_GetEdgeNumbers
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();
  Icu_EdgeNumberType EdgeNum = 0U;

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_GET_EDGE_NUMBERS, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_GET_EDGE_NUMBERS, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_GET_EDGE_NUMBERS, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_EDGE_COUNTER)
    {
      /* ICU channel not configured for edge counter mode */
      Icu_ReportError(ICU_API_GET_EDGE_NUMBERS, ICU_E_PARAM_CHANNEL);
    }
    else/* Call Icu_GetEdgeNumbers_Internal function */
    {
      EdgeNum = Icu_GetEdgeNumbers_Internal(ChPtr);
    }
  }
  
  return EdgeNum;
}
#endif

#if (ICU_EDGE_DETECT_API == STD_ON)
/** \brief Icu_EnableEdgeDetection
 **
 ** This function enables / re-enables the detection of edges of the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_EnableEdgeDetection
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_ENABLE_EDGE_DETECTION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_ENABLE_EDGE_DETECTION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_ENABLE_EDGE_DETECTION, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_ENABLE_EDGE_DETECTION, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_EDGE_DETECT)
    {
      /* ICU channel not configured for edge detection mode */
      Icu_ReportError(ICU_API_ENABLE_EDGE_DETECTION, ICU_E_PARAM_CHANNEL);
    }
    else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      /* Wait start or stop trigger */
      Icu_ReportError(ICU_API_ENABLE_EDGE_DETECTION, ICU_E_WAITING_TRIGGER);
    }
    else /* Call Icu_EnableEdgeDetection_Internal function */
    {
      Icu_EnableEdgeDetection_Internal(ChPtr ,ICU_CHSTART);
    }
  }
}
#endif


#if (ICU_EDGE_DETECT_API == STD_ON)
/** \brief Icu_DisableEdgeDetection
 **
 ** This function disables the detection of edges of the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_DisableEdgeDetection
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_DISABLE_EDGE_DETECTION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_DISABLE_EDGE_DETECTION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_DISABLE_EDGE_DETECTION, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_DISABLE_EDGE_DETECTION, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_EDGE_DETECT)
    {
      /* ICU channel not configured for edge detection mode */
      Icu_ReportError(ICU_API_DISABLE_EDGE_DETECTION, ICU_E_PARAM_CHANNEL);
    }
    else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      /* Wait start or stop trigger */
      Icu_ReportError(ICU_API_DISABLE_EDGE_DETECTION, ICU_E_WAITING_TRIGGER);
    }
    else /* Call Icu_DisableEdgeDetection_Internal function */
    {
      Icu_DisableEdgeDetection_Internal(ChPtr, ICU_CHSTOP);
    }
  }
}
#endif


#if (ICU_SIGNAL_MEASUREMENT_API == STD_ON)
/** \brief Icu_StartSignalMeasurement
 **
 ** This function implements to start signal measurement for given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 ** - channel is configured in Signal Measurement mode
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_StartSignalMeasurement
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_START_SIGNAL_MEAS, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_START_SIGNAL_MEAS, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_START_SIGNAL_MEAS, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_START_SIGNAL_MEAS, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT)
    {
      /* Invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_START_SIGNAL_MEAS, ICU_E_PARAM_CHANNEL);
    }
    else /* Call Icu_StartSignalMeasurement_Internal function */
    {
      Icu_StartSignalMeasurement_Internal(ChPtr);
    }
  }
}
#endif


#if (ICU_SIGNAL_MEASUREMENT_API == STD_ON)
/** \brief Icu_StopSignalMeasurement
 **
 ** This function implements to stop signal measurement for given channel.
 **
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 ** - channel is configured in Signal Measurement mode
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_StopSignalMeasurement
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_STOP_SIGNAL_MEAS, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_STOP_SIGNAL_MEAS, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_STOP_SIGNAL_MEAS, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_STOP_SIGNAL_MEAS, ICU_E_DURING_SLEEP);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT)
    {
      /* invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_STOP_SIGNAL_MEAS, ICU_E_PARAM_CHANNEL);
    }
    else /* Call Icu_StopSignalMeasurement_Internal function */
    {
      Icu_StopSignalMeasurement_Internal(ChPtr);
    }
  }
}
#endif


#if (ICU_GET_TIME_ELAPSED_API == STD_ON)
/** \brief Icu_GetTimeElapsed
 **
 ** This function gets time elapsed.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    Return the elapsed time for the given channel.
 **
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_GetTimeElapsed
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  /* return 0 if DET is activated and an error is detected */
  Icu_ValueType GetTime = 0U;

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_GET_TIME_ELAPSED, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_GET_TIME_ELAPSED, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_GET_TIME_ELAPSED, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;

    if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT)
    {
      /* invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_GET_TIME_ELAPSED, ICU_E_PARAM_CHANNEL);
    }
    else if ((ChExtCfgPtr->MeasurementProperty != ICU_LOW_TIME) &&
             (ChExtCfgPtr->MeasurementProperty != ICU_HIGH_TIME) &&
             (ChExtCfgPtr->MeasurementProperty != ICU_PERIOD_TIME))
    {
      /* invalid measurement property, return 0 */
    }
    else /* Call Icu_GetTimeElapsed_Internal function */
    {
      GetTime = Icu_GetTimeElapsed_Internal(ChPtr);
    }
  }
  return GetTime;
}
#endif


#if (ICU_GET_DUTY_CYCLE_VALUES_API == STD_ON)
/** \brief Icu_GetDutyCycleValues
 **
 ** This function reads the coherent active time and period time for the given ICU channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel         Numeric identifier of the ICU channel.
 ** \param[out]DutyCycleValues Pointer to a buffer where the results 
 **                            (high time and period time) shall be placed.
 ** 
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_GetDutyCycleValues
(
  VAR(Icu_ChannelType, AUTOMATIC)                    Channel,
  P2VAR(Icu_DutyCycleType, AUTOMATIC, ICU_APPL_DATA) DutyCycleValues
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (DutyCycleValues == NULL_PTR)
  {
    /* Invalid buffer pointer specified */
    Icu_ReportError(ICU_API_GET_DUTY_CYCLE_VALUES, ICU_E_PARAM_POINTER);
  }
  else if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_GET_DUTY_CYCLE_VALUES, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_GET_DUTY_CYCLE_VALUES, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_GET_DUTY_CYCLE_VALUES, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    ChPtr       = &(ConfigPtr->ChannelPtr[Channel]);
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;

    if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT)
    {
      /* invalid ICU channel; wrong measurement mode configured */
      Icu_ReportError(ICU_API_GET_DUTY_CYCLE_VALUES, ICU_E_PARAM_CHANNEL);
    }
    else if (ChExtCfgPtr->MeasurementProperty != ICU_DUTY_CYCLE)
    {
      /* invalid measurement property, return 0 */
    }
    else /* Call Icu_GetDutyCycleValues_Internal function */
    {
      Icu_GetDutyCycleValues_Internal(ChPtr, DutyCycleValues);
    }
  }
}
#endif


#if (ICU_GET_VERSION_INFO_API == STD_ON)
/** \brief Icu_GetVersionInfo
 **
 ** This function gets the version information of the module.
 **
 ** \param[out] versioninfo Pointer to where to store the version
 **                         information of this module.
 **
 ** \return     None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, ICU_APPL_DATA) versioninfo
)
{
  /* Check if versioninfo is valid */
  if (versioninfo == NULL_PTR)
  {
    Icu_ReportError(ICU_API_GET_VERSION_INFO, ICU_E_PARAM_VINFO);
  }
  else /* Call Icu_GetVersionInfo_Internal function */
  {
    versioninfo->vendorID         = ICU_VENDOR_ID;
    versioninfo->moduleID         = ICU_MODULE_ID;
    versioninfo->sw_major_version = ICU_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = ICU_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = ICU_SW_PATCH_VERSION;
  }
}
#endif


#if (ICU_SAFETY_FUNCTION_API == STD_ON)
/** \brief Icu_CheckChannelStatus
 **
 ** This function checks the register of the ICU driver.
 **
 ** \param[in]  Channel               Numeric identifier of the ICU channel.
 ** \param[out] CheckChannelStatusPtr Pointer to the structure of checking channel status.
 **
 ** \return     Return the result of checking channel status.
 **
 ** */
FUNC(Std_ReturnType, ICU_CODE) Icu_CheckChannelStatus
(
  VAR(Icu_ChannelType, AUTOMATIC)                             Channel,
  P2VAR(Icu_CheckChannelStatusType, AUTOMATIC, ICU_APPL_DATA) CheckChannelStatusPtr
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  Std_ReturnType retVal = E_NOT_OK;

  if (CheckChannelStatusPtr == NULL_PTR)
  {
    Icu_ReportError(ICU_API_CHECK_CHANNEL_STATUS, ICU_E_PARAM_CHECK_STATUS_POINTER);
  } 
  else
  {
    CheckChannelStatusPtr->DriverStatus = Icu_DriverStatus;
    if ((ICU_S_INITIALIZED != Icu_DriverStatus) && (NULL_PTR == ConfigPtr))
    {
      retVal = E_OK;
    }
    else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
    {
      /* Invalid configuration pointer */
      Icu_ReportError(ICU_API_CHECK_CHANNEL_STATUS, ICU_E_UNINIT);
    }

    else if (Channel >= ConfigPtr->ConfiguredChannels)
    {
      /* Invalid ICU channel specified */
      Icu_ReportError(ICU_API_CHECK_CHANNEL_STATUS, ICU_E_PARAM_CHANNEL);
    }
    else
    {
      if (Icu_CheckChannelStatus_Internal(Channel, ConfigPtr, CheckChannelStatusPtr) == TRUE)
      {
        retVal = E_OK;
      }
    }
  }
  return retVal;
}
#endif /* ICU_SAFETY_FUNCTION_API == STD_ON */


#if (ICU_CHANNEL_GROUP_API == STD_ON)
/** \brief Icu_StartGroupTrigger
 **
 ** Service to start the trigger all ICU channels in provided channel group.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Group Numeric identifier of the ICU channel group.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_StartGroupTrigger
(
  VAR(Icu_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_START_GROUP_TRIGGER, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_START_GROUP_TRIGGER, ICU_E_UNINIT);
  }
  else if (Group >= ConfigPtr->ConfiguredGroups)
  {
    /* Invalid ICU Group specified */
    Icu_ReportError(ICU_API_START_GROUP_TRIGGER, ICU_E_PARAM_CHANNEL_GROUP);
  }
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  else if (FALSE == Icu_CheckGroupChannels(ConfigPtr, Group))
  {
    /* Invalid ICU Group condition */
    Icu_ReportError(ICU_API_START_GROUP_TRIGGER, ICU_E_CHANNEL_GROUP_CONDITION);
  }
#endif
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_START_GROUP_TRIGGER, ICU_E_DURING_SLEEP);
  }
  else if (Icu_CheckGroupChannelsWaitTrigger(ConfigPtr, Group) == TRUE)
  {
    /* Wait start or stop trigger */
    Icu_ReportError(ICU_API_START_GROUP_TRIGGER, ICU_E_WAITING_TRIGGER);
  }
  else/* Call Icu_StartGroup_Internal function */
  {
    Icu_StartGroup_Internal(ConfigPtr, Group);
  }
}
#endif /* ICU_CHANNEL_GROUP_API == STD_ON */


#if (ICU_CHANNEL_GROUP_API == STD_ON)
/** \brief Icu_StopGroupTrigger
 **
 ** Service to stop the trigger all ICU channels in provided channel group.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Group Numeric identifier of the ICU channel group.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_StopGroupTrigger
(
  VAR(Icu_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_STOP_GROUP_TRIGGER, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_STOP_GROUP_TRIGGER, ICU_E_UNINIT);
  }
  else if (Group >= ConfigPtr->ConfiguredGroups)
  {
    /* Invalid ICU Group specified */
    Icu_ReportError(ICU_API_STOP_GROUP_TRIGGER, ICU_E_PARAM_CHANNEL_GROUP);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_STOP_GROUP_TRIGGER, ICU_E_DURING_SLEEP);
  }
  else if (Icu_CheckGroupChannelsWaitTrigger(ConfigPtr, Group) == TRUE)
  {
    /* Wait start or stop trigger */
    Icu_StopGroup_Internal(ConfigPtr, Group, TRUE);
  }
  else/* Call Icu_StopGroup_Internal function */
  {
    Icu_StopGroup_Internal(ConfigPtr, Group, FALSE);
  }
}
#endif /* ICU_CHANNEL_GROUP_API == STD_ON */


#if (ICU_GET_INPUT_LEVEL_API == STD_ON)
/** \brief Icu_GetInputLevel.
 **
 ** An API shall return the state of the input pin related to an ICU channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 ** 
 ** \return    The level gets from channel.
 **            ICU_HIGH: High level has been detected.
 **            ICU_LOW: Low level has been detected.
 **
 ** */
FUNC(Icu_LevelType, ICU_CODE) Icu_GetInputLevel
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();
  Icu_LevelType InputLevel = ICU_LOW;

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_GET_INPUT_LEVEL, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_GET_INPUT_LEVEL, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_GET_INPUT_LEVEL, ICU_E_PARAM_CHANNEL);
  } 
  else /* Call Icu_GetInputLevel_Internal function */
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    InputLevel = Icu_GetInputLevel_Internal(ChPtr);
  }

  return InputLevel;
}
#endif


#if (ICU_SET_PRESCALER_API == STD_ON)
/** \brief Icu_SetPrescaler
 **
 ** Service to set prescaler.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 **
 ** \param [in] Channel        Numeric identifier of the ICU channel.
 ** \param [in] ClockFrequency Clock frequency.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE) Icu_SetPrescaler
(
  VAR(Icu_ChannelType, AUTOMATIC)      Channel,
  VAR(Icu_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_PARAM_CHANNEL);
  }
  else if (ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP)
  {
    /* Unexpectedly call function in sleep mode */
    Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_DURING_SLEEP);
  }
  else
  {
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
    
    if ((ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP) && (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT))
    {
      /* Invalid ICU channel specified */
      Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_PARAM_CHANNEL);
    }
    else if (ChPtr->StatePtr->Status == ICU_RUNNING)
    {
      /* ICU channel is running */
      Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_BUSY_OPERATION);
    }
    else if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      /* Wait stop trigger */
      Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_WAITING_TRIGGER);
    }
    else
    {
#if (ICU_RESOUCRCE_TCPWM_ENABLE == STD_ON)
      if (FALSE == Icu_SetPrescaler_Internal(ChPtr, ClockFrequency))
      {
        Icu_ReportError(ICU_API_SET_PRESCALER, ICU_E_PARAM_CLOCK);
      }
#endif /* (ICU_RESOUCRCE_TCPWM_ENABLE == STD_ON) */
    }
  }
}
#endif /* (ICU_SET_PRESCALER_API == STD_ON) */


/** \brief Icu_DisableOverflowNotification
 **
 ** This function disables the overflow notification on the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_DisableOverflowNotification
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_DISABLE_OVERFLOW_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_DISABLE_OVERFLOW_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_DISABLE_OVERFLOW_NOTIFICATION, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if ((ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT) &&
        (ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP))
    {
      /* ICU channel not configured for edge detection mode */
      Icu_ReportError(ICU_API_DISABLE_OVERFLOW_NOTIFICATION, ICU_E_PARAM_CHANNEL);
    }
    else
    {
      Icu_EnterCritiSec();

#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
      {
        Icu_SetTimeStampOverflowNotification(ChPtr, FALSE, ConfigPtr->StatePtr->WakeupMode);
      }
#endif
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
      {
        Icu_SetMeasurementOverflowNotification(ChPtr, FALSE, ConfigPtr->StatePtr->WakeupMode);
      }
#endif
      Icu_ExitCritiSec();
    }
  }
}


/** \brief Icu_EnableOverflowNotification
 **
 ** This function enables the overflow notification on the given channel.
 **
 ** Preconditions:
 ** - Icu_Init should have been done.
 **
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_EnableOverflowNotification
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if (Icu_DriverStatus != ICU_S_INITIALIZED)
  {
    /* No Icu_Init was done before */
    Icu_ReportError(ICU_API_ENABLE_OVERFLOW_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (FALSE == Icu_CheckConfigPtr(ConfigPtr))
  {
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_ENABLE_OVERFLOW_NOTIFICATION, ICU_E_UNINIT);
  }
  else if (Channel >= ConfigPtr->ConfiguredChannels)
  {
    /* Invalid ICU channel specified */
    Icu_ReportError(ICU_API_ENABLE_OVERFLOW_NOTIFICATION, ICU_E_PARAM_CHANNEL);
  }
  else
  {
    P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

    if ((ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT) &&
        (ChPtr->MeasurementMode != ICU_MODE_TIMESTAMP))
    {
      /* ICU channel not configured for edge detection mode */
      Icu_ReportError(ICU_API_ENABLE_OVERFLOW_NOTIFICATION, ICU_E_PARAM_CHANNEL);
    }
    else
    {
      Icu_EnterCritiSec();

#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
      {
        Icu_SetTimeStampOverflowNotification(ChPtr, TRUE, ConfigPtr->StatePtr->WakeupMode);
      }
#endif
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
      if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
      {
        Icu_SetMeasurementOverflowNotification(ChPtr, TRUE, ConfigPtr->StatePtr->WakeupMode);
      }
#endif
      Icu_ExitCritiSec();

    }
  }
}


/** \brief Icu_EnterCritiSec
 **
 ** This function enters exclusive area (call SchM module).
 **
 ** \param[in] None.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_EnterCritiSec(void)
{
  SchM_Enter_Icu_ICU_EXCLUSIVE_AREA_0();
}


/** \brief Icu_ExitCritiSec
 **
 **  This function exits exclusive area (call SchM module).
 **
 ** \param[in] None.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_ExitCritiSec(void)
{
  SchM_Exit_Icu_ICU_EXCLUSIVE_AREA_0();
}


/** \brief Icu_DemReportEvent
 **
 ** This function implements to report DEM error.
 **
 ** \param [in] ApiId       The type of Api id.
 ** \param [in] EventId     The type of event id.
 ** \param [in] EventStatus The status of event.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE) Icu_DemReportEvent
(
  VAR(uint8, AUTOMATIC) ApiId,
  VAR(uint8, AUTOMATIC) EventId,
  VAR(uint8, AUTOMATIC) EventStatus
)
{
#if (ICU_DEM_E_HW_ERROR == STD_ON)
  Dem_EventStatusType  DemEventStatus;
#endif /* ICU_DEM_E_HW_ERROR == STD_ON */

  if (EventStatus == ICU_DEM_EVENT_STATUS_FAILED)
  {
    /* Call error callout function. */
    ICU_ERROR_CALLOUT_FUNCTION(ICU_MODULE_ID, ICU_INSTANCE_ID, ApiId, EventId);
  }
#if (ICU_DEM_E_HW_ERROR == STD_ON)
  /* Check if hardware error occurs */
  if (EventId == ICU_E_HW_ERROR)
  {
    /* Prepare a value which be passed */
    DemEventStatus = (EventStatus == ICU_DEM_EVENT_STATUS_PASSED) ?
                     (DEM_EVENT_STATUS_PASSED) : (DEM_EVENT_STATUS_FAILED);

    /* Call diagnostic event manager */
    Dem_ReportErrorStatus (ICU_INTERNAL_E_HW_ERROR, DemEventStatus);
  }
#endif /* ICU_DEM_E_HW_ERROR == STD_ON */
}


/** \brief Icu_InitChannelState
 **
 ** This function initializes the extension state of configured each channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE) Icu_InitChannelState
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
  {
    P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

    ChExtStatePtr->Time[0]               = 0U;
    ChExtStatePtr->Time[1]               = 0U;
    ChExtStatePtr->ActiveTime[0]         = 0U;
    ChExtStatePtr->ActiveTime[1]         = 0U;
    ChExtStatePtr->InputState[0]         = ICU_IDLE;
    ChExtStatePtr->InputState[1]         = ICU_IDLE;
    ChExtStatePtr->OverflowNotifyEnabled = FALSE;
  }
#endif

#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

    ChExtStatePtr->NotifyEnabled         = FALSE;
    ChExtStatePtr->OverflowNotifyEnabled = FALSE;
    ChExtStatePtr->EdgeNumber            = 0U;
    ChExtStatePtr->NotifyInterval        = 0U;
    ChExtStatePtr->BufferPos             = 0U;
    ChExtStatePtr->BufferSize            = 0U;
  }
#endif

#if (ICU_MAX_NUMBER_OF_EDGE_COUNT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)
  {
    P2VAR(Icu_EdgeCountChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_EdgeCountChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

    ChExtStatePtr->EdgeNumber = 0U;
  }
#endif

#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
  {
    P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

    ChExtStatePtr->NotifyEnabled   = FALSE;
    ChExtStatePtr->InputStateIndex = 0U;

    ChExtStatePtr->InputState[0]   = ICU_IDLE;
    ChExtStatePtr->InputState[1]   = ICU_IDLE;
  }
#endif
}

/** \brief Icu_StopGroupChannel
 **
 ** This function stops group channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] ChannelCtrl  Control the channel stop or no stop.
 ** 
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StopGroupChannel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  /* Stop channel */
#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
  {
    Icu_DisableEdgeDetection_Internal(ChannelPtr, ChannelCtrl);
  }
#endif
#if (ICU_MAX_NUMBER_OF_EDGE_COUNT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)
  {
    Icu_DisableEdgeCount_Internal(ChannelPtr, ChannelCtrl);
  }
#endif
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
  {
    Icu_StopSignalMeasurement_Internal(ChannelPtr);
  }
  /* If only signal measurement mode channel,
     ChannelCtrl is unused */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelCtrl;
#endif
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 2 */
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    if (ChExtCfgPtr->UseDMA == FALSE)
    {
      Icu_StopTimestamp_Internal(ChannelPtr, ChannelCtrl);     /* No DW Mode */
    }
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
    else
    {
      Icu_StopTimestampDma_Internal(ChannelPtr, ChannelCtrl);  /*  DW Mode   */
    }
#endif
  }
#endif
}


/** \brief Icu_StartGroupChannel
 **
 ** This function starts group channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] ChannelCtrl  Control the channel start or no start.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StartGroupChannel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  /* Stop channel */
#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
  {
    Icu_EnableEdgeDetection_Internal(ChannelPtr, ChannelCtrl);
  }
#endif
#if (ICU_MAX_NUMBER_OF_EDGE_COUNT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)
  {
    Icu_EnableEdgeCount_Internal(ChannelPtr, ChannelCtrl);
  }
#endif
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
  {
    Icu_StartSignalMeasurement_Internal(ChannelPtr);
  }
  /* If only signal measurement mode channel, ChannelCtrl is unused */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelCtrl;
#endif
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 2 */
    ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    if (ChExtCfgPtr->UseDMA == FALSE)
    {
      /* TimeStamp Mode */
      Icu_StartTimestamp_Internal(ChannelPtr,ChExtStatePtr->BufferPtr, ChExtStatePtr->BufferSize,
                                    ChExtStatePtr->NotifyInterval, ChannelCtrl);
    }
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
    else
    {
      Icu_StartTimestampDma_Internal(ChannelPtr, ChExtStatePtr->BufferPtr, ChExtStatePtr->BufferSize,
                                       ChExtStatePtr->NotifyInterval,ChannelCtrl);
    }
#endif
  }
#endif
}


/** \brief Icu_GetChannelStatus
 **
 ** This function gets the channel status each channel for checking.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 ** \param[out] CheckChannelStatusPtr  Pointer to return the internal state.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE) Icu_GetChannelStatus
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST)     ChannelPtr,
  P2VAR  (Icu_CheckChannelStatusType, AUTOMATIC, ICU_APPL_DATA) CheckChannelStatusPtr
)
{
  P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA)  ChStatePtr = ChannelPtr->StatePtr;
  CheckChannelStatusPtr->ChannelWakeupEnable   = ChStatePtr->WakeupEnable;
  CheckChannelStatusPtr->ChannelActivationEdge = ChStatePtr->ActivationEdge;
  CheckChannelStatusPtr->Prescaler = ChStatePtr->PrescalerRegisterValue;

#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
  {
    P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    CheckChannelStatusPtr->ChannelNotifyEnabled = ChExtStatePtr->NotifyEnabled;
    CheckChannelStatusPtr->ChannelOverflowNotifyEnabled = FALSE;
  }
#endif
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    CheckChannelStatusPtr->ChannelNotifyEnabled = ChExtStatePtr->NotifyEnabled;
    CheckChannelStatusPtr->ChannelOverflowNotifyEnabled = ChExtStatePtr->OverflowNotifyEnabled;
  }
#endif
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
  {
    P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    CheckChannelStatusPtr->ChannelNotifyEnabled = FALSE;
    CheckChannelStatusPtr->ChannelOverflowNotifyEnabled = ChExtStatePtr->OverflowNotifyEnabled;
  }
#endif
#if (ICU_MAX_NUMBER_OF_EDGE_COUNT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)
  {
    CheckChannelStatusPtr->ChannelNotifyEnabled = FALSE;
    CheckChannelStatusPtr->ChannelOverflowNotifyEnabled = FALSE;
  }
#endif
}

/** \brief Icu_InitDMAChannel
 **
 ** This function initialize or de-initializes DW channel.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 ** \param[in]  InitFlag     Initializes or de-initializes DW.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE) Icu_InitDMAChannel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   InitFlag
)
{
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    if (ChExtCfgPtr->UseDMA == TRUE)
    {
      Icu_InitDMAChannel_Internal(ChannelPtr, InitFlag);
    }
  }
#else
  /* If no DW channel, parameters are unused */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 2 */
  (void)ChannelPtr;
  (void)InitFlag;
#endif
}

/** \brief Icu_CheckDMAChannelStatus
 **
 ** This function check DW channel status.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 ** \param[in]  DriverState  Current driver initial state.
 **
 ** \return     Return DW channel status.
 **             TRUE:  Channel status is valid.
 **             FALSE: Channel status is invalid.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckDMAChannelStatus
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverState
)
{
  boolean result = TRUE;
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    if (ChExtCfgPtr->UseDMA == TRUE)
    {
       result = Icu_CheckDMAChannel(ChannelPtr, DriverState);
    }
  }
#else
  /* If no DW channel, parameters are unused */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 2 */
  (void)ChannelPtr;
  (void)DriverState;
#endif
  return result;
}

/** \brief Icu_WakeupOverflowInterrupt
 **
 ** This function wakes up overflow interrupt of channel.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE)Icu_WakeupOverflowInterrupt
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    if (TRUE == ChExtStatePtr->OverflowNotifyEnabled)
    {
      /* TCPWM Overflow Interrupt Enable */
      Icu_SetTimeStampOverflowNotification(ChannelPtr, TRUE, ICU_MODE_NORMAL);
    }
  }
#endif
#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
  {
    P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    if (TRUE == ChExtStatePtr->OverflowNotifyEnabled)
    {
      /* TCPWM Overflow Interrupt Enable */
      Icu_SetMeasurementOverflowNotification(ChannelPtr, TRUE, ICU_MODE_NORMAL);
    }
  }
#endif
  /* Channel is ICU_MODE_EDGE_COUNTER or ICU_MODE_SIGNAL_EDGE_DETECT, it does nothing. */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
}


/** \brief Icu_Isr_Vector_Internal
 **
 ** Internal service of ICU interrupt routine.
 **
 ** \param[in] BaseAddress   Base address of channel.
 ** \param[in] ResourceIndex Logic resource index of TCPWM/GPIO channel
 **                          (defined by software generate source).
 ** \param[in] ResourceId    Physical resource identifier of GPIO channel
 **                          (read from property file).
 **                          For TCPWM channel, the value of this parameter
 **                          shall be always ICU_INVALID_RESOURCEID.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE)Icu_Isr_Vector_Internal
(
  volatile P2VAR(uint32, ICU_CONST, REGSPACE) BaseAddress,
  VAR(uint16, AUTOMATIC)                      ResourceIndex,
  VAR(uint16, AUTOMATIC)                      ResourceId
)
{
  Icu_ChannelType Channel;
  uint8  IntrReqFlag;
  uint8  IntrClrFlag;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if ((FALSE == Icu_CheckConfigPtr(ConfigPtr)) || (ICU_S_INITIALIZED != Icu_DriverStatus))
  {
    /* Set flag to clear interrupt flag */
    IntrClrFlag = (ICU_INT_OVERFLOW | ICU_INT_CAPTURE | ICU_INT_CC1MATCH);
    /* Clear the interrupt flag */
    Icu_ClearIsr_Internal(BaseAddress, ResourceId, IntrClrFlag);
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_INTERRUPT_EVENT, ICU_E_UNINIT);
  }
  else
  {
    Channel = ConfigPtr->ResPtr[ResourceIndex];

    if (Channel < ConfigPtr->ConfiguredChannels)
    {
      ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
      IntrReqFlag = (uint8)Icu_GetInterruptRequestFlag(ChPtr);
      IntrClrFlag = (IntrReqFlag & (ICU_INT_CAPTURE | ICU_INT_OVERFLOW | ICU_INT_CC1MATCH));
      /* Clear the interrupt flag */
      Icu_ClearIsr_Internal(BaseAddress, ResourceId, IntrClrFlag);
#if (ICU_REPORT_WAKEUP_SOURCE == STD_ON)
      if (0U != (ICU_INT_CAPTURE & IntrReqFlag))
      {
        Icu_ReportWakeupSource(Channel);
      }
#endif
      if ((0U != (ICU_INT_OVERFLOW & IntrReqFlag)) ||
          (0U != (ICU_INT_CAPTURE & IntrReqFlag)))
      {
        Icu_Channel_InterruptEvent_Internal(ChPtr, IntrReqFlag, ConfigPtr->StatePtr->WakeupMode);
      }
    }
    else
    {
      /* Set flag to clear interrupt flag */
      IntrClrFlag = (ICU_INT_OVERFLOW | ICU_INT_CAPTURE | ICU_INT_CC1MATCH);
      /* Clear the interrupt flag */
      Icu_ClearIsr_Internal(BaseAddress, ResourceId, IntrClrFlag);
    }
  }
}


#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
/** \brief Icu_DwIsr_Vector_Internal
 **
 ** Internal function of the DataWire ISR.
 **
 ** \param[in] BaseAddress   Base address of channel.
 ** \param[in] ResourceIndex Resource index of TCPWM peripheral.
 ** 
 ** \return    None.
 ** */
FUNC(void, ICU_CODE)Icu_DwIsr_Vector_Internal
(
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) BaseAddress,
  VAR(uint16, AUTOMATIC)                                   ResourceIndex
)
{
  Icu_ChannelType Channel;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();

  if ((FALSE == Icu_CheckConfigPtr(ConfigPtr))|| (ICU_S_INITIALIZED != Icu_DriverStatus))
  {
    Icu_ClearDwIsr_Internal(BaseAddress);
    /* Invalid configuration pointer */
    Icu_ReportError(ICU_API_DW_INTERRUPT_EVENT, ICU_E_UNINIT);
  }
  else
  {
    Channel = ConfigPtr->ResPtr[ ResourceIndex ];

    if (Channel < ConfigPtr->ConfiguredChannels)
    {
      ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
      Icu_TimeStamp_Dw_InterruptEvent(ChPtr);
    }
    else
    {
      Icu_ClearDwIsr_Internal(BaseAddress);
    }
  }
}
#endif

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[internal function definitions]==========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

#if (ICU_SET_MODE_API == STD_ON)
/** \brief Icu_CheckDriverBusy
 **
 ** This function checks whether driver is busy or not.
 **
 **
 ** \param[in] ConfigPtr Configuration pointer to config data.
 **
 ** \return    The return value TRUE or FALSE.
 **            TRUE:  Driver is busy.
 **            FALSE: Driver is not busy.
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckDriverBusy
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr
)
{
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  Icu_ChannelType Channel;
  /* Return FALSE in case of no channel is busy. */
  boolean result = FALSE;

  /* Check if a channel is running */
  for (Channel=0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
  {
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
    
    if ((ChPtr->StatePtr->Status == ICU_RUNNING)                  &&
        (ChPtr->MeasurementMode  != ICU_MODE_SIGNAL_EDGE_DETECT))
    {
      /* Driver is running break here */
      result = TRUE;
      break;
    }
  }

  return result;
}
#endif


#if (ICU_TIMESTAMP_API == STD_ON)
/** \brief Icu_CheckStartTimeStamp
 **
 ** This function checks Icu_StartTimeStamp whether occur DET error.
 **
 **
 ** \param[in] ChannelPtr     Pointer to the channel configuration.
 ** \param[in/out] BufferPtr  Pointer to the buffer-array where the timestamp
 **                           values shall be placed.
 ** \param[in] BufferSize     Size of the external buffer (number of entries).
 ** \param[in] NotifyInterval Notification interval (number of events).
 **                           This parameter cannot be checked in a reasonable way.
 **
 ** \return    The return whether occur DET error.
 **            TRUE:  No DET error occur.
 **            FALSE: DET error occur.
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckStartTimeStamp
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  P2CONST(Icu_ValueType, AUTOMATIC, ICU_APPL_CONST)         BufferPtr,
  VAR(uint16, AUTOMATIC)                                    BufferSize,
  VAR(uint16, AUTOMATIC)                                    NotifyInterval
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  boolean result = TRUE;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  if (ChannelPtr->MeasurementMode != ICU_MODE_TIMESTAMP)
  {
    /* Invalid ICU channel; wrong measurement mode configured */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_CHANNEL);
    result = FALSE;
  }
  else if (Icu_CheckChannelHWstatus(ChannelPtr) == FALSE)
  {
    /* Wait start or stop trigger */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_WAITING_TRIGGER);
    result = FALSE;
  }
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
     Justification: Casting to integer value from pointer for comparing address values */
  /* PRQA S 306 3 */
  else if ((ChExtCfgPtr->BufNamePtr !=  NULL_PTR) &&
           ((((uint32)BufferPtr) < ((uint32)(&(ChExtCfgPtr->BufNamePtr)[0]))) ||
            (((uint32)(&(ChExtCfgPtr->BufNamePtr)[ChExtCfgPtr->BufSize])) <= ((uint32)BufferPtr))))
  {
    /* Invalid BufferNamePtr pointer */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_POINTER);
    result = FALSE;
  }
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
     Justification: Casting to integer value from pointer for comparing address values */
  /* PRQA S 306 3 */
  else if ((BufferSize == 0U) ||
            ((ChExtCfgPtr->BufNamePtr !=  NULL_PTR) &&
             ((uint32)(&BufferPtr[BufferSize]) > (uint32)(&(ChExtCfgPtr->BufNamePtr)[ChExtCfgPtr->BufSize]))))
  {
    /* Invalid buffer size specified */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_BUFFER_SIZE);
    result = FALSE;
  }
  else if ((ChExtCfgPtr->Notification != NULL_PTR) && (NotifyInterval == 0U))
  {
    /* Invalid notification interval specified */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_NOTIFY_INTERVAL);
    result = FALSE;
  }
#if (ICU_DMA_FUNCTION_ENABLE == STD_ON)
  else if (Icu_CheckBufferSizeDma_Internal(ChannelPtr, BufferSize, NotifyInterval) == FALSE)
  {
    /* Invalid notification interval specified */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_BUFFER_SIZE);
    result = FALSE;
  }
  else if ((ChExtCfgPtr->UseDMA == TRUE) && (ChExtCfgPtr->Notification != NULL_PTR) &&
           (((BufferSize % NotifyInterval) != 0U) || (NotifyInterval > ICU_DW_COUNT_SIZE)))
  {
    /* Invalid notification interval specified */
    Icu_ReportError(ICU_API_START_TIMESTAMP, ICU_E_PARAM_NOTIFY_INTERVAL);
    result = FALSE;
  }
#endif
  else
  {
    /* No Det Error, Call Start TimeStamp internal function */
  }

  return result;
}
#endif

#if (ICU_REPORT_WAKEUP_SOURCE == STD_ON)
/** \brief Icu_ReportWakeupSource
 **
 ** The function reports wakeup sources to the Ecu Manager 
 ** if wakeup capability configured.
 **
 ** \param[in] Channel Numeric identifier of the ICU channel.
 **
 ** \return    None.
 **
 ** */
/* Mode: Common function to report wakeup sources to the ECU state manager */
static FUNC(void, ICU_CODE) Icu_ReportWakeupSource
(
  VAR(Icu_ChannelType, AUTOMATIC) Channel
)
{
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr = Icu_GetConfigPtr();
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

  if (((ConfigPtr->StatePtr)->WakeupMode == ICU_MODE_SLEEP) && 
      (ChPtr->StatePtr->WakeupEnable == TRUE))
  {
    ChPtr->StatePtr->WakeupDetected = TRUE;
    if (ChPtr->IcuDisableEcumWakeupNotification == FALSE)
    {
      EcuM_CheckWakeup((EcuM_WakeupSourceType)(ConfigPtr->WakeupSourcePtr[Channel]));
    }
  }
}
#endif


/** \brief Icu_Channel_InterruptEvent_Internal
 **
 ** Internal function of the ISRs is based on different mode to call interrupt event.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntrFlag     Interrupt request flag of channel.
 ** \param[in] Mode         Icu wakeup mode, sleep or normal.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Channel_InterruptEvent_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                     IntrFlag,
  VAR(Icu_ModeType, AUTOMATIC)                              Mode
)
{
#if (ICU_MAX_NUMBER_OF_EDGE_DETECT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
  {
    Icu_EdgeDetect_InterruptEvent(ChannelPtr, IntrFlag, Mode);
  }
#endif

#if (ICU_MAX_NUMBER_OF_EDGE_COUNT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)
  {
    Icu_EdgeCount_InterruptEvent(ChannelPtr, IntrFlag);
  }
#endif

#if (ICU_MAX_NUMBER_OF_SIGNAL_MEASURMENT_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
  {
    Icu_Measure_InterruptEvent(ChannelPtr, IntrFlag);
  }
#endif

#if (ICU_MAX_NUMBER_OF_TIMESTAMP_CHANNEL > 0U)
  if (ChannelPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
  {
    Icu_TimeStamp_InterruptEvent(ChannelPtr, IntrFlag);
  }
#endif
   /* If no EdgeDetect mode channel, Mode is unused */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)Mode;
}


/** \brief Icu_GetConfigPtr
 **
 ** This function implements to get the pointer to ICU config.
 **
 ** \param[in] None.
 **
 ** \return    Return pointer to the ICU configuration.
 ** */
static FUNC_P2CONST(Icu_ConfigType, ICU_APPL_CONST, ICU_CODE) Icu_GetConfigPtr(void)
{
  return Icu_ConfigPtr;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[end of file]============================================*/
