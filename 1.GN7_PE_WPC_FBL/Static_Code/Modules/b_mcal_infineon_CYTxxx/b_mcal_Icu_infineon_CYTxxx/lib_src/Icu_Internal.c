/** \file Icu_Internal.c
 **
 ** This file contains internal architecture function for the
 ** AUTOSAR Icu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Icu_Internal.h>
#include <Icu_Resource.h>
#include <Icu_Channel_EdgeCount.h>
#include <Icu_Channel_SignalEdgeDetection.h>
#include <Icu_Channel_SignalMeasurement.h>
#include <Icu_Channel_TimeStamp.h>

/*==================[macros]================================================*/

/* The update number */
#define ICU_UPDATE_NUMBER               ((uint8) 0x2U)
/* The maximum timeout value */
#define ICU_COUNT_LOOP_TIMEOUT           ((uint32) 0x0000003CUL)

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>
/** \brief Icu_ClearInterruptBeforeSleep
 **
 ** This function implements to update status and clear INTR register value before set sleep mode.
 **
 ** \param[in] ConfigPtr         Configuration pointer to config data.
 ** \param[in] AcceptInSetMode   Acceptance of wakeup signal.
 **
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_ClearInterruptBeforeSleep
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(boolean, AUTOMATIC)                            AcceptInSetMode
);

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[external function definitions]========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/** \brief Icu_Init_Internal
 **
 ** This function initializes all configured channels of the ICU module.
 **
 ** \param[in] ConfigPtr   Configuration pointer to config data.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Init_Internal
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr
)
{
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  Icu_ChannelType     Channel;
  Icu_ActivationType  ActEdge;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr;
  uint32 ActReg;

  ConfigPtr->StatePtr->WakeupMode = ICU_MODE_NORMAL;

  for (Channel = 0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
  {
    ChPtr = &(ConfigPtr->ChannelPtr[Channel]);
    ActEdge = ChPtr->DefaultEdge;
    ChPtr->StatePtr->Status         = ICU_NOT_STARTED;
    ChPtr->StatePtr->WakeupEnable   = FALSE;
    ChPtr->StatePtr->WakeupDetected = FALSE;
    ChPtr->StatePtr->ActivationEdge = ActEdge;
    ChPtr->StatePtr->PrescalerRegisterValue = ChPtr->PrescalerValue;
    ChPtr->StatePtr->HWTriggerStart = FALSE;
    ChPtr->StatePtr->HWTriggerStop  = FALSE;
    /* Initial channel status */
    Icu_InitChannelState(ChPtr);

    FuncTablePtr = (*ChPtr->GetFuncTable)();
    /* Interrupt disable */
    FuncTablePtr->drvIsrDisable(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH|ICU_MASK_INTR_MASK_TC);
    Icu_InitDMAChannel(ChPtr, TRUE);

    FuncTablePtr->drvDriverInit(ChPtr);
    ActReg = FuncTablePtr->drvCalculateActivation(ChPtr, ActEdge);
    FuncTablePtr->drvSetActivationCondition(ChPtr, ActReg);
    FuncTablePtr->drvCtrlEnable(ChPtr, TRUE);
  }
}

/** \brief Icu_DeInit_Internal
 **
 ** This function does the de-initialization of the ICU module.
 **
 ** \param[in] ConfigPtr   Configuration pointer to config data.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_DeInit_Internal
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr
)
{
  Icu_ChannelType Channel;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_drvFctTable_t,     AUTOMATIC, ICU_APPL_CONST) FuncTablePtr;

  ConfigPtr->StatePtr->WakeupMode = ICU_MODE_NORMAL;
  for (Channel = 0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
  {
    ChPtr        = &(ConfigPtr->ChannelPtr[Channel]);
    FuncTablePtr = (*ChPtr->GetFuncTable)();

    /* De-initialize prescaler value */
    ChPtr->StatePtr->PrescalerRegisterValue = 0U;
    /* De-initialize HWTriggerStart  */
    ChPtr->StatePtr->HWTriggerStart = FALSE;
    ChPtr->StatePtr->HWTriggerStop  = FALSE;
    ChPtr->StatePtr->Status         = ICU_NOT_STARTED;
    ChPtr->StatePtr->WakeupEnable   = FALSE;
    ChPtr->StatePtr->WakeupDetected = FALSE;
    ChPtr->StatePtr->ActivationEdge = ICU_INIT_EDGE;
    /* De-Initial channel status */
    Icu_InitChannelState(ChPtr);
    Icu_InitDMAChannel(ChPtr, FALSE);
    FuncTablePtr->drvDriverDeInit(ChPtr);
  }
}

/** \brief Icu_SetMode_Internal
 **
 ** This function implements to set the mode of ICU module.
 **
 ** \param[in] ConfigPtr   Configuration pointer to config data.
 ** \param[in] Mode        ICU_MODE_NORMAL: Normal operation, all used interrupts
 **                        are enabled according to the notification requests.
 **                        ICU_MODE_SLEEP: Reduced power mode. In sleep mode
 **                        only those notifications are available which are
 **                        configured as wakeup capable.
 ** \param[in] AcceptInSetMode   Acceptance of wakeup signal.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_SetMode_Internal
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(Icu_ModeType, AUTOMATIC)                       Mode,
  VAR(boolean, AUTOMATIC)                            AcceptInSetMode
)
{
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr;
  P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  Icu_ChannelType Channel;

  if (Mode == ICU_MODE_SLEEP)
  {
    Icu_ClearInterruptBeforeSleep(ConfigPtr, AcceptInSetMode);

    for (Channel = 0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
    {
      ChPtr        = &(ConfigPtr->ChannelPtr[Channel]);
      FuncTablePtr = (*ChPtr->GetFuncTable)();

      if ((ChPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT) ||
          (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP))
      {
        /* Disable overflow interrupt */
        FuncTablePtr->drvIsrDisable(ChPtr, ICU_MASK_INTR_MASK_TC);
      }

      if (ChPtr->StatePtr->WakeupEnable == TRUE)
      {
        /* Initialize WakeupDetected state */
        ChPtr->StatePtr->WakeupDetected = FALSE;

        if (AcceptInSetMode != TRUE)
        {
          FuncTablePtr->drvClearInterruptRequestFlag(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
        }
        /* Enable capture interrupt */
        FuncTablePtr->drvIsrEnable(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
        /* Check is channel is in running state */
        if ((ICU_STOPPED == ChPtr->StatePtr->Status) || (ICU_NOT_STARTED == ChPtr->StatePtr->Status))
        {
          /* Restart counter (Applicable for TCPWM resource channel) */
          FuncTablePtr->drvReloadCountTrigger(ChPtr);
        }
      }
      else
      {
        if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
        {
          /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
             Justification: It is a necessary for Extension State access. */
          /* PRQA S 316 1 */
          ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
          if ((TRUE == ChExtStatePtr->NotifyEnabled) && (ICU_RUNNING == ChPtr->StatePtr->Status))
          {
            /* Disable capture interrupt */
            FuncTablePtr->drvIsrDisable(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
          }
        }
      }
    }
  }
  else /* ICU_MODE_NORMAL */
  {
    for (Channel=0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
    {
      ChPtr        = &(ConfigPtr->ChannelPtr[Channel]);
      FuncTablePtr = (*ChPtr->GetFuncTable)();

      if (ChPtr->StatePtr->WakeupEnable == TRUE)
      {
        FuncTablePtr->drvIsrDisable(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
        /* Check is channel is in running state */
        if ((ICU_STOPPED == ChPtr->StatePtr->Status) || (ICU_NOT_STARTED == ChPtr->StatePtr->Status))
        {
          /* Stop counter (Applicable for TCPWM resource channel) */
          FuncTablePtr->drvCtrlEnable(ChPtr, FALSE);
          FuncTablePtr->drvCtrlEnable(ChPtr, TRUE);
        }
      }
      
      if (ChPtr->MeasurementMode  == ICU_MODE_SIGNAL_EDGE_DETECT)
      {
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
           Justification: It is a necessary for Extension State access. */
        /* PRQA S 316 1 */
        ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
        if ((ICU_RUNNING == ChPtr->StatePtr->Status) &&
            (TRUE == ChExtStatePtr->NotifyEnabled))
        {
          /* Enable capture interrupt */
          FuncTablePtr->drvIsrEnable(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
        }
      }
      else
      {
        /* Restore overflow interrupt, it does nothing in ICU_MODE_EDGE_COUNTER */
        Icu_WakeupOverflowInterrupt(ChPtr);
      }
    }
  }
  /* Update WakeupMode */
  ConfigPtr->StatePtr->WakeupMode = Mode;
}

/** \brief Icu_CheckWakeup_Internal
 **
 ** This function implements to check the wake-up capability of a channel.
 **
 ** \param[in] ConfigPtr    Configuration pointer to config data.
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Return whether wakeup is detected.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckWakeup_Internal
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean Ret = FALSE;
  Icu_EnterCritiSec();

  if ((ConfigPtr->StatePtr->WakeupMode == ICU_MODE_SLEEP) &&
      (ChannelPtr->StatePtr->WakeupEnable   == TRUE)      &&
      (ChannelPtr->StatePtr->WakeupDetected == TRUE))
  {
    ChannelPtr->StatePtr->WakeupDetected = FALSE;
    Ret = TRUE;
  }

  Icu_ExitCritiSec();

  return Ret;
}

/** \brief Icu_CheckGroupChannels
 **
 ** This function implements to check group start condition.
 **
 ** \param[in] ConfigPtr   Configuration pointer to config data.
 ** \param[in] Group       Numeric identifier of the ICU channel group.
 **
 ** \return    Returns group start condition is TRUE or FALSE.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckGroupChannels
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(Icu_GroupType, AUTOMATIC)                      Group
)
{
  Icu_ChannelType Channelnum;
  Icu_ChannelType loop;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_ChannelGroupConfigType, AUTOMATIC, ICU_APPL_CONST) GroupPtr = &(ConfigPtr->ChannelGroupPtr[Group]);
  boolean GroupCondition = TRUE;
  for (loop = 0u; loop < GroupPtr->IcuChannelNumber; loop++)
  {
    Channelnum = GroupPtr->IcuChannelListPtr[loop];
    ChPtr = &(ConfigPtr->ChannelPtr[Channelnum]);
    if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
    {
      P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
      /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
         Justification: It is a necessary for Extension State access. */
      /* PRQA S 316 1 */
      ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
      if (ChExtStatePtr->BufferSize == 0U)
      {
        GroupCondition = FALSE;
        break;
      }
    }
  }
  return GroupCondition;
}


/** \brief Icu_CheckGroupChannelsWaitTrigger
 **
 ** This function implements to check if channels of group are waiting trigger.
 **
 ** \param[in] ConfigPtr   Configuration pointer to config data.
 ** \param[in] Group       Numeric identifier of the ICU channel group.
 **
 ** \return    Returns channels of group are waiting trigger or not.
 **            TRUE:  channels are waiting trigger.
 **            FALSE: channels aren't waiting trigger.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckGroupChannelsWaitTrigger
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(Icu_GroupType, AUTOMATIC)                      Group
)
{
  Icu_ChannelType Channelnum;
  Icu_ChannelType loop;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_ChannelGroupConfigType, AUTOMATIC, ICU_APPL_CONST) GroupPtr = &(ConfigPtr->ChannelGroupPtr[Group]);
  boolean result = FALSE;
  for (loop = 0u; loop < GroupPtr->IcuChannelNumber; loop++)
  {
    Channelnum = GroupPtr->IcuChannelListPtr[loop];
    ChPtr = &(ConfigPtr->ChannelPtr[Channelnum]);
    if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
    {
      result = TRUE;
      break;
    }
  }

  return result;
}

/** \brief Icu_CheckChannelHWstatus
 **
 ** This function checks whether HW status match SW status.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 **
 ** \return     Returns channel is waiting trigger or not.
 **             TRUE:  HW status matches SW status.
 **             FALSE: HW status doesn't match SW status.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckChannelHWstatus
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean result = TRUE;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = (*ChannelPtr->GetFuncTable)();

  if (ChannelPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT)
  {
    if (ChannelPtr->StatePtr->Status == ICU_RUNNING)
    {
      /* Check if counter is running */
      if (FALSE == FuncTablePtr->drvCheckChannelRunning(ChannelPtr))
      {
        result = FALSE;
      }
      else
      {
        ChannelPtr->StatePtr->HWTriggerStart = FALSE;
      }
    }
    else /* ((Status == ICU_STOPPED) || (Status == ICU_NOT_STARTED)) */
    {
      if (FALSE == FuncTablePtr->drvCheckChannelStop(ChannelPtr))
      {
        result = FALSE;
      }
      else
      {
        ChannelPtr->StatePtr->HWTriggerStop = FALSE;
      }
    }
  }
  return result;
}


/** \brief Icu_CheckWaitTrigger
 **
 ** This function checks whether driver is waiting trigger.
 **
 **
 ** \param[in] ConfigPtr Configuration pointer to config data.
 **
 ** \return    Returns channels of configuration are waiting trigger or not.
 **            TRUE:  channels are waiting trigger.
 **            FALSE: channels aren't waiting trigger.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckWaitTrigger
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr
)
{
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  Icu_ChannelType Channel;
  /* Return FALSE in case of no channel is busy. */
  boolean result = FALSE;
  if (ConfigPtr->StatePtr->WakeupMode != ICU_MODE_SLEEP)
  {
    /* Check if a channel is running */
    for (Channel=0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
    {
      ChPtr = &(ConfigPtr->ChannelPtr[Channel]);

      if (Icu_CheckChannelHWstatus(ChPtr) == FALSE)
      {
        /* Driver is waiting trigger break here */
        result = TRUE;
        break;
      }
    }
  }

  return result;
}


/** \brief Icu_StartGroup_Internal
 **
 ** This function starts group channel.
 **
 ** \param[in] ConfigPtr   Configuration pointer to config data.
 ** \param[in] Group       Numeric identifier of the ICU channel group.
 **
 ** \return    none
 ** */
FUNC(void, ICU_CODE) Icu_StartGroup_Internal
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(Icu_GroupType, AUTOMATIC)                      Group
)
{
  Icu_ChannelType loop;
  Icu_ChannelType Channelnum;
  Icu_ChannelCtrlType CtrlMode;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_ChannelGroupConfigType, AUTOMATIC, ICU_APPL_CONST) GroupPtr;

  GroupPtr = &(ConfigPtr->ChannelGroupPtr[Group]);
  if (GroupPtr->InputStartTrigger != ICU_INVALID_TRIGGERVALUE)
  {
    CtrlMode = ICU_NOSTART;
  }
  else
  {
    CtrlMode = ICU_CHSTART;
  }

  for (loop = 0u; loop < GroupPtr->IcuChannelNumber; loop++)
  {
    Channelnum = GroupPtr->IcuChannelListPtr[loop];
    ChPtr = &(ConfigPtr->ChannelPtr[Channelnum]);

    /* Stop channel */
    if (ChPtr->StatePtr->Status == ICU_RUNNING)
    {
      Icu_StopGroupChannel(ChPtr, ICU_CHSTOP);
    }
    Icu_StartGroupChannel(ChPtr, CtrlMode);
    if ((ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT) && (ICU_NOSTART == CtrlMode))
    {
      P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr;
      FuncTablePtr = (*ChPtr->GetFuncTable)();
      FuncTablePtr->drvCtrlEnable(ChPtr, FALSE);
      /* Set start trigger */
      FuncTablePtr->drvSetInputTrigger(ChPtr, GroupPtr->InputStartTrigger);
      /* Set reload trigger Edge */
      FuncTablePtr->drvSetReloadTriggerEdge(ChPtr);
      FuncTablePtr->drvCtrlEnable(ChPtr, TRUE);
      if (ICU_TCPWM == ChPtr->ChannelResourceKind)
      {
        /* Set HWTriggerStart  */
        ChPtr->StatePtr->HWTriggerStart = TRUE;
      }
    }
  }
}

/** \brief Icu_StopGroup_Internal
 **
 ** This function stops group channel.
 **
 ** \param[in] ConfigPtr        Configuration pointer to config data.
 ** \param[in] Group            Numeric identifier of the ICU channel group.
 ** \param[in] WaitingTrigger   Whether channels of group are waiting trigger or not.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StopGroup_Internal
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(Icu_GroupType, AUTOMATIC)                      Group,
  VAR(boolean, AUTOMATIC)                            WaitingTrigger
)
{
  Icu_ChannelType loop;
  Icu_ChannelType Channelnum;
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_ChannelGroupConfigType, AUTOMATIC, ICU_APPL_CONST) GroupPtr = &(ConfigPtr->ChannelGroupPtr[Group]);

  for (loop = 0u; loop < GroupPtr->IcuChannelNumber; loop++)
  {
    Channelnum = GroupPtr->IcuChannelListPtr[loop];
    ChPtr = &(ConfigPtr->ChannelPtr[Channelnum]);

    if ((ChPtr->InputStopTrigger != ICU_INVALID_TRIGGERVALUE) &&
        (WaitingTrigger == FALSE))
    {
      Icu_StopGroupChannel(ChPtr, ICU_NOSTOP);
      /* Set HWTriggerStop  */
      ChPtr->StatePtr->HWTriggerStop = TRUE;
    }
    else
    {
      Icu_StopGroupChannel(ChPtr, ICU_CHSTOP);
      ChPtr->StatePtr->HWTriggerStart = FALSE;
      ChPtr->StatePtr->HWTriggerStop = FALSE;
    }
  }
}

/** \brief Icu_CheckNewMeas
 **
 ** This function checks whether the new capture event occurred.
 ** Updates measurement information for Icu_GetInputState/Icu_GetDutyCycleValues/Icu_GetTimeElapsed.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_CheckNewMeas
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)  ChExtStatePtr;
  P2CONST(Icu_SignalMeasExtConfigType,  AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  Icu_ValueType PrdTime;
  Icu_ValueType ActTime;
  Icu_LevelType TempCapture0;
  Icu_LevelType TempCapture1;
  Icu_ValueType TempCounter;
  uint32        IntValue;
  uint32        Timeout;
  uint8         Readnumber;
  uint32        Cc1Value;
  uint32        Cc1buffValue;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtCfgPtr   = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
  IntValue = Icu_Resource_Tcpwm_GetInterruptFlag(ChannelPtr);

  /* Measurement property is one of High/Low/Period */
  if ((ChExtCfgPtr->MeasurementProperty == ICU_HIGH_TIME) ||
      (ChExtCfgPtr->MeasurementProperty == ICU_LOW_TIME)  ||
      (ChExtCfgPtr->MeasurementProperty == ICU_PERIOD_TIME))
  {
    /* If new capture event occurred, ... */
    if ((IntValue & ICU_MASK_INTR_CC0_MATCH) == ICU_MASK_INTR_CC0_MATCH)
    {
      /* Clear INTR.CC0_Match. */
      FuncTablePtr->drvClearInterruptRequestFlag(ChannelPtr, ICU_MASK_INTR_CC0_MATCH);
      /* Update measurement information for Icu_GetInputState() */
      /* (Period and active time don't need to hold for this API.) */
      /* Set input state flags to 'ACTIVE' */
      ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_INPUTSTATE] = ICU_ACTIVE;
      /* Update measurement information for Icu_GetTimeElapsed() */
      /* Set capture event flags to 'ACTIVE' */
      ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT]  = ICU_ACTIVE;
      ChExtStatePtr->Time[ICU_CAPTURE_FLAG_MEASUREMENT]        = Icu_Resource_Tcpwm_GetCc0Counter(ChannelPtr);
    }
    /* Otherwise, ... */
    else
    {
      /* Do nothing */
    }
  }
  /* Measurement property is Duty Cycle */
  else
  {
    /*
      If (CC1_Match==1 && TC==0 && CC1>0) then a new period was captured.
          i. Clear CCx_Match flags.
          ii. Read CC0 for duty, CC1 for period.
      Hint: (CC1==0) indicates that the timer was not yet started at the time of capture.
            Although we could have captured falling and rising edge, the first period was incomplete.
      Problem: We don't know if we measured high-low (consistent period) or
               low-high (end of a period and beginning of next period). 
               This can be mitigated by listening to CC1_Match interrupt and hope to read before the next edge. 
               However, this is not bullet proof. Anyway, probably it's ok even without the interrupt.
    */
    /* If new capture event occurred, ... */
    Cc1Value = Icu_Resource_Tcpwm_GetCc1Counter(ChannelPtr);
    if (((IntValue & ICU_MASK_INTR_CC1_MATCH) == ICU_MASK_INTR_CC1_MATCH) &&
        (Cc1Value > 0u))
    {

      for (Readnumber = 0U;
           (((Readnumber == 0U)                                      ||
             ((TempCapture1 != TempCapture0) || (Cc1buffValue != 0U))) &&
            (Readnumber < ICU_UPDATE_NUMBER));
           Readnumber++)
      {
        /* 6.1 Write CC1_BUFF = 0 */
        Icu_Resource_Tcpwm_ResetCounter(ChannelPtr, ICU_CC1_BUFF_COUNT);

        /* 6.2 Read STATUS.TR_CAPTURE0 (or STATUS.TR_CAPTURE1 which is the same in this use case) */
        TempCapture0 = FuncTablePtr->drvGetInputLevel(ChannelPtr);

        /* 6.3 Read COUNTER */
        TempCounter = Icu_Resource_Tcpwm_GetCounter(ChannelPtr);

        /* 6.4 Read COUNTER again and compare against 6.3 */
        for(Timeout = 0U;
            (TempCounter == Icu_Resource_Tcpwm_GetCounter(ChannelPtr)) && (Timeout < ICU_COUNT_LOOP_TIMEOUT);
            Timeout++)
        {
        }

        /* 6.5 Clear INTR.CCx_Match. */
        /*   when CCx_Match clear, counter synchronization */
        /*   About CCx_Match, after the synchronization acquisition is actually the value defined in the act,  */
        /*   there is a possibility that the CCx_Match corresponding to the acquired values remain. */
        /*   Clear CCx_Match after synchronizing all counter values. */
        /*   If it was cleared before synchronization, */
        /*   CCx_Match may remain improper value that associated with processed information. */
        FuncTablePtr->drvClearInterruptRequestFlag(ChannelPtr, ICU_MASK_INTR_CC0_MATCH|ICU_MASK_INTR_CC1_MATCH);

        /* 6.6 Read period = CC1 */
        PrdTime = Icu_Resource_Tcpwm_GetCc1Counter(ChannelPtr);

        /* 6.7 If Register value is in inverse to ActivationEdge then */
        /*       read duty = CC0 */
        /*     else */
        /*       read duty = CC0_BUFF */
        if (((ChannelPtr->StatePtr->ActivationEdge == ICU_RISING_EDGE ) && (TempCapture0 == ICU_HIGH)) ||
            ((ChannelPtr->StatePtr->ActivationEdge == ICU_FALLING_EDGE ) && (TempCapture0 == ICU_LOW)))
        {
          ActTime = Icu_Resource_Tcpwm_GetCc0Counter(ChannelPtr);
        }
        else
        {
          ActTime = Icu_Resource_Tcpwm_GetCc0BuffCounter(ChannelPtr);
        }
        /* 6.8 Read STATUS.TR_CAPTURE0 again and compare against 6.2, */
        /*     if they are different then repeat from 6.1 */
        TempCapture1 = FuncTablePtr->drvGetInputLevel(ChannelPtr);
        
        /* 6.9 Read CC1_BUFF, */
        /*      if different than 0 then repeat from 6.1 */
        Cc1buffValue = Icu_Resource_Tcpwm_GetCc1BuffCounter(ChannelPtr);
      }

      /* Update measurement information for Icu_GetInputState() */
      /* (Period and active time don't need to hold for this API.) */
      ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_INPUTSTATE] = ICU_ACTIVE;   /* Set input state flags to 'ACTIVE' */

      /* Update measurement information for Icu_GetDutyCycleValues() */
      ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT]  = ICU_ACTIVE; /* Set capture event flags to 'ACTIVE' */
      ChExtStatePtr->Time[ICU_CAPTURE_FLAG_MEASUREMENT]        = PrdTime;    /* Store period time */
      ChExtStatePtr->ActiveTime[ICU_CAPTURE_FLAG_MEASUREMENT]  = ActTime;    /* Store active time */
    }
    /* Otherwise, ... */
    else
    {
      /* Do nothing */
    }
  }
}

/** \brief Icu_UpdateInputState
 **
 ** This function updates the input state of a channel in edge detection mode.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_UpdateInputState
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean        IntValue;
  P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = (*ChannelPtr->GetFuncTable)();
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  IntValue = FuncTablePtr->drvCheckIntrCause(ChannelPtr);
  /* If new capture event occurred, ... */
  if (TRUE == IntValue)
  {
    ChExtStatePtr->InputState[ChExtStatePtr->InputStateIndex] = ICU_ACTIVE;
  }
}

/** \brief Icu_ClearIsr_Internal
 **
 ** This function implements to clear interrupt flag.
 **
 ** \param[in] BaseAddress    Base address of channel.
 ** \param[in] ResourceId     Resource Id. It is not used in TCPWM.
 **                           It is read from properties file.
 ** \param[in] IntrClrFlag    Interrupt clear flag.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE)Icu_ClearIsr_Internal
(
  volatile P2VAR(uint32, ICU_CONST, REGSPACE) BaseAddress,
  VAR(Icu_ResourceType, AUTOMATIC)            ResourceId,
  VAR(uint8, AUTOMATIC)                       IntrClrFlag
)
{
  if (ResourceId == ICU_INVALID_RESOURCEID)
  {
    Icu_Resource_Tcpwm_ClearInterruptByBaseAddr(BaseAddress, (uint32)IntrClrFlag);
  }
  else
  {
    Icu_Resource_Gpio_ClearInterruptByBaseAddr(BaseAddress, ResourceId);
  }
}

/** \brief Icu_ClearDwIsr_Internal
 **
 ** This function implements to clear DataWire interrupt flag.
 **
 ** \param[in] BaseAddress Base address of channel.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE)Icu_ClearDwIsr_Internal
(
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) BaseAddress
)
{
  Icu_Resource_Tcpwm_DwClearInterruptFlag(BaseAddress);
}


/** \brief Icu_InitDMAChannel_Internal
 **
 ** This function initializes or de-initializes DW channel.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 ** \param[in]  InitFlag     Initializes or de-initializes DW.
 **
 ** \return     None.
 ** */
FUNC(void, ICU_CODE) Icu_InitDMAChannel_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   InitFlag
)
{
  if (InitFlag == TRUE)  /* Initialize DW   */
  {
    Icu_Resource_Tcpwm_DwInit(ChannelPtr);
  }
  else                   /* De-Initialize DW */
  {
    Icu_Resource_Tcpwm_DwDeInit(ChannelPtr);
  }
}

/** \brief Icu_ClearInterruptBeforeSleep
 **
 ** This function implements to update status and clear INTR register value before set sleep mode.
 **
 ** \param[in] ConfigPtr         Configuration pointer to config data.
 ** \param[in] AcceptInSetMode   Acceptance of wakeup signal.
 **
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_ClearInterruptBeforeSleep
(
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr,
  VAR(boolean, AUTOMATIC)                            AcceptInSetMode
)
{
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr;
  P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  Icu_ChannelType Channel;

  for (Channel = 0U; Channel < ConfigPtr->ConfiguredChannels; Channel++)
  {
    ChPtr        = &(ConfigPtr->ChannelPtr[Channel]);
    FuncTablePtr = (*ChPtr->GetFuncTable)();

    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
    if ((ChPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT) &&
        (ICU_RUNNING == ChPtr->StatePtr->Status) &&
        (FALSE == ChExtStatePtr->NotifyEnabled))
    {
      Icu_UpdateInputState(ChPtr);
      /* Capture interrupt clear before SetMode */
      FuncTablePtr->drvClearInterruptRequestFlag(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
    }
    else
    {
      if ((ICU_GPIO == ChPtr->ChannelResourceKind) && (AcceptInSetMode == TRUE) &&
          (ChPtr->StatePtr->Status != ICU_RUNNING))
      {
        /* Capture interrupt clear before SetMode */
        FuncTablePtr->drvClearInterruptRequestFlag(ChPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
      }
    }
  }

}
#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
