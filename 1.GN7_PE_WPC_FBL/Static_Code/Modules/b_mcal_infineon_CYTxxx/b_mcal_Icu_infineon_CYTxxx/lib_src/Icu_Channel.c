/** \file Icu_Channel.c
 **
 ** This file contains internal architecture function for the AUTOSAR
 ** Icu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Icu_Channel.h>
#include <Icu_Internal.h>
#include <Icu_Resource.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>

/* \brief Icu_CheckIsrAbility
 **
 ** This function gets the expected IsrAbility of a channel from internal state.
 **
 ** \param[in]  DriverStatus  Driver status of ICU module.
 ** \param[in]  WakeupMode    Wakeup status of ICU module.
 ** \param[in]  ChPtr         Pointer to the channel configuration.
 **
 ** \return     Expected IsrAbility of a channel.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckIsrAbility
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  VAR(Icu_ModeType, AUTOMATIC)                              WakeupMode,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr
);

/* \brief Icu_CheckOverflowIsrAbility
 **
 ** This function gets the expected Overflow IsrAbility of a channel from internal state.
 **
 ** \param[in]  DriverStatus  Driver status of ICU module.
 ** \param[in]  WakeupMode    Wakeup status of ICU module.
 ** \param[in]  ChPtr         Channel status information.
 **
 ** \return     TRUE software overflow interrupt is enable.
 **             FALSE if not.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckOverflowIsrAbility
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  VAR(Icu_ModeType, AUTOMATIC)                              WakeupMode,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr
);

/** \brief Icu_CheckActivation
 **
 ** This function gets the expected activation of a channel from internal state.
 **
 ** \param[in]  DriverStatus       Driver status of ICU module.
 ** \param[in]  ChPtr              Channel status information.
 ** \param[in]  CurrentActivation  Current Activation status.
 **
 ** \return     Expected activation of a channel.
 **
 ** */
static FUNC(Icu_ActivationType, ICU_CODE) Icu_CheckActivation
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        CurrentActivation
);

/** \brief Icu_GetPrescalerValue
 **
 ** This function gets prescaler value of a channel.
 **
 ** \param[in]  TickFrequency     Tick frequency of channel configuration.
 ** \param[in]  ClockFrequency    Clock frequency.
 **
 ** \return     Expected prescaler value of a channel.
 **
 ** */
static FUNC(uint8, ICU_CODE) Icu_GetPrescalerValue
(
  VAR(Icu_ClkFrequencyType, AUTOMATIC) TickFrequency,
  VAR(Icu_ClkFrequencyType, AUTOMATIC) ClockFrequency
);

/* \brief Icu_CheckDWIsrAbility
 **
 ** This function gets the expected DW IsrAbility of a channel from internal state.
 **
 ** \param[in]  DriverStatus  Driver status of ICU module.
 ** \param[in]  ChPtr         Pointer to the channel configuration.
 **
 ** \return     Expected DataWire IsrAbility of a channel.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckDWIsrAbility
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr
);

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[external function definitions]=========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/* \brief Icu_SetWakeup_Internal
 **
 ** This function implements to enable/disable the wake-up capability of a channel.
 **
 ** \param[in] ChannelPtr  Pointer to the channel configuration.
 ** \param[in] Wak         Value depended to set the wake-up state of the specified channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_SetWakeup_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   Wak
)
{
  ChannelPtr->StatePtr->WakeupEnable = Wak;
}

/* \brief Icu_SetActivationCondition_Internal
 **
 ** This function implements to set the activation condition of the ICU channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Activation   The type of activation edge of an ICU channel.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_SetActivationCondition_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        Activation
)
{
  uint32 ActReg;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = (*ChannelPtr->GetFuncTable)();
  P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)  ChExtStatePtr;

  Icu_EnterCritiSec();

  if (ChannelPtr->ChannelResourceKind == ICU_GPIO )
  {
    /* Disable interrupt, this action is applicable for GPIO resource channel */
    FuncTablePtr->drvIsrDisable(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
  }

  /* Disable counter, this action is applicable for TCPWM resource channel */
  /* It do nothing for GPIO resource channel */
  FuncTablePtr->drvCtrlEnable(ChannelPtr, FALSE);

  /* Set activation edge */
  ActReg = FuncTablePtr->drvCalculateActivation(ChannelPtr,Activation);
  FuncTablePtr->drvSetActivationCondition(ChannelPtr, ActReg);
  /* Update Activation to channel state */
  ChannelPtr->StatePtr->ActivationEdge = Activation;
  /* Enable counter, this action is applicable for TCPWM resource channel */
  /* It do nothing for GPIO resource channel */
  FuncTablePtr->drvCtrlEnable(ChannelPtr, TRUE);
  /* Clear input state for edgedetect channel */
  if (ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)
  {
    Icu_LowCountType idx;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
    ChExtStatePtr = (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
    idx = ChExtStatePtr->InputStateIndex;
    ChExtStatePtr->InputStateIndex ^= 0x01u;
    ChExtStatePtr->InputState[idx]  = ICU_IDLE;
  }
  if (ICU_RUNNING == ChannelPtr->StatePtr->Status)
  {
    /* Clear interrupt flags for clearing state */
    FuncTablePtr->drvClearInterruptRequestFlag(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
    if ((ChannelPtr->ChannelResourceKind == ICU_GPIO) &&
        (((ChannelPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT) && (ChExtStatePtr->NotifyEnabled == TRUE)) ||
         (ChannelPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)))
    {
      /* Enable interrupt */
      FuncTablePtr->drvIsrEnable(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
    }
    /* Software reload trigger counter start, this action is applicable for TCPWM resource channel */
    FuncTablePtr->drvReloadCountTrigger(ChannelPtr);
  }

  Icu_ExitCritiSec();
}

/* \brief Icu_CheckChannelStatus_Internal
 **
 ** This function checks the internal state of a channel.
 **
 ** \param[in]  Channel                Numeric identifier of the ICU channel.
 ** \param[in]  DrvPtr                 Pointer to the driver configuration.
 ** \param[out] CheckChannelStatusPtr  Pointer to return the internal state.
 ** 
 ** \return     Return Channel status.
 **             TRUE:  Channel status is valid. 
 **             FALSE: Channel status is invalid.
 **
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckChannelStatus_Internal
(
  VAR(Icu_ChannelType, AUTOMATIC)                               Channel,
  P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST)            DrvPtr,
  P2VAR  (Icu_CheckChannelStatusType, AUTOMATIC, ICU_APPL_DATA) CheckChannelStatusPtr
)
{
  boolean             IsrEnabled;
  boolean             OverIsrEnabled;
  Icu_ActivationType  Activation;
  boolean result = TRUE;
  P2VAR  (Icu_StateType,              AUTOMATIC, ICU_APPL_DATA) DrvStatePtr  = DrvPtr->StatePtr;
  P2CONST(Icu_ChannelConfigType,      AUTOMATIC, ICU_APPL_CONST) ChPtr        = &(DrvPtr->ChannelPtr[Channel]);
  P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA) ChStatePtr = ChPtr->StatePtr;
  P2CONST(Icu_drvFctTable_t,          AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = (*ChPtr->GetFuncTable)();

  Icu_EnterCritiSec();

  /* Get channel ISR enable state */
  IsrEnabled = FuncTablePtr->drvCheckIsrAbility(ChPtr);
  /* Get channel OverflowISR state */
  OverIsrEnabled = FuncTablePtr->drvCheckOverflowIsrAbility(ChPtr);
  /* Get Activation condition */
  Activation = FuncTablePtr->drvCheckActivation(ChPtr);
  /* Get current channel status  */
  Icu_GetChannelStatus(ChPtr, CheckChannelStatusPtr);
  CheckChannelStatusPtr->DriverWakeupMode      = DrvStatePtr->WakeupMode;

  if (ICU_S_INITIALIZED == CheckChannelStatusPtr->DriverStatus)
  {
    /*  Check status after initialized */
    /* Check if software and hardware counter status is sync */
    /* Channel is not running */
    if ((ChStatePtr->Status == ICU_STOPPED) || (ChStatePtr->Status == ICU_NOT_STARTED))
    {
      if( (DrvStatePtr->WakeupMode == ICU_MODE_SLEEP) && (ChStatePtr->WakeupEnable == TRUE) )
      {
        /* Check if counter is running */
        if (FALSE == FuncTablePtr->drvCheckChannelRunning(ChPtr))
        {
          result = FALSE;
        }
        
        CheckChannelStatusPtr->ChannelStatus = ChStatePtr->Status;
      }
      else
      {
        /* Check if counter is stop */
        if (FALSE == FuncTablePtr->drvCheckChannelStop(ChPtr))
        {
          if (TRUE == ChStatePtr->HWTriggerStop)
          {
            /* Channel is waiting status */
            CheckChannelStatusPtr->ChannelStatus = ICU_WAITING_STOP_TRIGGER;
          }
          else
          {
            result = FALSE;
            CheckChannelStatusPtr->ChannelStatus = ICU_RUNNING;
          }
        }
        else
        {
          CheckChannelStatusPtr->ChannelStatus = ChStatePtr->Status;
        }
      }
    }
    /* Channel is running */
    else
    {
      /* Check if counter is running */
      if (FALSE == FuncTablePtr->drvCheckChannelRunning(ChPtr))
      {
        if (ChPtr->MeasurementMode != ICU_MODE_SIGNAL_MEASUREMENT)
        {
          if (TRUE == ChStatePtr->HWTriggerStart)
          {
            /* Channel is waiting status */
            CheckChannelStatusPtr->ChannelStatus = ICU_WAITING_START_TRIGGER;
          }
          else
          {
            result = FALSE;
            CheckChannelStatusPtr->ChannelStatus = ICU_STOPPED;
          }
        }
        else
        {
          /* Channel is signal measurement mode, return software status */
          CheckChannelStatusPtr->ChannelStatus = ChStatePtr->Status;
        }
      }
      /* Counter is in running state */
      else
      {
        CheckChannelStatusPtr->ChannelStatus = ChStatePtr->Status;
      }
    }
    /* Check register status */
    if( TRUE != FuncTablePtr->drvCheckInitRegister(ChPtr) )
    {
      result = FALSE;
    }
  }
  else
  {
    /* Check channel status */
    CheckChannelStatusPtr->ChannelStatus = ChStatePtr->Status;
    /* Check register value */
    if(TRUE != FuncTablePtr->drvCheckDeinitRegister(ChPtr))
    {
      result = FALSE;
    }
  }
  /* Check channel interrupt status */
  if (IsrEnabled != Icu_CheckIsrAbility(CheckChannelStatusPtr->DriverStatus, DrvStatePtr->WakeupMode, ChPtr))
  {
    result = FALSE;
  }
  /* Check channel overflow interrupt status, if resource is GPIO, overflow interrupt does not check */
  if (OverIsrEnabled != Icu_CheckOverflowIsrAbility(CheckChannelStatusPtr->DriverStatus, DrvStatePtr->WakeupMode, ChPtr))
  {
    result = FALSE;
  }
  /* Check activation condition status */
  if (Activation != Icu_CheckActivation(CheckChannelStatusPtr->DriverStatus, ChPtr, Activation))
  {
   result = FALSE;
  }
  /* Check DW channel status */
  if (FALSE == Icu_CheckDMAChannelStatus(ChPtr, CheckChannelStatusPtr->DriverStatus))
  {
    result = FALSE;
  }

  /* Check prescaler register value */
  if (ChPtr->StatePtr->PrescalerRegisterValue != FuncTablePtr->drvGetPrescalerValue(ChPtr))
  {
    result = FALSE;
  }

  Icu_ExitCritiSec();

  return result;
}

/* \brief Icu_GetInputLevel_Internal
 **
 ** This function implements to get the level of the input pin related to an ICU channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    The level get from channel.
 **            ICU_HIGH: High level has been detected.
 **            ICU_LOW:  Low level has been detected.
 ** */
FUNC(Icu_LevelType, ICU_CODE) Icu_GetInputLevel_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_LevelType InputLevel;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = (*ChannelPtr->GetFuncTable)();

  /* Get input level */
  InputLevel = FuncTablePtr->drvGetInputLevel(ChannelPtr);

  return InputLevel;
}

/** \brief Icu_SetPrescaler_Internal
 **
 ** This function implements to set prescaler of channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] ClockFrequency   Clock frequency.
 **
 ** \return    If calculated prescaler value is valid, return TRUE, else return FALSE.
 ** */
FUNC(boolean, ICU_CODE) Icu_SetPrescaler_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ClkFrequencyType, AUTOMATIC)                      ClockFrequency
)
{
  boolean CheckResult;
  uint8 PreValue;

  PreValue = Icu_GetPrescalerValue(ChannelPtr->TickFrequency, ClockFrequency);
  if (PreValue == ICU_INVALID_PRESCALER)
  {
    CheckResult = FALSE;
  }
  else
  {
    Icu_EnterCritiSec();

    /* Set prescaler in TCPWM */
    Icu_Resource_Tcpwm_SetClockDivider(ChannelPtr, PreValue);

    ChannelPtr->StatePtr->PrescalerRegisterValue = PreValue;

    Icu_ExitCritiSec();

    CheckResult = TRUE;
  }

  return CheckResult;
}

/** \brief Icu_GetInterruptRequestFlag
 **
 ** This function gets interrupt request flag of specific channel.
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Interrupt flag value.
 **            ICU_INT_OVERFLOW: Overflow interrupt flag.
 **            ICU_INT_CAPTURE : Capture interrupt flag.
 **            ICU_NO_INT      : No interrupt flag.
 ** */
FUNC(uint32, ICU_CODE) Icu_GetInterruptRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32      retval;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = (*ChannelPtr->GetFuncTable)();
  /* Get interrupt flag */
  retval = FuncTablePtr->drvGetIsrRequestFlag(ChannelPtr);

  return retval;
}

/** \brief Icu_CheckDMAChannel
 **
 ** This function check DW channel status.
 **
 ** \param[in]  ChannelPtr   Pointer to the channel configuration.
 ** \param[in]  DriverState  Current driver initial state.
 **
 ** \return     DW channel status.
 **             TRUE:  Channel status is valid.
 **             FALSE: Channel status is invalid.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckDMAChannel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverState
)
{
  boolean DwHwIsrEnableState;
  boolean DwSwIsrEnableState;
  boolean result;
  P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA) ChStatePtr = ChannelPtr->StatePtr;
  DwHwIsrEnableState = Icu_Resource_Tcpwm_CheckDwIsrAbility(ChannelPtr);
  DwSwIsrEnableState = Icu_CheckDWIsrAbility(DriverState, ChannelPtr);
  result = TRUE;
  
  /* Check if software and hardware interrupt state is sync */
  if (DwHwIsrEnableState != DwSwIsrEnableState)
  {
    result = FALSE;
  }
  else
  {
    /* Check if software and hardware enable state is sync */
    boolean DwHwEnableState;
    /* Get DW register Enable state */
    DwHwEnableState = Icu_Resource_Tcpwm_DwGetRegisterEnabled(ChannelPtr);
    
    /* Driver initialized */
    if(ICU_S_INITIALIZED == DriverState)
    {
      /* Check DW enable state */
      if (TRUE == DwHwEnableState)
      {
        if ((ICU_STOPPED == ChStatePtr->Status) || (ICU_NOT_STARTED == ChStatePtr->Status))
        {
          result = FALSE;
        }
      }
      else
      {
        if (ICU_RUNNING == ChStatePtr->Status)
        {
          result = FALSE;
        }
      }
    }
    /* Driver uninitialized */
    else
    {
      /* Check DW enable state */
      if (TRUE == DwHwEnableState)
      {
        result = FALSE;
      }
    }
  }
  return result;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[internal function definitions]==========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/* \brief Icu_CheckIsrAbility
 **
 ** This function gets the expected IsrAbility of a channel from internal state.
 **
 ** \param[in]  DriverStatus  Driver status of ICU module.
 ** \param[in]  WakeupMode    Wakeup status of ICU module.
 ** \param[in]  ChPtr         Pointer to the channel configuration.
 **
 ** \return     Expected IsrAbility of a channel.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckIsrAbility
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  VAR(Icu_ModeType, AUTOMATIC)                              WakeupMode,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr
)
{
  boolean IsrAbility;
  P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA) ChStatePtr = ChPtr->StatePtr;

  IsrAbility = FALSE;
  if (DriverStatus == ICU_S_INITIALIZED)
  {
    if (WakeupMode == ICU_MODE_NORMAL)
    {
      if (ICU_RUNNING == ChStatePtr->Status)
      {
        if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)      /* TIMESTAMP Mode */
        {
          P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
          /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
             Justification: It is a necessary for Extension State access. */
          /* PRQA S 316 2 */
          ChExtCfgPtr =
          (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;
          if (ChExtCfgPtr->UseDMA != TRUE)
          {
            IsrAbility = TRUE;
          }
        }
        else if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_EDGE_DETECT)    /* EDGEDETECT Mode */
        {
          P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)  ChExtStatePtr;
          /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
             Justification: It is a necessary for Extension State access. */
          /* PRQA S 316 2 */
          ChExtStatePtr =
          (P2VAR(Icu_EdgeDetectChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
          if (ChExtStatePtr->NotifyEnabled == TRUE)
          {
            IsrAbility = TRUE;
          }
        }
        else if (ChPtr->MeasurementMode == ICU_MODE_EDGE_COUNTER)   /* EDGECOUNT Mode */
        {
          IsrAbility = TRUE;
        }
        else
        {
          /* IsrAbility is FALSE in MEASUREMENT mode */
        }
      }
    }
    else  /* (DrvStatePtr->WakeupMode == ICU_MODE_SLEEP) */
    {
      if (ChStatePtr->WakeupEnable == TRUE)
      {
        IsrAbility = TRUE;
      }
    }
  }
  return IsrAbility;
}

/* \brief Icu_CheckOverflowIsrAbility
 **
 ** This function gets the expected Overflow IsrAbility of a channel from internal state.
 **
 ** \param[in]  DriverStatus  Driver status of ICU module.
 ** \param[in]  WakeupMode    Wakeup status of ICU module.
 ** \param[in]  ChPtr         Channel status information.
 **
 ** \return     TRUE software overflow interrupt is enable.
 **             FALSE if not.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckOverflowIsrAbility
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  VAR(Icu_ModeType, AUTOMATIC)                              WakeupMode,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr
)
{
  boolean IsrAbility;
    
  if (DriverStatus == ICU_S_UNINITIALIZED)
  {
    IsrAbility = FALSE;
  }
  else
  {
    if (ChPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
    {
      P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
      /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
         Justification: It is a necessary for Extension State access. */
      /* PRQA S 316 2 */
      ChExtStatePtr =
      (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
      if ((ChExtStatePtr->OverflowNotifyEnabled == TRUE) && (WakeupMode == ICU_MODE_NORMAL))
      {
        IsrAbility = TRUE;
      }
      else
      {
        IsrAbility = FALSE;
      }
    }
    else if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
    {
      P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
      /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
         Justification: It is a necessary for Extension State access. */
      /* PRQA S 316 2 */
      ChExtStatePtr =
      (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChPtr->ExtStatePtr;
      if ((ChExtStatePtr->OverflowNotifyEnabled == TRUE) && (WakeupMode == ICU_MODE_NORMAL))
      {
        IsrAbility = TRUE;
      }
      else
      {
        IsrAbility = FALSE;
      }
    }
    else
    {
      IsrAbility = FALSE;
    }
  }
  return IsrAbility;
}

/* \brief Icu_CheckDWIsrAbility
 **
 ** This function gets the expected DW IsrAbility of a channel from internal state.
 **
 ** \param[in]  DriverStatus  Driver status of ICU module.
 ** \param[in]  ChPtr         Pointer to the channel configuration.
 **
 ** \return     Expected DataWire IsrAbility of a channel.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_CheckDWIsrAbility
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr
)
{
  boolean IsrAbility = FALSE;

  if (DriverStatus != ICU_S_UNINITIALIZED)
  {
    if (ChPtr->MeasurementMode == ICU_MODE_TIMESTAMP)
    {
      P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
      /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
         Justification: It is a necessary for Extension State access. */
      /* PRQA S 316 1 */
      ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;
      if (ChExtCfgPtr->UseDMA == TRUE)
      {
        if (ICU_RUNNING == ChPtr->StatePtr->Status)
        {
          IsrAbility = TRUE;
        }
      }
    }
  }

  return IsrAbility;
}

/** \brief Icu_CheckActivation
 **
 ** This function gets the expected activation of a channel from internal state.
 **
 ** \param[in]  DriverStatus       Driver status of ICU module.
 ** \param[in]  ChPtr              Channel status information.
 ** \param[in]  CurrentActivation  Current Activation status.
 **
 ** \return     Expected activation of a channel.
 **
 ** */
static FUNC(Icu_ActivationType, ICU_CODE) Icu_CheckActivation
(
  VAR(Icu_DriverStatusType, AUTOMATIC)                      DriverStatus,
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        CurrentActivation
)
{
  Icu_ActivationType ActEdge;
  Icu_ActivationType InactEdge;
  Icu_ActivationType Activation;
  P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA) ChStatePtr = ChPtr->StatePtr;

  ActEdge = ChStatePtr->ActivationEdge;
  InactEdge = (ActEdge == ICU_RISING_EDGE) ? ICU_FALLING_EDGE : ICU_RISING_EDGE;

  if (DriverStatus == ICU_S_UNINITIALIZED)
  {
    /* Activation should be ICU_INIT_EDGE in uninitialized status */
    Activation = ICU_INIT_EDGE;
  }
  else
  {
    P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChPtr->ExtConfigPtr;
    if ((ChPtr->MeasurementMode == ICU_MODE_SIGNAL_MEASUREMENT)
      && (ChExtCfgPtr->MeasurementProperty != ICU_PERIOD_TIME))
    {
      if (ICU_RUNNING == ChStatePtr->Status)
      {
        Activation = InactEdge;
      }
      else
      {
        /* No check : return CurrentActivation */
        Activation = CurrentActivation;
      }
    }
    else
    {
      Activation = ActEdge;
    }
  }

  return Activation;
}

/** \brief Icu_GetPrescalerValue
 **
 ** This function gets prescaler value of a channel.
 **
 ** \param[in]  TickFrequency     Tick frequency of channel configuration.
 ** \param[in]  ClockFrequency    Clock frequency.
 **
 ** \return     Expected prescaler value of a channel.
 **
 ** */
static FUNC(uint8, ICU_CODE) Icu_GetPrescalerValue
(
  VAR(Icu_ClkFrequencyType, AUTOMATIC) TickFrequency,
  VAR(Icu_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  uint8 prescaler;
  uint32 divider;

  /* clock frequency check */
  divider = ClockFrequency/TickFrequency;
  if (divider == ICU_PRESCALING_DIVIDE_NONE)
  {
    prescaler = ICU_INVALID_PRESCALER;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_1+ICU_PRESCALING_DIVIDE_BY_2)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_1;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_2+ICU_PRESCALING_DIVIDE_BY_4)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_2;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_4+ICU_PRESCALING_DIVIDE_BY_8)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_4;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_8+ICU_PRESCALING_DIVIDE_BY_16)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_8;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_16+ICU_PRESCALING_DIVIDE_BY_32)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_16;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_32+ICU_PRESCALING_DIVIDE_BY_64)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_32;
  }
  else if (divider <= ((ICU_PRESCALING_DIVIDE_BY_64+ICU_PRESCALING_DIVIDE_BY_128)/ICU_HALF_DIVIDER))
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_64;
  }
  else
  {
    prescaler = ICU_PRESCALER_DIVIDE_BY_128;
  }

  return prescaler;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[end of file]===========================================*/ 
