/** \file Icu_Resource_Tcpwm.c
 ** \brief AUTOSAR Icu Driver
 **
 ** This file contains the implementation of the AUTOSAR module Icu
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Icu_Resource.h>

/*==================[prototypes]==============================================*/

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/
#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>

/** \brief Icu_Resource_Tcpwm_GetCc0BaseAddr
 **
 ** This function gets baseaddress of the cc0 register of specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    CC0 register baseaddress.
 **
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetCc0BaseAddr
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_GetActivationCondition
 **
 ** This function gets TR_IN_EDGE_SEL register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Value of TR_IN_EDGE_SEL register.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_GetInputLevel
 **
 ** This function gets the current input level a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Current input level of a specific channel.
 **
 ** */
static FUNC(Icu_LevelType, ICU_CODE) Icu_Resource_Tcpwm_GetInputLevel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_Init
 **
 ** This function initializes the registers of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_Init
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_SetActivationCondition
 **
 ** This function sets the activation condition of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] RegValue     Value to be set in register TR_IN_EDGE_SEL.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    RegValue
);

/** \brief Icu_Resource_Tcpwm_ClearInterruptRequestFlag
 **
 ** This function clears the interrupt request flag bit of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Clear Interrupt value.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ClearInterruptRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
);

/** \brief Icu_Resource_Tcpwm_GetIsrRequestFlag
 **
 ** This function gets the interrupt request flag of specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Interrupt request flag value.
 **            ICU_INT_OVERFLOW: Overflow interrupt flag.
 **            ICU_INT_CAPTURE : Capture interrupt flag.
 **
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetIsrRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);


/** \brief Icu_Resource_Tcpwm_InterruptDisable
 **
 ** This function disables the interrupt of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt value.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_InterruptDisable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
);

/** \brief Icu_Resource_Tcpwm_InterruptEnable
 **
 ** This function enables the interrupt of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt value.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_InterruptEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
);

/** \brief Icu_Resource_Tcpwm_DeInit
 **
 ** This function de-initializes the resource of TCPWM.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DeInit
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_StartCountTrigger
 **
 ** This function starts count trigger of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_StartCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_ReloadCountTrigger
 **
 ** This function reloads count trigger of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ReloadCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckDeinitRegister
 **
 ** This function gets channel register state in de-initialization.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of checking register.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckDeinitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckInitRegister
 **
 ** This function gets channel register state in initialization.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of checking register.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckInitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_SetInputStartTrigger
 **
 ** This function selects input trigger for a specific channel.
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 ** \param[in] TriggerSrc Trigger source.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetInputStartTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                     TriggerSrc
);

/** \brief Icu_Resource_Tcpwm_SetReloadTriggerEdge
 **
 ** This function sets reload trigger edge for a specific channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetReloadTriggerEdge
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_ClearInputTrigger
 **
 ** The function clears input trigger.
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ClearInputTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CalculateActivation
 **
 ** The function calculates value to be set in register TR_IN_EDGE_SEL.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Activation   The type of activation edge of an ICU channel.
 **
 ** \return    Calculated TR_IN_EDGE_SEL register value.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_CalculateActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        Activation
);

/** \brief Icu_Resource_Tcpwm_CtrlEnable
 **
 ** This function sets CTRL register enable or disable.
 **
 ** \param[in] ChannelPtr  Pointer to the channel configuration.
 ** \param[in] CtrlMode    Control counter enable or disable.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_CtrlEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   CtrlMode
);

/** \brief Icu_Resource_Tcpwm_CheckActivation
 **
 ** The function checks activation of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Activation edge of an ICU channel.
 ** */
static FUNC(Icu_ActivationType, ICU_CODE) Icu_Resource_Tcpwm_CheckActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckIsrAbility
 **
 ** The function checks Isr Ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Isr Ability of an ICU channel.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckOverflowIsrAbility
 **
 ** The function checks Overflow Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Overflow Isr Ability of an ICU channel.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckOverflowIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_GetPrescalerValue
 **
 ** The function gets DT register value of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    DT register value of ICU channel.
 ** */
static FUNC(uint8, ICU_CODE) Icu_Resource_Tcpwm_GetPrescalerValue
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckChRunning
 **
 ** The function checks running state of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Result of checking running state.
 **            TRUE:  HardWare state is running state.
 **            FALSE: HardWare state is not running state.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckChRunning
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckChStop
 **
 ** The function checks stopped state of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Result of checking stopped state.
 **            TRUE:  HardWare state is stopped state.
 **            FALSE: HardWare state is not stopped state.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckChStop
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Tcpwm_CheckCaptureIntrCause
 **
 ** This function checks if CC0_MATCH interrupt was detected.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of detecting edge.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckCaptureIntrCause
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/
#define ICU_START_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: Since the section to place data is specified, it should be placed in a different location from the reference function. */
/* PRQA S 3218 29 */
static CONST(Icu_drvFctTable_t, ICU_CONST) Icu_TcpwmDrvFctTable =
{
  (Icu_drvVoidFct_t)       &Icu_Resource_Tcpwm_Init,
  (Icu_drvVoidFct2_t)      &Icu_Resource_Tcpwm_SetActivationCondition,
  (Icu_drvVoidFct3_t)      &Icu_Resource_Tcpwm_InterruptEnable,
  (Icu_drvVoidFct3_t)      &Icu_Resource_Tcpwm_InterruptDisable,
  (Icu_drvVoidFct3_t)      &Icu_Resource_Tcpwm_ClearInterruptRequestFlag,
  (Icu_drvRegValFct_t)     &Icu_Resource_Tcpwm_GetIsrRequestFlag,
  (Icu_drvRegValFct_t)     &Icu_Resource_Tcpwm_GetActivationCondition,
  (Icu_drvEdgeFct_t)       &Icu_Resource_Tcpwm_GetInputLevel,
  (Icu_drvVoidFct_t)       &Icu_Resource_Tcpwm_DeInit,
  (Icu_drvVoidFct_t)       &Icu_Resource_Tcpwm_StartCountTrigger,
  (Icu_drvVoidFct_t)       &Icu_Resource_Tcpwm_ReloadCountTrigger,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckDeinitRegister,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckInitRegister,
  (Icu_drvTriggerFct_t)    &Icu_Resource_Tcpwm_SetInputStartTrigger,
  (Icu_drvVoidFct_t)       &Icu_Resource_Tcpwm_SetReloadTriggerEdge,
  (Icu_drvVoidFct_t)       &Icu_Resource_Tcpwm_ClearInputTrigger,
  (Icu_drvCalValFct_t)     &Icu_Resource_Tcpwm_CalculateActivation,
  (Icu_drvCtrlFct_t)       &Icu_Resource_Tcpwm_CtrlEnable,
  (Icu_drvCheckActFct_t)   &Icu_Resource_Tcpwm_CheckActivation,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckIsrAbility,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckOverflowIsrAbility,
  (Icu_drvDividFct_t)      &Icu_Resource_Tcpwm_GetPrescalerValue,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckChRunning,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckChStop,
  (Icu_drvCheckRegFct_t)   &Icu_Resource_Tcpwm_CheckCaptureIntrCause
};

#define ICU_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/** \brief Icu_Tcpwm_GetFuncTable
 **
 ** This function gets the address of the functional table of TCPWM in register layer.
 **
 ** \param[in] None.
 **
 ** \return    Return the pointer to Icu_drvFctTable_t.
 **
 ** */
FUNC_P2CONST(Icu_drvFctTable_t, ICU_APPL_CONST, ICU_CODE) Icu_Tcpwm_GetFuncTable(void)
{
  return &Icu_TcpwmDrvFctTable;
}

/** \brief Icu_Resource_Tcpwm_ResetCounter
 **
 ** This function resets the COUNTER register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Count        Counter to be reset.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ResetCounter
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                     Count
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Clear CC0 value */
  if ((ICU_CC0_COUNT & Count) == ICU_CC0_COUNT)
  {
    IcuReg->Cc0 = ICU_RESET_COUNTER_VALUE;
  }

  /* Clear CC1 value */
  if ((ICU_CC1_COUNT & Count) == ICU_CC1_COUNT)
  {
    IcuReg->Cc1 = ICU_RESET_COUNTER_VALUE;
  }

  /* Clear CC0_BUFF value */
  if ((ICU_CC0_BUFF_COUNT & Count) == ICU_CC0_BUFF_COUNT)
  {
    IcuReg->Cc0_buff = ICU_RESET_COUNTER_VALUE;
  }

  /* Clear CC1_BUFF count */
  if ((ICU_CC1_BUFF_COUNT & Count) == ICU_CC1_BUFF_COUNT)
  {
    IcuReg->Cc1_buff = ICU_RESET_COUNTER_VALUE;
  }
}

/** \brief Icu_Resource_Tcpwm_GetCounter
 **
 ** This function gets the COUNTER register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    COUNTER register value.
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_Resource_Tcpwm_GetCounter
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_ValueType retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Get COUNTER value */
  retval = (Icu_ValueType)IcuReg->Counter;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetCc0Counter
 **
 ** This function gets the CC0 register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    CC0 register value.
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_Resource_Tcpwm_GetCc0Counter
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_ValueType retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Get CC0 value */
  retval = (Icu_ValueType)IcuReg->Cc0;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetCc1Counter
 **
 ** This function gets the CC1 register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    CC1 register value.
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_Resource_Tcpwm_GetCc1Counter
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_ValueType retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Get CC1 value */
  retval = (Icu_ValueType)IcuReg->Cc1;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetCc0BuffCounter
 **
 ** This function gets the CC0_BUFF register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    CC0_BUFF register value.
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_Resource_Tcpwm_GetCc0BuffCounter
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_ValueType retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Get CC0_BUFF value */
  retval = (Icu_ValueType)IcuReg->Cc0_buff;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetCc1BuffCounter
 **
 ** This function gets the CC1_BUFF register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    CC1_BUFF register value.
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_Resource_Tcpwm_GetCc1BuffCounter
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_ValueType retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Get CC1_BUFF value */
  retval = (Icu_ValueType)IcuReg->Cc1_buff;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_SetClockDivider
 **
 ** The function sets clock divider of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Divider      Counter divider value.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetClockDivider
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                     Divider
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  /* Disable counter */
  IcuReg->Ctrl &= ~ICU_MASK_CTRL_ENABLED;

  /* Set DT register */
  IcuReg->Dt = (uint32)Divider;

  /* Enable counter */
  IcuReg->Ctrl |= ICU_MASK_CTRL_ENABLED;
}

/** \brief Icu_Resource_Tcpwm_DwSetting
 **
 ** The function set DataWire register to start data transfer.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwSetting
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);
  
  /* DataWire Descriptor set */
  /**********
  DataWire Descriptor set Icu_StartTimestampDma_Internal
  Pre-Condition: (BufferSize % NotifyInterval == 0u)
  **********/
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
     Justification: Casting to integer value from pointer for comparing address values */
  /* PRQA S 306 1 */
  DWReg->Ch_Curr_Ptr = (uint32)ChExtCfgPtr->DWDescPtr;

  if (ChExtCfgPtr->BufferMode == ICU_CIRCULAR_BUFFER)
  {
    /* Set default value for 2D transfer */
    ChExtCfgPtr->DWDescPtr->Descr_Ctl = ICU_DW_DESC_CTL_DEFAULT;
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: Casting to integer value from pointer for comparing address values */
    /* PRQA S 306 1 */
    ChExtCfgPtr->DWDescPtr->Descr_Next_Ptr = (uint32)ChExtCfgPtr->DWDescPtr;
  }
  else
  {
    /* Set value to disable channel after completion of the current descriptor for 2D transfer */
    ChExtCfgPtr->DWDescPtr->Descr_Ctl = ICU_DW_DESC_CTL_DISABLE_NEXTCH;
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: Casting to integer value from pointer for comparing address values */
    /* PRQA S 306 1 */
    ChExtCfgPtr->DWDescPtr->Descr_Next_Ptr = (uint32)NULL_PTR;
  }
  ChExtCfgPtr->DWDescPtr->Descr_Src = Icu_Resource_Tcpwm_GetCc0BaseAddr(ChannelPtr);
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
     Justification: Casting to integer value from pointer for comparing address values */
  /* PRQA S 306 1 */
  ChExtCfgPtr->DWDescPtr->Descr_Dst = (uint32)ChExtStatePtr->BufferPtr;

  /* 2D  */
  ChExtCfgPtr->DWDescPtr->Descr_X_Ctl =
  (uint32)(((uint32)((uint32)(ChExtStatePtr->NotifyInterval) - 1UL) << ICU_DW_SHIFT_X_COUNT) |
           ((uint32)1UL << ICU_DW_SHIFT_DST_X_INCR));
  ChExtCfgPtr->DWDescPtr->Descr_Y_Ctl =
  (uint32)(((uint32)(((uint32)(ChExtStatePtr->BufferSize) / (uint32)(ChExtStatePtr->NotifyInterval)) - 1UL) << ICU_DW_SHIFT_Y_COUNT) |
           ((uint32)(ChExtStatePtr->NotifyInterval) << ICU_DW_SHIFT_DST_Y_INCR));

  /* Initialize Ch_Idx */
  DWReg->Ch_Idx = 0u;
  /* Enable DW transfer */
  DWReg->Ch_Ctl |= ICU_DW_MASK_CH_CTL_ENABLE;
}

/** \brief Icu_Resource_Tcpwm_DwDisable
 **
 ** The function disables DataWire transfer.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwDisable 
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  /* Disable DW transfer */
  DWReg->Ch_Ctl &= ~ICU_DW_MASK_CH_CTL_ENABLE;

}

/** \brief Icu_Resource_Tcpwm_DwInterruptEnable
 **
 ** The function enables DataWire interrupt.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwInterruptEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  /* Clear interrupt flag */
  DWReg->Intr = ICU_DW_MASK_INTR_CH;
  /* Enable interrupt */
  DWReg->Intr_Mask = ICU_DW_MASK_INTR_MASK_CH;
  /* Read INTR register (This read ensures that the write has been flushed to hardware) */
  (void)DWReg->Intr;
}


/** \brief Icu_Resource_Tcpwm_DwInterruptDisable
 **
 ** The function disables DataWire interrupt.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwInterruptDisable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  /* Disable interrupt */
  DWReg->Intr_Mask = 0u;

  /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
  (void)DWReg->Intr_Mask;
}


/** \brief Icu_Resource_Tcpwm_CheckDwIsrAbility
 **
 ** The function checks DataWire Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    DataWire Isr ability of an ICU channel.
 ** */
FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckDwIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean retval;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  /* Check value of register INTR_MASK:CH */
  retval = ((DWReg->Intr_Mask & ICU_DW_MASK_INTR_MASK_CH) != 0x0u) ? TRUE : FALSE;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetDwBuffIndex
 **
 ** The function gets buffer transfer index when use DW transfer.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Return the value of buffer transfer index
 ** */
FUNC(Icu_IndexType, ICU_CODE) Icu_Resource_Tcpwm_GetDwBuffIndex
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_IndexType retval;
  uint32 IdxReg;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  /* Get current Ch_Idx value */
  IdxReg = DWReg->Ch_Idx;

  /* Calculate current buffer transfer index */
  retval = (Icu_IndexType)((((IdxReg >> ICU_DW_SHIFT_CH_IDX) & ICU_DW_MASK_CH_IDX) *
                           (uint32)ChExtStatePtr->NotifyInterval) +
                           (IdxReg & ICU_DW_MASK_CH_IDX));

  return retval;
}

/** \brief Icu_Resource_Tcpwm_DwClearInterruptFlag
 **
 ** The function clears DataWire interrupt flag.
 **
 ** \param[in] IcuDwBaseAddr   DataWire register base address.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwClearInterruptFlag
(
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) IcuDwBaseAddr
)
{
  IcuDwBaseAddr->Intr = ICU_DW_MASK_INTR_CH;

  (void)IcuDwBaseAddr->Intr;
}

/** \brief Icu_Resource_Tcpwm_DwGetInterruptFlag
 **
 ** The function gets DataWire interrupt flag.
 **
 ** \param[in] IcuDwBaseAddr   DataWire register base address.
 **
 ** \return    None.
 ** */
FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_DwGetInterruptFlag
(
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) IcuDwBaseAddr
)
{
  boolean  retval;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(IcuDwBaseAddr);

  /* Check if INTR_MASKED:CH is 1 */
  if (ICU_DW_MASK_INTR_MASKED_CH == (DWReg->Intr_Masked & ICU_DW_MASK_INTR_MASKED_CH))
  {
    retval = TRUE;
  }
  else
  {
    retval = FALSE;
  }

  return retval;
}

/** \brief Icu_Resource_Tcpwm_ClearInterruptByBaseAddr
 **
 ** This function clears the interrupt request flag bit of specific TCPWM channel.
 **
 ** \param[in] IcuChannelBaseAddr Base address of the TCWPM hardware resource register structure.
 ** \param[in] IntValue           Clear Interrupt value.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ClearInterruptByBaseAddr
(
  volatile P2VAR(uint32, ICU_CONST, REGSPACE) IcuChannelBaseAddr,
  VAR(uint32, AUTOMATIC)                      IntValue
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(IcuChannelBaseAddr);

  /* Clear the interrupt flag for the specified channel */
  IcuReg->Intr = (uint32)IntValue;

  (void)IcuReg->Intr;
}


/** \brief Icu_Resource_Tcpwm_CalEdgeMode
 **
 ** This function calculates edge mode.
 **
 ** \param[in] Activation   Activation of channel.
 **
 ** \return    Edge mode value.
 ** */
FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_CalEdgeMode
(
  VAR(Icu_ActivationType, AUTOMATIC) Activation
)
{
  uint32 CalValue;

  switch (Activation)
  {
    case ICU_RISING_EDGE:
      CalValue = ICU_REGS_ICS_RISING_EDGE;
      break;
    case ICU_FALLING_EDGE:
      CalValue = ICU_REGS_ICS_FALLING_EDGE;
      break;
    case ICU_BOTH_EDGES:
      CalValue = ICU_REGS_ICS_ANY_EDGES;
      break;
    default:
      CalValue = ICU_REGS_ICS_NO_EDGE_DET;
      break;
  }

  return CalValue;
}

/** \brief Icu_Resource_Tcpwm_GetInterruptFlag
 **
 ** This function gets the INTR register value of specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    INTR register value.
 **
 ** */
FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetInterruptFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32  retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  retval = (uint32)IcuReg->Intr;

  return retval;
}


/** \brief Icu_Resource_Tcpwm_GetDWStatus
 **
 ** This function gets the DataWire CH_STATUS register value of specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    DW CH_STATUS register value.
 **
 ** */
FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetDWStatus
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32 retval;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);
  retval = (uint32)DWReg->Ch_Status;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_DwInit
 **
 ** This function initializes the DataWire registers of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwInit
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);
  /* Disable interrupt */
  DWReg->Intr_Mask = 0u;
  DWReg->Ch_Ctl = ICU_DW_CH_CTL_RESET_VALUE;
}


/** \brief Icu_Resource_Tcpwm_DwDeInit
 **
 ** This function de-initializes the DataWire registers of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DwDeInit
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);
  /* Disable interrupt */
  DWReg->Intr_Mask = 0u;
  DWReg->Ch_Ctl = ICU_DW_CH_CTL_RESET_VALUE;
}

/** \brief Icu_Resource_Tcpwm_DwGetRegisterEnabled
 **
 ** This function gets the CH_CTL register ENABLED bit value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Return CH_CTL register ENABLED bit value.
 **            TRUE :     DW Enabled.
 **            FALSE:     DW Disabled.
 ** */
FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_DwGetRegisterEnabled
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;
  boolean retval;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  if (ICU_DW_MASK_CH_CTL_ENABLE == (DWReg->Ch_Ctl & ICU_DW_MASK_CH_CTL_ENABLE))
  {
    retval = TRUE;
  }
  else
  {
    retval = FALSE;
  }

  return retval;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[internal function definitions]==========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>


/** \brief Icu_Resource_Tcpwm_GetCc0BaseAddr
 **
 ** This function gets baseaddress of the CC0 register of specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    CC0 register baseaddress.
 **
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetCc0BaseAddr
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32 retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 1 */
  retval = (uint32)(&IcuReg->Cc0);

  return retval;
}


/** \brief Icu_Resource_Tcpwm_GetActivationCondition
 **
 ** This function gets TR_IN_EDGE_SEL register value of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Value of TR_IN_EDGE_SEL register.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32  retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  retval = (uint32)IcuReg->Tr_in_edge_sel;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetInputLevel
 **
 ** This function gets the current input level a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Current input level of a specific channel.
 **
 ** */
static FUNC(Icu_LevelType, ICU_CODE) Icu_Resource_Tcpwm_GetInputLevel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_LevelType retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* (TR_CAPTURE0 == 1) */
  if ((IcuReg->Status & ICU_MASK_STATUS_TR_CAPTURE0) == ICU_MASK_STATUS_TR_CAPTURE0)
  {
    retval = ICU_HIGH;
  }
  /* (TR_CAPTURE0 == 0) */
  else
  {
    retval = ICU_LOW;
  }

  return retval;
}

/** \brief Icu_Resource_Tcpwm_Init
 **
 ** This function initializes the registers of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_Init
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32 TrSel0Value;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Initialize CTRL register */
  if (TRUE == ChannelPtr->EnableDebug)
  {
    /* Debug enable */
    IcuReg->Ctrl = (uint32)(ICU_TCPWM_CTRL_INIT_VALUE | ICU_TCPWM_CTRL_DBG_FREEZE_EN);
  }
  else
  {
    /* Debug disable */
    IcuReg->Ctrl = ICU_TCPWM_CTRL_INIT_VALUE;
  }

  /* Set PRRIOD register */
  IcuReg->Period = ICU_REGS_VALUE_PERIOD;

  /* Initialize COUNTER register */
  IcuReg->Counter = ICU_RESET_COUNTER_VALUE;

  /* Set prescaler */
  IcuReg->Dt = (uint32)(ChannelPtr->PrescalerValue);

  /* Set Output Trigger register*/
  if (ICU_MODE_TIMESTAMP == ChannelPtr->MeasurementMode)
  {
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    if (ChExtCfgPtr->UseDMA == TRUE)
    {
      IcuReg->Tr_out_sel = ICU_TCPWM_DMA_TR_OUT_SEL_INIT_VALUE;
    }
    else
    {
      IcuReg->Tr_out_sel = ICU_TCPWM_TR_OUT_SEL_INIT_VALUE;
    }
  }
  else
  {
    IcuReg->Tr_out_sel = ICU_TCPWM_TR_OUT_SEL_INIT_VALUE;
  }

  /* Set input trigger */
  TrSel0Value = (uint32)(ChannelPtr->InputTrigger);
  /* Set count input trigger (bits 8:15) */
  TrSel0Value |= (uint32)(ICU_REGS_VALUE_TR_IN_SEL0_COUNT_SEL << ICU_SHIFT_TR_IN_SEL0_COUNT_SEL);

  /* Check if signal measurement mode */
  if (ICU_MODE_SIGNAL_MEASUREMENT == ChannelPtr->MeasurementMode)
  {
    P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    
    /* Check if measurement duty */
    if (ICU_DUTY_CYCLE == ChExtCfgPtr->MeasurementProperty)
    {
      /* Set capture1 input trigger */
      IcuReg->Tr_in_sel1 = ((uint32)(ChannelPtr->InputTrigger)) << ICU_SHIFT_TR_IN_SEL1_CAPTURE1_SEL;
    }
    else
    {
      /* Initialize Tr_in_sel1 */
      IcuReg->Tr_in_sel1 = ICU_TCPWM_TR_IN_SEL_INIT_VALUE;
    }
  }
  else
  {
    /* Initialize Tr_in_sel1 */
    IcuReg->Tr_in_sel1 = ICU_TCPWM_TR_IN_SEL_INIT_VALUE;
  }
  if (ChannelPtr->InputStopTrigger != ICU_INVALID_TRIGGERVALUE)
  {
    /* Initialize Tr_in_edge_sel */
    IcuReg->Tr_in_edge_sel = ((ICU_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE) & (~ICU_MASK_TR_IN_EDGE_SEL_STOP_EDGE));
    TrSel0Value |= ((uint32)(ChannelPtr->InputStopTrigger) << ICU_SHIFT_TR_IN_SEL0_STOP_SEL);
  }
  else
  {
    /* Initialize Tr_in_edge_sel */
    IcuReg->Tr_in_edge_sel = ICU_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE;
  }
  /* Write value to register TR_IN_SEL0 */
  IcuReg->Tr_in_sel0 = TrSel0Value;
}

/** \brief Icu_Resource_Tcpwm_DeInit
 **
 ** This function de-initializes the resource of TCPWM.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_DeInit
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Disable interrupt */
  IcuReg->Intr_mask = 0u;
  /* De-Initialize CTRL register */
  IcuReg->Ctrl = ICU_TCPWM_CTRL_DEINIT_VALUE;
  /* De-Initialize PERIOD register */
  IcuReg->Period = ICU_REGS_VALUE_PERIOD;
  /* De-Initialize DT register */
  IcuReg->Dt = ICU_TCPWM_DT_DEINIT_VALUE;
  /* De-Initialize TR_OUT_SEL register */
  IcuReg->Tr_out_sel = ICU_TCPWM_TR_OUT_SEL_DEINIT_VALUE;
  /* De-Initialize TR_IN_SEL0 register */
  IcuReg->Tr_in_sel0 = ICU_TCPWM_TR_IN_SEL0_INIT_VALUE;
  /* De-Initialize TR_IN_SEL1 register */
  IcuReg->Tr_in_sel1 = ICU_TCPWM_TR_IN_SEL1_INIT_VALUE;
  /* De-Initialize TR_IN_EDGE_SEL register */
  IcuReg->Tr_in_edge_sel = ICU_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE;
  /* De-Initialize COUNTER register */
  IcuReg->Counter = ICU_RESET_COUNTER_VALUE;
}

/** \brief Icu_Resource_Tcpwm_SetActivationCondition
 **
 ** This function sets the activation condition of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] RegValue     Value to be set in register TR_IN_EDGE_SEL.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    RegValue
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  IcuReg->Tr_in_edge_sel = RegValue;
}

/** \brief Icu_Resource_Tcpwm_ClearInterruptRequestFlag
 **
 ** This function clears the interrupt request flag bit of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Clear Interrupt value.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ClearInterruptRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Clear interrupt flag */
  IcuReg->Intr = (uint32)IntValue;

  (void)IcuReg->Intr;
}

/** \brief Icu_Resource_Tcpwm_GetIsrRequestFlag
 **
 ** This function gets the interrupt request flag of specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Interrupt request flag value.
 **            ICU_INT_OVERFLOW: Overflow interrupt flag.
 **            ICU_INT_CAPTURE : Capture interrupt flag.
 **            ICU_INT_CC1MATCH: CC1_MATCH interrupt flag.
 **
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_GetIsrRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32  retval;
  uint32  IntrMaskedValue;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  IntrMaskedValue = IcuReg->Intr_masked;
  
  /* Check if TC interrupt flag has been set */
  if (ICU_MASK_INTR_MASKED_TC == (IntrMaskedValue & ICU_MASK_INTR_MASKED_TC))
  {
    retval = ICU_INT_OVERFLOW;
  }
  else
  {
    retval = 0x0u;
  }
  
  /* Check if CC0_MATCH interrupt flag has been set */
  if (ICU_MASK_INTR_MASKED_CC0_MATCH == (IntrMaskedValue & ICU_MASK_INTR_MASKED_CC0_MATCH))
  {
    retval |= ICU_INT_CAPTURE;
  }

  /* Check if CC1_MATCH interrupt flag has been set */
  if (ICU_MASK_INTR_MASKED_CC1_MATCH == (IntrMaskedValue & ICU_MASK_INTR_MASKED_CC1_MATCH))
  {
    retval |= ICU_INT_CC1MATCH;
  }

  return retval;
}

/** \brief Icu_Resource_Tcpwm_InterruptEnable
 **
 ** This function enables the interrupt of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt value.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_InterruptEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Set interrupt */
  IcuReg->Intr_mask |= IntValue;
}

/** \brief Icu_Resource_Tcpwm_InterruptDisable
 **
 ** This function disables the interrupt of a specific channel.
 **
 ** \param[in] ChannelPtr  Pointer to the channel configuration.
 ** \param[in] IntValue    Interrupt value.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_InterruptDisable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Set interrupt */
  IcuReg->Intr_mask &= ~IntValue;

  (void)IcuReg->Intr_mask;
}

/** \brief Icu_Resource_Tcpwm_StartCountTrigger
 **
 ** This function starts count trigger of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_StartCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* SW start trigger of counter timer */
  IcuReg->Tr_cmd |= ICU_MASK_TR_CMD_START;
}


/** \brief Icu_Resource_Tcpwm_ReloadCountTrigger
 **
 ** This function reloads count trigger of a specific channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ReloadCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
 
  /* SW reload trigger of counter timer */
  IcuReg->Tr_cmd |= ICU_MASK_TR_CMD_RELOAD;
  /* Read Tr_cmd register (This read ensures that the write has been flushed to hardware) */
  (void)IcuReg->Tr_cmd;

}

/** \brief Icu_Resource_Tcpwm_CheckDeinitRegister
 **
 ** This function gets channel register state in de-initialization.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of checking register.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckDeinitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Check counter enable state */
  if (0u != (IcuReg->Ctrl & ICU_MASK_CTRL_ENABLED))
  {
    retval = FALSE;
  }
  else
  {
    retval = TRUE;
  }

  /* Check debug mode */
  if (0u != (IcuReg->Ctrl & ICU_TCPWM_CTRL_DBG_FREEZE_EN))
  {
    retval = FALSE;
  }

  /* Check PERIOD register */
  /* 32bit timer width */
  if (ICU_TIMER_WIDTH_32 == ChannelPtr->CountWidth)
  {
    if (ICU_REGS_VALUE_PERIOD != IcuReg->Period)
    {
      retval = FALSE;
    }
  }
  else   /* 16bit timer width */
  {
    if ((uint32)(ICU_REGS_VALUE_PERIOD & ICU_16BIT_MAX_TIMER_VALUE) != IcuReg->Period)
    {
      retval = FALSE;
    }
  }

  /* Check counter register */
  if (ICU_RESET_COUNTER_VALUE != IcuReg->Counter)
  {
    retval = FALSE;
  }

  /* Check Output trigger register */
  if (ICU_TCPWM_TR_OUT_SEL_DEINIT_VALUE != (IcuReg->Tr_out_sel & ICU_MASK_TR_OUT_SEL))
  {
    retval = FALSE;
  }

  /* Check Tr_in_edge_sel register */
  if (ICU_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE != (IcuReg->Tr_in_edge_sel & ICU_MASK_TR_IN_EDGE_SEL))
  {
    retval = FALSE;
  }

  /* Check Tr_in_sel0 register */
  if (ICU_TCPWM_TR_IN_SEL0_INIT_VALUE != IcuReg->Tr_in_sel0)
  {
    retval = FALSE;
  }

  /* Check Tr_in_sel1 register */
  if (ICU_TCPWM_TR_IN_SEL1_INIT_VALUE != (IcuReg->Tr_in_sel1 & ICU_MASK_TR_IN_SEL1))
  {
    retval = FALSE;
  }

  return retval;
}

/** \brief Icu_Resource_Tcpwm_CheckInitRegister
 **
 ** This function gets channel register state in initialization.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of checking register.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckInitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  retval = TRUE;
  
  /* Check debug enable status */
  if (TRUE == ChannelPtr->EnableDebug)
  {
    /* Check debug mode */
    if (0u == (IcuReg->Ctrl & ICU_TCPWM_CTRL_DBG_FREEZE_EN))
    {
      retval = FALSE;
    }
  }
  else
  {
    if (0u != (IcuReg->Ctrl & ICU_TCPWM_CTRL_DBG_FREEZE_EN))
    {
      retval = FALSE;
    }
  }

  /* Check Period register */
  /* 32bit timer width */
  if (ICU_TIMER_WIDTH_32 == ChannelPtr->CountWidth)
  {
    if (ICU_REGS_VALUE_PERIOD != IcuReg->Period)
    {
      retval = FALSE;
    }
  }
  else   /* 16bit timer width */
  {
    if ((uint32)(ICU_REGS_VALUE_PERIOD & ICU_16BIT_MAX_TIMER_VALUE) != IcuReg->Period)
    {
      retval = FALSE;
    }
  }
  
  /* Check Output Trigger register */
  if (ICU_MODE_TIMESTAMP == ChannelPtr->MeasurementMode)
  {
    P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    if (ChExtCfgPtr->UseDMA == TRUE)
    {
      if (ICU_TCPWM_DMA_TR_OUT_SEL_INIT_VALUE != (IcuReg->Tr_out_sel & ICU_MASK_TR_OUT_SEL))
      {
        retval = FALSE;
      }
    }
    else /* No DW */
    {
      if (ICU_TCPWM_TR_OUT_SEL_INIT_VALUE != (IcuReg->Tr_out_sel & ICU_MASK_TR_OUT_SEL))
      {
        retval = FALSE;
      }
    }
  }  /* Other MeasurementMode */
  else
  {
    if (ICU_TCPWM_TR_OUT_SEL_INIT_VALUE != (IcuReg->Tr_out_sel & ICU_MASK_TR_OUT_SEL))
    {
      retval = FALSE;
    }
  }

  /* Check CAPTURE0_SEL register */
  if((uint32)(ChannelPtr->InputTrigger) != (IcuReg->Tr_in_sel0 & ICU_MASK_TR_IN_SEL0_CAPTURE0_SEL))
  {
    retval = FALSE;
  }

  /* Check CAPTURE1_SEL register */
  if (ICU_MODE_SIGNAL_MEASUREMENT == ChannelPtr->MeasurementMode)
  {
    P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)ChExtCfgPtr;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
       Justification: It is a necessary for Extension State access. */
    /* PRQA S 316 1 */
    ChExtCfgPtr = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
    
    /* Check if measurement duty */
    if (ICU_DUTY_CYCLE == ChExtCfgPtr->MeasurementProperty)
    {
      if (((uint32)(ChannelPtr->InputTrigger) << ICU_SHIFT_TR_IN_SEL1_CAPTURE1_SEL) !=
          (IcuReg->Tr_in_sel1 & ICU_MASK_TR_IN_SEL1_CAPTURE1_SEL))
      {
        retval = FALSE;
      }
    }
    else /* Check other MeasurementProperty */
    {
      if (ICU_TCPWM_TR_IN_SEL_INIT_VALUE != (IcuReg->Tr_in_sel1 & ICU_MASK_TR_IN_SEL1_CAPTURE1_SEL))
      {
        retval = FALSE;
      }
    }
  }
  else /* Check other MeasurementMode */
  {
    if (ICU_TCPWM_TR_IN_SEL_INIT_VALUE != (IcuReg->Tr_in_sel1 & ICU_MASK_TR_IN_SEL1_CAPTURE1_SEL))
    {
      retval = FALSE;
    }
  }

  return retval;
}


/** \brief Icu_Resource_Tcpwm_SetInputStartTrigger
 **
 ** This function selects input trigger for a specific channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 ** \param[in] TriggerSrc Trigger source.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetInputStartTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                     TriggerSrc
)
{
  uint32 TriggerValue0;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  TriggerValue0 = IcuReg->Tr_in_sel0;
  TriggerValue0 &= ~(uint32)ICU_MASK_TR_IN_SEL0_RELOAD_SEL;
  TriggerValue0 |= ((uint32)TriggerSrc << ICU_SHIFT_TR_IN_SEL0_RELOAD_SEL);
  IcuReg->Tr_in_sel0 = TriggerValue0;
}

/** \brief Icu_Resource_Tcpwm_SetReloadTriggerEdge
 **
 ** This function sets reload trigger edge for a specific channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_SetReloadTriggerEdge
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  /* Set RISING_EDGE to Tr_in_edge_sel RELOAD bit */
  IcuReg->Tr_in_edge_sel &= ~ICU_MASK_TR_IN_EDGE_SEL_RELOAD_EDGE;
}

/** \brief Icu_Resource_Tcpwm_ClearInputTrigger
 **
 ** The function clears input trigger.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_ClearInputTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  IcuReg->Tr_in_sel0 &= ~ICU_MASK_TR_IN_SEL0_RELOAD_SEL;
  /* Set NO_EDGE_DET to Tr_in_edge_sel RELOAD bit */
  IcuReg->Tr_in_edge_sel |= ICU_REGS_ICS_NO_EDGE_DET << ICU_SHIFT_TR_IN_EDGE_SEL_RELOAD_EDGE;
}

/** \brief Icu_Resource_Tcpwm_CalculateActivation
 **
 ** The function calculates value to be set in register TR_IN_EDGE_SEL.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Activation   The type of activation edge of an ICU channel.
 **
 ** \return    Calculated TR_IN_EDGE_SEL register value.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Tcpwm_CalculateActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        Activation
)
{
  uint32 EdgeMode;
  uint32 retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  EdgeMode = Icu_Resource_Tcpwm_CalEdgeMode(Activation);
  retval = (uint32)IcuReg->Tr_in_edge_sel;
  retval &= ~ICU_MASK_TR_IN_EDGE_SEL_CAPTURE0_EDGE;
  retval |= (uint32)EdgeMode;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_CtrlEnable
 **
 ** This function sets CTRL register enable or disable.
 **
 **
 ** \param[in] ChannelPtr  Pointer to the channel configuration.
 ** \param[in] CtrlMode    Control counter enable or disable.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Tcpwm_CtrlEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   CtrlMode
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  if (CtrlMode == TRUE)
  {
    /* Enable counter */
    IcuReg->Ctrl |= ICU_MASK_CTRL_ENABLED;
    /* Read CTRL register (This read ensures that the write has been flushed to hardware) */
    (void)IcuReg->Ctrl;
  }
  else
  {
    /* Disable counter */
    IcuReg->Ctrl &= ~ICU_MASK_CTRL_ENABLED;
  }
}

/** \brief Icu_Resource_Tcpwm_CheckActivation
 **
 ** The function checks activation of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Activation edge of an ICU channel.
 ** */
static FUNC(Icu_ActivationType, ICU_CODE) Icu_Resource_Tcpwm_CheckActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32 EdgeMode;
  Icu_ActivationType RetValue;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  EdgeMode = (uint32)((uint32)IcuReg->Tr_in_edge_sel & ICU_MASK_TR_IN_EDGE_SEL_CAPTURE0_EDGE);

  switch (EdgeMode)
  {
    case ICU_REGS_ICS_RISING_EDGE:
      RetValue = ICU_RISING_EDGE;
      break;
    case ICU_REGS_ICS_FALLING_EDGE:
      RetValue = ICU_FALLING_EDGE;
      break;
    case ICU_REGS_ICS_ANY_EDGES:
      RetValue = ICU_BOTH_EDGES;
      break;
    default:  /* case ICU_REGS_ICS_NO_EDGE_DET */
      RetValue = ICU_INIT_EDGE;
      break;
  }

  return RetValue;
}

/** \brief Icu_Resource_Tcpwm_CheckIsrAbility
 **
 ** The function checks Isr Ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Isr Ability of an ICU channel.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean  retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  retval = (((uint32)IcuReg->Intr_mask & ICU_MASK_INTR_MASK_CC0_MATCH) != 0x00U) ? TRUE : FALSE;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_CheckOverflowIsrAbility
 **
 ** The function checks Overflow Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Overflow Isr ability of an ICU channel.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckOverflowIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean  retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  retval = (((uint32)IcuReg->Intr_mask & ICU_MASK_INTR_MASK_TC) != 0x00U) ? TRUE : FALSE;

  return retval;
}

/** \brief Icu_Resource_Tcpwm_GetPrescalerValue
 **
 ** The function gets DT register value of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    DT register value of ICU channel.
 ** */
static FUNC(uint8, ICU_CODE) Icu_Resource_Tcpwm_GetPrescalerValue
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  return (uint8)IcuReg->Dt;
}

/** \brief Icu_Resource_Tcpwm_CheckChRunning
 **
 ** The function checks running state of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Result of checking running state.
 **            TRUE:  HardWare state is running state.
 **            FALSE: HardWare state is not running state.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckChRunning
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Check counter running state */
  if ((0u != (IcuReg->Status & ICU_MASK_STATUS_RUNNING)) ||
      (0u != (IcuReg->Tr_cmd & (ICU_MASK_TR_CMD_START | ICU_MASK_TR_CMD_RELOAD))))
  {
    retval = TRUE;
  }
  else
  {
    retval = FALSE;
  }

  return retval;
}

/** \brief Icu_Resource_Tcpwm_CheckChStop
 **
 ** The function checks stopped state of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Result of checking stopped state.
 **            TRUE:  HardWare state is stopped state.
 **            FALSE: HardWare state is not stopped state.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckChStop
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Check counter running state */
  if (0u == (IcuReg->Status & ICU_MASK_STATUS_RUNNING))
  {
    retval = TRUE;
  }
  else
  {
    retval = FALSE;
  }

  return retval;
}

/** \brief Icu_Resource_Tcpwm_CheckCaptureIntrCause
 **
 ** This function checks if CC0_MATCH interrupt was detected.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of detecting edge.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Tcpwm_CheckCaptureIntrCause
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean  retval;
  volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE) IcuReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  IcuReg = (volatile P2VAR(Icu_TcpwmRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  retval = (((uint32)IcuReg->Intr & ICU_MASK_INTR_CC0_MATCH) == ICU_MASK_INTR_CC0_MATCH) ? TRUE : FALSE;

  return retval;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[end of file]============================================*/
