/** \brief AUTOSAR Adc Driver
 **
 ** This file contains the implementation of the AUTOSAR module ADC functions 
 ** for accessing hardware registers.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/* NOTE: In order to access hardware register elements, bitfields in 
         conjunction with unions are used in this file. A specific packing of 
         the bitfields is required for correct operation.
         This is only assured by using one of the compilers and corresponding 
         options which are approved for this software product. Please consult
         the Release Notes for information on supported compilers.
*/

/*==================[inclusions]============================================*/

#include <Adc_Types.h>    /* Module public types */
#include <Adc_Internal.h> /* Module internal declaration */
#include <Adc_Regs.h>     /* Module register types */
#include <Adc_Data.h>     /* Module data declaration */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ADC_START_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

/** \brief Adc_SetupGlobalControlRegister
 **
 ** Setup global control register for ADC HwUnit (ESAR:CTL).
 **
 ** \param [in] EsarRegPtr            Pointer to registers (ESAR).
 ** \param [in] PowerControlSetting   Enable or disable SARMUX, SAR sequencer and/or SAR IP.
 ** \param [in] HalfLsbEnable         Enable or disable half LSB conversion.
 **
 */
static FUNC(void, ADC_CODE) Adc_SetupGlobalControlRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(uint8, AUTOMATIC) PowerControlSetting,
  VAR(uint8, AUTOMATIC) HalfLsbEnable
);

/** \brief Adc_SetupGlobalDiagRegister
 **
 ** Diagnostic feature is enabled or disabled by calling this function.
 ** If enabled, which diagnostic reference is selected according to the parameter.
 **
 ** \param [in] EsarRegPtr      Pointer to registers (ESAR).
 ** \param [in] DiagSelect      Select diagnostic reference.
 ** \param [in] EnableSetting   Setting to enable or disable diagnostic (TRUE or FALSE).
 **
 */
static FUNC(void, ADC_CODE) Adc_SetupGlobalDiagRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(Adc_DiagReferenceType, AUTOMATIC) DiagSelect,
  VAR(boolean, AUTOMATIC) EnableSetting
);

/** \brief Adc_SetupGlobalPrecondRegister
 **
 ** This function is used to setup preconditioning control register.
 **
 ** \param [in] EsarRegPtr    Pointer to registers (ESAR).
 ** \param [in] PrecondTime   Number ADC clock cycles that Preconditioning is done
 **                           before the sample window starts.
 **
 */
static FUNC(void, ADC_CODE) Adc_SetupGlobalPrecondRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(uint8, AUTOMATIC) PrecondTime
);

/** \brief Adc_ClearCalibrationRegisters
 **
 ** Clear all calibration registers for ADC HwUnit.
 ** (ESAR:ANA_CAL, ANA_CAL_ALT, DIG_CAL,DIG_CAL_ALT).
 **
 ** \param [in] EsarRegPtr  Pointer to registers (ESAR).
 **
 */
static FUNC(void, ADC_CODE) Adc_ClearCalibrationRegisters
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr
);

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define ADC_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/** \brief Adc_ClearChannelInterruptFlags
 **
 ** Clear interrupt flags for range comparator and group conversion done.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
FUNC(void, ADC_CODE) Adc_ClearChannelInterruptFlags
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
)
{
  /* Write value to register.  */
  EsarChStructRegPtr->ChIntr = ADC_MASK_ESAR_INTR;
  
  /* Dummy read for HW require */
  (void)EsarChStructRegPtr->ChIntr;
}

/** \brief Adc_SetupChannelTriggerRegister
 **
 ** Configures the HW register for one channel as given by the parameters.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] Priority             Channel priority.
 ** \param [in] TriggerType          Trigger type.
 ** \param [in] ReplacementMode      Replacement mode.
 ** \param [in] IsEndChannel         Represent that it is last channel in a group.
 ** \param [in] DoneLevel            Select level or pulse for 'tr_ch_done' trigger output.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupChannelTriggerRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint8,   AUTOMATIC) Priority,
  VAR(uint8,   AUTOMATIC) TriggerType,
  VAR(uint8,   AUTOMATIC) ReplacementMode,
  VAR(boolean, AUTOMATIC) IsEndChannel,
  VAR(uint8,   AUTOMATIC) DoneLevel
)
{
  Adc_EsarChStructTrCtlType curEsarChStructTrCtl;

  /* Fulfill all bits with zero. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarChStructTrCtl) = 0U;

  /* Setup trigger conditions. */
  curEsarChStructTrCtl.u3SEL         = TriggerType;                          /* ESAR:CH_STRUCT:TR_CTL:SEL */
  curEsarChStructTrCtl.u3PRIO        = Priority;                             /* ESAR:CH_STRUCT:TR_CTL:PRIO */
  curEsarChStructTrCtl.u2PREEMPTTYPE = ReplacementMode;                      /* ESAR:CH_STRUCT:TR_CTL:PREEMPT_TYPE */
  curEsarChStructTrCtl.u1GROUPEND    = (IsEndChannel == TRUE) ? (1U) : (0U); /* ESAR:CH_STRUCT:TR_CTL:GROUP_END */
  curEsarChStructTrCtl.u1DONELEVEL   = DoneLevel;                            /* ESAR:CH_STRUCT:TR_CTL:DONE_LEVEL */

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarChStructRegPtr->ChTrCtl = ADC_STRUCT_UINT32(curEsarChStructTrCtl);
}

/** \brief Adc_EnableChannelRegister
 **
 ** Enable or disable ADC channel (ESAR:CH_STRUCT:CHAN_EN).
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] EnableSetting        Represent that the channel is enabled or disabled.
 **
 */
FUNC(void, ADC_CODE) Adc_EnableChannelRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
)
{
  /* Write value to register. */
  EsarChStructRegPtr->ChEnable = (EnableSetting == TRUE) ? (1U) : (0U);
}

/** \brief Adc_EnableGroupChannelsRegister
 **
 ** Enable or disable all ADC channels (ESAR:CH_STRUCT:CHAN_EN) in the ADC channel group.
 **
 ** \param [in] FirstEsarChStructRegPtr   Pointer to registers for ESAR first channel control.
 ** \param [in] LastEsarChStructRegPtr    Pointer to registers for ESAR last channel control.
 ** \param [in] EnableSetting             Represent that the channel is enabled or disabled.
 **
 */
FUNC(void, ADC_CODE) Adc_EnableGroupChannelsRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) FirstEsarChStructRegPtr,
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) LastEsarChStructRegPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
)
{
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;

  /* Check whether EnableSetting is 'true'? */
  if (EnableSetting == TRUE)
  {
    /* Iterate over all logical channels of the group. */
    for (curEsarChStructRegPtr = LastEsarChStructRegPtr;
         curEsarChStructRegPtr >= FirstEsarChStructRegPtr;
         curEsarChStructRegPtr--)
    {
      /* Write value to register. */
      curEsarChStructRegPtr->ChEnable = 1U;
    }
  }
  /* EnableSetting is 'false'. */
  else
  {
    /* Iterate over all logical channels of the group. */
    for (curEsarChStructRegPtr = FirstEsarChStructRegPtr;
         curEsarChStructRegPtr <= LastEsarChStructRegPtr;
         curEsarChStructRegPtr++)
    {
      /* Write value to register. */
      curEsarChStructRegPtr->ChEnable = 0U;
    }
  }
}

/** \brief Adc_SetupChannelSampleRegister
 **
 ** Setup sampling conditions for an ADC channel (ESAR:CH_STRUCT:SAMPLE_CTL).
 **
 ** \param [in] EsarChStructRegPtr      Pointer to registers for ESAR channel control.
 ** \param [in] PinAddr                 Physical channel.
 ** \param [in] PortAddr                Physical port.
 ** \param [in] SamplingMode            Sampling mode.
 ** \param [in] SampleTime              Sampling time.
 ** \param [in] UseAlternateCalibration Use alternate calibration values or not.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupChannelSampleRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(Adc_ChannelType,      AUTOMATIC) PinAddr,
  VAR(Adc_SarMuxType,       AUTOMATIC) PortAddr,
  VAR(Adc_SamplingModeType, AUTOMATIC) SamplingMode,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SampleTime,
  VAR(boolean,              AUTOMATIC) UseAlternateCalibration
)
{
  Adc_EsarChStructSampleCtlType curEsarChStructSampleCtl;

  /* Setup sampling conditions. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarChStructSampleCtl)
    = ((uint32)(SamplingMode) << ADC_REG_OFFSET_8BIT);           /* ESAR:CH_STRUCT:SAMPLE_CTL:PRECOND_MODE & OVERLAP_DIAG */

  /* Setup physical channel. */
  curEsarChStructSampleCtl.u6PIN_ADDR     = PinAddr;             /* ESAR:SAMPLE_CTL:PIN_ADDR */

  /* Setup physical port. */
  curEsarChStructSampleCtl.u2PORT_ADDR    = PortAddr;            /* ESAR:SAMPLE_CTL:PORT_ADDR */

  /* Setup sampling time. */
  curEsarChStructSampleCtl.u12SAMPLE_TIME = SampleTime;          /* ESAR:CH_STRUCT:SAMPLE_CTL:SAMPLE_TIME */

  /* Setup use alternate calibration values or regular calibration values. */
  curEsarChStructSampleCtl.u1ALT_CAL = (UseAlternateCalibration == TRUE) ? (1U) : (0U);  /* ESAR:CH_STRUCT:SAMPLE_CTL:ALT_CAL */

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarChStructRegPtr->ChSampleCtl = ADC_STRUCT_UINT32(curEsarChStructSampleCtl);
}

/** \brief Adc_SetupChannelPostRegister
 **
 ** Setup post conditions for an ADC channel (ESAR:CH_STRUCT:POST_CTL).
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] RegisterValue        Setting value for POST_CTL register.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupChannelPostRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint32, AUTOMATIC) RegisterValue
)
{
  /* Write value to register */
  EsarChStructRegPtr->ChPostCtl = RegisterValue;
}

/** \brief Adc_SetupChannelRangeRegister
 **
 ** Setup range upper/lower threshold for an ADC channel (ESAR:CH_STRUCT:RANGE_CTL).
 **
 ** \param [in] EsarChStructRegPtr              Pointer to registers for ESAR channel control.
 ** \param [in] RangeComparatorUpperThreshold   Upper threshold for range comparator.
 ** \param [in] RangeComparatorLowerThreshold   Lower threshold for range comparator.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupChannelRangeRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint16, AUTOMATIC) RangeComparatorUpperThreshold,
  VAR(uint16, AUTOMATIC) RangeComparatorLowerThreshold
)
{
  Adc_EsarChStructRangeCtlType curEsarChStructRangeCtl;

  /* Setup range comparator. */
  curEsarChStructRangeCtl.u16RANGE_LO = RangeComparatorLowerThreshold; /* ESAR:CH_STRUCT:RANGE_CTL:RANGE_LO */
  curEsarChStructRangeCtl.u16RANGE_HI = RangeComparatorUpperThreshold; /* ESAR:CH_STRUCT:RANGE_CTL:RANGE_HI */

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarChStructRegPtr->ChRangeCtl = ADC_STRUCT_UINT32(curEsarChStructRangeCtl);
}

/** \brief Adc_GetConversionStatusFlags
 **
 ** Returns interrupt flags for the given pointer to ADC channel registers.
 **
 ** \return                          bit 0: Conversion of channel was done.
 **                                  bit 8: Range comparator interrupt was detected.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
FUNC(uint32, ADC_CODE) Adc_GetConversionStatusFlags
(
  volatile P2CONST(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
)
{
  /* Return register value. */
  return (uint32)(EsarChStructRegPtr->ChIntr);
}

/** \brief Adc_GetConversionValue
 **
 ** Returns the conversion value for the given HW channel and at same
 ** time resets the conversion done flag.
 **
 ** \return                          The value of the conversion for the given HW channel.
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
FUNC(uint16, ADC_CODE) Adc_GetConversionValue
(
  volatile P2CONST(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
)
{
  /* Return register value. */
  return (uint16)EsarChStructRegPtr->ChResult;
}

/** \brief Adc_SetTriggerFlag
 **
 ** Sets the Sw trigger flag for the given Hw channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
FUNC(void, ADC_CODE) Adc_SetTriggerFlag
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
)
{
  /* Write value to register. */
  EsarChStructRegPtr->ChTrCmd = 1U; /* Start ADC conversion by SW trigger */
}

/** \brief Adc_InitConfigurationRegisters
 **
 ** Set configuration registers when initialize the Hw unit.
 **
 ** \param [in] HwUnitConfigPtr   Hw unit configuration structure pointer.
 **
 */
FUNC(void, ADC_CODE) Adc_InitConfigurationRegisters
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr
    = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE)) HwUnitConfigPtr->RegisterBase;

  /* Setup ESAR control register. */
  Adc_SetupGlobalControlRegister(
    curEsarRegPtr,                        /* Pointer to registers (ESAR) */
    HwUnitConfigPtr->PowerControlSetting, /* ESAR:CTL:SARMUX_EN/ADC_EN/ENABLED */
    1U                                    /* ESAR:CTL:HALF_LSB */
  );

  /* Setup diagnostic control register. */
  Adc_SetupGlobalDiagRegister(
    curEsarRegPtr,                  /* Pointer to registers (ESAR) */
    HwUnitConfigPtr->DiagReference, /* ESAR:DIAG_CTL:DIAG_SEL */
    HwUnitConfigPtr->DiagEnabled    /* ESAR:DIAG_CTL:DIAG_EN */
  );

  if (HwUnitConfigPtr->SarEnabled == TRUE)
  {
    /* In case ADC SAR is used, the following registers are set. */
    /* Setup preconditioning control register. */
    Adc_SetupGlobalPrecondRegister(
      curEsarRegPtr,                /* Pointer to registers (ESAR) */
      HwUnitConfigPtr->PrecondCycle /* ESAR:PRECOND_CTL:PRECOND_TIME */
    );

    /* Clear calibration registers. */
    Adc_ClearCalibrationRegisters(curEsarRegPtr);
  }
}

/** \brief Adc_DeInitConfigurationRegisters
 **
 ** Reset configuration registers when deinitialize the Hw unit. 
 **
 ** \param [in] HwUnitConfigPtr   Hw unit configuration structure pointer.
 **
 */
FUNC(void, ADC_CODE) Adc_DeInitConfigurationRegisters
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr
    = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE)) HwUnitConfigPtr->RegisterBase;

  /* Setup global configuration for ADC HwUnit. */
  Adc_SetupGlobalControlRegister(
    curEsarRegPtr, /* Pointer to registers (ESAR) */
    0U,            /* ESAR:CTL:SARMUX_EN/ADC_EN/ENABLED */
    0U             /* ESAR:CTL:HALF_LSB */
  );

  /* Setup preconditioning control register. */
  Adc_SetupGlobalDiagRegister(
    curEsarRegPtr, /* Pointer to registers (ESAR) */
    0U,            /* ESAR:DIAG_CTL:DIAG_SEL */
    FALSE          /* ESAR:DIAG_CTL:DIAG_EN */
  );

  if (HwUnitConfigPtr->SarEnabled == TRUE)
  {
    /* In case ADC SAR is used, the following registers are set. */
    /* Setup preconditioning control register. */
    Adc_SetupGlobalPrecondRegister(
      curEsarRegPtr, /* Pointer to registers (ESAR) */
      0U             /* ESAR:PRECOND_CTL:PRECOND_TIME */
    );

    /* Clear calibration registers. */
    Adc_ClearCalibrationRegisters(curEsarRegPtr);
  }
}

/** \brief Adc_SetIntrMaskRegister
 **
 ** Set interrupt mask for the specified ADC channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] IntrMask             Setting value for INTR_MASK register.
 **
 */
FUNC(void, ADC_CODE) Adc_SetIntrMaskRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint32, AUTOMATIC) IntrMask
)
{
  /* Write value to register. */
  EsarChStructRegPtr->ChIntrMask = IntrMask; /* ESAR:CH_STRUCT:INTR_MASK */
}

/** \brief Adc_ChangeSamplingTimeRegister
 **
 ** Change sampling time for ADC channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] SamplingTime         Specifies sampling time for the ADC channel.
 **
 */
FUNC(void, ADC_CODE) Adc_ChangeSamplingTimeRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SamplingTime
)
{
  Adc_EsarChStructSampleCtlType curEsarChStructSampleCtl;

  /* Read value from register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarChStructSampleCtl) = EsarChStructRegPtr->ChSampleCtl;

  /* Change sampling time only. */
  curEsarChStructSampleCtl.u12SAMPLE_TIME = SamplingTime;

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarChStructRegPtr->ChSampleCtl = ADC_STRUCT_UINT32(curEsarChStructSampleCtl);
}

/** \brief Adc_GetEnablePower
 **
 ** Gets state of power enable.
 **
 ** \return                  Returns the status of the power enable.
 **                          TRUE : Power is on.
 **                          FALSE: Power is off.
 ** \param [in] EsarRegPtr   Pointer to registers (ESAR).
 **
 */
FUNC(boolean, ADC_CODE) Adc_GetEnablePower
(
  volatile P2CONST(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr
)
{
  Adc_EsarCtlType curEsarCtl;
  boolean result;

  /* Read value from register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarCtl) = EsarRegPtr->EsarCtl;

  /* Check whether enabled or not. */
  /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
     Justification: The variable 'curEsarCtl' including 'u1ENABLED' has already been set in previous process. */
  /* PRQA S 2961 1 */
  result = (curEsarCtl.u1ENABLED == 1U) ? (TRUE) : (FALSE);

  return result;
}

/** \brief Adc_SetEnablePower
 **
 ** Sets state of enable power.
 **
 ** \param [in] EsarRegPtr        Pointer to registers (ESAR).
 ** \param [in] HwUnitConfigPtr   Hw unit configuration structure pointer.
 ** \param [in] EnableSetting     TRUE: enabled, FALSE: disabled.
 **
 */
FUNC(void, ADC_CODE) Adc_SetEnablePower
(
  volatile P2VAR(Adc_EsarType,  AUTOMATIC, REGSPACE)       EsarRegPtr,
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
)
{
  Adc_EsarCtlType curEsarCtl;
  Adc_EsarDiagCtlType curEsarDiagCtl;

  /* Read value from registers. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 2 */
  ADC_STRUCT_UINT32(curEsarCtl)     = EsarRegPtr->EsarCtl;
  ADC_STRUCT_UINT32(curEsarDiagCtl) = EsarRegPtr->EsarDiagCtl;

  /* Check whether it should be enabled. */
  if (EnableSetting == TRUE)
  {
    /* Enable SAR. */
    curEsarCtl.u1SARMUX_EN = 1U; /* ESAR:CTL:SARMUX_EN */
    curEsarCtl.u1ADC_EN    = (HwUnitConfigPtr->SarEnabled == TRUE) ? (1U) : (0U); /* ESAR:CTL:ADC_EN    */
    curEsarCtl.u1ENABLED   = 1U; /* ESAR:CTL:ENABLED   */

    /* Enable or disable diagnostic according to config. */
    curEsarDiagCtl.u1DIAG_EN = (HwUnitConfigPtr->DiagEnabled == TRUE) ? (1U) : (0U); /* ESAR:DIAG_CTL:DIAG_EN */
  }
  /* It should be disabled. */
  else
  {
    /* Disable SAR. */
    curEsarCtl.u1SARMUX_EN = 0U;
    curEsarCtl.u1ADC_EN    = 0U;
    curEsarCtl.u1ENABLED   = 0U;

    /* Disable diagnostic. */
    curEsarDiagCtl.u1DIAG_EN = 0U;
  }

  /* Write value to registers. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 2 */
  EsarRegPtr->EsarCtl = ADC_STRUCT_UINT32(curEsarCtl);
  EsarRegPtr->EsarDiagCtl = ADC_STRUCT_UINT32(curEsarDiagCtl);
}

/** \brief Adc_SetupPassControl
 **
 ** Setup PASS control register (ESAR:EPASS_MMIO:PASS_CTL).
 **
 ** \param [in] ControlSetting   Setting for PASS control.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupPassControl
(
  VAR(uint32, AUTOMATIC) ControlSetting
)
{
  /* Get the PASS MMIO register base address. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarMmioType, AUTOMATIC, REGSPACE) curEsarMmioRegPtr
    = (volatile P2VAR(Adc_EsarMmioType, AUTOMATIC, REGSPACE))Adc_GetPassMmioRegAddr();

  /* Write value to register. */
  curEsarMmioRegPtr->PassPassCtl = ControlSetting; /* ESAR:EPASS_MMIO:PASS_CTL */
}

/** \brief Adc_SetupSarTrOutSel
 **
 ** Setup PASS control register (ESAR:EPASS_MMIO:SAR_TR_OUT_SEL).
 **
 ** \param [in] HwUnit            An ADC hwunit numeric ID.
 ** \param [in] OutputNumber      Select generic trigger output.
 ** \param [in] SelTriggerNumber  Select SAR output trigger for generic trigger output.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupSarTrOutSel
(
  VAR(uint8, AUTOMATIC)  HwUnit,
  VAR(uint8, AUTOMATIC)  OutputNumber,
  VAR(uint8, AUTOMATIC)  SelTriggerNumber
)
{
  /* Get the PASS MMIO register base address. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarMmioType, AUTOMATIC, REGSPACE) curEsarMmioRegPtr
    = (volatile P2VAR(Adc_EsarMmioType, AUTOMATIC, REGSPACE))Adc_GetPassMmioRegAddr();
  Adc_EpassMmioSarTrOutSelType curPassSarTrOutSel;

  /* Read value from registers. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curPassSarTrOutSel) = curEsarMmioRegPtr->PassSarTrOutSel[HwUnit];
  
  if (OutputNumber == ADC_OUT0_SEL)
  {
    curPassSarTrOutSel.u6OUT0_SEL = SelTriggerNumber;
  }
  else
  {
    curPassSarTrOutSel.u6OUT1_SEL = SelTriggerNumber;
  }

  /* Write value to register (ESAR:EPASS_MMIO:SAR_TR_OUT_SEL). */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  curEsarMmioRegPtr->PassSarTrOutSel[HwUnit] = ADC_STRUCT_UINT32(curPassSarTrOutSel); 
}

/** \brief Adc_DmaInitChannelRegister
 **
 ** Initialize a DMA channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaInitChannelRegister
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
)
{
  DwChStructRegPtr->ChCtl      = ADC_DW_CHCTL_INIT_VALUE; /* Initialize ChCtl     */
  DwChStructRegPtr->ChIntr     = ADC_DW_CHINTR_CH_BIT;    /* Clear Interrupt flag */
  DwChStructRegPtr->ChIntrMask = 0U;                      /* Clear Interrupt mask */
}

/** \brief Adc_DmaSetupDescriptor
 **
 ** Set the DMA descriptor.
 **
 ** \param [in] GroupConfigPtr      Pointer to configuration for a group.
 ** \param [in] EsarChStructRegPtr  Pointer to registers for ESAR channel structure.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaSetupDescriptor
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  volatile P2CONST(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
)
{
  Adc_DwDescriptorXYControlType curDwDescCtl;
  
  /* Set the descriptor. */
  if (GroupConfigPtr->GroupAccessMode == ADC_ACCESS_MODE_SINGLE)
  {
    /* In case of single access mode, set the descriptor for 1D transfer. */
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                      and the 32 bit unsigned integer type is used to access register faster. 
                      Therefore, it is necessary to cast to different object pointer type. 
                      And the bit-fields structure of each register definition is 32 bits width 
                      and it is the same as hardware register access width. */
    /* PRQA S 310 2 */
    P2VAR(Adc_DwDescriptorOneDType, AUTOMATIC, ADC_APPL_DATA) descr1DPtr
      = (P2VAR(Adc_DwDescriptorOneDType, AUTOMATIC, ADC_APPL_DATA))
          GroupConfigPtr->DmaChannelConfigPtr->DescriptorBasePtr;

    /* Set "Descriptor control". */
    descr1DPtr->DwDescrCtl     = ADC_DW_DESCRCTL_START1D_VALUE;

    /* Set "Descriptor source" (RESULT register address of first channel in group). */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is necessary to set pointer address as integral type. */
    /* PRQA S 303 1 */
    descr1DPtr->DwDescrSrc     = (uint32)&(EsarChStructRegPtr->ChResult);

    /* Set "Descriptor destination" (Result Buffer address). */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: It is necessary to set pointer address as integral type. */
    /* PRQA S 306 1 */
    descr1DPtr->DwDescrDst     = (uint32)GroupConfigPtr->StreamInfoPtr->BufferBasePtr;

    /* Set "SRC_X_INCR" (size of between RESULT registers). */
    curDwDescCtl.u12SRC_INCR   = ADC_DW_ESAR_CH_STRUCT_SIZE;

    /* Set "DST_X_INCR" (number of samples of streaming). */
    curDwDescCtl.u12DST_INCR   = GroupConfigPtr->StreamNumSamples;

    /* Set "X_COUNT" (number of channels in group). */
    curDwDescCtl.u8COUNT       = GroupConfigPtr->NumberOfChannels - 1U;

    /* Set "Descriptor X loop control". */
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                      and the 32 bit unsigned integer type is used to access register faster. 
                      Therefore, it is necessary to cast to different object pointer type. 
                      And the bit-fields structure of each register definition is 32 bits width 
                      and it is the same as hardware register access width. */
    /* PRQA S 310 1 */
    descr1DPtr->DwDescrXCtl    = ADC_STRUCT_UINT32(curDwDescCtl);

    /* Set "Descriptor next pointer" (repeat of descriptor). */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: It is necessary to set pointer address as integral type. */
    /* PRQA S 306 1 */
    descr1DPtr->DwDescrNextPtr = (uint32)GroupConfigPtr->DmaChannelConfigPtr->DescriptorBasePtr;
  }
  else
  {
    /* In case of streaming access mode, set the descriptor for 2D transfer. */
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                      and the 32 bit unsigned integer type is used to access register faster. 
                      Therefore, it is necessary to cast to different object pointer type. 
                      And the bit-fields structure of each register definition is 32 bits width 
                      and it is the same as hardware register access width. */
    /* PRQA S 310 2 */
    P2VAR(Adc_DwDescriptorTwoDType, AUTOMATIC, ADC_APPL_DATA) descr2DPtr
      = (P2VAR(Adc_DwDescriptorTwoDType, AUTOMATIC, ADC_APPL_DATA))
          GroupConfigPtr->DmaChannelConfigPtr->DescriptorBasePtr;

    /* Set "Descriptor control". */
    descr2DPtr->DwDescrCtl     = ADC_DW_DESCRCTL_START2D_VALUE;

    /* Set "Descriptor source" (RESULT register address of first channel in group). */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is necessary to set pointer address as integral type. */
    /* PRQA S 303 1 */
    descr2DPtr->DwDescrSrc     = (uint32)&(EsarChStructRegPtr->ChResult);

    /* Set "Descriptor destination" (Result Buffer address). */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: It is necessary to set pointer address as integral type. */
    /* PRQA S 306 1 */
    descr2DPtr->DwDescrDst     = (uint32)GroupConfigPtr->StreamInfoPtr->BufferBasePtr;

    /* Set "SRC_X_INCR" (size of between RESULT registers). */
    curDwDescCtl.u12SRC_INCR   = ADC_DW_ESAR_CH_STRUCT_SIZE;

    /* Set "DST_X_INCR" (number of samples of streaming). */
    curDwDescCtl.u12DST_INCR   = GroupConfigPtr->StreamNumSamples;

    /* Set "X_COUNT" (number of channels in group). */
    curDwDescCtl.u8COUNT       = GroupConfigPtr->NumberOfChannels - 1U;

    /* Set "Descriptor X loop control". */
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                      and the 32 bit unsigned integer type is used to access register faster. 
                      Therefore, it is necessary to cast to different object pointer type. 
                      And the bit-fields structure of each register definition is 32 bits width 
                      and it is the same as hardware register access width. */
    /* PRQA S 310 1 */
    descr2DPtr->DwDescrXCtl    = ADC_STRUCT_UINT32(curDwDescCtl);

    /* Set "SRC_Y_INCR" (fixed). */
    curDwDescCtl.u12SRC_INCR   = 0U;

    /* Set "SRC_Y_INCR" (1). */
    curDwDescCtl.u12DST_INCR   = 1U;

    /* Set "Y_COUNT" (number of samples of streaming). */
    curDwDescCtl.u8COUNT       = GroupConfigPtr->StreamNumSamples - 1U;

    /* Set "Descriptor Y loop control". */
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                      and the 32 bit unsigned integer type is used to access register faster. 
                      Therefore, it is necessary to cast to different object pointer type. 
                      And the bit-fields structure of each register definition is 32 bits width 
                      and it is the same as hardware register access width. */
    /* PRQA S 310 1 */
    descr2DPtr->DwDescrYCtl    = ADC_STRUCT_UINT32(curDwDescCtl);

    /* Set "Descriptor next pointer" (repeat of descriptor). */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: It is necessary to set pointer address as integral type. */
    /* PRQA S 306 1 */
    descr2DPtr->DwDescrNextPtr = (uint32)GroupConfigPtr->DmaChannelConfigPtr->DescriptorBasePtr;
  }
}

/** \brief Adc_DmaStartChannelRegister
 **
 ** Start a DMA channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 ** \param [in] DescriptorAddr    Base address of a DMA descriptor.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaStartChannelRegister
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr,
  VAR(uint32, AUTOMATIC) DescriptorAddr
)
{
  DwChStructRegPtr->ChIdx      = 0U;                        /* Initialize ChIdx     */
  DwChStructRegPtr->ChCurrPtr  = DescriptorAddr;            /* Initialize ChCurrPtr */
  DwChStructRegPtr->ChIntr     = ADC_DW_CHINTR_CH_BIT;      /* Clear Interrupt flag */
  DwChStructRegPtr->ChCtl     |= ADC_DW_CHCTL_ENABLED_BIT;  /* Set only Enable bit  */
}

/** \brief Adc_DmaStopChannelRegister
 **
 ** Stop a DMA channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaStopChannelRegister
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
)
{
  DwChStructRegPtr->ChCtl  &= ~ADC_DW_CHCTL_ENABLED_BIT;  /* Clear only ENABLED bit */
  DwChStructRegPtr->ChIntr  = ADC_DW_CHINTR_CH_BIT;       /* Clear Interrupt flag   */
}

/** \brief Adc_DmaGetChannelStatusFlags
 **
 ** Return current status for the DW channel.
 **
 ** \return                       0   : Interrupt was not detected.
 **                               1   : Completion interrupt was detected.
 **                               2-8 : Error interrupt was detected.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
FUNC(uint32, ADC_CODE) Adc_DmaGetChannelStatusFlags
(
  volatile P2CONST(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
)
{
  uint32 statusValue = 0U;

  /* Check the interrupt flag. */
  if ((DwChStructRegPtr->ChIntr & ADC_DW_CHINTR_CH_BIT) != 0U)
  {
    /* If interrupt flag is ON, get interrupt cause. */
    statusValue = DwChStructRegPtr->ChStatus & ADC_DW_CHSTATUS_INTRCASE_MASK;
  }

  return statusValue;
}

/** \brief Adc_DmaClearChannelInterruptFlags
 **
 ** Clear the interrupt flag for the DW channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaClearChannelInterruptFlags
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
)
{
  /* Clear Interrupt flag. */
  DwChStructRegPtr->ChIntr = ADC_DW_CHINTR_CH_BIT;
  
  /* Dummy read for HW require */
  (void)DwChStructRegPtr->ChIntr;
}

/** \brief Adc_DmaSetChannelInterruptMask
 **
 ** Enable or disable the interrupt for the DW channel. 
 ** (I.e. Set or clear the interrupt mask.)
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 ** \param [in] EnableSetting     Setting which the request is enabled or disabled.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaSetChannelInterruptMask
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
)
{
  if (EnableSetting == TRUE)
  {
    /* Set the interrupt mask. */
    DwChStructRegPtr->ChIntrMask = ADC_DW_CHINTR_CH_BIT;
  }
  else
  {
    /* Clear the interrupt mask. */
    DwChStructRegPtr->ChIntrMask = 0U;
  }
}

/** \brief Adc_DmaRegisterReadCtl
 **
 ** Just read DMA ctl register to read back DMA registers.
 **
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 */
FUNC(void, ADC_CODE) Adc_DmaRegisterReadCtl
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  volatile P2VAR(Adc_DwChStructType,   AUTOMATIC, REGSPACE) dmaChStructRegPtr;

  if(GroupConfigPtr->UseDma == TRUE)
  {
    /* Get a pointer to DMA channel registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    dmaChStructRegPtr = 
      (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))
        GroupConfigPtr->DmaChannelConfigPtr->RegisterBase;

    (void)dmaChStructRegPtr->ChCtl;
  }
}

/** \brief Adc_AdcRegisterReadTrCtl
 **
 ** Just read ADC Ch ctl register to read back ADC registers.
 **
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 */
FUNC(void, ADC_CODE) Adc_AdcRegisterReadTrCtl
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) firstChannelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) firstEsarChStructRegPtr;

  /* Get the channel config of the first channel. */
  firstChannelConfigPtr
    = Adc_GetChannelConfig(GroupConfigPtr->FirstLogicalChannelConfigIndex);

  /* Get a pointer to ESAR:CH_STRUCT registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  firstEsarChStructRegPtr
    = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))firstChannelConfigPtr->RegisterBase;

  (void)firstEsarChStructRegPtr->ChTrCtl;
}

/** \brief Adc_SetupAnalogCalibrationAlternateRegister
 **
 ** Setup alternate analog calibration values register for ADC HwUnit (ESAR:ANA_CAL_ALT).
 **
 ** \param [in] EsarRegPtr  Pointer to registers (ESAR).
 ** \param [in] Offset      Offset correction.
 ** \param [in] Gain        Gain correction.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupAnalogCalibrationAlternateRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(Adc_OffsetValueType, AUTOMATIC) Offset,
  VAR(Adc_GainValueType,   AUTOMATIC) Gain
)
{
  Adc_EsarAnaCalAltType curEsarAnaCalAlt;

  /* Fulfill all bits with zero. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarAnaCalAlt) = 0U;

  /* Setup AOFFSET and AGAIN. */
  curEsarAnaCalAlt.u8AOFFSET = (uint8)Offset;    /* ESAR:ANA_CAL_ALT:AOFFSET */
  curEsarAnaCalAlt.u5AGAIN   = (uint8)Gain;      /* ESAR:ANA_CAL_ALT:AGAIN   */

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarRegPtr->EsarAnaCal_Alt = ADC_STRUCT_UINT32(curEsarAnaCalAlt);
}

/** \brief Adc_GetCalibrationAlternateRegister
 **
 ** Gets alternate analog calibration values.
 **
 ** \param [in]  EsarRegPtr  Pointer to registers (ESAR).
 ** \param [out] OffsetPtr   Buffer pointer stored offset value of alternate calibration.
 ** \param [out] GainPtr     Buffer pointer stored gain value of alternate calibration.
 **
 */
FUNC(void, ADC_CODE) Adc_GetCalibrationAlternateRegister
(
  volatile P2CONST(Adc_EsarType, AUTOMATIC, REGSPACE)    EsarRegPtr,
  P2VAR(Adc_OffsetValueType,   AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,     AUTOMATIC, ADC_APPL_DATA) GainPtr
)
{
  Adc_EsarAnaCalAltType curEsarAnaCalAlt;

  /* Read value from register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarAnaCalAlt) = EsarRegPtr->EsarAnaCal_Alt;

  /* Get ESAR:ANA_CAL_ALT:AOFFSET. */
  /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
     Justification: The variable 'curEsarAnaCalAlt' including 'u8AOFFSET' has already been set in previous process. */
  /* PRQA S 2961 1 */
  *OffsetPtr = (Adc_OffsetValueType)(curEsarAnaCalAlt.u8AOFFSET);

  /* In case AGAIN is minus value */
  /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
     Justification: The variable 'curEsarAnaCalAlt' including 'u5AGAIN' has already been set in previous process. */
  /* PRQA S 2961 1 */
  if (ADC_ANA_CAL_AGAIN_MASK == (curEsarAnaCalAlt.u5AGAIN & ADC_ANA_CAL_AGAIN_MASK))
  {
    /* Get ESAR:ANA_CAL_ALT:AGAIN. */
    *GainPtr = (Adc_GainValueType)((Adc_GainValueType)curEsarAnaCalAlt.u5AGAIN - ADC_ANA_CAL_AGAIN_MSB_EXTEND);
  }
  else
  {
    /* Get ESAR:ANA_CAL_ALT:AGAIN. */
    *GainPtr = (Adc_GainValueType)(curEsarAnaCalAlt.u5AGAIN);
  }
}

/** \brief Adc_SetupCalibrationUpdateRegister
 **
 ** Sets calibration update command for ADC HwUnit (ESAR:CAL_UPD_CMD).
 **
 ** \param [in] EsarRegPtr  Pointer to registers (ESAR).
 ** \param [in] Update      Update calibration values or cancel the update request.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupCalibrationUpdateRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(uint32, AUTOMATIC) Update
)
{
  /* Set calibration update command register. */
  EsarRegPtr->EsarCalUpd_Cmd = Update;
}

/** \brief Adc_GetCalibrationRegister
 **
 ** Gets regular analog calibration values.
 **
 ** \param [in]  EsarRegPtr  Pointer to registers (ESAR).
 ** \param [out] OffsetPtr   Buffer pointer stored offset value of regular calibration.
 ** \param [out] GainPtr     Buffer pointer stored gain value of regular calibration.
 **
 */
FUNC(void, ADC_CODE) Adc_GetCalibrationRegister
(
  volatile P2CONST(Adc_EsarType, AUTOMATIC, REGSPACE)    EsarRegPtr,
  P2VAR(Adc_OffsetValueType,   AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,     AUTOMATIC, ADC_APPL_DATA) GainPtr
)
{
  Adc_EsarAnaCalType curEsarAnaCal;

  /* Read value from register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarAnaCal) = EsarRegPtr->EsarAnaCal;

  /* Get ESAR:ANA_CAL:AOFFSET. */
  /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
     Justification: The variable 'curEsarAnaCal' including 'u8AOFFSET' has already been set in previous process. */
  /* PRQA S 2961 1 */
  *OffsetPtr = (Adc_OffsetValueType)(curEsarAnaCal.u8AOFFSET);

  /* In case AGAIN is minus value. */
  /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
     Justification: The variable 'curEsarAnaCal' including 'u5AGAIN' has already been set in previous process. */
  /* PRQA S 2961 1 */
  if (ADC_ANA_CAL_AGAIN_MASK == (curEsarAnaCal.u5AGAIN & ADC_ANA_CAL_AGAIN_MASK))
  {
    /* Get ESAR:ANA_CAL:AGAIN. */
    *GainPtr = (Adc_GainValueType)((Adc_GainValueType)curEsarAnaCal.u5AGAIN - ADC_ANA_CAL_AGAIN_MSB_EXTEND);
  }
  else
  {
    /* Get ESAR:ANA_CAL:AGAIN. */
    *GainPtr = (Adc_GainValueType)(curEsarAnaCal.u5AGAIN);
  }
}

/** \brief Adc_ChangeSamplingSignalRegister
 **
 ** Changes analog input signal sampled by the ADC channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] AnalogSignal         Analog signal to be sampled.
 **
 */
FUNC(void, ADC_CODE) Adc_ChangeSamplingSignalRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(Adc_SignalType, AUTOMATIC) AnalogSignal
)
{
  Adc_EsarChStructSampleCtlType curEsarChStructSampleCtl;

  /* Read value from register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarChStructSampleCtl) = EsarChStructRegPtr->ChSampleCtl;

  /* Change analog signal. */
  curEsarChStructSampleCtl.u6PIN_ADDR = AnalogSignal;

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarChStructRegPtr->ChSampleCtl = ADC_STRUCT_UINT32(curEsarChStructSampleCtl);
}

/** \brief Adc_SetupGenericInputTriggerSelect
 **
 ** Setup generic input trigger select register for ADC HwUnit (ESAR:EPASS_MMIO:SAR_TR_IN_SEL).
 **
 ** \param [in] HwUnit               An ADC hwunit numeric ID.
 ** \param [in] InputTriggerSelect   Setting for input trigger select.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupGenericInputTriggerSelect
(
  VAR(Adc_HwUnitType, AUTOMATIC) HwUnit,
  VAR(uint32, AUTOMATIC) InputTriggerSelect
)
{
  /* Get the PASS MMIO register base address. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarMmioType, AUTOMATIC, REGSPACE) curEsarMmioRegPtr
    = (volatile P2VAR(Adc_EsarMmioType, AUTOMATIC, REGSPACE))Adc_GetPassMmioRegAddr();

  /* Write register value for the HW unit. */
  curEsarMmioRegPtr->PassSarTrInSel[HwUnit] = InputTriggerSelect; /* ESAR:EPASS_MMIO:SAR_TR_IN_SEL */
}

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[internal function definitions]=========================*/

#define ADC_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/** \brief Adc_SetupGlobalControlRegister
 **
 ** Setup global control register for ADC HwUnit (ESAR:CTL).
 **
 ** \param [in] EsarRegPtr            Pointer to registers (ESAR).
 ** \param [in] PowerControlSetting   Enable or disable SARMUX, SAR sequencer and/or SAR IP.
 ** \param [in] HalfLsbEnable         Enable or disable half LSB conversion.
 **
 */
static FUNC(void, ADC_CODE) Adc_SetupGlobalControlRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(uint8, AUTOMATIC) PowerControlSetting,
  VAR(uint8, AUTOMATIC) HalfLsbEnable
)
{
  uint32 curEsarCtl;

  /* Get setting value. */
  curEsarCtl = (((uint32)(PowerControlSetting) << ADC_REG_OFFSET_24BIT) |
                ((uint32)HalfLsbEnable << ADC_BIT_POSITION_HALFLSB));

  /* Write value to register. */
  EsarRegPtr->EsarCtl = curEsarCtl;
}

/** \brief Adc_SetupGlobalDiagRegister
 **
 ** Diagnostic feature is enabled or disabled by calling this function.
 ** If enabled, which diagnostic reference is selected according to the parameter.
 **
 ** \param [in] EsarRegPtr      Pointer to registers (ESAR).
 ** \param [in] DiagSelect      Select diagnostic reference.
 ** \param [in] EnableSetting   Setting to enable or disable diagnostic (TRUE or FALSE).
 **
 */
static FUNC(void, ADC_CODE) Adc_SetupGlobalDiagRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(Adc_DiagReferenceType, AUTOMATIC) DiagSelect,
  VAR(boolean, AUTOMATIC) EnableSetting
)
{
  Adc_EsarDiagCtlType curEsarDiagCtl;

  /* Fulfill all bits with zero. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarDiagCtl) = 0U;

  /* Setup diagnostic reference and enable/disable it. */
  curEsarDiagCtl.u4DIAG_SEL = DiagSelect;                            /* ESAR:DIAG_CTL:DIAG_SEL */
  curEsarDiagCtl.u1DIAG_EN  = (EnableSetting == TRUE) ? (1U) : (0U); /* ESAR:DIAG_CTL:DIAG_EN  */

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarRegPtr->EsarDiagCtl = ADC_STRUCT_UINT32(curEsarDiagCtl);
}

/** \brief Adc_SetupGlobalPrecondRegister
 **
 ** This function is used to setup preconditioning control register.
 **
 ** \param [in] EsarRegPtr    Pointer to registers (ESAR).
 ** \param [in] PrecondTime   Number ADC clock cycles that Preconditioning is done
 **                            before the sample window starts.
 **
 */
static FUNC(void, ADC_CODE) Adc_SetupGlobalPrecondRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(uint8, AUTOMATIC) PrecondTime
)
{
  Adc_EsarPrecondCtlType curEsarPrecondCtl;

  /* Fulfill all bits with zero. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  ADC_STRUCT_UINT32(curEsarPrecondCtl) = 0U;

  /* Set preconditioning clock cycles. */
  curEsarPrecondCtl.u4PRECOND_TIME = PrecondTime; /* ESAR:PRECOND_CTL:PRECOND_TIME */

  /* Write value to register. */
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The bit-fields structure variable is used to access easily each bit filed of hardware register, 
                    and the 32 bit unsigned integer type is used to access register faster. 
                    Therefore, it is necessary to cast to different object pointer type. 
                    And the bit-fields structure of each register definition is 32 bits width 
                    and it is the same as hardware register access width. */
  /* PRQA S 310 1 */
  EsarRegPtr->EsarPrecondCtl = ADC_STRUCT_UINT32(curEsarPrecondCtl);
}

/** \brief Adc_ClearCalibrationRegisters
 **
 ** Clear all calibration registers for ADC HwUnit.
 ** (ESAR:ANA_CAL, ANA_CAL_ALT, DIG_CAL,DIG_CAL_ALT).
 **
 ** \param [in] EsarRegPtr  Pointer to registers (ESAR).
 **
 */
static FUNC(void, ADC_CODE) Adc_ClearCalibrationRegisters
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr
)
{
  EsarRegPtr->EsarAnaCal     = 0U;    /* Clear ESAR:ANA_CAL     */
  EsarRegPtr->EsarAnaCal_Alt = 0U;    /* Clear ESAR:ANA_CAL_ALT */
  EsarRegPtr->EsarDigCal     = 0U;    /* Clear ESAR:DIG_CAL     */
  EsarRegPtr->EsarDigCal_Alt = 0U;    /* Clear ESAR:DIG_CAL_ALT */
}

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[end of file]===========================================*/
