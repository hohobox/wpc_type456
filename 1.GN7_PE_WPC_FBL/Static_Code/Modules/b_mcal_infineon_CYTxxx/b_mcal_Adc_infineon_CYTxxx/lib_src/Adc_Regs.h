/** \brief AUTOSAR Adc Driver
 **
 ** This file contains the declaration of the AUTOSAR module Adc function
 ** for accessing hardware registers.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef ADC_REGS_H_INCLUDED
#define ADC_REGS_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Adc_Types.h>   /* Module public types */

/*==================[macros]================================================*/

/*------------------[PASS register]-----------------------------------------*/

/* Bit mask for ESAR:INTR register */
#define ADC_MASK_ESAR_INTR                  ( 0x707U )

/* Initial value for MMIO:SAR_TR_IN_SEL register */
#define ADC_DEFAULT_MMIO_SAR_TR_IN_SEL      ( 0x43210U )

/* Start value of selects a tr_sar_ch_rangvio trigger for MMIO:SAR_TR_OUT_SEL register */
#define ADC_OUTSEL_START_OF_RANGVIO         ( 32U )

/* Offset to adjust bit position */
#define ADC_REG_OFFSET_24BIT                ( 24U )
#define ADC_REG_OFFSET_8BIT                 (  8U )

/* HALF_LSB bit position for ESAR:CTL register */
#define ADC_BIT_POSITION_HALFLSB            ( 10U )

/* Sign bit (MSB) mask for ESAR:ANA_CAL/ANA_CAL_ALT:AGAIN */
#define ADC_ANA_CAL_AGAIN_MASK              ( 0x10U )

/* Operand for getting minus AGAIN value */
#define ADC_ANA_CAL_AGAIN_MSB_EXTEND        ( 32 )

/*------------------[DW register]-------------------------------------------*/
/* Initialization value for DW_CH_STRUCT:CH_CTL register */
#define ADC_DW_CHCTL_INIT_VALUE             ( 0x00000002U )

/* ENABLED Bit position for DW_CH_STRUCT:CH_CTL register */
#define ADC_DW_CHCTL_ENABLED_BIT            ( 0x80000000U )

/* INTR_CAUSE Bit mask for DW_CH_STRUCT:CH_STATUS register */
#define ADC_DW_CHSTATUS_INTRCASE_MASK       ( 0x0000000FU )

/* Definition INTR_CASE (interrupt cause) for DW_CH_STRUCT:CH_STATUS register */
#define ADC_DW_INTRCASE_NO_INTR             ( 0U )
#define ADC_DW_INTRCASE_COMPLETION          ( 1U )

/* CH Bit position for DW_CH_STRUCT:INTR/INTR_SET/INTR_MASK/INTR_MASKED register */
#define ADC_DW_CHINTR_CH_BIT                ( 0x00000001U )

/* Starting value of 1D transfer for DW_DESCR_STRUCT:DESCR_CTL register */
#define ADC_DW_DESCRCTL_START1D_VALUE       ( 0x54000074U )

/* Starting value of 2D transfer for DW_DESCR_STRUCT:DESCR_CTL register */
#define ADC_DW_DESCRCTL_START2D_VALUE       ( 0x94000074U )

/* Size between the RESULT register for Channel structure of ESAR */
/* This size is CH_STRUCT size (0x40) / word size (4).            */
#define ADC_DW_ESAR_CH_STRUCT_SIZE          ( 0x10U )

/* Access macro to struct data in 32bit */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: In case of very small processing, function-like macro is used.
                  It improves readability and performance. */
/* PRQA S 3453 1 */
#define ADC_STRUCT_UINT32(reg_name)         ( *((uint32 *)(&(reg_name))) )

/*==================[type definitions]======================================*/

/*------------------[ESAR:CH_STRUCT:TR_CTL]---------------------------------*/

/* Definition register type for Adc_EsarChStructTrCtlType */
/* Deviation from MISRA-C:2004 rule 1.1, 6.4, MISRA-C:2012 Rule-1.2, Rule-6.1
   Justification: Type definition is used for register (32bit width) access.
                  Therefore, Bit-fields in this struct are used with 32 bit unsigned of standard AUTOSAR type. */
/* PRQA S 635 EOF */
typedef struct
{
  uint32 u3SEL:3;
  uint32 :1;
  uint32 u3PRIO:3;
  uint32 :1;
  uint32 u2PREEMPTTYPE:2;
  uint32 :1;
  uint32 u1GROUPEND:1;
  uint32 :19;
  uint32 u1DONELEVEL:1;
} Adc_EsarChStructTrCtlType;

/*------------------[ESAR:CH_STRUCT:SAMPLE_CTL]------------------------------*/

/* Definition register type for Adc_EsarChStructSampleCtlType */
typedef struct
{
  uint32 u6PIN_ADDR:6;
  uint32 u2PORT_ADDR:2;
  uint32 u3EXT_MUX_SEL:3;
  uint32 u1EXT_MUX_EN:1;
  uint32 u2PRECOND_MODE:2;
  uint32 u2OVERLAP_DIAG:2;
  uint32 u12SAMPLE_TIME:12;
  uint32 :3;
  uint32 u1ALT_CAL:1;
} Adc_EsarChStructSampleCtlType;

/*------------------[ESAR:CH_STRUCT:POST_CTL]-------------------------------*/

/* Definition register type for Adc_EsarChStructPostCtlType */
typedef struct
{
  uint32 u3POST_PROC:3;
  uint32 :3;
  uint32 u1LEFT_ALIGN:1;
  uint32 u1SIGN_EXT:1;
  uint32 u8AVG_CNT:8;
  uint32 u5SHIFT_R:5;
  uint32 :1;
  uint32 u2RANGE_MODE:2;
  uint32 :1;
  uint32 u1TR_DONE_GRP_VIO:1;
  uint32 :6;
} Adc_EsarChStructPostCtlType;

/*------------------[ESAR:CH_STRUCT:RANGE_CTL]------------------------------*/

/* Definition register type for Adc_EsarChStructRangeCtlType */
typedef struct
{
  uint32 u16RANGE_LO:16;
  uint32 u16RANGE_HI:16;
} Adc_EsarChStructRangeCtlType;

/*------------------[ESAR:CH_STRUCT:INTR]-----------------------------------*/

/* Definition register type for Adc_EsarChStructIntrType */
typedef struct
{
  uint32 u1GRP_DONE:1;
  uint32 u1GRP_CANCELLED:1;
  uint32 u1GRP_OVERFLOW:1;
  uint32 :5;
  uint32 u1CH_RANGE:1;
  uint32 u1CH_PULSE:1;
  uint32 u1CH_OVERFLOW:1;
  uint32 :21;
} Adc_EsarChStructIntrType;

/*------------------[ESAR:CH_STRUCT:INTR_SET]-------------------------------*/

/* Definition register type for Adc_EsarChStructIntrSetType */
typedef struct
{
  uint32 u1GRP_DONE_SET:1;
  uint32 u1GRP_CANCELLED_SET:1;
  uint32 u1GRP_OVERFLOW_SET:1;
  uint32 :5;
  uint32 u1CH_RANGE_SET:1;
  uint32 u1CH_PULSE_SET:1;
  uint32 u1CH_OVERFLOW_SET:1;
  uint32 :21;
} Adc_EsarChStructIntrSetType;

/*------------------[ESAR:CH_STRUCT:INTR_MASK]------------------------------*/

/* Definition register type for Adc_EsarChStructIntrMaskType */
typedef struct
{
  uint32 u1GRP_DONE_MASK:1;
  uint32 u1GRP_CANCELLED_MASK:1;
  uint32 u1GRP_OVERFLOW_MASK:1;
  uint32 :5;
  uint32 u1CH_RANGE_MASK:1;
  uint32 u1CH_PULSE_MASK:1;
  uint32 u1CH_OVERFLOW_MASK:1;
  uint32 :21;
} Adc_EsarChStructIntrMaskType;

/*------------------[ESAR:CH_STRUCT:INTR_MASKED]----------------------------*/

/* Definition register type for Adc_EsarChStructIntrMaskedType */
typedef struct
{
  uint32 u1GRP_DONE_MASKED:1;
  uint32 u1GRP_CANCELLED_MASKED:1;
  uint32 u1GRP_OVERFLOW_MASKED:1;
  uint32 :5;
  uint32 u1CH_RANGE_MASKED:1;
  uint32 u1CH_PULSE_MASKED:1;
  uint32 u1CH_OVERFLOW_MASKED:1;
  uint32 :21;
} Adc_EsarChStructIntrMaskedType;

/*------------------[ESAR:CH_STRUCT:WORK]-----------------------------------*/

/* Definition register type for Adc_EsarChStructWorkType */
typedef struct
{
  uint32 u16WORK:16;
  uint32 :12;
  uint32 u1ABOVE_HI_MIR:1;
  uint32 u1RANGE_MIR:1;
  uint32 u1PULSE_MIR:1;
  uint32 u1VALID_MIR:1;
} Adc_EsarChStructWorkType;

/*------------------[ESAR:CH_STRUCT:RESULT]---------------------------------*/

/* Definition register type for Adc_EsarChStructResultType */
typedef struct
{
  uint32 u16RESULT:16;
  uint32 :12;
  uint32 u1ABOVE_HI_MIR:1;
  uint32 u1RANGE_INTR_MIR:1;
  uint32 u1PULSE_INTR_MIR:1;
  uint32 u1VALID_MIR:1;
} Adc_EsarChStructResultType;

/*------------------[ESAR:CH_STRUCT:GRP_STAT]-------------------------------*/

/* Definition register type for Adc_EsarChStructGrpStatType */
typedef struct
{
  uint32 u1GRP_COMPLETE:1;
  uint32 u1GRP_CANCELLED:1;
  uint32 u1GRP_OVERFLOW:1;
  uint32 :5;
  uint32 u1CH_RANGE_COMPLETE:1;
  uint32 u1CH_PULSE_COMPLETE:1;
  uint32 u1CH_OVERFLOW:1;
  uint32 :5;
  uint32 u1GRP_BUSY:1;
  uint32 :15;
} Adc_EsarChStructGrpStatType;

/*------------------[ESAR:CH_STRUCT:ENABLE]---------------------------------*/

/* Definition register type for Adc_EsarChStructEnableType */
typedef struct
{
  uint32 u1CHAN_EN:1;
  uint32 :31;
} Adc_EsarChStructEnableType;

/*------------------[CH_STRUCT:TR_CMD]--------------------------------------*/

/* Definition register type for Adc_EsarChStructTrCmdType */
typedef struct
{
  uint32 u1START:1;
  uint32 :31;
} Adc_EsarChStructTrCmdType;

/*------------------[ESAR:CTL]----------------------------------------------*/

/* Definition register type for Adc_EsarCtlType */
typedef struct
{
  uint32 u8PWRUP_TIME:8;
  uint32 u1IDLE_PWRDWN:1;
  uint32 u1MSB_STRETCH:1;
  uint32 u1HALF_LSB:1;
  uint32 :18;
  uint32 u1SARMUX_EN:1;
  uint32 u1ADC_EN:1;
  uint32 u1ENABLED:1;
} Adc_EsarCtlType;

/*------------------[ESAR:DIAG_CTL]-----------------------------------------*/

/* Definition register type for Adc_EsarDiagCtlType */
typedef struct
{
  uint32 u4DIAG_SEL:4;
  uint32 :27;
  uint32 u1DIAG_EN:1;
} Adc_EsarDiagCtlType;

/*------------------[ESAR:PRECOND_CTL]--------------------------------------*/

/* Definition register type for Adc_EsarPrecondCtlType */
typedef struct
{
  uint32 u4PRECOND_TIME:4;
  uint32 :28;
} Adc_EsarPrecondCtlType;

/*------------------[ESAR:ANA_CAL]------------------------------------------*/

/* Definition register type for Adc_EsarAnaCalType */
typedef struct
{
  uint32 u8AOFFSET:8;
  uint32 :8;
  uint32 u5AGAIN:5;
  uint32 :11;
} Adc_EsarAnaCalType;

/*------------------[ESAR:DIG_CAL]------------------------------------------*/

/* Definition register type for Adc_EsarDigCalType */
typedef struct
{
  uint32 u12DOFFSET:12;
  uint32 :4;
  uint32 u6DGAIN:6;
  uint32 :10;
} Adc_EsarDigCalType;

/*------------------[ESAR:ANA_CAL_ALT]--------------------------------------*/

/* Definition register type for Adc_EsarAnaCalAltType */
typedef struct
{
  uint32 u8AOFFSET:8;
  uint32 :8;
  uint32 u5AGAIN:5;
  uint32 :11;
} Adc_EsarAnaCalAltType;

/*------------------[ESAR:DIG_CAL_ALT]--------------------------------------*/

/* Definition register type for Adc_EsarDigCalAltType */
typedef struct
{
  uint32 u12DOFFSET:12;
  uint32 :4;
  uint32 u6DGAIN:6;
  uint32 :10;
} Adc_EsarDigCalAltType;

/*------------------[ESAR:CAL_UPD_CMD]--------------------------------------*/

/* Definition register type for Adc_EsarCalUpdCmdType */
typedef struct
{
  uint32 u1UPDATE:1;
  uint32 :31;
} Adc_EsarCalUpdCmdType;

/*------------------[ESAR:STATUS]-------------------------------------------*/

/* Definition register type for Adc_EsarStatusType */
typedef struct
{
  uint32 u5CUR_CHAN:5;
  uint32 :3;
  uint32 u3CUR_PRIO:3;
  uint32 :1;
  uint32 u2CUR_PREEMPT_TYPE:2;
  uint32 :15;
  uint32 u1DBG_FREEZE:1;
  uint32 u1PWRUP_BUSY:1;
  uint32 u1BUSY:1;
} Adc_EsarStatusType;

/*------------------[ESAR:AVG_STAT]-----------------------------------------*/

/* Definition register type for Adc_EsarAvgStatType */
typedef struct
{
  uint32 u20CUR_AVG_ACCU:20;
  uint32 :4;
  uint32 u8CUR_AVG_CNT:8;
} Adc_EsarAvgStatType;

/*------------------[EPASS_MMIO:SAR_TR_OUT_SEL]-----------------------------*/

/* Definition register type for Adc_EpassMmioSarTrOutSelType */
typedef struct
{
  uint32 u6OUT0_SEL:6;
  uint32 :2;
  uint32 u6OUT1_SEL:6;
  uint32 :18;
} Adc_EpassMmioSarTrOutSelType;

/*------------------[DW:CH_STRUCT:CH_CTL]-----------------------------------*/

/* Definition register type for Adc_DwChStructChCtlType */
typedef struct
{
  uint32 u1P:1;
  uint32 u1NS:1;
  uint32 u1B:1;
  uint32 :1;
  uint32 u4PC:4;
  uint32 u2PRIO:2;
  uint32 :1;
  uint32 u1PREEMPTABLE:1;
  uint32 :19;
  uint32 u1ENABLED:1;
} Adc_DwChStructChCtlType;

/*------------------[DW:CH_STRUCT:CH_STATUS]--------------------------------*/

/* Definition register type for Adc_DwChStructChStatusType */
typedef struct
{
  uint32 u4INTR_CAUSE:4;
  uint32 :27;
  uint32 u1PENDING:1;
} Adc_DwChStructChStatusType;

/*------------------[DW:CH_STRUCT:CH_IDX]-----------------------------------*/

/* Definition register type for Adc_DwChStructChIdxType */
typedef struct
{
  uint32 u8X_IDX:8;
  uint32 u8Y_IDX:8;
  uint32 :16;
} Adc_DwChStructChIdxType;

/*------------------[DW:CTL]------------------------------------------------*/

/* Definition register type for Adc_DwCtlType */
typedef struct
{
  uint32 u1ECC_EN:1;
  uint32 u1ECC_INJ_EN:1;
  uint32 :29;
  uint32 u1ENABLED:1;
} Adc_DwCtlType;

/*------------------[DW:STATUS]---------------------------------------------*/

/* Definition register type for Adc_DwStatusType */
typedef struct
{
  uint32 u1P:1;
  uint32 u1NS:1;
  uint32 u1B:1;
  uint32 :1;
  uint32 u4PC:4;
  uint32 u2PRIO:2;
  uint32 :1;
  uint32 u1PREEMPTABLE:1;
  uint32 :4;
  uint32 u9CH_IDX:9;
  uint32 :3;
  uint32 u3STATE:3;
  uint32 u1ACTIVE:1;
} Adc_DwStatusType;

/*------------------[DW:ECC_CTL]--------------------------------------------*/

/* Definition register type for Adc_DwEccCtlType */
typedef struct
{
  uint32 u10WORD_ADDR:10;
  uint32 :15;
  uint32 u7PARITY:7;
} Adc_DwEccCtlType;

/*------------------[DW:CRC_CTL]--------------------------------------------*/

/* Definition register type for Adc_DwCrcCtlType */
typedef struct
{
  uint32 u1DATA_REVERSE:1;
  uint32 :7;
  uint32 u1REM_REVERSE:1;
  uint32 :23;
} Adc_DwCrcCtlType;

/*------------------[DW:CRC_DATA_CTL]---------------------------------------*/

/* Definition register type for Adc_DwCrcDataCtlType */
typedef struct
{
  uint32 u8DATA_XOR:8;
  uint32 :24;
} Adc_DwCrcDataCtlType;

/*------------------[DW_DESCR_STRUCT:DESCR_CTL]-----------------------------*/

/* Definition descriptor type for Adc_DwDescriptorControlType */
typedef struct
{
  uint32 u2WAIT_FOR_DEACT:2;
  uint32 u2INTR_TYPE:2;
  uint32 u2TR_OUT_TYPE:2;
  uint32 u2TR_IN_TYPE:2;
  uint32 :16;
  uint32 u1CH_DISABLE:1;
  uint32 :1;
  uint32 u1SRC_TRANSFER_SIZE:1;
  uint32 u1DST_TRANSFER_SIZE:1;
  uint32 u2DATA_SIZE:2;
  uint32 u2DESCR_TYPE:2;
} Adc_DwDescriptorControlType;

/*------------------[DW_DESCR_STRUCT:DESCR_XY_CTL]--------------------------*/

/* Definition descriptor type for Adc_DwDescriptorXYControlType */
typedef struct
{
  uint32 u12SRC_INCR:12;
  uint32 u12DST_INCR:12;
  uint32 u8COUNT:8;
} Adc_DwDescriptorXYControlType;


/** \brief struct Adc_HwUnitConfigType
 **
 ** Configuration structure containing configuration items that apply to the whole
 ** HW unit.
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) ChTrCtl;      /* 0x000 : CH_TR_CTL      */
  VAR(uint32, AUTOMATIC) ChSampleCtl;  /* 0x004 : CH_SAMPLE_CTL  */
  VAR(uint32, AUTOMATIC) ChPostCtl;    /* 0x008 : CH_POST_CTL    */
  VAR(uint32, AUTOMATIC) ChRangeCtl;   /* 0x00C : CH_RANGE_CTL   */
  VAR(uint32, AUTOMATIC) ChIntr;       /* 0x010 : CH_INTR        */
  VAR(uint32, AUTOMATIC) ChIntrSet;    /* 0x014 : CH_INTR_SET    */
  VAR(uint32, AUTOMATIC) ChIntrMask;   /* 0x018 : CH_INTR_MASK   */
  VAR(uint32, AUTOMATIC) ChIntrMasked; /* 0x01C : CH_INTR_MASKED */
  VAR(uint32, AUTOMATIC) ChWork;       /* 0x020 : CH_WORK        */
  VAR(uint32, AUTOMATIC) ChResult;     /* 0x024 : CH_RESULT      */
  VAR(uint32, AUTOMATIC) ChGrpStat;    /* 0x028 : CH_GRP_STAT    */
  VAR(uint32, AUTOMATIC) ChRes02C[3];  /* 0x02C : Reserved       */
  VAR(uint32, AUTOMATIC) ChEnable;     /* 0x038 : CH_ENABLE      */
  VAR(uint32, AUTOMATIC) ChTrCmd;      /* 0x03C : CH_TR_CMD      */
} Adc_EsarChStructType;

/** \brief struct Adc_HwUnitConfigType
 **
 ** Configuration structure containing configuration items that apply to the whole
 ** HW unit.
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) EsarCtl;                        /* 0x000 : ESAR_CTL             */
  VAR(uint32, AUTOMATIC) EsarDiagCtl;                    /* 0x004 : ESAR_DIAG_CTL        */
  VAR(uint32, AUTOMATIC) EsarRes008[2];                  /* 0x008 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarPrecondCtl;                 /* 0x010 : ESAR_PRECOND_CTL     */
  VAR(uint32, AUTOMATIC) EsarRes014[27];                 /* 0x014 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarAnaCal;                     /* 0x080 : ESAR_ANA_CAL         */
  VAR(uint32, AUTOMATIC) EsarDigCal;                     /* 0x084 : ESAR_DIG_CAL         */
  VAR(uint32, AUTOMATIC) EsarRes088[2];                  /* 0x088 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarAnaCal_Alt;                 /* 0x090 : ESAR_ANA_CAL_ALT     */
  VAR(uint32, AUTOMATIC) EsarDigCal_Alt;                 /* 0x094 : ESAR_DIG_CAL_ALT     */
  VAR(uint32, AUTOMATIC) EsarCalUpd_Cmd;                 /* 0x098 : ESAR_CAL_UPD_CMD     */
  VAR(uint32, AUTOMATIC) EsarRes09C[21];                 /* 0x09C : Reserved             */
  VAR(uint32, AUTOMATIC) EsarDftCtl;                     /* 0x0F0 : ESAR_DFT_CTL         */
  VAR(uint32, AUTOMATIC) EsarRes0F4[3];                  /* 0x0F4 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarTrPend;                     /* 0x100 : ESAR_TR_PEND         */
  VAR(uint32, AUTOMATIC) EsarRes104[31];                 /* 0x104 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarWorkValid;                  /* 0x180 : ESAR_WORK_VALID      */
  VAR(uint32, AUTOMATIC) EsarWorkRange;                  /* 0x184 : ESAR_WORK_RANGE      */
  VAR(uint32, AUTOMATIC) EsarWorkRange_Hi;               /* 0x188 : ESAR_WORK_RANGE_HI   */
  VAR(uint32, AUTOMATIC) EsarWorkPulse;                  /* 0x18C : ESAR_WORK_PULSE      */
  VAR(uint32, AUTOMATIC) EsarRes190[4];                  /* 0x190 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarResultValid;                /* 0x1A0 : ESAR_RESULT_VALID    */
  VAR(uint32, AUTOMATIC) EsarResultRange_Hi;             /* 0x1A4 : ESAR_RESULT_RANGE_HI */
  VAR(uint32, AUTOMATIC) EsarRes1A8[22];                 /* 0x1A8 : Reserved             */
  VAR(uint32, AUTOMATIC) EsarStatus;                     /* 0x200 : ESAR_STATUS          */
  VAR(uint32, AUTOMATIC) EsarAvgStat;                    /* 0x204 : ESAR_AVG_STAT        */
  VAR(uint32, AUTOMATIC) EsarRes208[382];                /* 0x208 : Reserved             */
  VAR(Adc_EsarChStructType, AUTOMATIC) EsarChConfig[32]; /* 0x800 : ESAR:CH_STRUCT       */
} Adc_EsarType;

/** \brief struct Adc_HwUnitConfigType
 **
 ** Configuration structure containing configuration items that apply to the whole
 ** HW unit.
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) PassPassCtl;        /* 0x000 : PASS_PASS_CTL       */
  VAR(uint32, AUTOMATIC) PassRes004[7];      /* 0x004 : Reserved            */
  VAR(uint32, AUTOMATIC) PassSarTrInSel[4];  /* 0x020 : PASS_SAR_TR_IN_SEL  */
  VAR(uint32, AUTOMATIC) PassRes024[4];      /* 0x030 : Reserved            */
  VAR(uint32, AUTOMATIC) PassSarTrOutSel[4]; /* 0x040 : PASS_SAR_TR_OUT_SEL */
} Adc_EsarMmioType;

/** \brief struct Adc_DwChStructType
 **
 ** Configuration structure containing configuration items that apply to the
 ** Data-Wire channel unit.
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) ChCtl;        /* 0x000 : CH_CTL      */
  VAR(uint32, AUTOMATIC) ChStatus;     /* 0x004 : CH_STATUS   */
  VAR(uint32, AUTOMATIC) ChIdx;        /* 0x008 : CH_IDX      */
  VAR(uint32, AUTOMATIC) ChCurrPtr;    /* 0x00C : CH_CURR_PTR */
  VAR(uint32, AUTOMATIC) ChIntr;       /* 0x010 : INTR        */
  VAR(uint32, AUTOMATIC) ChIntrSet;    /* 0x014 : INTR_SET    */
  VAR(uint32, AUTOMATIC) ChIntrMask;   /* 0x018 : INTR_MASK   */
  VAR(uint32, AUTOMATIC) ChIntrMasked; /* 0x01C : INTR_MASKED */
  VAR(uint32, AUTOMATIC) ChSramData0;  /* 0x020 : SRAM_DATA0  */
  VAR(uint32, AUTOMATIC) ChSramData1;  /* 0x024 : SRAM_DATA1  */
  VAR(uint32, AUTOMATIC) ChRes028[6];  /* 0x028 : Reserved    */
} Adc_DwChStructType;

/** \brief struct Adc_DwType
 **
 ** Configuration structure containing configuration items that apply to the whole
 ** Data-Wire unit.
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) DwCtl;                       /* 0x0000 : CTL                */
  VAR(uint32, AUTOMATIC) DwStatus;                    /* 0x0004 : STATUS             */
  VAR(uint32, AUTOMATIC) DwRes008[6];                 /* 0x0008 : Reserved           */
  VAR(uint32, AUTOMATIC) DwActDescrCtl;               /* 0x0020 : ACT_DESCR_CTL      */
  VAR(uint32, AUTOMATIC) DwActDescrSrc;               /* 0x0024 : ACT_DESCR_SRC      */
  VAR(uint32, AUTOMATIC) DwActDescrDst;               /* 0x0028 : ACT_DESCR_DST      */
  VAR(uint32, AUTOMATIC) DwRes02C;                    /* 0x002C : Reserved           */
  VAR(uint32, AUTOMATIC) DwActDescrXCtl;              /* 0x0030 : ACT_DESCR_X_CTL    */
  VAR(uint32, AUTOMATIC) DwActDescrYCtl;              /* 0x0034 : ACT_DESCR_Y_CTL    */
  VAR(uint32, AUTOMATIC) DwActDescrNextPtr;           /* 0x0038 : ACT_DESCR_NEXT_PTR */
  VAR(uint32, AUTOMATIC) DwRes03C;                    /* 0x003C : Reserved           */
  VAR(uint32, AUTOMATIC) DwActSrc;                    /* 0x0040 : ACT_SRC            */
  VAR(uint32, AUTOMATIC) DwActDst;                    /* 0x0044 : ACT_DST            */
  VAR(uint32, AUTOMATIC) DwRes048[14];                /* 0x0048 : Reserved           */
  VAR(uint32, AUTOMATIC) DwEccCtl;                    /* 0x0080 : ECC_CTL            */
  VAR(uint32, AUTOMATIC) DwRes084[31];                /* 0x0084 : Reserved           */
  VAR(uint32, AUTOMATIC) DwCrcCtl;                    /* 0x0100 : CRC_CTL            */
  VAR(uint32, AUTOMATIC) DwRes104[3];                 /* 0x0104 : Reserved           */
  VAR(uint32, AUTOMATIC) DwCrcDataCtl;                /* 0x0110 : CRC_DATA_CTL       */
  VAR(uint32, AUTOMATIC) DwRes114[3];                 /* 0x0114 : Reserved           */
  VAR(uint32, AUTOMATIC) DwCrcPolCtl;                 /* 0x0120 : CRC_POL_CTL        */
  VAR(uint32, AUTOMATIC) DwRes124[3];                 /* 0x0124 : Reserved           */
  VAR(uint32, AUTOMATIC) DwCrcLfsrCtl;                /* 0x0130 : CRC_LFSR_CTL       */
  VAR(uint32, AUTOMATIC) DwRes134[3];                 /* 0x0134 : Reserved           */
  VAR(uint32, AUTOMATIC) DwCrcRemCtl;                 /* 0x0140 : CRC_REM_CTL        */
  VAR(uint32, AUTOMATIC) DwRes144;                    /* 0x0144 : Reserved           */
  VAR(uint32, AUTOMATIC) DwCrcRemResult;              /* 0x0148 : CRC_REM_RESULT     */
  VAR(uint32, AUTOMATIC) DwRes14C[8109];              /* 0x014C : Reserved           */
  VAR(Adc_DwChStructType, AUTOMATIC) DwChConfig[512]; /* 0x8000 : DW:CH_STRUCT       */
} Adc_DwType;

/** \brief struct Adc_DwDescriptorOneDType
 **
 ** Definition descriptor type for Adc_DwDescriptorOneDType.
 **
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) DwDescrCtl;      /* 0x000 : DESCR_CTL      */
  VAR(uint32, AUTOMATIC) DwDescrSrc;      /* 0x004 : DESCR_SRC      */
  VAR(uint32, AUTOMATIC) DwDescrDst;      /* 0x008 : DESCR_DST      */
  VAR(uint32, AUTOMATIC) DwDescrXCtl;     /* 0x00C : DESCR_X_CTL    */
  VAR(uint32, AUTOMATIC) DwDescrNextPtr;  /* 0x010 : DESCR_NEXT_PTR */
} Adc_DwDescriptorOneDType;

/** \brief struct Adc_DwDescriptotTwoDType
 **
 ** Definition descriptor type for Adc_DwDescriptotTwoDType.
 **
 */
typedef struct
{
  VAR(uint32, AUTOMATIC) DwDescrCtl;      /* 0x000 : DESCR_CTL      */
  VAR(uint32, AUTOMATIC) DwDescrSrc;      /* 0x004 : DESCR_SRC      */
  VAR(uint32, AUTOMATIC) DwDescrDst;      /* 0x008 : DESCR_DST      */
  VAR(uint32, AUTOMATIC) DwDescrXCtl;     /* 0x00C : DESCR_X_CTL    */
  VAR(uint32, AUTOMATIC) DwDescrYCtl;     /* 0x010 : DESCR_Y_CTL    */
  VAR(uint32, AUTOMATIC) DwDescrNextPtr;  /* 0x014 : DESCR_NEXT_PTR */
} Adc_DwDescriptorTwoDType;

/*==================[external function declarations]========================*/

#define ADC_START_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

/** \brief Adc_ClearChannelInterruptFlags
 **
 ** Clear interrupt flags for range comparator and group conversion done.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
extern FUNC(void, ADC_CODE) Adc_ClearChannelInterruptFlags
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
);

/** \brief Adc_SetupChannelTriggerRegister
 **
 ** Configures the HW register for one channel as given by the parameters.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] Priority             Channel priority.
 ** \param [in] TriggerType          Trigger type.
 ** \param [in] ReplacementMode      Replacement mode.
 ** \param [in] IsEndChannel         Represent that it is last channel in a group.
 ** \param [in] DoneLevel            Select level or pulse for 'tr_ch_done' trigger output.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupChannelTriggerRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint8, AUTOMATIC) Priority,
  VAR(uint8, AUTOMATIC) TriggerType,
  VAR(uint8, AUTOMATIC) ReplacementMode,
  VAR(boolean, AUTOMATIC) IsEndChannel,
  VAR(uint8, AUTOMATIC) DoneLevel
);

/** \brief Adc_EnableChannelRegister
 **
 ** Enable or disable ADC channel (ESAR:CH_STRUCT:CHAN_EN).
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] EnableSetting        Represent that the channel is enabled or disabled.
 **
 */
extern FUNC(void, ADC_CODE) Adc_EnableChannelRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
);

/** \brief Adc_EnableGroupChannelsRegister
 **
 ** Enable or disable all ADC channels (ESAR:CH_STRUCT:CHAN_EN) in the ADC channel group.
 **
 ** \param [in] FirstEsarChStructRegPtr   Pointer to registers for ESAR first channel control.
 ** \param [in] LastEsarChStructRegPtr    Pointer to registers for ESAR last channel control.
 ** \param [in] EnableSetting             Represent that the channel is enabled or disabled.
 **
 */
extern FUNC(void, ADC_CODE) Adc_EnableGroupChannelsRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) FirstEsarChStructRegPtr,
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) LastEsarChStructRegPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
);

/** \brief Adc_SetupChannelSampleRegister
 **
 ** Setup sampling conditions for an ADC channel (ESAR:CH_STRUCT:SAMPLE_CTL).
 **
 ** \param [in] EsarChStructRegPtr       Pointer to registers for ESAR channel control.
 ** \param [in] PinAddr                  Physical channel.
 ** \param [in] PortAddr                 Physical port.
 ** \param [in] SamplingMode             Sampling mode.
 ** \param [in] SampleTime               Sampling time.
 ** \param [in] UseAlternateCalibration  Use alternate calibration values or not.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupChannelSampleRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(Adc_ChannelType,      AUTOMATIC) PinAddr,
  VAR(Adc_SarMuxType,       AUTOMATIC) PortAddr,
  VAR(Adc_SamplingModeType, AUTOMATIC) SamplingMode,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SampleTime,
  VAR(boolean,              AUTOMATIC) UseAlternateCalibration
);

/** \brief Adc_SetupChannelPostRegister
 **
 ** Setup post conditions for an ADC channel (ESAR:CH_STRUCT:POST_CTL).
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] RegisterValue        Setting value for POST_CTL register.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupChannelPostRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint32, AUTOMATIC) RegisterValue
);

/** \brief Adc_SetupChannelRangeRegister
 **
 ** Setup range upper/lower threshold for an ADC channel (ESAR:CH_STRUCT:RANGE_CTL).
 **
 ** \param [in] EsarChStructRegPtr              Pointer to registers for ESAR channel control.
 ** \param [in] RangeComparatorUpperThreshold   Upper threshold for range comparator.
 ** \param [in] RangeComparatorLowerThreshold   Lower threshold for range comparator.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupChannelRangeRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint16, AUTOMATIC) RangeComparatorUpperThreshold,
  VAR(uint16, AUTOMATIC) RangeComparatorLowerThreshold
);

/** \brief Adc_GetConversionStatusFlags
 **
 ** Returns interrupt flags for the given pointer to ADC channel registers.
 **
 ** \return                          bit 0: Conversion of channel was done.
 **                                  bit 8: Range comparator interrupt was detected.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
extern FUNC(uint32, ADC_CODE) Adc_GetConversionStatusFlags
(
  volatile P2CONST(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
);

/** \brief Adc_GetConversionValue
 **
 ** Returns the conversion value for the given HW channel and at same
 ** time resets the conversion done flag.
 **
 ** \return                          The value of the conversion for the given HW channel.
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
extern FUNC(uint16, ADC_CODE) Adc_GetConversionValue
(
  volatile P2CONST(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
);

/** \brief Adc_SetTriggerFlag
 **
 ** Sets the Sw trigger flag for the given Hw channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetTriggerFlag
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
);

/** \brief Adc_InitConfigurationRegisters
 **
 ** Set configuration registers when initialize the Hw unit.
 **
 ** \param [in] HwUnitConfigPtr   Hw unit configuration structure pointer.
 **
 */
extern FUNC(void, ADC_CODE) Adc_InitConfigurationRegisters
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr
);

/** \brief Adc_DeInitConfigurationRegisters
 **
 ** Reset configuration registers when deinitialize the Hw unit. 
 **
 ** \param [in] HwUnitConfigPtr   Hw unit configuration structure pointer.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DeInitConfigurationRegisters
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr
);

/** \brief Adc_SetIntrMaskRegister
 **
 ** Set interrupt mask for the specified ADC channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] IntrMask             Setting value for INTR_MASK register.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetIntrMaskRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(uint32, AUTOMATIC) IntrMask
);

/** \brief Adc_ChangeSamplingTimeRegister
 **
 ** Change sampling time for ADC channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] SamplingTime         Specifies sampling time for the ADC channel.
 **
 */
extern FUNC(void, ADC_CODE) Adc_ChangeSamplingTimeRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SamplingTime
);

/** \brief Adc_GetEnablePower
 **
 ** Gets state of power enable.
 **
 **  \return                 Returns the status of the power enable.
 **                          TRUE : Power is on.
 **                          FALSE: Power is off.
 ** \param [in] EsarRegPtr   Pointer to registers (ESAR).
 **
 */
extern FUNC(boolean, ADC_CODE) Adc_GetEnablePower
(
  volatile P2CONST(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr
);

/** \brief Adc_SetEnablePower
 **
 ** Sets state of enable power.
 **
 ** \param [in] EsarRegPtr        Pointer to registers (ESAR).
 ** \param [in] HwUnitConfigPtr   Hw unit configuration structure pointer.
 ** \param [in] EnableSetting     TRUE: enabled, FALSE: disabled.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetEnablePower
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
);

/** \brief Adc_SetupPassControl
 **
 ** Setup PASS control register (ESAR:EPASS_MMIO:PASS_CTL).
 **
 ** \param [in] ControlSetting   Setting for PASS control.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupPassControl
(
  VAR(uint32,  AUTOMATIC) ControlSetting
);

/** \brief Adc_SetupSarTrOutSel
 **
 ** Setup PASS control register (ESAR:EPASS_MMIO:SAR_TR_OUT_SEL).
 **
 ** \param [in] HwUnit            An ADC hwunit numeric ID.
 ** \param [in] OutputNumber      Select generic trigger output.
 ** \param [in] SelTriggerNumber  Select SAR output trigger for generic trigger output.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupSarTrOutSel
(
  VAR(uint8, AUTOMATIC)  HwUnit,
  VAR(uint8, AUTOMATIC)  OutputNumber,
  VAR(uint8, AUTOMATIC)  SelTriggerNumber
);

/** \brief Adc_DmaInitChannelRegister
 **
 ** Initialize a DMA channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaInitChannelRegister
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
);

/** \brief Adc_DmaSetupDescriptor
 **
 ** Set the DMA descriptor.
 **
 ** \param [in] GroupConfigPtr      Pointer to configuration for a group.
 ** \param [in] EsarChStructRegPtr  Pointer to registers for ESAR channel structure.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaSetupDescriptor
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST)     GroupConfigPtr,
  volatile P2CONST(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr
);

/** \brief Adc_DmaStartChannelRegister
 **
 ** Start a DMA channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 ** \param [in] DescriptorAddr    Base address of a DMA descriptor.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaStartChannelRegister
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr,
  VAR(uint32, AUTOMATIC) DescriptorAddr
);

/** \brief Adc_DmaStopChannelRegister
 **
 ** Stop a DMA channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaStopChannelRegister
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
);

/** \brief Adc_DmaGetChannelStatusFlags
 **
 ** Return current status for the DW channel.
 **
 ** \return                       0   : Interrupt was not detected.
 **                               1   : Completion interrupt was detected.
 **                               2-8 : Error interrupt was detected.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
extern FUNC(uint32, ADC_CODE) Adc_DmaGetChannelStatusFlags
(
  volatile P2CONST(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
);

/** \brief Adc_DmaClearChannelInterruptFlags
 **
 ** Clear the interrupt flag for the DW channel.
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaClearChannelInterruptFlags
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr
);

/** \brief Adc_DmaSetChannelInterruptMask
 **
 ** Enable or disable the interrupt for the DW channel. 
 ** (I.e. Set or clear the interrupt mask.)
 **
 ** \param [in] DwChStructRegPtr  Pointer to registers for DW channel structure.
 ** \param [in] EnableSetting     Setting which the request is enabled or disabled.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaSetChannelInterruptMask
(
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) DwChStructRegPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
);


/** \brief Adc_DmaRegisterReadCtl
 **
 ** Just read DMA ctl register to read back DMA registers.
 **
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DmaRegisterReadCtl
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_AdcRegisterReadTrCtl
 **
 ** Just read ADC Ch ctl register to read back ADC registers.
 **
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 */
extern FUNC(void, ADC_CODE) Adc_AdcRegisterReadTrCtl
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_SetupAnalogCalibrationAlternateRegister
 **
 ** Setup alternate analog calibration values register for ADC HwUnit (ESAR:ANA_CAL_ALT).
 **
 ** \param [in] EsarRegPtr  Pointer to registers (ESAR).
 ** \param [in] Offset      Offset correction.
 ** \param [in] Gain        Gain correction.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupAnalogCalibrationAlternateRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(Adc_OffsetValueType, AUTOMATIC) Offset,
  VAR(Adc_GainValueType,   AUTOMATIC) Gain
);

/** \brief Adc_GetCalibrationAlternateRegister
 **
 ** Gets alternate analog calibration values.
 **
 ** \param [in]  EsarRegPtr  Pointer to registers (ESAR).
 ** \param [out] OffsetPtr   Buffer pointer stored offset value of alternate calibration.
 ** \param [out] GainPtr     Buffer pointer stored gain value of alternate calibration.
 **
 */
extern FUNC(void, ADC_CODE) Adc_GetCalibrationAlternateRegister
(
  volatile P2CONST(Adc_EsarType, AUTOMATIC, REGSPACE)    EsarRegPtr,
  P2VAR(Adc_OffsetValueType,   AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,     AUTOMATIC, ADC_APPL_DATA) GainPtr
);

/** \brief Adc_SetupCalibrationUpdateRegister
 **
 ** Sets calibration update command for ADC HwUnit (ESAR:CAL_UPD_CMD).
 **
 ** \param [in] EsarRegPtr  Pointer to registers (ESAR).
 ** \param [in] Update      Update calibration values or cancel the update request.
 **
 */
extern FUNC(void, ADC_CODE) Adc_SetupCalibrationUpdateRegister
(
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) EsarRegPtr,
  VAR(uint32, AUTOMATIC) Update
);

/** \brief Adc_GetCalibrationRegister
 **
 ** Gets regular analog calibration values.
 **
 ** \param [in]  EsarRegPtr  Pointer to registers (ESAR).
 ** \param [out] OffsetPtr   Buffer pointer stored offset value of regular calibration.
 ** \param [out] GainPtr     Buffer pointer stored gain value of regular calibration.
 **
 */
extern FUNC(void, ADC_CODE) Adc_GetCalibrationRegister
(
  volatile P2CONST(Adc_EsarType, AUTOMATIC, REGSPACE)    EsarRegPtr,
  P2VAR(Adc_OffsetValueType,   AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,     AUTOMATIC, ADC_APPL_DATA) GainPtr
);

/** \brief Adc_ChangeSamplingSignalRegister
 **
 ** Changes analog input signal sampled by the ADC channel.
 **
 ** \param [in] EsarChStructRegPtr   Pointer to registers for ESAR channel control.
 ** \param [in] AnalogSignal         Analog signal to be sampled.
 **
 */
extern FUNC(void, ADC_CODE) Adc_ChangeSamplingSignalRegister
(
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) EsarChStructRegPtr,
  VAR(Adc_SignalType, AUTOMATIC) AnalogSignal
);

/** \brief Adc_SetupGenericInputTriggerSelect
 **
 ** Setup generic input trigger select register for ADC HwUnit (ESAR:EPASS_MMIO:SAR_TR_IN_SEL).
 **
 ** \param [in] HwUnit               An ADC hwunit numeric ID.
 ** \param [in] InputTriggerSelect   Setting for input trigger select.
 **
 */
FUNC(void, ADC_CODE) Adc_SetupGenericInputTriggerSelect
(
  VAR(Adc_HwUnitType, AUTOMATIC) HwUnit,
  VAR(uint32, AUTOMATIC) InputTriggerSelect
);

#define ADC_STOP_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /*!defined(ADC_REGS_H_INCLUDED)*/

/*==================[end of file]===========================================*/
