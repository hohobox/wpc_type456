/** \brief AUTOSAR Adc Driver
 **
 ** This file contains or includes all external identifiers of the AUTOSAR 
 ** module ADC.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef ADC_H_INCLUDED
#define ADC_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Adc_Types.h>   /* Module public types */
#include <Adc_Cfg.h>     /* Generated ADC driver config */
#include <Adc_PBcfg.h>   /* Post-build configuration */
#include <Adc_Irq.h>     /* Module interrupt declaration */
#include <Adc_Version.h> /* Module version declarations */

/*==================[macros]================================================*/

/*------------------[AUTOSAR configuration AR version number check]---------*/

#if !defined( ADC_GEN_AR_RELEASE_MAJOR_VERSION )
#  error ADC_GEN_AR_RELEASE_MAJOR_VERSION not defined
#elif !defined( ADC_GEN_AR_RELEASE_MINOR_VERSION )
#  error ADC_GEN_AR_RELEASE_MINOR_VERSION not defined
#elif !defined( ADC_GEN_AR_RELEASE_REVISION_VERSION )
#  error ADC_GEN_AR_RELEASE_REVISION_VERSION not defined
#elif !ADC_AR_VERSION_CHECK( ADC_GEN_AR_RELEASE_MAJOR_VERSION,    \
                             ADC_GEN_AR_RELEASE_MINOR_VERSION,    \
                             ADC_GEN_AR_RELEASE_REVISION_VERSION )
#  error AUTOSAR ADC configuration AR version number mismatch
#endif

/*------------------[AUTOSAR configuration SW version number check]---------*/

#if !defined( ADC_GEN_SW_MAJOR_VERSION )
#  error ADC_GEN_SW_MAJOR_VERSION not defined
#elif !defined( ADC_GEN_SW_MINOR_VERSION )
#  error ADC_GEN_SW_MINOR_VERSION not defined
#elif !defined( ADC_GEN_SW_PATCH_VERSION )
#  error ADC_GEN_SW_PATCH_VERSION not defined
#elif !ADC_SW_VERSION_CHECK( ADC_GEN_SW_MAJOR_VERSION,    \
                             ADC_GEN_SW_MINOR_VERSION,    \
                             ADC_GEN_SW_PATCH_VERSION )
#  error AUTOSAR ADC configuration SW version number mismatch
#endif

/*------------------[AUTOSAR configuration additional check]----------------*/

#if !defined( ADC_GEN_MODULE_ID )
#  error ADC_GEN_MODULE_ID not defined
#elif !defined( ADC_GEN_VENDOR_ID )
#  error ADC_GEN_VENDOR_ID not defined
#elif !ADC_EXTRA_CHECK( ADC_GEN_MODULE_ID, ADC_GEN_VENDOR_ID )
#  error AUTOSAR ADC configuation additional checks failed
#endif

/*------------------[ADC Driver services IDs]-------------------------------*/
/** \brief Service Id definition of the init service */
#define ADC_API_INIT                            ( (uint8)0x00U )
/** \brief Service Id definition of the deinit service */
#define ADC_API_DEINIT                          ( (uint8)0x01U )
/** \brief Service Id definition of the start group conversion service */
#define ADC_API_START_GROUP_CONVERSION          ( (uint8)0x02U )
/** \brief Service Id definition of the stop group conversion service */
#define ADC_API_STOP_GROUP_CONVERSION           ( (uint8)0x03U )
/** \brief Service Id definition of the read group service */
#define ADC_API_READ_GROUP                      ( (uint8)0x04U )
/** \brief Service Id definition of the enable hardware trigger service */
#define ADC_API_ENABLE_HARDWARE_TRIGGER         ( (uint8)0x05U )
/** \brief Service Id definition of the disable hardware trigger service */
#define ADC_API_DISABLE_HARDWARE_TRIGGER        ( (uint8)0x06U )
/** \brief Service Id definition of the enable group notification service */
#define ADC_API_ENABLE_GROUP_NOTIFICATION       ( (uint8)0x07U )
/** \brief Service Id definition of the disable group notification service */
#define ADC_API_DISABLE_GROUP_NOTIFICATION      ( (uint8)0x08U )
/** \brief Service Id definition of the get group status service */
#define ADC_API_GET_GROUP_STATUS                ( (uint8)0x09U )
/** \brief Service Id definition of the get version info service */
#define ADC_API_GET_VERSION_INFO                ( (uint8)0x0AU )
/** \brief Service Id definition of the get stream last pointer service */
#define ADC_API_GET_STREAM_LAST_POINTER         ( (uint8)0x0BU )
/** \brief Service Id definition of setup result buffer service */
#define ADC_API_SETUP_RESULT_BUFFER             ( (uint8)0x0CU )
/** \brief Service Id definition of setting for power state */
#define ADC_API_SET_POWER_STATE                 ( (uint8)0x10U )
/** \brief Service Id definition of getting current power state */
#define ADC_API_GET_CURRENT_POWER_STATE         ( (uint8)0x11U )
/** \brief Service Id definition of getting target power state */
#define ADC_API_GET_TARGET_POWER_STATE          ( (uint8)0x12U )
/** \brief Service Id definition of preparation for power state */
#define ADC_API_PREPARE_POWER_STATE             ( (uint8)0x13U )
/** \brief Service Id definition of the main power transition manager service */
#define ADC_API_MAIN_POWER_TRANSITION_MANAGER   ( (uint8)0x14U )

/*------------------[ADC Driver services IDs (vendor specific)]-------------*/
/** \brief Service Id definition of the change sampling time service */
#define ADC_API_CHANGE_SAMPLING_TIME            ( (uint8)0x30U )
/** \brief Service Id definition of changing calibration channel */
#define ADC_API_CHANGE_CALIBRATION_CHANNEL      ( (uint8)0x31U )
/** \brief Service Id definition of setting alternate calibration values */
#define ADC_API_SET_CALIBRATION_VALUE           ( (uint8)0x32U )
/** \brief Service Id definition of getting alternate calibration values */
#define ADC_API_GET_CALIBRATION_ALTERNATE_VALUE ( (uint8)0x33U )
/** \brief Service Id definition of getting regular calibration values */
#define ADC_API_GET_CALIBRATION_VALUE           ( (uint8)0x34U )

/*------------------[Development errors]------------------------------------*/
/** \brief API service called without module initialization */
#define ADC_E_UNINIT                           ( (uint8)0x0AU )
/** \brief API service called while a conversion is ongoing */
#define ADC_E_BUSY                             ( (uint8)0x0BU )
/** \brief API service called while no conversion was running */
#define ADC_E_IDLE                             ( (uint8)0x0CU )
/** \brief ADC driver and hardware already initialized. */
#define ADC_E_ALREADY_INITIALIZED              ( (uint8)0x0DU )
/** \brief API Adc_Init service called with an invalid configuration */
#define ADC_E_PARAM_CONFIG                     ( (uint8)0x0EU )
/** \brief API service called with invalid data buffer pointer, NULL_PTR passed **/
#define ADC_E_PARAM_POINTER                    ( (uint8)0x14U )
/** \brief API service called with an invalid group ID value */
#define ADC_E_PARAM_GROUP                      ( (uint8)0x15U )
/** \brief API service called for a group configured in continuous mode */
#define ADC_E_WRONG_CONV_MODE                  ( (uint8)0x16U )
/** \brief API service called for a group not configured for the necessary trigger mode */
#define ADC_E_WRONG_TRIGG_SRC                  ( (uint8)0x17U )
/** \brief API service called for a group configured not to have notification */
#define ADC_E_NOTIF_CAPABILITY                 ( (uint8)0x18U )
/** \brief API service called while result buffer pointer is not initialized */
#define ADC_E_BUFFER_UNINIT                    ( (uint8)0x19U )
/** \brief API service called and one or more ADC group/channel not in IDLE state */
#define ADC_E_NOT_DISENGAGED                   ( (uint8)0x1AU )
/** \brief API service called and unsupported power state request */
#define ADC_E_POWER_STATE_NOT_SUPPORTED        ( (uint8)0x1BU )
/** \brief API service called and requested power state can not be reached directly */
#define ADC_E_TRANSITION_NOT_POSSIBLE          ( (uint8)0x1CU )
/** \brief API service called and ADC is not prepared for target power state yet */
#define ADC_E_PERIPHERAL_NOT_PREPARED          ( (uint8)0x1DU )
/*------------------[Development errors (vendor specific)]------------------*/
/** \brief API service called and channel is not in the group. */
#define ADC_E_PARAM_CHANNEL                    ( (uint8)0x2AU )
/** \brief API service called and HwUnit is out of valid range */
#define ADC_E_PARAM_HWUNIT                     ( (uint8)0x2BU )
/** \brief API service called and sampling time is not in valid range */
#define ADC_E_PARAM_SAMPLING_TIME              ( (uint8)0x2CU )
/** \brief API service called while a conversion is error */
#define ADC_E_CONVERSION_ERROR                 ( (uint8)0x2DU )
/** \brief hardware product error id for callout */
#define ADC_E_HARDWARE_ERROR_FOR_CALLOUT       ( (uint8)0x2EU )
/** \brief API service called and GAIN setting value is out of valid range */
#define ADC_E_PARAM_GAIN                       ( (uint8)0x30U )
/** \brief API service called and Update is out of valid range */
#define ADC_E_PARAM_UPDATE                     ( (uint8)0x31U )
/** \brief API service called with invalid input signal */
#define ADC_E_PARAM_SIGNAL                     ( (uint8)0x32U )
/*------------------[Adc instance id]---------------------------------------*/
/** \brief Adc instance id used for Det reports */
#define ADC_INSTANCE_ID_DET (0U)

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

#define ADC_START_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

#if ( ADC_DEINIT_API == STD_ON )
/** \brief Adc_DeInit
 **
 ** Returns all ADC HW Units to a state comparable to their power on reset state.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DeInit(void);
#endif/* #if ( ADC_DEINIT_API == STD_ON ) */

#if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON )
/** \brief Adc_DisableGroupNotification
 **
 ** Disables the notification mechanism for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DisableGroupNotification
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);
#endif /* #if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON ) */

#if ( ADC_HW_TRIGGER_API == STD_ON )
/** \brief Adc_DisableHardwareTrigger
 **
 ** Disables the hardware trigger for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(void, ADC_CODE) Adc_DisableHardwareTrigger
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);
#endif /* #if ( ADC_HW_TRIGGER_API == STD_ON ) */

#if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON )
/** \brief Adc_EnableGroupNotification
 **
 ** Enables the notification mechanism for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(void, ADC_CODE) Adc_EnableGroupNotification
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);
#endif /* #if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON ) */

#if ( ADC_HW_TRIGGER_API == STD_ON )
/** \brief Adc_EnableHardwareTrigger
 **
 ** Enables the hardware trigger for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(void, ADC_CODE) Adc_EnableHardwareTrigger
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);
#endif /* #if ( ADC_HW_TRIGGER_API == STD_ON ) */

/** \brief Adc_GetGroupStatus
 **
 ** Returns the conversion status of the requested ADC Channel group.
 **
 ** \return             Conversion status for the requested group.
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(Adc_StatusType, ADC_CODE) Adc_GetGroupStatus
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);

/** \brief Adc_GetStreamLastPointer
 **
 ** Returns the number of valid samples per channel, stored in the result buffer.
 ** Reads a pointer, pointing to a position in the group result buffer. With the
 ** pointer position, the results of all group channels of the last completed
 ** conversion round can be accessed.
 ** With the pointer and the return value, all valid group conversion results can
 ** be accessed (the user has to take the layout of the result buffer into account).
 **
 ** \return                       Number of valid samples per channel.
 ** \param [in] Group             Numeric ID of requested ADC Channel group.
 ** \param [out] PtrToSamplePtr   Pointer to result buffer pointer.
 **
 */
extern FUNC(Adc_StreamNumSampleType, ADC_CODE) Adc_GetStreamLastPointer
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  P2VAR(P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA), AUTOMATIC, ADC_APPL_DATA) PtrToSamplePtr
);

#if ( ADC_VERSION_INFO_API == STD_ON )
/** \brief Adc_GetVersionInfo
 **
 ** Returns the version information of this module.
 **
 ** \param [out] versioninfo   Pointer to where to store the version information of
 **                            this module.
 **
 */
extern FUNC(void, ADC_CODE) Adc_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, ADC_APPL_DATA) versioninfo
);
#endif /* #if ( ADC_VERSION_INFO_API == STD_ON ) */

/** \brief Adc_Init
 **
 ** Initializes the ADC hardware units and driver.
 **
 ** \param [in] ConfigPtr   Pointer to configuration set.
 **
 */
extern FUNC(void, ADC_CODE) Adc_Init
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
);

#if ( ADC_READ_GROUP_API == STD_ON )
/** \brief Adc_ReadGroup
 **
 ** Reads the group conversion result of the last completed conversion round of
 ** the requested group and stores the channel values starting at the DataBufferPtr
 ** address. The group channel values are stored in ascending channel number order
 ** (in contrast to the storage layout of the result buffer if streaming access is
 ** configured).
 **
 ** \return                    E_OK    : results are available and written to the data buffer.
 **                            E_NOT_OK: no results are available or development error occurred.
 ** 
 ** 
 ** \param [in] Group          Numeric ID of requested ADC channel group.
 ** \param [in] DataBufferPtr  ADC results of all channels of the selected group
 **                             are stored in the data buffer addressed with the pointer.
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_ReadGroup
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) DataBufferPtr
);
#endif /* #if ( ADC_READ_GROUP_API == STD_ON ) */

/** \brief Adc_SetupResultBuffer
 **
 ** Initializes ADC driver with the group specific result buffer start address
 ** where the conversion results will be stored. The application has to ensure that
 ** the application buffer, where DataBufferPtr points to, can hold all the
 ** conversion results of the specified group. The initialization with
 ** Adc_SetupResultBuffer is required after reset, before a group conversion can be
 ** started.
 **
 ** \return                     E_OK    :  result buffer pointer initialized correctly.
 **                             E_NOT_OK:  operation failed or development error occurred.
 ** 
 ** \param [in] Group           Numeric ID of requested ADC channel group.
 ** \param [in] DataBufferPtr   Pointer to result data buffer.
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_SetupResultBuffer
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) DataBufferPtr
);

#if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON )
/** \brief Adc_StartGroupConversion
 **
 ** Starts the conversion of all channels of the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(void, ADC_CODE) Adc_StartGroupConversion
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);
#endif /* #if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON ) */

#if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON )
/** \brief Adc_StopGroupConversion
 **
 ** Stops the conversion of the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
extern FUNC(void, ADC_CODE) Adc_StopGroupConversion
(
  VAR(Adc_GroupType, AUTOMATIC) Group
);
#endif /* #if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON ) */

/** \brief Adc_ChangeSamplingTime
 **
 ** This API is used to change a sampling time for ADC channel
 ** if a group which to the channel is belong is not running.
 **
 ** \return                    E_OK    : Sampling time changed.
 **                            E_NOT_OK: Request rejected.
 **
 ** \param [in] Group          An ADC group that it has the specified ADC channel.
 ** \param [in] Channel        An ADC physical channel that its sampling time is changed.
 ** \param [in] SamplingTime   Sampling time that it is set to the specified ADC channel.
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_ChangeSamplingTime
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  VAR(Adc_ChannelType, AUTOMATIC) Channel,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SamplingTime
);

#if ( ADC_LOWPOWER_STATES_SUPPORT == STD_ON )
/** \brief Adc_SetPowerState
 **
 ** This API configures the Adc module so that it enters the already prepared
 ** power state, chosen between a predefined set of configured ones.
 **
 ** \return               E_OK    : Power Mode changed.
 **                       E_NOT_OK: Request rejected.
 **
 ** \param [out] Result   Pointer to where to store the result.
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_SetPowerState
(
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
);

/** \brief Adc_GetCurrentPowerState
 **
 ** This API returns the current power state of the ADC HW unit.
 **
 ** \return                         E_OK    : Mode could be read.
 **                                 E_NOT_OK: Service is rejected.
 **
 ** \param [out] CurrentPowerState  The current power mode of the ADC HW Unit
 **                                  is returned in this parameter.
 ** \param [out] Result             Pointer to where to store the result.
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_GetCurrentPowerState
(
  P2VAR(Adc_PowerStateType,              AUTOMATIC, ADC_APPL_DATA) CurrentPowerState,
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
);

/** \brief Adc_GetTargetPowerState
 **
 ** This API returns the Target power state of the ADC HW unit.
 **
 ** \return                        E_OK    : Mode could be read
 **                                E_NOT_OK: Service is rejected
 **
 ** \param [out] TargetPowerState  The Target power mode of the ADC HW Unit
 **                                 is returned in this parameter.
 ** \param [out] Result            Pointer to where to store the result.
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_GetTargetPowerState
(
  P2VAR(Adc_PowerStateType,              AUTOMATIC, ADC_APPL_DATA) TargetPowerState,
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
);

/** \brief Adc_PreparePowerState
 **
 ** This API starts the needed process to allow the ADC HW module to enter
 ** the requested power state.
 **
 ** \return                 E_OK    : Preparation process started
 **                         E_NOT_OK: Service is rejected
 **
 ** \param [in]  PowerState The target power state intended to be attained.
 ** \param [out] Result     Pointer to where to store the result.
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_PreparePowerState
(
  VAR(Adc_PowerStateType, AUTOMATIC) PowerState,
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
);

/** \brief Adc_Main_PowerTransitionManager
 **
 ** This API is cyclically called and supervises the power state transitions, 
 ** checking for the readiness of the module and issuing the callbacks.
 ** (As there is no preparation period in the hardware feature, asynchronous 
 ** power state transition mode is not supported. Therefore, this main function 
 ** is implemented as null function.)
 **
 */
extern FUNC(void, ADC_CODE) Adc_Main_PowerTransitionManager(void);
#endif /* #if ( ADC_LOWPOWER_STATES_SUPPORT == STD_ON ) */

#if ( ADC_CALIBRATION_API == STD_ON )
/** \brief Adc_ChangeCalibrationChannel
 **
 ** Changes calibration measurement analog signal (VrefL / VrefH) for the group 
 ** converted by using of alternate calibration values.
 **
 ** \return              E_OK    : Analog input signal is changed correctly.
 **                      E_NOT_OK: Request is rejected.
 **
 ** \param [in] Group    Numeric ID of requested ADC channel group.
 ** \param [in] Signal   Calibration measurement analog signal.
 **                      (ADC_PIN_VREFL: VrefL / ADC_PIN_VREFH: VrefH)
 **
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_ChangeCalibrationChannel
(
  VAR(Adc_GroupType,  AUTOMATIC) Group,
  VAR(Adc_SignalType, AUTOMATIC) Signal
);

/** \brief Adc_SetCalibrationValue
 **
 ** Sets alternate calibration values for the requested ADC HwUnit.
 ** And if paramter "Update" is true, triggers updating regular calibration 
 ** values with alternate calibration values.
 **
 ** \return             E_OK    : Alternate calibration values are set correctly 
 **                               and update of regular calibration values are
 **                               triggered if necessary.
 **                     E_NOT_OK: Request is rejected.
 **
 ** \param [in] HwUnit  Numeric ID of requested ADC HwUnit.
 ** \param [in] Offset  Offset value of alternate calibration.
 ** \param [in] Gain    Gain value of alternate calibration.
 ** \param [in] Update  Flag indicates whether to update regular calibration values with 
 **                     alternate calibration values or not.
 **                     -TRUE : trigger updating of regular calibration values.
 **                     -FALSE: not trigger updating.
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_SetCalibrationValue
(
  VAR(Adc_HwUnitType,      AUTOMATIC) HwUnit,
  VAR(Adc_OffsetValueType, AUTOMATIC) Offset,
  VAR(Adc_GainValueType,   AUTOMATIC) Gain,
  VAR(boolean,             AUTOMATIC) Update
);

/** \brief Adc_GetCalibrationAlternateValue
 **
 ** Gets alternate calibration values of the requested ADC HwUnit.
 **
 ** \return                 E_OK    : Alternate calibration values are read correctly.
 **                         E_NOT_OK: Request is rejected.
 **
 ** \param [in]  HwUnit     Numeric ID of requested ADC HwUnit.
 ** \param [out] OffsetPtr  Buffer pointer stored offset value of alternate calibration.
 ** \param [out] GainPtr    Buffer pointer stored gain value of alternate calibration.
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_GetCalibrationAlternateValue
(
  VAR(Adc_HwUnitType, AUTOMATIC)                       HwUnit,
  P2VAR(Adc_OffsetValueType, AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,   AUTOMATIC, ADC_APPL_DATA) GainPtr
);

/** \brief Adc_GetCalibrationValue
 **
 ** Gets regular calibration values of the requested ADC HwUnit.
 **
 ** \return                 E_OK    : Regular calibration values are read correctly.
 **                         E_NOT_OK: Request is rejected.
 **
 ** \param [in]  HwUnit     Numeric ID of requested ADC HwUnit.
 ** \param [out] OffsetPtr  Buffer pointer stored offset value of regular calibration.
 ** \param [out] GainPtr    Buffer pointer stored gain value of regular calibration.
 */
extern FUNC(Std_ReturnType, ADC_CODE) Adc_GetCalibrationValue
(
  VAR(Adc_HwUnitType, AUTOMATIC)                       HwUnit,
  P2VAR(Adc_OffsetValueType, AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,   AUTOMATIC, ADC_APPL_DATA) GainPtr
);
#endif /* #if ( ADC_CALIBRATION_API == STD_ON ) */

#define ADC_STOP_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /*!defined(ADC_H_INCLUDED)*/

/*==================[end of file]===========================================*/

