/** \brief AUTOSAR Adc Driver
 **
 ** This file contains the declaration of the AUTOSAR module Adc types
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef ADC_TYPES_H_INCLUDED
#define ADC_TYPES_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Std_Types.h>   /* AUTOSAR standard types */

/*==================[macros]================================================*/

/** \brief definition for Adc_ChannelType */
#define ADC_PIN_AN0      ( (uint8)0U )  /* AN0 */
#define ADC_PIN_AN1      ( (uint8)1U )  /* AN1 */
#define ADC_PIN_AN2      ( (uint8)2U )  /* AN2 */
#define ADC_PIN_AN3      ( (uint8)3U )  /* AN3 */
#define ADC_PIN_AN4      ( (uint8)4U )  /* AN4 */
#define ADC_PIN_AN5      ( (uint8)5U )  /* AN5 */
#define ADC_PIN_AN6      ( (uint8)6U )  /* AN6 */
#define ADC_PIN_AN7      ( (uint8)7U )  /* AN7 */
#define ADC_PIN_AN8      ( (uint8)8U )  /* AN8 */
#define ADC_PIN_AN9      ( (uint8)9U )  /* AN9 */
#define ADC_PIN_AN10     ( (uint8)10U ) /* AN10 */
#define ADC_PIN_AN11     ( (uint8)11U ) /* AN11 */
#define ADC_PIN_AN12     ( (uint8)12U ) /* AN12 */
#define ADC_PIN_AN13     ( (uint8)13U ) /* AN13 */
#define ADC_PIN_AN14     ( (uint8)14U ) /* AN14 */
#define ADC_PIN_AN15     ( (uint8)15U ) /* AN15 */
#define ADC_PIN_AN16     ( (uint8)16U ) /* AN16 */
#define ADC_PIN_AN17     ( (uint8)17U ) /* AN17 */
#define ADC_PIN_AN18     ( (uint8)18U ) /* AN18 */
#define ADC_PIN_AN19     ( (uint8)19U ) /* AN19 */
#define ADC_PIN_AN20     ( (uint8)20U ) /* AN20 */
#define ADC_PIN_AN21     ( (uint8)21U ) /* AN21 */
#define ADC_PIN_AN22     ( (uint8)22U ) /* AN22 */
#define ADC_PIN_AN23     ( (uint8)23U ) /* AN23 */
#define ADC_PIN_AN24     ( (uint8)24U ) /* AN24 */
#define ADC_PIN_AN25     ( (uint8)25U ) /* AN25 */
#define ADC_PIN_AN26     ( (uint8)26U ) /* AN26 */
#define ADC_PIN_AN27     ( (uint8)27U ) /* AN27 */
#define ADC_PIN_AN28     ( (uint8)28U ) /* AN28 */
#define ADC_PIN_AN29     ( (uint8)29U ) /* AN29 */
#define ADC_PIN_AN30     ( (uint8)30U ) /* AN30 */
#define ADC_PIN_AN31     ( (uint8)31U ) /* AN31 */
#define ADC_PIN_VMOTOR   ( (uint8)32U ) /* Vmotor */
#define ADC_PIN_VAUX     ( (uint8)33U ) /* Vaux */
#define ADC_PIN_AMUXBUSA ( (uint8)34U ) /* AmuxbusA */
#define ADC_PIN_AMUXBUSB ( (uint8)35U ) /* AmuxbusB */
#define ADC_PIN_VCCD     ( (uint8)36U ) /* Vccd */
#define ADC_PIN_VDDA     ( (uint8)37U ) /* Vdda */
#define ADC_PIN_VBG      ( (uint8)38U ) /* Vbg */
#define ADC_PIN_VTEMP    ( (uint8)39U ) /* Vtemp */
#define ADC_PIN_VREFL    ( (uint8)62U ) /* Vrefl */
#define ADC_PIN_VREFH    ( (uint8)63U ) /* Vrefh */

/** \brief definition for Adc_SamplingModeType */
#define ADC_SAMPLE_NORMAL      ( (uint8)0x00U ) /* PRECOND_MODE=OFF,   OVERLAP_DIAG=OFF */
#define ADC_SAMPLE_NORMAL_HALF ( (uint8)0x40U ) /* PRECOND_MODE=OFF,   OVERLAP_DIAG=HALF */
#define ADC_SAMPLE_NORMAL_FULL ( (uint8)0x80U ) /* PRECOND_MODE=OFF,   OVERLAP_DIAG=FULL */
#define ADC_SAMPLE_NORMAL_MUX  ( (uint8)0xC0U ) /* PRECOND_MODE=OFF,   OVERLAP_DIAG=MUX_DIAG */
#define ADC_SAMPLE_VREFL       ( (uint8)0x10U ) /* PRECOND_MODE=VREFL, OVERLAP_DIAG=OFF */
#define ADC_SAMPLE_VREFL_HALF  ( (uint8)0x50U ) /* PRECOND_MODE=VREFL, OVERLAP_DIAG=HALF */
#define ADC_SAMPLE_VREFL_FULL  ( (uint8)0x90U ) /* PRECOND_MODE=VREFL, OVERLAP_DIAG=FULL */
#define ADC_SAMPLE_VREFL_MUX   ( (uint8)0xD0U ) /* PRECOND_MODE=VREFL, OVERLAP_DIAG=MUX_DIAG */
#define ADC_SAMPLE_VREFH       ( (uint8)0x20U ) /* PRECOND_MODE=VREFH, OVERLAP_DIAG=OFF */
#define ADC_SAMPLE_VREFH_HALF  ( (uint8)0x60U ) /* PRECOND_MODE=VREFH, OVERLAP_DIAG=HALF */
#define ADC_SAMPLE_VREFH_FULL  ( (uint8)0xA0U ) /* PRECOND_MODE=VREFH, OVERLAP_DIAG=FULL */
#define ADC_SAMPLE_VREFH_MUX   ( (uint8)0xE0U ) /* PRECOND_MODE=VREFH, OVERLAP_DIAG=MUX_DIAG */
#define ADC_SAMPLE_DIAG        ( (uint8)0x30U ) /* PRECOND_MODE=DIAG,  OVERLAP_DIAG=OFF */
#define ADC_SAMPLE_DIAG_MUX    ( (uint8)0xF0U ) /* PRECOND_MODE=DIAG,  OVERLAP_DIAG=MUX_DIAG */

/** \brief definition for Adc_DiagnosticEnabledType */
#define ADC_DIAG_DISABLED    ( (uint8)0x00 ) /* Diagnostic disabled */
#define ADC_DIAG_ENABLED     ( (uint8)0x80 ) /* Diagnostic enabled */

/** \brief definition for Adc_DiagnosticReferenceType */
#define ADC_DIAG_VREFL       ( (uint8)0x00 ) /* VREFL */
#define ADC_DIAG_VREFH_1DIV8 ( (uint8)0x01 ) /* VREFH_1DIV8 */
#define ADC_DIAG_VREFH_2DIV8 ( (uint8)0x02 ) /* VREFH_2DIV8 */
#define ADC_DIAG_VREFH_3DIV8 ( (uint8)0x03 ) /* VREFH_3DIV8 */
#define ADC_DIAG_VREFH_4DIV8 ( (uint8)0x04 ) /* VREFH_4DIV8 */
#define ADC_DIAG_VREFH_5DIV8 ( (uint8)0x05 ) /* VREFH_5DIV8 */
#define ADC_DIAG_VREFH_6DIV8 ( (uint8)0x06 ) /* VREFH_6DIV8 */
#define ADC_DIAG_VREFH_7DIV8 ( (uint8)0x07 ) /* VREFH_7DIV8 */
#define ADC_DIAG_VREFH       ( (uint8)0x08 ) /* VREFH */
#define ADC_DIAG_VREFX       ( (uint8)0x09 ) /* VREFX */
#define ADC_DIAG_VBG         ( (uint8)0x0A ) /* VBG */
#define ADC_DIAG_VIN1        ( (uint8)0x0B ) /* VIN1 */
#define ADC_DIAG_VIN2        ( (uint8)0x0C ) /* VIN2 */
#define ADC_DIAG_VIN3        ( (uint8)0x0D ) /* VIN3 */
#define ADC_DIAG_I_SOURCE    ( (uint8)0x0E ) /* I_SOURCE */
#define ADC_DIAG_I_SINK      ( (uint8)0x0F ) /* I_SINK */

/** \brief definition of generic trigger output number of SAR_TR_OUT_SEL */
#define ADC_OUT0_SEL         ( 0U )     /* Generic trigger output 0      */
#define ADC_OUT1_SEL         ( 1U )     /* Generic trigger output 1      */
#define ADC_INVALID_SEL      ( 255U )   /* Unused generic output trigger */

/*==================[type definitions]======================================*/


/** \brief struct Adc_dmaDescriptorType
 **
 ** This type is used to store Descriptor data.
 ** This DMA Descriptor size is 32byte.
 */
typedef struct adc_dmadescriptortype_struct
{
  VAR(uint32, TYPEDEF)  DescData[8];   /* Descriptor data */
} Adc_DmaDescriptorType;

/** \brief struct Adc_DmaChannelConfigType
 **
 ** Data structure containing the set of DMA channel configuration.
 */
typedef struct adc_dmachannelconfigtype_struct
{
  /* Base address of the register set associated to the DMA channel. */
  CONST(uint32, TYPEDEF)                               RegisterBase;
  /* Address of Descriptor used by DMA */
  CONSTP2VAR(Adc_DmaDescriptorType, TYPEDEF, ADC_APPL_DATA)  DescriptorBasePtr;
  /* Used generic trigger output of SAR_TR_OUT_SEL */
  CONST(uint8, TYPEDEF)                                SarTrOutNum;
}Adc_DmaChannelConfigType;

/** \brief struct Adc_DmaConfigType
 **
 ** Data structure containing the set of global DMA configuration.
 */
typedef struct adc_dmaconfigtype_struct
{
  /* A pointer to a head of DMA channel config */
  CONSTP2CONST(Adc_DmaChannelConfigType, TYPEDEF, ADC_APPL_CONST) DmaChannelConfigPtr;
  /* Number of the array of Dma channel config. */
  CONST(uint8, TYPEDEF)                                    DmaChannelsNumber;
}Adc_DmaConfigType;

/** \brief type definition for the ADC hardware unit ID
 **
 ** This type stores the hardware unit ID in an uint8 resulting in
 ** 256 maximum number of hardware units.
 */
typedef uint8 Adc_HwUnitType;

/** \brief typedef Adc_VoidFctPtrType
 **
 ** Type definition of a void function pointer. 
 */
typedef P2FUNC(void, TYPEDEF, Adc_VoidFctPtrType)(void);

/** \brief typedef Adc_ChannelType
 **
 ** Numeric ID of a physical ADC channel.
 ** Range: 0..39 
 */
typedef uint16 Adc_ChannelType;

/** \brief typedef Adc_SarMuxType
 **
 ** Numeric ID of a physical port.
 ** Range: 0..3 
 */
typedef uint8 Adc_SarMuxType;

/** \brief typedef  Adc_GroupType
 **
 ** Numeric ID of an ADC channel group.
 */
typedef uint16 Adc_GroupType;

/** \brief typedef  Adc_GroupPriorityType
 **
 ** Priority level of a group (as to be configured in HW). Highest priority is 0.
 ** Range: 0..7 
 */
typedef uint8 Adc_GroupPriorityType;

/** \brief typedef  Adc_ValueGroupType
 **
 ** Type for reading the converted values of a channel group (raw, without further
 ** scaling, alignment according precompile switch ADC_RESULT_ALIGNMENT).
 */
typedef uint16 Adc_ValueGroupType;

/** \brief typedef  Adc_StreamNumSampleType
 **
 ** Type for configuring the number of group conversions in streaming access mode
 ** (in single access mode, parameter is 1). 
 */
typedef uint16 Adc_StreamNumSampleType;

/** \brief enum Adc_StatusType
 **
 ** Current status of the conversion of the requested ADC Channel group.
 */
typedef enum adc_statustype_enum
{
  ADC_IDLE,
  ADC_BUSY,
  ADC_COMPLETED,
  ADC_STREAM_COMPLETED,
  ADC_ERROR
} Adc_StatusType;

/** \brief enum Adc_TriggerSourceType
 **
 ** Type for configuring the trigger source for an ADC Channel group.
 */
typedef enum adc_triggersourcetype_enum
{
  ADC_TRIGG_SRC_SW,
  ADC_TRIGG_SRC_HW
} Adc_TriggerSourceType;

/** \brief enum Adc_GroupConvModeType
 **
 ** Type for configuring the conversion mode of an ADC Channel group.
 */
typedef enum adc_groupconvmodetype_enum
{
  ADC_CONV_MODE_ONESHOT,
  ADC_CONV_MODE_CONTINUOUS
} Adc_GroupConvModeType;

/** \brief enum Adc_GroupAccessModeType
 **
 ** Type for configuring the access mode to group conversion results.
 */
typedef enum adc_groupaccessmodetype_enum
{
  ADC_ACCESS_MODE_SINGLE,
  ADC_ACCESS_MODE_STREAMING
} Adc_GroupAccessModeType;

/** \brief enum Adc_StreamBufferModeType
 **
 ** Type for configuring the streaming access mode buffer type.
 */
typedef enum adc_streambuffermodetype_enum
{
  ADC_STREAM_BUFFER_LINEAR,
  ADC_STREAM_BUFFER_CIRCULAR
} Adc_StreamBufferModeType;

/** \brief enum Adc_ResultAlignmentType
 **
 ** Type for alignment (left/right alignment) of ADC raw results. Adc_ReadGroup and
 ** the stream handling will obey this setting.
 */
typedef enum adc_resultalignmenttype_enum
{
  ADC_ALIGN_LEFT,
  ADC_ALIGN_RIGHT
} Adc_ResultAlignmentType;

/** \brief enum Adc_GroupReplacementType
 **
 ** Replacement mechanism, which is used on ADC group level, if a group conversion
 ** is interrupted by a group which has a higher priority.
 */
typedef enum adc_groupreplacementtype_enum
{
  ADC_GROUP_REPL_ABORT_RESTART = 1U,
  ADC_GROUP_REPL_ABORT_RESUME,
  ADC_GROUP_REPL_SUSPEND_RESUME
} Adc_GroupReplacementType;

/** \brief typedef Adc_ConversionTimeType
 **
 ** Type of conversion time,
 ** i.e. the time during which the sampled analogue value is
 ** converted into digital representation.
 */
typedef uint8 Adc_ConversionTimeType;

/** \brief typedef Adc_SamplingTimeType
 **
 ** Type of sampling time,
 ** i.e. the time during which the value is sampled, (in clock-cycles).
 */
typedef uint16 Adc_SamplingTimeType;

/** \brief typedef Adc_SamplingModeType
 **
 ** Type for configuring the sampling mode for an ADC Channel group.
 */
typedef uint8 Adc_SamplingModeType;

/** \brief typedef Adc_DiagReferenceType
 **
 ** Type for configuring the diagnostic reference for a HwUnit(SAR).
 */
typedef uint8 Adc_DiagReferenceType;

/** \brief typedef Adc_PrecondCycleType
 **
 ** Type for configuring the precondition cycle for a HwUnit(SAR).
 */
typedef uint8 Adc_PrecondCycleType;

/** \brief typedef Adc_OffsetValueType
 **
 ** Type for Offset correction setting value for a HwUnit(SAR).
 */
typedef sint8 Adc_OffsetValueType;

/** \brief typedef Adc_GainValueType
 **
 ** Type for Gain correction setting value for a HwUnit(SAR).
 */
typedef sint8 Adc_GainValueType;

/** \brief typedef Adc_SignalType
 **
 ** Type for input analog signal.
 */
typedef uint8 Adc_SignalType;

/** \brief enum Adc_GroupHwTriggSrcType
 **
 ** Type for specifying which hardware trigger is used.
 */
typedef enum adc_grouphwtriggsrctype_enum
{
  ADC_HWTRIGG_SRC_OFF,
  ADC_HWTRIGG_SRC_TCPWM,
  ADC_HWTRIGG_SRC_GENERIC0,
  ADC_HWTRIGG_SRC_GENERIC1,
  ADC_HWTRIGG_SRC_GENERIC2,
  ADC_HWTRIGG_SRC_GENERIC3,
  ADC_HWTRIGG_SRC_GENERIC4,
  ADC_HWTRIGG_SRC_CONTINUOUS
} Adc_GroupHwTriggSrcType;

/** \brief enum Adc_PowerStateRequestResultType
 **
 ** Type for result of the requests related to power state transitions.
 */
typedef enum adc_pwerstaterequestresulttype_enum
{
  ADC_SERVICE_ACCEPTED,     /* Power state change executed. */
  ADC_NOT_INIT,             /* ADC Module not initialized. */
  ADC_SEQUENCE_ERROR,       /* Wrong API call sequence. */
  ADC_HW_FAILURE,           /* The HW module has a failure which prevents it to enter the required power state. */
  ADC_POWER_STATE_NOT_SUPP, /* ADC Module does not support the requested power state. */
  ADC_TRANS_NOT_POSSIBLE    /* ADC Module cannot transition directly from the current power 
                            state to the requested power state or the HW peripheral is still busy. */
} Adc_PowerStateRequestResultType;

/** \brief enum Adc_PowerStateType
 **
 ** Type for power state currently active or set as target power state.
 */
typedef enum adc_powerstatetype_enum
{
  ADC_FULL_POWER,    /* Full Power (0) */
  ADC_OFF_POWER     /* Off Power (1)  */
} Adc_PowerStateType;

/** \brief struct Adc_HwUnitConfigType
 **
 ** Configuration structure containing configuration items that apply to the whole
 ** HW unit.
 */
typedef struct adc_hwunitconfigtype_struct
{
  /* Base address of the register set associated to the HW unit. */
  CONST(uint32, TYPEDEF) RegisterBase;
  /* Setting value of SAR_TR_IN_SEL register */
  CONST(uint32, TYPEDEF) TriggerInputSelection;
  /* Identifier for HwUnit */
  CONST(uint8, TYPEDEF) HwUnitId;
  /* Selected diagnostic reference for a HW unit */
  CONST(Adc_DiagReferenceType, TYPEDEF) DiagReference;
  /* Precondition cycle for a HW unit */
  CONST(uint8, TYPEDEF) PrecondCycle;
  /* Determine whether diagnostic feature is enabled or disabled */
  CONST(boolean, TYPEDEF) DiagEnabled;
  /* Initial value for power control */
  CONST(uint8, TYPEDEF) PowerControlSetting;
  /* Determine whether SAR power is enabled or disabled */
  CONST(boolean, TYPEDEF) SarEnabled;
} Adc_HwUnitConfigType;

/** \brief struct Adc_ChannelConfigType
 **
 ** This type contains the configuration parameters for a physical channel.
 */
typedef struct adc_channelconfigtype_struct
{
  /* Base address of the register set associated to the HW unit for channel. */
  CONST(uint32, TYPEDEF) RegisterBase;
  /* Setting value for post_ctl register */
  CONST(uint32, TYPEDEF) PostCtrlSettingVal;
  /* Sampling cycle for an ADC channel */
  CONST(Adc_SamplingTimeType, TYPEDEF) SamplingTime;
  /* Range comparator upper threshold for an ADC channel */
  CONST(uint16, TYPEDEF) RangeComparatorUpperThreshold;
  /* Range comparator lower threshold for an ADC channel */
  CONST(uint16, TYPEDEF) RangeComparatorLowerThreshold;
  /* Index of the logical channel, i.e. one of 32 possible channels per HW unit. */
  CONST(Adc_ChannelType, TYPEDEF) LogicalChannelId;
  /* Index of the physical channel, i.e. which input signal should be converted. */
  CONST(Adc_ChannelType, TYPEDEF) PhysicalChannelId;
} Adc_ChannelConfigType;

/** \brief struct Adc_StreamInfoType
 **
 ** This type is used to store management information on one stream.
 */
typedef struct adc_streaminfotype_struct
{
  /* Index of the element that was added last time. <0 when no element was added. */
  VAR(sint32, TYPEDEF) LastPushedIndex;
  /* Pointer to the beginning of the buffer.
      The pointer will not be updated when the stream is filled. */
  P2VAR(Adc_ValueGroupType, TYPEDEF, ADC_APPL_DATA) BufferBasePtr;
  /* Number of valid elements in the stream. */
  VAR(uint8, TYPEDEF) ValidElementCount;
} Adc_StreamInfoType;

/** \brief struct Adc_GroupConfigType
 **
 ** Structure that contains the configuration for a single group.
 */
typedef struct adc_groupconfigtype_struct
{
  /* Initial value for masking interrupt */
  CONST(uint32, TYPEDEF) InterruptMaskValue;
  /* Pointer to the configuration of the used HW unit (defined in the array
   Adc_HwUnitConfigs). The referenced HW unit contains the group. */
  CONSTP2CONST(Adc_HwUnitConfigType, TYPEDEF, ADC_APPL_CONST) HwUnitConfigPtr;
  /* Pointer to the configuration of the used DMA channel. */
  CONSTP2CONST(Adc_DmaChannelConfigType, TYPEDEF, ADC_APPL_CONST) DmaChannelConfigPtr;
  /* Group notification pointer. */
  CONST(Adc_VoidFctPtrType, TYPEDEF) NotificationPtr;
  /* Pointer to an object of the array of group notification enable settings.
      The referred element contains the setting whether a notification should
      be called on group conversion completion. */
  CONSTP2VAR(boolean, TYPEDEF, ADC_APPL_DATA) NotificationEnableSettingPtr;
  /* Pointer to an object of the array of stream infos (Adc_StreamInfos).
      The referred element contains the stream info for this group. */
  CONSTP2VAR(Adc_StreamInfoType, TYPEDEF, ADC_APPL_DATA) StreamInfoPtr;
  /* Status for a channel group. */
  CONSTP2VAR(Adc_StatusType, AUTOMATIC, ADC_APPL_DATA) GroupStatusPtr;
  /* Access mode to group conversion results. */
  CONST(Adc_GroupAccessModeType, TYPEDEF) GroupAccessMode;
  /* Conversion mode of the group. */
  CONST(Adc_GroupConvModeType, TYPEDEF) GroupConvMode;
  /* Replacement mechanism, which is used on ADC group level, if a group
      conversion is interrupted by a group which has a higher priority. */
  CONST(Adc_GroupReplacementType, TYPEDEF) GroupReplacement;
  /* Streaming access mode to buffer. */
  CONST(Adc_StreamBufferModeType, TYPEDEF) StreamBufferMode;
  /* Trigger source for the group. */
  CONST(Adc_TriggerSourceType, TYPEDEF) TriggerSource;
  /* Which hardware trigger source is used. */
  CONST(Adc_GroupHwTriggSrcType, TYPEDEF) HwTriggerSource;
  /* Number of samples that can be stored for each channel within the stream.
      (I.e. length of the stream in conversion rounds.) */
  CONST(Adc_StreamNumSampleType, TYPEDEF) StreamNumSamples;
  /* Index of the config (in Adc_ChannelConfig) of the first logical channel 
   of this group. This channel will actually be triggered. */
  CONST(uint16, TYPEDEF) FirstLogicalChannelConfigIndex;
  /* Index of the config (in Adc_ChannelConfig) of the last logical channel 
   of this group. This channel will actually be triggered. */
  CONST(uint16, TYPEDEF) LastLogicalChannelConfigIndex;
  /* Sampling mode (combination of precondition and overlap) for the group. */
  CONST(Adc_SamplingModeType, TYPEDEF) SamplingMode;
  /* Number of channels of the group. */
  CONST(uint8, TYPEDEF) NumberOfChannels;
  /* Priority to set in HW register (0 is highest). */
  CONST(Adc_GroupPriorityType, TYPEDEF) GroupHwPriority;
  /* Either interrupt or polling mode is used. */
  CONST(boolean, TYPEDEF) InterruptMode;
  /* DMA in a group is used or not. */
  CONST(boolean, TYPEDEF) UseDma;
  /* Alternate calibration values are used or not. */
  CONST(boolean, TYPEDEF) UseAlternateCalibration;
} Adc_GroupConfigType;

/** \brief struct Adc_ConfigType
 **
 ** Data structure containing the set of configuration parameters required for
 ** initializing the ADC Driver and ADC HW Unit(s).
 */
typedef struct adc_configtype_struct
{
  /* A pointer to a head of Channel config */
  CONSTP2CONST(Adc_ChannelConfigType, TYPEDEF, ADC_APPL_CONST) ChannelConfigPtr;
  /* A pointer to a head of Group config */
  CONSTP2CONST(Adc_GroupConfigType, TYPEDEF, ADC_APPL_CONST)   GroupConfigPtr;
  /* A pointer to a head of HwUnit config */
  CONSTP2CONST(Adc_HwUnitConfigType, TYPEDEF, ADC_APPL_CONST)  HwUnitConfigPtr;
  /* A pointer to DMA config */
  CONSTP2CONST(Adc_DmaConfigType, TYPEDEF, ADC_APPL_CONST)     DmaConfigPtr;
  /* A pointer to Group Id location data */
  CONSTP2CONST(Adc_GroupType, TYPEDEF, ADC_APPL_CONST)         GroupIdLocationPtr;
  /* Number of the array of Group config. */
  CONST(uint8, TYPEDEF) GroupConfigsNumber;
  /* Number of the array of HwUnit config. */
  CONST(uint8, TYPEDEF) HwUnitConfigsNumber;
  /* Number of the array of Dma HwUnit config. */
  CONST(uint8, TYPEDEF) DmaHwUnitConfigsNumber;
  /* Initial value for Pass control */
  CONST(uint32, TYPEDEF) PassControlSetting;
} Adc_ConfigType;

/** \brief enum Adc_ChannelRangeSelectType
 **
 ** Type for which conversion values are taken into account.
 */
typedef enum adc_channelrangeselecttype_enum
{
  ADC_RANGE_UNDER_LOW,     /* Range below low limit - low limit value included. */
  ADC_RANGE_BETWEEN,       /* Range between low limit and high limit - high limit value included. */
  ADC_RANGE_OVER_HIGH,     /* Range above high limit. */
  ADC_RANGE_ALWAYS,        /* Complete range - independent from channel limit settings. */
  ADC_RANGE_NOT_UNDER_LOW, /* Range above low limit. */
  ADC_RANGE_NOT_BETWEEN,   /* Range above high limit or below low limit - low limit value included. */
  ADC_RANGE_NOT_OVER_HIGH  /* Range below high limit - high limit value included. */
} Adc_ChannelRangeSelectType;

/** \brief enum Adc_HwTriggerSignalType
 **
 ** Type for configuring on which edge of the hardware trigger signal the driver should react.
 */
typedef enum adc_hwtriggersignaltype_enum
{
  ADC_HW_TRIG_RISING_EDGE,  /* React on the rising edge of the hardware trigger signal. */
  ADC_HW_TRIG_FALLING_EDGE, /* React on the falling edge of the hardware trigger signal. */
  ADC_HW_TRIG_BOTH_EDGES    /* React on both edges of the hardware trigger signal. */
} Adc_HwTriggerSignalType;

/** \brief typedef Adc_HwTriggerTimerType
 **
 ** Type for the reload value of the ADC module embedded timer.
 */
typedef uint32 Adc_HwTriggerTimerType;

/** \brief enum Adc_PriorityImplementationType
 **
 ** Type for configuring the prioritization mechanism. 
 */
typedef enum adc_priorityimplementationtype_enum
{
  ADC_PRIORITY_NONE,  /* Priority mechanism is not available. */
  ADC_PRIORITY_HW,    /* Hardware priority mechanism is available only. */
  ADC_PRIORITY_HW_SW  /* Hardware and software priority mechanism is available. */
} Adc_PriorityImplementationType;

/** \brief typedef Adc_ResolutionType
 **
 ** Type of channel resolution in number of bits.
 */
typedef uint8 Adc_ResolutionType;

/** \brief typedef Adc_PrescaleType
 **
 ** Type of clock prescaler factor.
 */
typedef uint32 Adc_PrescaleType;

/** \brief typedef Adc_GroupDefType
 **
 ** Type for assignment of channels to a channel group.
 */
typedef uint32 Adc_GroupDefType;

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/


#endif /*!defined(ADC_TYPES_H_INCLUDED)*/

/*==================[end of file]===========================================*/
