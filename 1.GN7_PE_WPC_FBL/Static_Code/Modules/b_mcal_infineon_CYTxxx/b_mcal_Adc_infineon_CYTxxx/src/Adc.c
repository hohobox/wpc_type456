/** \brief AUTOSAR Adc Driver
 **
 ** This file contains the implementation of the AUTOSAR module Adc
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Adc.h>                 /* Module public declaration       */
#include <Adc_Data.h>            /* Module data declaration         */
#include <Adc_Internal.h>        /* Module internal declaration     */
#include <SchM_Adc.h>            /* Schedule Manager for Adc module */
#include <Adc_ExternalInclude.h> /* External include file           */

#if ADC_DEV_ERROR_DETECT == STD_ON
#include <Det.h>          /* DET declarations */
#endif  /* #if ADC_DEV_ERROR_DETECT == STD_ON */

#ifdef ADC_E_HARDWARE_ERROR
#include <Dem.h>          /* DEM declarations */
#endif  /* #ifdef ADC_E_HARDWARE_ERROR        */

/*==================[macros]================================================*/

/*------------------[AUTOSAR AR version number check]-----------------------*/

#if !ADC_AR_VERSION_CHECK( 4U, 2U, 2U )
#  error AUTOSAR AR version number mismatch
#endif

/*------------------[AUTOSAR SW version number check]-----------------------*/

#if !ADC_SW_VERSION_CHECK( 1U, 14U, 0U )
#  error AUTOSAR SW version number mismatch
#endif

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ADC_START_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

/** \brief Adc_ReportError
 **
 ** Reports an error to the error handler and optionally to the DET.
 **
 ** \param [in] ApiId     Id of the service that detected the error.
 ** \param [in] ErrorId   Id of the error that was detected.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReportError
(
  VAR(uint8, AUTOMATIC) ApiId,
  VAR(uint8, AUTOMATIC) ErrorId
);

/** \brief Adc_DemReportEvent
 **
 ** Reports an error to the error handler and optionally to the DEM.
 **
 ** \param [in] ApiId        Id of the service that detected the error.
 ** \param [in] EventId      Id of the event code that was detected.
 ** \param [in] EventStatus  Status of event.
 **
 */
static FUNC(void, ADC_CODE) Adc_DemReportEvent
(
  VAR(uint8, AUTOMATIC)   ApiId,
  VAR(uint8, AUTOMATIC)   EventId,
  VAR(boolean, AUTOMATIC) EventStatus
);

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define ADC_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

#if ( ADC_DEINIT_API == STD_ON )
/** \brief Adc_DeInit
 **
 ** Returns all ADC HW Units to a state comparable to their power on reset state.
 **
 */
FUNC(void, ADC_CODE) Adc_DeInit(void)
{
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) configPtr;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_DEINIT, ADC_E_UNINIT);
  }
  else
  {
    /* Enter critical section. */
    Adc_EnterCriticalSection();

    /* Check if any group is in state running. */
    if (Adc_IsAllTriggerEnabled() != FALSE)
    {
      /* Exit critical section. */
      Adc_ExitCriticalSection();

      /* Report an error. */
      Adc_ReportError(ADC_API_DEINIT, ADC_E_BUSY);
    }
    else
    {
      /* Get a pointer to current configuration setting. */
      configPtr = Adc_GetConfig();

      /* Initialize DMA hardware. */
      Adc_InitDma(configPtr);

      /* De-initialize ADC hardware. */
      Adc_DeInitHw(configPtr);

      /* Set configuration global pointer to NULL. */
      Adc_SetConfigData(NULL_PTR);

      /* Exit critical section. */
      Adc_ExitCriticalSection();
    }
  }
}
#endif/* #if ( ADC_DEINIT_API == STD_ON ) */

#if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON )
/** \brief Adc_DisableGroupNotification
 **
 ** Disables the notification mechanism for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(void, ADC_CODE) Adc_DisableGroupNotification
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_DISABLE_GROUP_NOTIFICATION, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_DISABLE_GROUP_NOTIFICATION, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Check if given group has a valid notification pointer. */
      if (groupConfigPtr->NotificationPtr == NULL_PTR)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_DISABLE_GROUP_NOTIFICATION, ADC_E_NOTIF_CAPABILITY);
      }
      else
      {
        /* Disable group notification. */
        Adc_SetGroupNotification(groupConfigPtr, FALSE);
      }
    }
  }
}
#endif /*#if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON )*/

#if ( ADC_HW_TRIGGER_API == STD_ON )
/** \brief Adc_DisableHardwareTrigger
 **
 ** Disables the hardware trigger for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(void, ADC_CODE) Adc_DisableHardwareTrigger
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType groupStatus;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_DISABLE_HARDWARE_TRIGGER, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_DISABLE_HARDWARE_TRIGGER, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Invalid trigger source */
      if (groupConfigPtr->TriggerSource != ADC_TRIGG_SRC_HW)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_DISABLE_HARDWARE_TRIGGER, ADC_E_WRONG_TRIGG_SRC);
      }
      /* Invalid conversion mode */
      else if (groupConfigPtr->GroupConvMode != ADC_CONV_MODE_ONESHOT)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_DISABLE_HARDWARE_TRIGGER, ADC_E_WRONG_CONV_MODE);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Get the group status. */
        groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

        /* Check if given group is currently in status ADC_IDLE. */
        if (groupStatus == ADC_IDLE)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_DISABLE_HARDWARE_TRIGGER, ADC_E_IDLE);
        }
        else
        {
          /* Automatically disable group notification. */
          Adc_SetGroupNotification(groupConfigPtr, FALSE);

          /* Disable ADC channel group. */
          Adc_SetChannelEnable(groupConfigPtr, FALSE);

          /* When DMA is disabled in polling mode,
             this function may be called during interrupt flag is still set.
             In this case, the interrupt flag must be cleared here. */
          Adc_ClearChannelInterrupt(groupConfigPtr->LastLogicalChannelConfigIndex);

          /* Update the channel group status to ADC_IDLE. */
          *(groupConfigPtr->GroupStatusPtr) = ADC_IDLE;

          /* Exit critical section. */
          Adc_ExitCriticalSection();
        }
      }
    }
  }
}
#endif /* #if ( ADC_HW_TRIGGER_API == STD_ON ) */

#if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON )
/** \brief Adc_EnableGroupNotification
 **
 ** Enables the notification mechanism for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(void, ADC_CODE) Adc_EnableGroupNotification
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_ENABLE_GROUP_NOTIFICATION, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_ENABLE_GROUP_NOTIFICATION, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Check if given group has a valid notification pointer. */
      if (groupConfigPtr->NotificationPtr == NULL_PTR)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_ENABLE_GROUP_NOTIFICATION, ADC_E_NOTIF_CAPABILITY);
      }
      else
      {
        /* Enable group notification. */
        Adc_SetGroupNotification(groupConfigPtr, TRUE);
      }
    }
  }
}
#endif /* #if ( ADC_GRP_NOTIF_CAPABILITY == STD_ON ) */

#if ( ADC_HW_TRIGGER_API == STD_ON )
/** \brief Adc_EnableHardwareTrigger
 **
 ** Enables the hardware trigger for the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(void, ADC_CODE) Adc_EnableHardwareTrigger
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  boolean isHwTriggerEnabled;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_ENABLE_HARDWARE_TRIGGER, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_ENABLE_HARDWARE_TRIGGER, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Invalid trigger source */
      if (groupConfigPtr->TriggerSource != ADC_TRIGG_SRC_HW)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_ENABLE_HARDWARE_TRIGGER, ADC_E_WRONG_TRIGG_SRC);
      }
      /* Invalid conversion mode */
      else if (groupConfigPtr->GroupConvMode != ADC_CONV_MODE_ONESHOT)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_ENABLE_HARDWARE_TRIGGER, ADC_E_WRONG_CONV_MODE);
      }
      /* Streaming buffer is un-initialized. */
      else if (groupConfigPtr->StreamInfoPtr->BufferBasePtr == NULL_PTR)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_ENABLE_HARDWARE_TRIGGER, ADC_E_BUFFER_UNINIT);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* HW trigger is enabled for this group. */
        isHwTriggerEnabled = Adc_IsHwTriggerEnabled(groupConfigPtr);
        if (isHwTriggerEnabled == FALSE)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_ENABLE_HARDWARE_TRIGGER, ADC_E_BUSY);
        }
        else
        {
          /* Enable ADC channel group. */
          Adc_SetChannelEnable(groupConfigPtr, TRUE);

          /* Update the channel group status to ADC_BUSY. */
          *(groupConfigPtr->GroupStatusPtr) = ADC_BUSY;

          /* Reset stream indices. */
          groupConfigPtr->StreamInfoPtr->LastPushedIndex   = -1;
          groupConfigPtr->StreamInfoPtr->ValidElementCount = 0U;

          /* Exit critical section. */
          Adc_ExitCriticalSection();
        }
      }
    }
  }
}
#endif /* #if ( ADC_HW_TRIGGER_API == STD_ON ) */

/** \brief Adc_GetGroupStatus
 **
 ** Returns the conversion status of the requested ADC Channel group.
 **
 ** \return             Conversion status for the requested group.
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(Adc_StatusType, ADC_CODE) Adc_GetGroupStatus
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType result = ADC_IDLE;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_GROUP_STATUS, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_GET_GROUP_STATUS, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Enter critical section. */
      Adc_EnterCriticalSection();

      /* Actually perform the required task. */
      result = Adc_GetGroupStatusInternal(groupConfigPtr);

      /* Exit critical section. */
      Adc_ExitCriticalSection();

      /* Check if DMA is used. */
      if (groupConfigPtr->UseDma == TRUE)
      {
        /* Report to DEM. */
        if (result != ADC_ERROR)
        {
          Adc_DemReportEvent(ADC_API_GET_GROUP_STATUS, ADC_E_HARDWARE_ERROR_FOR_CALLOUT, TRUE);
        }
        else
        {
          Adc_DemReportEvent(ADC_API_GET_GROUP_STATUS, ADC_E_HARDWARE_ERROR_FOR_CALLOUT, FALSE);
        }
      }
    }
  }
  return result;
}

/** \brief Adc_GetStreamLastPointer
 **
 ** Returns the number of valid samples per channel, stored in the result buffer.
 ** Reads a pointer, pointing to a position in the group result buffer. With the
 ** pointer position, the results of all group channels of the last completed
 ** conversion round can be accessed.
 ** With the pointer and the return value, all valid group conversion results can
 ** be accessed (the user has to take the layout of the result buffer into account).
 **
 ** \return                       Number of valid samples per channel.
 ** \param [in] Group             Numeric ID of requested ADC Channel group.
 ** \param [out] PtrToSamplePtr   Pointer to result buffer pointer.
 **
 */
FUNC(Adc_StreamNumSampleType, ADC_CODE) Adc_GetStreamLastPointer
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  P2VAR(P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA), AUTOMATIC, ADC_APPL_DATA) PtrToSamplePtr
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType          groupStatus;
  Adc_StreamNumSampleType result = 0U;

  /* Check if parameter 'PtrToSamplePtr' is invalid. */
  if (PtrToSamplePtr == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_STREAM_LAST_POINTER, ADC_E_PARAM_POINTER);
  }
  else
  {
    *PtrToSamplePtr = NULL_PTR;

    /* Check if driver is initialized. */
    if (Adc_CheckConfigPtr() != TRUE)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_GET_STREAM_LAST_POINTER, ADC_E_UNINIT);
    }
    else
    {
      /* Get the group config pointer. */
      groupConfigPtr = Adc_GetGroupConfig(Group);

      /* Check if parameter 'Group' is valid. */
      if (groupConfigPtr == NULL_PTR)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_GET_STREAM_LAST_POINTER, ADC_E_PARAM_GROUP);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Get the group status. */
        groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

        /* Check if group is currently in status ADC_IDLE. */
        if (groupStatus == ADC_IDLE)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_GET_STREAM_LAST_POINTER, ADC_E_IDLE);
        }
        /* Check if group is currently in status ADC_ERROR. */
        else if (groupStatus == ADC_ERROR)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_GET_STREAM_LAST_POINTER, ADC_E_CONVERSION_ERROR);
        }
        else
        {
          if (groupStatus != ADC_BUSY)
          {
            /* Call an internal function. */
            result = Adc_GetStreamLastPointerInternal(
                       groupConfigPtr,
                       groupStatus,
                       PtrToSamplePtr
                     );
          }
          /* Exit critical section. */
          Adc_ExitCriticalSection();
        }
      }
    }
  }

  return result;
}

#if ( ADC_VERSION_INFO_API == STD_ON )
/** \brief Adc_GetVersionInfo
 **
 ** Returns the version information of this module.
 **
 ** \param [out] versioninfo   Pointer to where to store the version information of
 **                             this module.
 **
 */
FUNC(void, ADC_CODE) Adc_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, ADC_APPL_DATA) versioninfo
)
{
  /* Check if parameter is valid. */
  if (versioninfo == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_VERSION_INFO, ADC_E_PARAM_POINTER);
  }
  else
  {
    versioninfo->vendorID         = ADC_VENDOR_ID;
    versioninfo->moduleID         = ADC_MODULE_ID;
    versioninfo->sw_major_version = ADC_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = ADC_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = ADC_SW_PATCH_VERSION;
  }
}
#endif /* #if ( ADC_VERSION_INFO_API == STD_ON ) */

/** \brief Adc_Init
 **
 ** Initializes the ADC hardware units and driver.
 **
 ** \param [in] ConfigPtr   Pointer to configuration set.
 */
FUNC(void, ADC_CODE) Adc_Init
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
)
{
  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() == TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_INIT, ADC_E_ALREADY_INITIALIZED);
  }
  else
  {
    /* Check if parameter pointer is valid. */
    if (Adc_CheckParamConfigPtr(ConfigPtr) != TRUE)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_INIT, ADC_E_PARAM_CONFIG);
    }
    /* Actually perform the required task. */
    else
    {
      /* Initialize DMA hardware. */
      Adc_InitDma(ConfigPtr);

      /* Initialize ADC hardware. */
      Adc_InitHw(ConfigPtr);

      /* Set target power state. */
      Adc_SetTargetPowerStateInternal(ADC_FULL_POWER);

      /* Hold the passed pointer to internal variable. */
      Adc_SetConfigData(ConfigPtr); 
    }
  }
}

#if ( ADC_READ_GROUP_API == STD_ON )
/** \brief Adc_ReadGroup
 **
 ** Reads the group conversion result of the last completed conversion round of
 ** the requested group and stores the channel values starting at the DataBufferPtr
 ** address. The group channel values are stored in ascending channel number order
 ** (in contrast to the storage layout of the result buffer if streaming access is
 ** configured).
 **
 ** \return                     E_OK    :  results are available and written to the data buffer.
 **                             E_NOT_OK:  no results are available or development error occurred.
 **
 ** \param [in] Group           Numeric ID of requested ADC channel group.
 ** \param [in] DataBufferPtr   ADC results of all channels of the selected group
 **                              are stored in the data buffer addressed with the pointer.
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_ReadGroup
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) DataBufferPtr
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType groupStatus;
  Std_ReturnType result = E_NOT_OK;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_READ_GROUP, ADC_E_UNINIT);
  }
  /* Check if parameter 'DataBufferPtr' is valid. */
  else if (DataBufferPtr == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_READ_GROUP, ADC_E_PARAM_POINTER);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_READ_GROUP, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Enter critical section. */
      Adc_EnterCriticalSection();

      /* Get the group status. */
      groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

      /* Check if group is currently in status ADC_IDLE. */
      if (groupStatus == ADC_IDLE)
      {
        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Report an error. */
        Adc_ReportError(ADC_API_READ_GROUP, ADC_E_IDLE);
      }
      /* Check if group is currently in status ADC_ERROR. */
      else if (groupStatus == ADC_ERROR)
      {
        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Report an error. */
        Adc_ReportError(ADC_API_READ_GROUP, ADC_E_CONVERSION_ERROR);
      }
      else
      {
        if (groupStatus != ADC_BUSY)
        {
          /* Call an internal function. */
          Adc_ReadGroupInternal(
            groupConfigPtr,
            groupStatus,
            DataBufferPtr);

          result = E_OK;
        }
        /* Exit critical section. */
        Adc_ExitCriticalSection();
      }
    }
  }

  return result;
}
#endif /* #if ( ADC_READ_GROUP_API == STD_ON ) */

/** \brief Adc_SetupResultBuffer
 **
 ** Initializes ADC driver with the group specific result buffer start address
 ** where the conversion results will be stored. The application has to ensure that
 ** the application buffer, where DataBufferPtr points to, can hold all the
 ** conversion results of the specified group. The initialization with
 ** Adc_SetupResultBuffer is required after reset, before a group conversion can be
 ** started.
 **
 ** \return                     E_OK    :  result buffer pointer initialized correctly.
 **                             E_NOT_OK:  operation failed or development error occurred.
 **
 ** \param [in] Group           Numeric ID of requested ADC channel group.
 ** \param [in] DataBufferPtr   Pointer to result data buffer.
 **
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_SetupResultBuffer
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) DataBufferPtr
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType groupStatus;
  Std_ReturnType result = E_NOT_OK;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SETUP_RESULT_BUFFER, ADC_E_UNINIT);
  }
  /* Check if parameter pointer 'DataBufferPtr' is invalid. */
  else if (DataBufferPtr == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SETUP_RESULT_BUFFER, ADC_E_PARAM_POINTER);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_SETUP_RESULT_BUFFER, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Enter critical section. */
      Adc_EnterCriticalSection();
      
      /* Get the group status. */
      groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

      /* Check if group is currently not in status ADC_IDLE. */
      if (groupStatus != ADC_IDLE)
      {
        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Report an error. */
        Adc_ReportError(ADC_API_SETUP_RESULT_BUFFER, ADC_E_BUSY);
      }
      else
      {
        Adc_InitResultBuffer(groupConfigPtr, DataBufferPtr);

        /* Exit critical section. */
        Adc_ExitCriticalSection();

        result = E_OK;
      }
    }
  }

  return result;
}

#if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON )
/** \brief Adc_StartGroupConversion
 **
 ** Starts the conversion of all channels of the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(void, ADC_CODE) Adc_StartGroupConversion
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  boolean isSwTriggerEnabled;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_START_GROUP_CONVERSION, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_START_GROUP_CONVERSION, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Invalid trigger source */
      if (groupConfigPtr->TriggerSource != ADC_TRIGG_SRC_SW)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_START_GROUP_CONVERSION, ADC_E_WRONG_TRIGG_SRC);
      }
      /* Streaming buffer is un-initialized. */
      else if (groupConfigPtr->StreamInfoPtr->BufferBasePtr == NULL_PTR)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_START_GROUP_CONVERSION, ADC_E_BUFFER_UNINIT);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Sw trigger is enabled for this group. */
        isSwTriggerEnabled = Adc_IsSwTriggerEnabled(groupConfigPtr);
        if (isSwTriggerEnabled == FALSE)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_START_GROUP_CONVERSION, ADC_E_BUSY);
        }
        else
        {
          /* Enable ADC channel group. */
          Adc_SetChannelEnable(groupConfigPtr, TRUE);

          /* Check whether it should activate next group conversion. */
          if (groupConfigPtr->HwTriggerSource == ADC_HWTRIGG_SRC_OFF)
          {
            /* Start SW-trigger group conversion immediately. */
            Adc_SetSwTrigger(groupConfigPtr);
          }

          /* Update a channel group status to ADC_BUSY. */
          *(groupConfigPtr->GroupStatusPtr) = ADC_BUSY;

          /* Reset stream indices. */
          groupConfigPtr->StreamInfoPtr->LastPushedIndex   = -1;
          groupConfigPtr->StreamInfoPtr->ValidElementCount = 0U;

          /* Exit critical section. */
          Adc_ExitCriticalSection();
        }
      }
    }
  }
}
#endif /* #if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON ) */

#if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON )
/** \brief Adc_StopGroupConversion
 **
 ** Stops the conversion of the requested ADC Channel group.
 **
 ** \param [in] Group   Numeric ID of requested ADC Channel group.
 **
 */
FUNC(void, ADC_CODE) Adc_StopGroupConversion
(
  VAR(Adc_GroupType, AUTOMATIC) Group
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType groupStatus;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_STOP_GROUP_CONVERSION, ADC_E_UNINIT);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_STOP_GROUP_CONVERSION, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Invalid trigger source. */
      if (groupConfigPtr->TriggerSource != ADC_TRIGG_SRC_SW)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_STOP_GROUP_CONVERSION, ADC_E_WRONG_TRIGG_SRC);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Get the group status. */
        groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

        /* Check if given group is currently in status ADC_IDLE. */
        if (groupStatus == ADC_IDLE)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_STOP_GROUP_CONVERSION, ADC_E_IDLE);
        }
        else
        {
          /* Automatically disable group notification. */
          Adc_SetGroupNotification(groupConfigPtr, FALSE);

          /* Stop group conversion. */
          Adc_SetChannelEnable(groupConfigPtr, FALSE);

          /* When DMA is disabled in polling mode,
             this function may be called during interrupt flag is still set.
             In this case, the interrupt flag must be cleared here. */
          Adc_ClearChannelInterrupt(groupConfigPtr->LastLogicalChannelConfigIndex);

          /* Update a channel group status to ADC_IDLE. */
          *(groupConfigPtr->GroupStatusPtr) = ADC_IDLE;

          /* Exit critical section. */
          Adc_ExitCriticalSection();
        }
      }
    }
  }
}
#endif /* #if ( ADC_ENABLE_START_STOP_GROUP_API == STD_ON ) */

/** \brief Adc_ChangeSamplingTime
 **
 ** This API is used to change a sampling time for ADC channel
 ** if a group which to the channel is belong is not running.
 **
 ** \return                    E_OK    : Sampling time changed.
 **                            E_NOT_OK: Request rejected.
 **
 ** \param [in] Group          An ADC group that it has the specified ADC channel.
 ** \param [in] Channel        An ADC physical channel that its sampling time is changed.
 ** \param [in] SamplingTime   Sampling time that it is set to the specified ADC channel.
 **
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_ChangeSamplingTime
(
  VAR(Adc_GroupType, AUTOMATIC) Group,
  VAR(Adc_ChannelType, AUTOMATIC) Channel,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SamplingTime
)
{
  Std_ReturnType returnResult;
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Adc_StatusType groupStatus;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Set result to failed. */
    returnResult = E_NOT_OK;

    /* Report an error. */
    Adc_ReportError(ADC_API_CHANGE_SAMPLING_TIME, ADC_E_UNINIT);
  }
  /* Driver is already initialized. */
  else
  {
    /* Get group status. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Set result to failed. */
      returnResult = E_NOT_OK;

      /* Report an error. */
      Adc_ReportError(ADC_API_CHANGE_SAMPLING_TIME, ADC_E_PARAM_GROUP);
    }
    /* Check whether the SamplingTime is within valid range. */
    else if (SamplingTime > ADC_SAMPLE_CYCLE_MAX)
    {
      /* Set result to failed. */
      returnResult = E_NOT_OK;

      /* Report an error. */
      Adc_ReportError(ADC_API_CHANGE_SAMPLING_TIME, ADC_E_PARAM_SAMPLING_TIME);
    }
    /* The passed parameters are valid. */
    else
    {
      /* Enter critical section. */
      Adc_EnterCriticalSection();
      groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

      /* Check whether the group is not on-going. */
      if (groupStatus != ADC_IDLE)
      {
        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Set result to failed. */
        returnResult = E_NOT_OK;

        /* Report an error. */
        Adc_ReportError(ADC_API_CHANGE_SAMPLING_TIME, ADC_E_BUSY);
      }
      /* No error is detected. */
      else
      {
        /* Call an internal function. */
        returnResult = Adc_ChangeSamplingTimeInternal(
                         groupConfigPtr,
                         Channel,
                         SamplingTime
                       );

        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Check whether sampling time is changed. */
        if (returnResult != E_OK)
        {
          /* Report an error */
          Adc_ReportError(ADC_API_CHANGE_SAMPLING_TIME, ADC_E_PARAM_CHANNEL);
        }
      }
    }
  }
  return returnResult;
}

#if ( ADC_LOWPOWER_STATES_SUPPORT == STD_ON )
/** \brief Adc_SetPowerState
 **
 ** This API configures the Adc module so that it enters the already prepared
 ** power state, chosen between a predefined set of configured ones.
 **
 ** \return               E_OK    : Power Mode changed.
 **                       E_NOT_OK: Request rejected.
 **
 ** \param [out] Result   Pointer to where to store the result.
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_SetPowerState
(
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Std_ReturnType returnResult;
  Adc_PowerStateType preparePowerState;
  Adc_GroupType GroupNum;
  Adc_StatusType groupStatus;
  uint8 groupCount;

  /* Check if parameter pointer 'Result' is valid. */
  if (Result == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SET_POWER_STATE, ADC_E_PARAM_POINTER);

    /* Set result to failed. */
    returnResult = E_NOT_OK;
  }
  /* Check if driver is initialized */
  else if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SET_POWER_STATE, ADC_E_UNINIT);
    *Result      = ADC_NOT_INIT;
    returnResult = E_NOT_OK;
  }
  else
  {
    /* Enter critical section. */
    Adc_EnterCriticalSection();

    /* Check the target power state. */
    preparePowerState = Adc_GetTargetPowerStateInternal();
    if ((preparePowerState != ADC_FULL_POWER) && (preparePowerState != ADC_OFF_POWER))
    {
      /* Exit critical section. */
      Adc_ExitCriticalSection();

      /* Report an error. */
      Adc_ReportError(ADC_API_SET_POWER_STATE, ADC_E_POWER_STATE_NOT_SUPPORTED);
      *Result      = ADC_POWER_STATE_NOT_SUPP;
      returnResult = E_NOT_OK;
    }
    else
    {
      groupCount = Adc_GetGroupCount();
      for (GroupNum = 0U; GroupNum < groupCount; GroupNum++)
      {
        /* Get the group config pointer. */
        groupConfigPtr = Adc_GetGroupConfig(GroupNum);

        /* Get the group status. */
        groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

        /* Check if group is NOT currently in status ADC_IDLE. */
        if (groupStatus != ADC_IDLE)
        {
          break;
        }
      }

      if (GroupNum < groupCount)
      {
        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Report an error. */
        Adc_ReportError(ADC_API_SET_POWER_STATE, ADC_E_NOT_DISENGAGED);
        *Result      = ADC_TRANS_NOT_POSSIBLE;
        returnResult = E_NOT_OK;
      }
      else
      {
        /* Check the current power state. */
        if (Adc_GetCurrentPowerStateInternal() != preparePowerState)
        {
          /* Set the current power state. */
          Adc_SetCurrentPowerStateInternal();
        }
        /* Exit critical section. */
        Adc_ExitCriticalSection();
        *Result      = ADC_SERVICE_ACCEPTED;
        returnResult = E_OK;
      }
    }
  }
  return returnResult;
}

/** \brief Adc_GetCurrentPowerState
 **
 ** This API returns the current power state of the ADC HW unit.
 **
 ** \return                         E_OK    : Mode could be read.
 **                                 E_NOT_OK: Service is rejected.
 **
 ** \param [out] CurrentPowerState  The current power mode of the ADC HW Unit
 **                                  is returned in this parameter.
 ** \param [out] Result             Pointer to where to store the result.
 **
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_GetCurrentPowerState
(
  P2VAR(Adc_PowerStateType,              AUTOMATIC, ADC_APPL_DATA) CurrentPowerState,
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
)
{
  VAR(Std_ReturnType, AUTOMATIC) returnResult;

  /* Check if parameter pointer 'Result' is valid. */
  if (Result == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CURRENT_POWER_STATE, ADC_E_PARAM_POINTER);
    returnResult = E_NOT_OK;
  }
  /* Check if parameter pointer 'CurrentPowerState' is valid. */
  else if (CurrentPowerState == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CURRENT_POWER_STATE, ADC_E_PARAM_POINTER);
    *Result      = ADC_NOT_INIT;
    returnResult = E_NOT_OK;
  }
  /* Check if driver is initialized. */
  else if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CURRENT_POWER_STATE, ADC_E_UNINIT);
    *Result      = ADC_NOT_INIT;
    returnResult = E_NOT_OK;
  }
  else
  {
    /* Get the current power state. */
    *CurrentPowerState = Adc_GetCurrentPowerStateInternal();
    *Result            = ADC_SERVICE_ACCEPTED;
    returnResult       = E_OK;
  }
  return returnResult;
}

/** \brief Adc_GetTargetPowerState
 **
 ** This API returns the Target power state of the ADC HW unit.
 **
 ** \return                        E_OK    : Mode could be read
 **                                E_NOT_OK: Service is rejected
 **
 ** \param [out] TargetPowerState  The Target power mode of the ADC HW Unit
 **                                 is returned in this parameter.
 ** \param [out] Result            Pointer to where to store the result.
 **
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_GetTargetPowerState
(
  P2VAR(Adc_PowerStateType,              AUTOMATIC, ADC_APPL_DATA) TargetPowerState,
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
)
{
  Std_ReturnType returnResult;

  /* Check if parameter pointer 'Result' is valid. */
  if (Result == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_TARGET_POWER_STATE, ADC_E_PARAM_POINTER);
    returnResult = E_NOT_OK;
  }
  /* Check if parameter pointer 'TargetPowerState' is valid. */
  else if (TargetPowerState == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_TARGET_POWER_STATE, ADC_E_PARAM_POINTER);
    *Result      = ADC_NOT_INIT;
    returnResult = E_NOT_OK;
  }
  /* Check if driver is initialized. */
  else if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_TARGET_POWER_STATE, ADC_E_UNINIT);
    *Result      = ADC_NOT_INIT;
    returnResult = E_NOT_OK;
  }
  else
  {
    /* Get the target power state. */
    *TargetPowerState = Adc_GetTargetPowerStateInternal();
    *Result           = ADC_SERVICE_ACCEPTED;
    returnResult      = E_OK;
  }
  return returnResult;
}

/** \brief Adc_PreparePowerState
 **
 ** This API starts the needed process to allow the ADC HW module to enter
 ** the requested power state.
 **
 ** \return                  E_OK    : Preparation process started
 **                          E_NOT_OK: Service is rejected
 **
 ** \param [in]  PowerState  The target power state intended to be attained.
 ** \param [out] Result      Pointer to where to store the result.
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_PreparePowerState
(
  VAR(Adc_PowerStateType, AUTOMATIC) PowerState,
  P2VAR(Adc_PowerStateRequestResultType, AUTOMATIC, ADC_APPL_DATA) Result
)
{
  Std_ReturnType returnResult;

  /* Check if parameter pointer 'Result' is valid. */
  if (Result == NULL_PTR)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_PREPARE_POWER_STATE, ADC_E_PARAM_POINTER);
    returnResult = E_NOT_OK;
  }
  /* Check if driver is initialized. */
  else if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_PREPARE_POWER_STATE, ADC_E_UNINIT);
    *Result      = ADC_NOT_INIT;
    returnResult = E_NOT_OK;
  }
  else if ((PowerState != ADC_FULL_POWER) && (PowerState != ADC_OFF_POWER))
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_PREPARE_POWER_STATE, ADC_E_POWER_STATE_NOT_SUPPORTED);
    *Result      = ADC_POWER_STATE_NOT_SUPP;
    returnResult = E_NOT_OK;
  }
  else
  {
    /* Enter critical section. */
    Adc_EnterCriticalSection();

    /* Check the current power state. */
    if (Adc_GetCurrentPowerStateInternal() != PowerState)
    {
      /* Set PreparePowerState. */
      Adc_SetTargetPowerStateInternal(PowerState);
    }

    /* Exit critical section. */
    Adc_ExitCriticalSection();
    *Result      = ADC_SERVICE_ACCEPTED;
    returnResult = E_OK;
  }
  return returnResult;
}

/** \brief Adc_Main_PowerTransitionManager
 **
 ** This API is cyclically called and supervises the power state transitions, 
 ** checking for the readiness of the module and issuing the callbacks.
 ** (As there is no preparation period in the hardware feature, asynchronous 
 ** power state transition mode is not supported. Therefore, this main function 
 ** is implemented as null function.)
 **
 */
FUNC(void, ADC_CODE) Adc_Main_PowerTransitionManager(void)
{
  /* No action here*/
}
#endif /* #if ( ADC_LOWPOWER_STATES_SUPPORT == STD_ON ) */

#if ( ADC_CALIBRATION_API == STD_ON )
/** \brief Adc_ChangeCalibrationChannel
 **
 ** Changes calibration measurement analog signal (VrefL / VrefH) for the group 
 ** converted by using of alternate calibration values.
 **
 ** \return              E_OK    : Analog input signal is changed correctly.
 **                      E_NOT_OK: Request is rejected.
 **
 ** \param [in] Group    Numeric ID of requested ADC channel group.
 ** \param [in] Signal   Calibration measurement analog signal.
 **                      (ADC_PIN_VREFL: VrefL / ADC_PIN_VREFH: VrefH)
 **
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_ChangeCalibrationChannel
(
  VAR(Adc_GroupType,  AUTOMATIC) Group,
  VAR(Adc_SignalType, AUTOMATIC) Signal
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) groupConfigPtr;
  Std_ReturnType result = E_NOT_OK;
  Adc_StatusType groupStatus;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_CHANGE_CALIBRATION_CHANNEL, ADC_E_UNINIT);
  }
  /* Check if parameter 'Signal' is valid. */
  else if ((Signal != ADC_PIN_VREFL) && (Signal != ADC_PIN_VREFH))
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_CHANGE_CALIBRATION_CHANNEL, ADC_E_PARAM_SIGNAL);
  }
  else
  {
    /* Get the group config pointer. */
    groupConfigPtr = Adc_GetGroupConfig(Group);

    /* Check if parameter 'Group' is valid. */
    if (groupConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_CHANGE_CALIBRATION_CHANNEL, ADC_E_PARAM_GROUP);
    }
    else
    {
      /* Check if parameter 'Group' uses alternate calibration values. */
      if (groupConfigPtr->UseAlternateCalibration == FALSE)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_CHANGE_CALIBRATION_CHANNEL, ADC_E_PARAM_GROUP);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Get the group status. */
        groupStatus = Adc_GetGroupStatusInternal(groupConfigPtr);

        /* Check whether the group is not on-going. */
        if (groupStatus != ADC_IDLE)
        {
          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Report an error. */
          Adc_ReportError(ADC_API_CHANGE_CALIBRATION_CHANNEL, ADC_E_BUSY);
        }
        else
        {
          /* Change calibration channel. */
          Adc_ChangeCalibrationChannelInternal(groupConfigPtr, Signal);

          /* Exit critical section. */
          Adc_ExitCriticalSection();

          /* Update return value. */
          result = E_OK;
        }
      }
    }
  }
  return result;
}

/** \brief Adc_SetCalibrationValue
 **
 ** Sets alternate calibration values for the requested ADC HwUnit.
 ** And if paramter "Update" is true, triggers updating regular calibration 
 ** values with alternate calibration values.
 **
 ** \return             E_OK    : Alternate calibration values are set correctly 
 **                               and update of regular calibration values are
 **                               triggered if necessary.
 **                     E_NOT_OK: Request is rejected.
 **
 ** \param [in] HwUnit  Numeric ID of requested ADC HwUnit.
 ** \param [in] Offset  Offset value of alternate calibration.
 ** \param [in] Gain    Gain value of alternate calibration.
 ** \param [in] Update  Flag indicates whether to update regular calibration values with 
 **                     alternate calibration values or not.
 **                     -TRUE : trigger updating of regular calibration values.
 **                     -FALSE: not trigger updating.
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_SetCalibrationValue
(
  VAR(Adc_HwUnitType,      AUTOMATIC) HwUnit,
  VAR(Adc_OffsetValueType, AUTOMATIC) Offset,
  VAR(Adc_GainValueType,   AUTOMATIC) Gain,
  VAR(boolean,             AUTOMATIC) Update
)
{
  Std_ReturnType result = E_NOT_OK;
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) hwUnitConfigPtr;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SET_CALIBRATION_VALUE, ADC_E_UNINIT);
  }
  /* Check if parameter 'Gain' is out of range. */
  else if ((Gain < ADC_AGAIN_MIN) || (Gain > ADC_AGAIN_MAX))
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SET_CALIBRATION_VALUE, ADC_E_PARAM_GAIN);
  }
  /* Check if parameter 'Update' is out of range. */
  else if ((Update != TRUE) && (Update != FALSE))
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_SET_CALIBRATION_VALUE, ADC_E_PARAM_UPDATE);
  }
  else
  {
    /* Get the HwUnit config pointer. */
    hwUnitConfigPtr = Adc_GetHwUnitConfig(HwUnit);

    /* Check if parameter 'HwUnit' is valid. */
    if (hwUnitConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_SET_CALIBRATION_VALUE, ADC_E_PARAM_HWUNIT);
    }
    else
    {
      /* Check if SAR of parameter 'HwUnit' is not used. (Only MUX is used.) */
      if (hwUnitConfigPtr->SarEnabled == FALSE)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_SET_CALIBRATION_VALUE, ADC_E_PARAM_HWUNIT);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Set calibration value. */
        Adc_SetCalibrationValueInternal(hwUnitConfigPtr, Offset, Gain, Update);

        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Update return value. */
        result = E_OK;
      }
    }
  }
  return result;
}

/** \brief Adc_GetCalibrationAlternateValue
 **
 ** Gets alternate calibration values of the requested ADC HwUnit.
 **
 ** \return                 E_OK    : Alternate calibration values are read correctly.
 **                         E_NOT_OK: Request is rejected.
 **
 ** \param [in]  HwUnit     Numeric ID of requested ADC HwUnit.
 ** \param [out] OffsetPtr  Buffer pointer stored offset value of alternate calibration.
 ** \param [out] GainPtr    Buffer pointer stored gain value of alternate calibration.
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_GetCalibrationAlternateValue
(
  VAR(Adc_HwUnitType, AUTOMATIC)                       HwUnit,
  P2VAR(Adc_OffsetValueType, AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,   AUTOMATIC, ADC_APPL_DATA) GainPtr
)
{
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) hwUnitConfigPtr;
  Std_ReturnType result = E_NOT_OK;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CALIBRATION_ALTERNATE_VALUE, ADC_E_UNINIT);
  }
  /* Check if parameter pointers are valid. */
  else if ((OffsetPtr == NULL_PTR) || (GainPtr == NULL_PTR))
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CALIBRATION_ALTERNATE_VALUE, ADC_E_PARAM_POINTER);
  }
  else
  {
    /* Get the HwUnit config pointer. */
    hwUnitConfigPtr = Adc_GetHwUnitConfig(HwUnit);

    /* Check if parameter 'HwUnit' is valid. */
    if (hwUnitConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_GET_CALIBRATION_ALTERNATE_VALUE, ADC_E_PARAM_HWUNIT);
    }
    else
    {
      /* Check if SAR of parameter 'HwUnit' is not used. (Only MUX is used.) */
      if (hwUnitConfigPtr->SarEnabled == FALSE)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_GET_CALIBRATION_ALTERNATE_VALUE, ADC_E_PARAM_HWUNIT);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Get alternate calibration value. */
        Adc_GetCalibrationAlternateInternal(hwUnitConfigPtr, OffsetPtr, GainPtr);

        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Update return value. */
        result = E_OK;
      }
    }
  }
  return result;
}

/** \brief Adc_GetCalibrationValue
 **
 ** Gets regular calibration values of the requested ADC HwUnit.
 **
 ** \return                 E_OK    : Regular calibration values are read correctly.
 **                         E_NOT_OK: Request is rejected.
 **
 ** \param [in]  HwUnit     Numeric ID of requested ADC HwUnit.
 ** \param [out] OffsetPtr  Buffer pointer stored offset value of regular calibration.
 ** \param [out] GainPtr    Buffer pointer stored gain value of regular calibration.
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_GetCalibrationValue
(
  VAR(Adc_HwUnitType, AUTOMATIC)                       HwUnit,
  P2VAR(Adc_OffsetValueType, AUTOMATIC, ADC_APPL_DATA) OffsetPtr,
  P2VAR(Adc_GainValueType,   AUTOMATIC, ADC_APPL_DATA) GainPtr
)
{
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) hwUnitConfigPtr;
  Std_ReturnType result = E_NOT_OK;

  /* Check if driver is initialized. */
  if (Adc_CheckConfigPtr() != TRUE)
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CALIBRATION_VALUE, ADC_E_UNINIT);
  }
  /* Check if parameter pointers are valid. */
  else if ((OffsetPtr == NULL_PTR) || (GainPtr == NULL_PTR))
  {
    /* Report an error. */
    Adc_ReportError(ADC_API_GET_CALIBRATION_VALUE, ADC_E_PARAM_POINTER);
  }
  else
  {
    /* Get the HwUnit config pointer. */
    hwUnitConfigPtr = Adc_GetHwUnitConfig(HwUnit);

    /* Check if parameter 'HwUnit' is valid. */
    if (hwUnitConfigPtr == NULL_PTR)
    {
      /* Report an error. */
      Adc_ReportError(ADC_API_GET_CALIBRATION_VALUE, ADC_E_PARAM_HWUNIT);
    }
    else
    {
      /* Check if SAR of parameter 'HwUnit' is not used. (Only MUX is used.) */
      if (hwUnitConfigPtr->SarEnabled == FALSE)
      {
        /* Report an error. */
        Adc_ReportError(ADC_API_GET_CALIBRATION_VALUE, ADC_E_PARAM_HWUNIT);
      }
      else
      {
        /* Enter critical section. */
        Adc_EnterCriticalSection();

        /* Get regular calibration value. */
        Adc_GetCalibrationInternal(hwUnitConfigPtr, OffsetPtr, GainPtr);

        /* Exit critical section. */
        Adc_ExitCriticalSection();

        /* Update return value. */
        result = E_OK;
      }
    }
  }
  return result;
}
#endif /* #if ( ADC_CALIBRATION_API == STD_ON ) */

/** \brief  Adc_EnterCriticalSection
 **
 ** This function is process of entering critical section.
 ** Calls SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_0.
 **
 */
FUNC(void, ADC_CODE) Adc_EnterCriticalSection(void)
{
  /* Lock interrupts: read-modify-store on most architectures */
  SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_0();
}

/** \brief Adc_ExitCriticalSection
 **
 ** This function is process of exiting critical section.
 ** Calls SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_0.
 **
 */
FUNC(void, ADC_CODE) Adc_ExitCriticalSection(void)
{
  /* Exit critical section. */
  SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_0();
}

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[internal function definitions]=========================*/

#define ADC_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/** \brief Adc_ReportError
 **
 ** Reports an error to the error handler and optionally to the DET.
 **
 ** \param [in] ApiId     Id of the service that detected the error.
 ** \param [in] ErrorId   Id of the error that was detected.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReportError
(
  VAR(uint8, AUTOMATIC) ApiId,
  VAR(uint8, AUTOMATIC) ErrorId
)
{
  /* ASIL error callout */
  (void)ADC_ERROR_CALLOUT_FUNCTION(ADC_MODULE_ID, ADC_INSTANCE_ID_DET, ApiId, ErrorId);

  /* DET error reporting */
#if ( ADC_DEV_ERROR_DETECT == STD_ON )
  (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID_DET, ApiId, ErrorId);
#endif /* #if ( ADC_DEV_ERROR_DETECT == STD_ON ) */
}

/** \brief Adc_DemReportEvent
 **
 ** Reports an error to the error handler and optionally to the DEM.
 **
 ** \param [in] ApiId        Id of the service that detected the error.
 ** \param [in] EventId      Id of the event code that was detected.
 ** \param [in] EventStatus  Status of event.
 **
 */
static FUNC(void, ADC_CODE) Adc_DemReportEvent
(
  VAR(uint8, AUTOMATIC)   ApiId,
  VAR(uint8, AUTOMATIC)   EventId,
  VAR(boolean, AUTOMATIC) EventStatus
)
{
#ifdef ADC_E_HARDWARE_ERROR
  Dem_EventStatusType  DemEventStatus;
#endif /* #ifdef ADC_E_HARDWARE_ERROR */

  /* Check if event is failed. */
  if (EventStatus == FALSE)
  {
    /* ASIL error callout */
    (void)ADC_ERROR_CALLOUT_FUNCTION(ADC_MODULE_ID,
                                     ADC_INSTANCE_ID_DET,
                                     ApiId,
                                     EventId);
  }

#ifdef ADC_E_HARDWARE_ERROR
  /* Check if hardware error occurred. */
  if (EventId == ADC_E_HARDWARE_ERROR_FOR_CALLOUT)
  {
    /* Prepare a value which will be passed. */
    DemEventStatus = (EventStatus == TRUE) ?
                     (DEM_EVENT_STATUS_PASSED) : (DEM_EVENT_STATUS_FAILED);

    /* Call diagnostic event manager. */
    Dem_ReportErrorStatus(ADC_E_HARDWARE_ERROR, DemEventStatus);
  }
#endif /* #ifdef ADC_E_HARDWARE_ERROR */
}

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[end of file]===========================================*/
