/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file defines the interface of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

#ifndef FEE_PUB_H_INCLUDED
#define FEE_PUB_H_INCLUDED


/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "MemIf_Types.h"
#include "Fee_Cancel.h"
#include "Fee_EraseImmediateBlock.h"
#include "Fee_GetJobResult.h"
#include "Fee_GetStatus.h"
#include "Fee_Init.h"
#include "Fee_InvalidateBlock.h"
#include "Fee_MainFunction.h"
#include "Fee_Read.h"
#include "Fee_Write.h"
#include "Fee_Types.h"
#include "Fee_Version.h"
#include "Fee_Clear.h"
#include "Fee_GetRemainingPages.h"
#include "Fee_CleanupAndErase.h"
#include "Fls_TypesLib.h"
#include "Fls_TypesDerLib.h"

/*****************************************************************************/
/* Global pre-processor symbols/macros ('#define')                           */
/*****************************************************************************/
/*!<
 Internal event ID for hardware error occurred. */
#define FEE_EVENT_HARDWARE_ERROR_OCCURRED         ((uint16)0x01)
/*!<
 Internal event ID for timeout error occurred. */
#define FEE_EVENT_TIMEOUT_ERROR_OCCURRED          ((uint16)0x02)
/*!<
 Internal event ID for unavailability of immediate data space. */
#define FEE_EVENT_IMMEDIATEDATASPACE_UNAVAILABLE  ((uint16)0x03)
/*!<
 Internal event ID for block ID unmatched error occurred. */
#define FEE_EVENT_BLOCKID_UNMATCHED_ERROR_OCCURRED  ((uint16)0x04)
/*!<
 Internal event ID for block size unmatched error occurred. */
#define FEE_EVENT_BLOCKSIZE_UNMATCHED_ERROR_OCCURRED  ((uint16)0x05)
/*!<
 Internal event ID for 1 bit ECC error occurred. */
#define FEE_EVENT_1BIT_ECC_ERROR_OCCURRED  ((uint16)0x06)
/*!<
 Internal event ID for 2 bit ECC error occurred. */
#define FEE_EVENT_2BIT_ECC_ERROR_OCCURRED  ((uint16)0x07)

#define FEE_FLS_BASE_ADDRESS         (0x14000000UL) /* FlsBaseAddress for wrapper function */

#define FEE_NULL                     (0U)           /* zero(NULL) */

#define FEE_SHIFT_BITS               (3U)           /* value for shifting 3-bit */

#define FEE_LIMIT_COUNT_INIT         (313365UL)     /* initilaize time-limit (in msec) */
#define FEE_LIMIT_COUNT_WRITE        (313365UL)     /* writing time-limit (in msec) */
#define FEE_LIMIT_COUNT_READ         (520UL)        /* reading time-limit (in msec) */
#define FEE_LIMIT_COUNT_INVALIDATE   (313365UL)     /* invalidating time-limit (in msec) */
#define FEE_LIMIT_COUNT_RECYCLE      (313365UL)     /* recycling time-limit (in msec) */
#define FEE_LIMIT_COUNT_WAIT         (1200UL)       /* waiting time-limit (in msec) */
#define FEE_LIMIT_COUNT_WRITE_CANCEL (200UL)        /* canceling time-limit (in msec) */

/* caculate the align8 of x */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: In case of very small processing, function-like macro is used.
                  It improves readability and performance. */
/* PRQA S 3453 1 */
#define FEE_CACULATE_ALIGN8(x)    ( ( (x) + 0x00000007U ) & 0xFFFFFFF8U )

/**
 * Use the symbol to avoid compiler warnings   
 */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: In case of very small processing, function-like macro is used.
                  It improves readability and performance. */
/* PRQA S 3453 1 */
#define FEE_PARAM_UNUSED(x)          (void) (x)

/*****************************************************************************/
/* Global type definitions ('typedef')                                       */
/*****************************************************************************/

/* typedef of block management information format */
/* Deviation from MISRA-C:2004 rule 18.4, MISRA-C:2012 Rule-19.2
   Justification: For efficient implementation, this union is necessary. And after analysis, the alignment, endian of union member is no problem. */
/* PRQA S 750 13 */
typedef struct
{
    VAR(uint32, AUTOMATIC) WriteFlag;                  /* Block Write Flag */
    union{
        struct{
            VAR(uint16, AUTOMATIC) BlkNum;
            VAR(uint16, AUTOMATIC) PageNum;
        }BNumAndPNumBitField;
        VAR(uint32, AUTOMATIC) BNumAndPNum;
    }BlkNumAndPageNum;                 /* Block Number and Page Number */
    VAR(uint32, AUTOMATIC) InvalidStat;                /* Invalid Status */
    VAR(uint32, AUTOMATIC) ValidStat;                  /* Valid Status */
} Fee_BlockManagementInfoType;

/* typedef of block index information format */
typedef struct
{
    VAR(uint32, AUTOMATIC)   BlkAddr;        /* block address */
    VAR(uint8, AUTOMATIC)    BlkStatus;      /* block status */
    VAR(uint8, AUTOMATIC)    BlkBlankCheck;  /* blank check has been executed or not */
}Fee_BlockAddrIndexType;     /* the block address and status in sector */

/* typedef of configuration information format */
typedef struct
{
    VAR(uint32, AUTOMATIC)  Fee_SecTopAddr;            /* Flash area top address */
    VAR(uint32, AUTOMATIC)  Fee_SecSize;               /* Size of Fee logic sectors */
    VAR(uint32, AUTOMATIC)  Fee_RemainSize;            /* The remaining area of configuration */
    VAR(uint32, AUTOMATIC)  Fee_SecEndAddr;            /* Flash area end address*/
    VAR(uint32, AUTOMATIC)  Fee_PSCCheckSum;           /* PSC1 + PSC2 + PSC1 * PSC2 */
    P2CONST(Fee_BlockConfigType, AUTOMATIC, AUTOMATIC)  Fee_BlkCfgPtr;  /* Pointer to Block configuration array */
    VAR(uint16, AUTOMATIC)  Fee_NoOfBlocks;            /* Number of defined blocks */
    VAR(uint16, AUTOMATIC)   Fee_SectorSizeLessThan800; /* Last Logical Sector Size less than 800 */
    VAR(uint8, AUTOMATIC)   Fee_NoOfSec;               /* Number of defined sectors */
    VAR(uint8, AUTOMATIC)   Fee_NormalSectorCount;     /* Normal Physical Sector Count */
    VAR(uint8, AUTOMATIC)   Fee_LastSectorCount;       /* Last Physical Sector Count */
} Fee_ConfigurationInfoType;

/* typedef of Fee_MainRecycle pointer */
typedef P2FUNC(void, FEE_CODE, Fee_MainRecycleFuncType)(void);

/* typedef of Fee_MainClear pointer */
typedef P2FUNC(void, FEE_CODE, Fee_MainClearFuncType)(void);

/* typedef of Fee_Erase/Fee_WriteEraseCompleteFlag pointer */
typedef P2FUNC(uint8, FEE_CODE, Fee_EraseOrWriteFlagFuncType)(void);

/* typedef of function pointer */
typedef struct Fee_LibFuncTable_s
{
    VAR(Fee_MainRecycleFuncType, AUTOMATIC)       MainRecycleFunc;
    VAR(Fee_MainClearFuncType, AUTOMATIC)         MainClearFunc;
    VAR(Fee_EraseOrWriteFlagFuncType, AUTOMATIC)  EraseOrWriteFlagFunc;
} Fee_LibFuncTableType;

typedef enum {
    FEE_ENUMTYPE_INIT = 0U,
    FEE_ENUMTYPE_WRITE,
    FEE_ENUMTYPE_READ,
    FEE_ENUMTYPE_INVAL,
    FEE_ENUMTYPE_RECYC,
    FEE_ENUMTYPE_CANCEL,
    FEE_ENUMTYPE_WRITECANCEL
} Fee_EnumTypeCurrentJobType;

/* Psc1 and Psc2 and Checksum */
/* Deviation from MISRA-C:2004 rule 18.4, MISRA-C:2012 Rule-19.2
   Justification: For efficient implementation, this union is necessary. And after analysis, the alignment, endian of union member is no problem. */
/* PRQA S 750 8 */
typedef union {
    struct{
            VAR(uint8, AUTOMATIC) Psc1;
            VAR(uint8, AUTOMATIC) Psc2;
            VAR(uint16, AUTOMATIC) PscChecksum;
        }PscBitField;
    VAR(uint32, AUTOMATIC) PscInfo;
}Fee_PscInfoType;

/** \brief Fee_FaultType
 ** Type of fault information
 */
typedef enum fee_faulttype
{
    FEE_FAULT_NONE       = FLS_FAULT_NONE,   /* no fault */
    FEE_FAULT_SED        = FLS_FAULT_SED,   /* single bit error */
    FEE_FAULT_DED        = FLS_FAULT_DED,   /* double bit error */
    FEE_FAULT_BUSERROR   = FLS_FAULT_BUSERROR,   /* bus error */
    FEE_FAULT_MACROERROR = FLS_FAULT_MACROERROR,   /* Flash macro error */
    FEE_FAULT_OTHERERROR = FLS_FAULT_OTHERERROR    /* any other error */
} Fee_FaultType;


/*****************************************************************************/
/* Global variable declarations ('extern', definition in C source)           */
/*****************************************************************************/
#define FEE_START_SEC_CONST_ASIL_B_UNSPECIFIED
#include "Fee_MemMap.h"

/*!<
 Configuration Information */
/* Deviation from MISRA-C:2004 rule 8.12, MISRA-C:2012 Rule-8.11
   Justification: The following array size is configuration dependent. */
/* PRQA S 3684 1 */
extern CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[];

/*!<
 Block configuration array. The size of this array depends on the block
 configuration and is set by the configuration tool in Fee_Cfg.h. Open array
 because Fee_Cfg.h header file is not available in Fee_Pub.h.
 [Fee_NoOfBlocks1/FEE_BLOCK_MAX_1] */
/* Deviation from MISRA-C:2004 rule 8.12, MISRA-C:2012 Rule-8.11
   Justification: The following array size is configuration dependent. */
/* PRQA S 3684 1 */
extern CONST(Fee_BlockConfigType, FEE_CONST) Fee_BlkCfg1[];

/*!<
 Block configuration array. The size of this array depends on the block
 configuration and is set by the configuration tool in Fee_Cfg.h. Open array
 because Fee_Cfg.h header file is not available in Fee_Pub.h.
 [Fee_NoOfBlocks2/FEE_BLOCK_MAX_2] */
/* Deviation from MISRA-C:2004 rule 8.12, MISRA-C:2012 Rule-8.11
   Justification: The following array size is configuration dependent. */
/* PRQA S 3684 1 */
extern CONST(Fee_BlockConfigType, FEE_CONST) Fee_BlkCfg2[];

#define FEE_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
#include "Fee_MemMap.h"


#define FEE_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

extern VAR(MemIf_ModeType, FEE_INTERNAL_VAR_CLEARED) FeeDefaultCycleMode;

extern VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_BlockBlankCheckOff;

extern VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_SectorBlankCheckOff;

#define FEE_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


/*****************************************************************************/
/* Global function prototypes ('extern', definition in C source)             */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
#include "Fee_MemMap.h"

extern FUNC(void, FEE_CODE) Fee_EnterCritiSec(void);


extern FUNC(void, FEE_CODE) Fee_ExitCritiSec(void);


extern FUNC(void, FEE_CODE) Fee_ErrorCallout(
  VAR(uint16, AUTOMATIC) Event);


extern FUNC(void, FEE_CODE) Fee_Det(
  VAR(uint8, AUTOMATIC) ApiId,
  VAR(uint8, AUTOMATIC) ErrorId);


extern FUNC(MemIf_StatusType, FEE_CODE) Fee_FlsGetStatus(void);


extern FUNC(MemIf_StatusType, FEE_CODE) Fee_FlsGetStatusSub(void);


extern FUNC(MemIf_JobResultType, FEE_CODE) Fee_FlsGetJobResult(void);


extern FUNC(Std_ReturnType, FEE_CODE) Fee_FlsRead(
  VAR(uint32, AUTOMATIC) SourceAddress,
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) TargetAddressPtr,
  VAR(uint32, AUTOMATIC) Length);

extern FUNC(void, FEE_CODE) Fee_FlsReadImmediateSync(
  VAR(uint32, AUTOMATIC) SourceAddress,
  P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) TargetAddressPtr,
  VAR(uint32, AUTOMATIC) Length);


extern FUNC(Std_ReturnType, FEE_CODE) Fee_FlsCompare(
  VAR(uint32, AUTOMATIC) SourceAddress,
  P2CONST(uint8, AUTOMATIC, FEE_APPL_CONST) TargetAddressPtr,
  VAR(uint32, AUTOMATIC) Length);


extern FUNC(Std_ReturnType, FEE_CODE) Fee_FlsWrite(
  VAR(uint32, AUTOMATIC) TargetAddress,
  P2CONST(uint8, AUTOMATIC, FEE_APPL_CONST) SourceAddressPtr,
  VAR(uint32, AUTOMATIC) Length);


extern FUNC(Std_ReturnType, FEE_CODE) Fee_FlsErase(
  VAR(uint32, AUTOMATIC) TargetAddress,
  VAR(uint32, AUTOMATIC) Length);


extern FUNC(void, FEE_CODE) Fee_FlsCancel(void);


extern FUNC(void, FEE_CODE) Fee_FlsEnableDMA(void);


extern FUNC(void, FEE_CODE) Fee_FlsDisableDMA(void);


extern FUNC(Fee_BlockAttributeType, FEE_CODE) Fee_BlockNumberToAttribute(
VAR(uint16, AUTOMATIC) BlockNumber);


extern FUNC(void, FEE_CODE) Fee_FlsSetMode(VAR(MemIf_ModeType, AUTOMATIC) Mode);


extern FUNC(void, FEE_CODE) Fee_FlsInit(void);


extern FUNC(Fee_FaultType, FEE_CODE) Fee_GetFlsFault(void);


extern FUNC(boolean, FEE_CODE) Fee_IsInitializing(void);


extern FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetData(void);


extern FUNC_P2VAR(uint64, AUTOMATIC, FEE_CODE) Fee_GetDataBuffer(void);


extern FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetDataBufferRecycle(void);


extern FUNC(uint8, FEE_CODE) Fee_GetSectorStatusElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index);


extern FUNC(uint8, FEE_CODE) Fee_GetSectorStatusMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index);


extern FUNC(void, FEE_CODE) Fee_SetSectorStatusElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) value);


extern FUNC(void, FEE_CODE) Fee_SetSectorStatusMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) value);


extern FUNC(void, FEE_CODE) Fee_SetBlkMgtAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(Fee_BlockManagementInfoType*, AUTOMATIC) value);


extern FUNC(void, FEE_CODE) Fee_SetBlkPageAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint32*, AUTOMATIC) value);


extern FUNC(void, FEE_CODE) Fee_SetBlkEmptySizeElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) value);


extern FUNC_P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_CODE) Fee_GetBlkMgtAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no);


extern FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetBlkPageAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no);


extern FUNC(uint16, FEE_CODE) Fee_GetBlkEmptySizeElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no);


extern FUNC(void, FEE_CODE) Fee_SetBlockAddrIndexElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockAddrIndexType, AUTOMATIC) value);


extern FUNC(void, FEE_CODE) Fee_SetBlockAddrIndexMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockAddrIndexType, AUTOMATIC) value);


extern FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_GetBlockAddrIndexElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index);


extern FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_GetBlockAddrIndexMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index);


extern FUNC_P2CONST(Fee_LibFuncTableType, FEE_CONST, AUTOMATIC) Fee_GetLibFuncTable(void);


/* Periodic processing of recycling. */
extern FUNC(void, FEE_CODE) Fee_MainRecycle(void);


/* Periodic processing of clearing. */
extern FUNC(void, FEE_CODE) Fee_MainClear(void);


/* Erase garbage sector and odd sector. */
extern FUNC(uint8, FEE_CODE) Fee_Erase(void);


/* Write erase completed flag. */
extern FUNC(uint8, FEE_CODE) Fee_WriteEraseCompleteFlag(void);


extern FUNC(uint8, FEE_CODE) Fee_GetCfgNum(void);


extern FUNC(Fee_ConfigType, FEE_CODE) Fee_GetCfg(void);


extern FUNC(MemIf_ModeType, FEE_CODE) Fee_GetModeVar(void);


extern FUNC(uint32, FEE_CODE) Fee_GetTimeoutCount(
  VAR(Fee_EnumTypeCurrentJobType, AUTOMATIC) current_job);


extern FUNC(uint32, FEE_CODE) Fee_FlsGetSecTopAddressFromAddress(
  VAR(uint32, AUTOMATIC) TargetAddress);


extern FUNC(uint32, FEE_CODE) Fee_FlsGetReadAddr(
  VAR(uint32, AUTOMATIC) TargetAddress);

/* get variable Fee_UnmatchedBlockCheck. */
extern FUNC(uint8, FEE_CODE) Fee_GetUnmatchedBlockCheck(void);

/* get variable Fee_DelayRecycleOperation. */
extern FUNC(uint8, FEE_CODE) Fee_GetDelayRecycleOperation(void);

/* get variable Fee_DefinedThresholdPageSize. */
extern FUNC(uint8, FEE_CODE) Fee_GetDefinedThresholdPageSize(void);

/* get variable Fee_ThresholdPageSize. */
extern FUNC(uint16, FEE_CODE) Fee_GetThresholdPageSize(
  VAR(uint8, AUTOMATIC) config_no);

/* get variable Fee_BlockRealMaxsize. */
extern FUNC(uint16, FEE_CODE) Fee_GetBlockRealMaxsize(
  VAR(uint8, AUTOMATIC) config_no);

/* get variable Fee_BlockNoFromRealMaxsize. */
extern FUNC(uint16, FEE_CODE) Fee_GetBlockNoFromRealMaxsize(
  VAR(uint8, AUTOMATIC) config_no);

/* get variable Fee_BlockBlankCheckOff. */
extern FUNC(uint8, FEE_CODE) Fee_GetBlockBlankCheckOff(void);

/* get variable Fee_SectorBlankCheckOff. */
extern FUNC(uint8, FEE_CODE) Fee_GetSectorBlankCheckOff(void);

/* get variable Fee_WflashLgSectorSize. */
extern FUNC(uint16, FEE_CODE) Fee_GetWflashLgSectorSize(void);

/* get variable Fee_WorkFlashAbsoluteEndAddress. */
extern FUNC(uint32, FEE_CODE) Fee_GetWorkFlashAbsoluteEndAddress(void);

/* get variable Fee_BlkCfgOnFlash1 or Fee_BlkCfgOnFlash2. */
extern FUNC(Fee_BlockConfigType, FEE_CODE) Fee_GetBlkCfgOnFlash(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index);

/* set variable Fee_BlkCfgOnFlash1 or Fee_BlkCfgOnFlash2. */
extern FUNC(void, FEE_CODE) Fee_SetBlkCfgOnFlash(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockConfigType, AUTOMATIC) blk_cfg);

/* initialize variable Fee_BlkCfgOnFlash1 or Fee_BlkCfgOnFlash2. */
extern FUNC(void, FEE_CODE) Fee_InitBlkCfgOnFlash(void);

/* When 2 bit ECC error occurs, this function will be called. */
extern FUNC(void, FEE_CODE) Fee_FlsDedErrorNotification(void);

/* When 1 bit ECC error occurs, this function will be called. */
extern FUNC(void, FEE_CODE) Fee_FlsSedErrorNotification(void);

/* Get variable Fee_FlsDedErrorNotificationVar. */
extern FUNC(uint8, FEE_CODE) Fee_GetFlsDedErrorNotificationVar(void);

/* Get variable Fee_FlsSedErrorNotificationVar. */
extern FUNC(uint8, FEE_CODE) Fee_GetFlsSedErrorNotificationVar(void);

/* Set variable Fee_FlsDedErrorNotificationVar. */
extern FUNC(void, FEE_CODE) Fee_SetFlsDedErrorNotificationVar(
  VAR(uint8, AUTOMATIC) ded_value);

/* Set variable Fee_FlsSedErrorNotificationVar. */
extern FUNC(void, FEE_CODE) Fee_SetFlsSedErrorNotificationVar(
  VAR(uint8, AUTOMATIC) sed_value);

/* Get variable Fee_InitiallyEraseEmptySectors. */
extern FUNC(uint8, FEE_CODE) Fee_GetInitiallyEraseEmptySectors(void);

/* set variable Fee_IsNextBlockCorrupt1 or Fee_IsNextBlockCorrupt2. */
extern FUNC(void, FEE_CODE) Fee_SetIsNextBlockCorrupt(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) value);

/* get variable Fee_IsNextBlockCorrupt1 or Fee_IsNextBlockCorrupt2. */
extern FUNC(uint8, FEE_CODE) Fee_GetIsNextBlockCorrupt(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index);

#define FEE_STOP_SEC_CODE_ASIL_B
#include "Fee_MemMap.h"


#endif /*!defined(FEE_PUB_H_INCLUDED)*/

