/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file defines the interface of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

#ifndef FEE_INTERNAL_H_INCLUDED
#define FEE_INTERNAL_H_INCLUDED


/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "Fee_Pub.h"
#include "Fee_Data.h"
#include <Fls_LibInterface.h>
#include <Fls_InternalLib.h>

/*****************************************************************************/
/* Global pre-processor symbols/macros ('#define')                           */
/*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-1.1
   Justification: The number of macro definition exceeds 1024 to maintain readable source code. */
/* PRQA S 857 EOF */
/*============*/
/* Macros     */
/*============*/

/* common defenition */
#define FEE_SHIFT_8BIT                   (8U)                             /* 8-bit shift */
#define FEE_SHIFT_16BIT                  (16U)                            /* 16-bit shift */
#define FEE_SHIFT_24BIT                  (24U)                            /* 24-bit shift */
#define FEE_SHIFT_32BIT                  (32U)                            /* 32-bit shift */
#define FEE_SHIFT_40BIT                  (40U)                            /* 40-bit shift */
#define FEE_SHIFT_48BIT                  (48U)                            /* 48-bit shift */
#define FEE_SHIFT_56BIT                  (56U)                            /* 56-bit shift */
#define FEE_TRUE                         (1U)                             /* true */
#define FEE_FALSE                        (0U)                             /* false */
#define FEE_ZERO                         (0U)                             /* initial value(zero clear) */

#define FEE_CONFIG_SET_1                 ((uint8)1)                       /* configuration 1 */
#define FEE_CONFIG_SET_2                 ((uint8)2)                       /* configuration 2 */

/* setting each microcomputer */
#define FEE_BLOCK_INITIAL_WRITEFLAG      (0x00000000UL)                   /* initial value of write flag */
#define FEE_BLOCK_INITIAL_VALUE          (0xFFFFFFFFUL)                   /* initial value of block status */
#define FEE_BLOCK_INITIAL_BLOCK_NO       (0xFFFFUL)                       /* initial value of block number */
#define FEE_BLOCK_INITIAL_BLOCK_INDEX    (0xFFFFUL)                       /* initial value of block index */
#define FEE_BLOCK_VALID_BLOCK            (0x00000000UL)                   /* value of Valid Status for valid block */
#define FEE_BLOCK_INVALID_BLOCK          (0x00000000UL)                   /* value of Invalid Status for invalid block */
#define FEE_BLOCK_FLAG_VALUE             (0x00000000UL)                   /* value of block flags */
#define FEE_BLOCK_INITIAL_PAGE_NO        (0x0000UL)                       /* initial value of page number */

#define FEE_BLOCK_MANAGE_SIZE            (16U)                            /* size of manage area */
#define FEE_BLOCK_BLKNUMPAGENUM_SIZE     (4U)                             /* size of Block Number and Page Number */
#define FEE_BLOCK_STATUS_SIZE            (4U)                             /* size of Valid Status or Invalid Status */
#define FEE_BLOCK_WRITEFLAG_SIZE         (4U)                             /* size of Write FLAG */

#define FEE_ERASE_COMPLETE_FLAG_SIZE     (4U)                             /* size of erase complete flag */
#define FEE_SECTOR_ONE_STATUS_SIZE       (4U)                             /* size of sector status */
#define FEE_SECTOR_STATUS_SIZE           (12U)                            /* size of all sector status */
#define FEE_SECTOR_RECYCLE_FLAG_SIZE     (4U)                             /* size of recycle flag */
#define FEE_PSC_SIZE                     (4U)                             /* size of psc */
#define FEE_PSC_OFFSET                   (FEE_SECTOR_STATUS_SIZE + FEE_SECTOR_RECYCLE_FLAG_SIZE)  /* offset of recycle count flag from top of sector */
#define FEE_TOP_BLOCK_OFFSET             (FEE_PSC_OFFSET + FEE_PSC_SIZE)  /* offset of block from top of sector */
#define FEE_SECOND_BLOCK_OFFSET          (FEE_TOP_BLOCK_OFFSET + FEE_BLOCK_MANAGE_SIZE) /* offset of second block from top of sector */
#define FEE_THIRD_BLOCK_OFFSET           (FEE_TOP_BLOCK_OFFSET + FEE_BLOCK_MANAGE_SIZE*2U) /* offset of third block from top of sector */

#define FEE_INITIAL_COUNTER_NUM          (0U)                             /* initial value for timer counter */

#define FEE_BLKIDX_INVALID_BLOCK           ((uint8)0x11U)             /* value indicates the block is an invalid block */
#define FEE_BLKIDX_VALID_BLOCK             ((uint8)0x00U)             /* value indicates the block is a valid block */
#define FEE_BLKIDX_NO_BLOCK_EXIST          ((uint8)0xFFU)             /* value indicates the block is not exist on flash */
#define FEE_BLKIDX_NEED_REFRESH            ((uint8)0x22U)             /* initial value of address index of blocks */
#define FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE  ((uint8)0x33U)             /* value indicates the block is a valid block */
#define FEE_BLKIDX_CORRUPT_BLOCK           ((uint8)0x44U)             /* value indicates the block is a corrupt block */


/* return values */
#define FEE_OK                           ((uint8)0)                   /* OK */
#define FEE_NG                           ((uint8)1)                   /* NG */
#define FEE_NONE_SECTOR                  ((uint8)0)                   /* no sector */
#define FEE_BLOCK_NONE_SEARCH            ((uint8)3)                   /* data none */
#define FEE_INVALID_SECTOR_NO            ((uint8)254)                 /* invalid sector number */
#define FEE_CONT                         ((uint8)255)                 /* continue */

/* parameter of Fee_Reset */
#define FEE_RESET_INIT                   ((uint8)0)                   /* reset for initilaize */
#define FEE_RESET_CANCEL                 ((uint8)1)                   /* reset for cancelling */

/* parameter of Fee_SetSector */
#define FEE_SECTOR_NOSTATUS              ((uint8)0)                   /* no status */
#define FEE_SECTOR_DISABLE               ((uint8)1)                   /* disable */
#define FEE_SECTOR_ENABLE                ((uint8)2)                   /* enable */
#define FEE_SECTOR_MOVING                ((uint8)3)                   /* data Moving */
#define FEE_SECTOR_GARBAGE               ((uint8)4)                   /* erasing */
#define FEE_RECYCLE_FLAG                 ((uint8)5)                   /* dector recycle flag */
#define FEE_SECTOR_UNKNOWN               ((uint8)0x0FU)               /* unknown(odd) */
#define FEE_SECTOR_EFFECTIVE             ((uint8)0x10U)               /* reading/moving target */

/* value for main state */
#define FEE_MAIN_STATE_NONE              ((uint16)0x0U)               /* no status */
#define FEE_MAIN_STATE_INITIALIZING      ((uint16)0x1U)               /* initializing */
#define FEE_MAIN_STATE_WRITING           ((uint16)0x2U)               /* writing */
#define FEE_MAIN_STATE_RECYCLING         ((uint16)0x4U)               /* recycling */
#define FEE_MAIN_STATE_RECOVERING        ((uint16)0x08U)              /* Data Flash recovering */
#define FEE_MAIN_STATE_READING           ((uint16)0x10U)              /* reading */
#define FEE_MAIN_STATE_INVALIDATING      ((uint16)0x20U)              /* Data Flash invalidating */
#define FEE_MAIN_STATE_CANCELING         ((uint16)0x40U)              /* Data Flash write cancelling */
#define FEE_MAIN_STATE_DATACOPY          ((uint16)0x80U)              /* Data copying */
#define FEE_MAIN_STATE_CLEARING          ((uint16)0x100U)             /* clearing all sector */
#define FEE_MAIN_STATE_RECYCEND          ((uint16)0xFBU)              /* recycling end */

#define FEE_SECTOR_STATUS_DATA_INIT      (0xFFFFFFFFUL)               /* initial value */
#define FEE_SECTOR_STATUS_DATA_SET       (0xCC33C33CUL)               /* valid value */


#define FEE_SECTOR_STATUS_OFFSET         ((uint8)1)                   /* Offset between sector_no and index of sector status */

#define FEE_PROC_START                   ((uint8)0)                   /* beginning of periodic function */
#define FEE_PROC_NOTINITIALIZE           ((uint8)0)                   /* unset for proc */

#define FEE_CALL_DEPTH_MAX               ((uint8)15)                  /* max depth of calling */
#define FEE_MEMCPY1_MAX                  ((uint16)304)                /* max count for memory copy(1byte unit) */
#define FEE_BLKCFGCHK_MAX                ((uint16)253)                /* max count for block config info check */
#define FEE_OVERWRITE_BLOCK_FLAG_MAX     ((uint8)63)                  /* max count for searching block in Fee_OverWriteBlockFlag */
#define FEE_CPY_BLK_INDEX_MAX            ((uint8)63)                  /* max count for copying block index in recycle */
#define FEE_BLOCK_SIZE_MAX               ((uint16)3072)               /* max size for block */


#define FEE_BLANK_CHECK_UNDO             (0U)                         /* blank check is not executed */
#define FEE_BLANK_CHECK_DONE             (1U)                         /* blank check has already done */

#define FEE_ON                           (1U)                         /* for ON, STD_ON=0x01 */
#define FEE_OFF                          (0U)                         /* for OFF,STD_OFF=0x00 */

#define FEE_CONFIG_IS_DIFFERENT          ((uint8)0)                   /* current config is different with work flash */
#define FEE_CONFIG_IS_SAME               ((uint8)1)                   /* current config is same with work flash */


#define FEE_CHECK_OLD_CONFIG_AND_COMPARE_MAX               ((uint8)1)        /* max count for checking physical sector */
#define FEE_CHECK_OLD_CONFIG_AND_COMPARE_MAX_FOR_BC_OFF    ((uint8)40)       /* max count for checking physical sector when blank check is OFF */

#define FEE_RESTORE_INDEX_YES            ((uint8)1)                   /* resotre the block index */
#define FEE_RESTORE_INDEX_NO             ((uint8)0)                   /* maintain the block index that has been updated */

#define FEE_BLOCK_INDEX_UPDATED_YES      ((uint8)1)                   /* block index has already updated to the variable Fee_BlockAddrIndex */
#define FEE_BLOCK_INDEX_UPDATED_NO       ((uint8)0)                   /* block index has not been updated to the variable Fee_BlockAddrIndex */

#define FEE_ADJUSTING_USE_NEW_STRUCT      ((uint8)1)                   /* use new struct */
#define FEE_ADJUSTING_USE_OLD_STRUCT      ((uint8)0)                   /* use old struct */

#define FEE_CHECK_BYTES_ALIGN             ((uint8)8)                   /* check bytes align */

#define FEE_USE_FLASH_TO_FLASH            ((uint8)1)                   /* write Flash to Flash */
#define FEE_USE_RAM_TO_FLASH              ((uint8)0)                   /* write Flash to Ram, then write Ram to Flash */

#define FEE_RECYCLE_USE_INDEX            ((uint8)1)                    /* use index when recycle */
#define FEE_RECYCLE_SEARCH_FLASH         ((uint8)0)                    /* search flash when recycle */

#define FEE_NEXT_BLOCK_IS_CORRUPT        ((uint8)1)                    /* next block is corrupt */
#define FEE_NEXT_BLOCK_IS_NOT_CORRUPT    ((uint8)0)                    /* next block is not corrupt */

/*===========*/
/* Utilities */
/*===========*/
/* The parameter is start from 1. */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: Improves readability of the address calculation operations. */
/* PRQA S 3453 1 */
#define FEE_GET_FLASH_SECTOR_START_ADDR(x)   ((uint8*)(Fee_GetSecTopAddr()) + ((uint32)Fee_GetSectorSize() * ((uint32)(x) - 1U)))

/* The parameter is start from 1. */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: Improves readability of the address calculation operations. */
/* PRQA S 3453 1 */
#define FEE_GET_FLASH_SECTOR_START_ADDR_OLD(x)   ((uint8*)(Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr) + ((uint32)(Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize) * ((uint32)(x) - 1U)))

/* push current process position */
#define FEE_PUSH_PROC(proc)                                             \
{                                                                       \
    Fee_PushProc((uint8)(proc));                                        \
}

/* pop current process position */
#define FEE_POP_PROC(proc, type)                                        \
{                                                                       \
    (proc) = (type)Fee_PopProc();                                       \
}

/* set current process position */
#define FEE_SET_PROC(proc)                                                 \
{                                                                          \
    Fee_MainProc[(Fee_PeriInfo.Fee_MainDepth - (uint8)1)] = (uint8)(proc); \
}

/* FEE state set macro */
/* Deviation from MISRA-C:2004 rule 19.10, MISRA-C:2012 Rule-20.7
   Justification: This is just a substitution operation. There is nothing special about the algorithm 
   using the status variable. There is no problem with this logic. */
/* PRQA S 3410 5 */
#define FEE_STATE_SET(state)                                            \
{                                                                       \
    Fee_ModuleState = state;                                            \
    Fee_ModuleStateMirror = state;                                      \
}

/* push in-process data to stack (uint32 type) */
#define FEE_PUSH_STACK_ULONG(var)                                                             \
{                                                                                             \
    ULONG_TO_UCHAR(&Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos], (var));                        \
    Fee_PeriInfo.Fee_MainStackPos += (uint8)sizeof(uint32);                                   \
}

/* push in-process data to stack (uint16 type) */
#define FEE_PUSH_STACK_USHORT(var)                                                            \
{                                                                                             \
    USHORT_TO_UCHAR(&Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos], (var));                       \
    Fee_PeriInfo.Fee_MainStackPos += (uint8)sizeof(uint16);                                   \
}

/* push in-process data to stack (uint8 type) */
/* Deviation from MISRA-C:2004 rule 19.10, MISRA-C:2012 Rule-20.7
   Justification: This is just a substitution operation. There is nothing special about the algorithm 
   using the var variable. There is no problem with this logic. */
/* PRQA S 3410 8 */
#define FEE_PUSH_STACK_UCHAR(var)                                                             \
{                                                                                             \
    Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos] = var;                                       \
    Fee_PeriInfo.Fee_MainStackPos += (uint8)sizeof(uint8);                                    \
}

/* push in-process data to stack ( pointer type) */
#define FEE_PUSH_STACK_POINTER(pval)                                                          \
{                                                                                             \
    FEE_POINTER_TO_UCHAR(&Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos], (pval));                 \
    Fee_PeriInfo.Fee_MainStackPos += (uint8)sizeof(void *);                                   \
}


/* pop in-process data to stack (uint32 type) */
#define FEE_POP_STACK_ULONG(var)                                                              \
{                                                                                             \
    Fee_PeriInfo.Fee_MainStackPos -= (uint8)sizeof(uint32);                                   \
    UCHAR_TO_ULONG((var), &Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos]);                        \
}

/* pop in-process data to stack (uint16 type) */
#define FEE_POP_STACK_USHORT(var)                                                             \
{                                                                                             \
    Fee_PeriInfo.Fee_MainStackPos -= (uint8)sizeof(uint16);                                   \
    UCHAR_TO_USHORT((var), &Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos]);                       \
}

/* pop in-process data to stack (uint8 type) */
#define FEE_POP_STACK_UCHAR(var)                                                              \
{                                                                                             \
    Fee_PeriInfo.Fee_MainStackPos -= (uint8)sizeof(uint8);                                    \
    (var) = Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos];                                     \
}

/* pop in-process data to stack (pointer type) */
/* Deviation from MISRA-C:2004 rule 19.10, MISRA-C:2012 Rule-20.7
   Justification: The macro parameter "type" means the cast type, and it must not be enclosed in parentheses for compiling.
                  This deviation is due to use of code block as macro function because of benefit for readability. */
/* PRQA S 3410 10 */
#define FEE_POP_STACK_POINTER(pval, type)                                                     \
{                                                                                             \
    Fee_PeriInfo.Fee_MainStackPos -= (uint8)sizeof(void*);                                    \
    UCHAR_TO_POINTER((pval), &Fee_MainStack[Fee_PeriInfo.Fee_MainStackPos], type);               \
}

/* copy pointer data to uint8 area */
#define FEE_POINTER_TO_UCHAR(u1p, pval)                                \
{                                                                      \
    *((u1p)    ) = (uint8)(((uint32)(pval)) >> FEE_SHIFT_24BIT);       \
    *((u1p) + 1) = (uint8)(((uint32)(pval)) >> FEE_SHIFT_16BIT);       \
    *((u1p) + 2) = (uint8)(((uint32)(pval)) >> FEE_SHIFT_8BIT);        \
    *((u1p) + 3) = (uint8)(((uint32)(pval))                  );        \
}

/* copy uint64 data to uint8 area */
#define ULONGLONG_TO_UCHAR(u1p, u8val)                                 \
{                                                                      \
    *((u1p)    ) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_56BIT);      \
    *((u1p) + 1) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_48BIT);      \
    *((u1p) + 2) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_40BIT);      \
    *((u1p) + 3) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_32BIT);      \
    *((u1p) + 4) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_24BIT);      \
    *((u1p) + 5) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_16BIT);      \
    *((u1p) + 6) = (uint8)(((uint64)(u8val)) >> FEE_SHIFT_8BIT);       \
    *((u1p) + 7) = (uint8)(((uint64)(u8val))                  );       \
}

/* copy uint32 data to uint8 area */
#define ULONG_TO_UCHAR(u1p, u4val)                                     \
{                                                                      \
    *((u1p)    ) = (uint8)(((uint32)(u4val)) >> FEE_SHIFT_24BIT);      \
    *((u1p) + 1) = (uint8)(((uint32)(u4val)) >> FEE_SHIFT_16BIT);      \
    *((u1p) + 2) = (uint8)(((uint32)(u4val)) >> FEE_SHIFT_8BIT);       \
    *((u1p) + 3) = (uint8)(((uint32)(u4val))                  );       \
}

/* copy uint16 data to uint8 area */
#define USHORT_TO_UCHAR(u1p, u2val)                                    \
{                                                                      \
    *((u1p)    ) = (uint8)(((uint16)(u2val)) >> FEE_SHIFT_8BIT );      \
    *((u1p) + 1) = (uint8)(((uint16)(u2val))                  );       \
}

/* copy uint8 data to pointer data area */
/* Deviation from MISRA-C:2004 rule 19.10, MISRA-C:2012 Rule-20.7
   Justification: The macro parameter "type" means the cast type, and it must not be enclosed in parentheses for compiling.
                  This deviation is due to use of code block as macro function because of benefit for readability. */
/* PRQA S 3410 8 */
#define UCHAR_TO_POINTER(pval,u1p,type)                                \
{                                                                      \
    (pval) = (type*)(                                                  \
             (((uint32)(*((u1p)    ))) << FEE_SHIFT_24BIT)             \
           | (((uint32)(*((u1p) + 1))) << FEE_SHIFT_16BIT)             \
           | (((uint32)(*((u1p) + 2))) << FEE_SHIFT_8BIT)              \
           | (((uint32)(*((u1p) + 3)))                  ));            \
}

/* copy uint8 data to uint64 data area */
#define UCHAR_TO_ULONGLONG(u8val, u1p)                                 \
{                                                                      \
    (u8val) = (                                                        \
              (((uint64)(*((u1p)    ))) << FEE_SHIFT_56BIT)            \
            | (((uint64)(*((u1p) + 1))) << FEE_SHIFT_48BIT)            \
            | (((uint64)(*((u1p) + 2))) << FEE_SHIFT_40BIT)            \
            | (((uint64)(*((u1p) + 3))) << FEE_SHIFT_32BIT)            \
            | (((uint64)(*((u1p) + 4))) << FEE_SHIFT_24BIT)            \
            | (((uint64)(*((u1p) + 5))) << FEE_SHIFT_16BIT)            \
            | (((uint64)(*((u1p) + 6))) << FEE_SHIFT_8BIT)             \
            | (((uint64)(*((u1p) + 7)))                  ));           \
}

/* copy uint8 data to uint32 data area */
#define UCHAR_TO_ULONG(u4val, u1p)                                     \
{                                                                      \
    (u4val) = (                                                        \
              (((uint32)(*((u1p)    ))) << FEE_SHIFT_24BIT)            \
            | (((uint32)(*((u1p) + 1))) << FEE_SHIFT_16BIT)            \
            | (((uint32)(*((u1p) + 2))) << FEE_SHIFT_8BIT)             \
            | (((uint32)(*((u1p) + 3)))                  ));           \
}

/* copy uint8 data to uint16 area */
#define UCHAR_TO_USHORT(u2val, u1p)                                    \
{                                                                      \
    (u2val)  = (                                                       \
               (uint16)(((uint16)(*((u1p)    ))) << FEE_SHIFT_8BIT )   \
             | (uint16)(((uint16)(*((u1p) + 1)))                  ));  \
}


/*****************************************************************************/
/* Global type definitions ('typedef')                                       */
/*****************************************************************************/

/* the information of block when searching from workflash */
typedef struct
{
    VAR(uint32, AUTOMATIC)  write_start_flag;                            /* block management infor */
    VAR(uint32, AUTOMATIC)  bnum_pnum;                                   /* block management infor */
    VAR(uint32, AUTOMATIC)  valid_status;                                /* block management infor */
    VAR(uint32, AUTOMATIC)  invalid_status;                              /* block management infor */
} Fee_SearchWorkFlashInfoType;

/*==========================*/
/* Value of the processing  */
/*==========================*/
/* for Fee_MainInit() */
typedef enum {
    FEE_INIT_START = FEE_PROC_START,      /* entry of periodic processing */
    FEE_INIT_SELECT_CONFIG_AREA,          /* select target configuration area */
    FEE_INIT_GET_IMMDATA_INITIAL_VALUE,   /* get initial value of immediate date reserve size */
    FEE_INIT_RECOVER,                     /* recover the target area */
    FEE_INIT_END                          /* end of periodic processing */
} Fee_InitProcType;

/* for Fee_MainWrite() */
typedef enum {
    FEE_MAIN_WRITE_START = FEE_PROC_START, /* entry of periodic processing */
    FEE_MAIN_WRITE_CHECK_SECTORS,          /* check sectors */
    FEE_MAIN_WRITE_SET_ERASING_SECTOR,     /* set erasing sector */
    FEE_MAIN_WRITE_PROC,                   /* execute periodic processing of writing */
    FEE_MAIN_WRITE_END                     /* end of periodic processing */
} Fee_MainWriteProcType;

/* for Fee_MainWriteProc() */
typedef enum {
    FEE_WRITE_START = FEE_PROC_START,    /* entry of periodic processing */
    FEE_WRITE_CLEAR_GLOBAL_VAR,          /* clear global variable */
    FEE_WRITE_CHECK_BLOCK_ADDRESS_INDEX, /* check block address index */
    FEE_WRITE_PRE_CHECK_EMPTY_SIZE,      /* distinguish write date before checking empty space size */
    FEE_WRITE_CHECK_EMPTY_SIZE,          /* check empty space size */
    FEE_WRITE_GET_SECTOR_FOR_RECYCLE,    /* get sector number for recycling */
    FEE_WRITE_RECYCLE_START,             /* recycle sector start */
    FEE_WRITE_RECYCLE,                   /* recycle sector */
    FEE_WRITE_RECYCLE_CHECK,             /* check result of recycling */
    FEE_WRITE_GET_OLD_BLOCK_PAGENO,      /* get old block page no */
    FEE_WRITE_CHECK_SAME_BLOCK,          /* check same block */
    FEE_WRITE_CHECK_SAME_BLOCK_CHECK,    /* check result of check same block */
    FEE_WRITE_MAKE_BLOCK,                /* make block */
    FEE_WRITE_PRE_WRITE_BLOCK,           /* check empty address before writing block */
    FEE_WRITE_SEARCH_BLANK_AREA,         /* search blank area(only search unexecuted) */
    FEE_WRITE_WRITE_BLOCK,               /* write block and verify */
    FEE_WRITE_DISABLE,                   /* invalidate old block */
    FEE_WRITE_DISABLE_CHECK,             /* check result of invalidating old block */
    FEE_WRITE_END                        /* end of periodic processing  */
} Fee_WriteProcType;

/* for Fee_MainRead() */
typedef enum {
    FEE_READ_START = FEE_PROC_START,     /* entry of periodic processing */
    FEE_READ_CHECK_BLOCK_ADDRESS_INDEX,  /* check block address index */
    FEE_READ_GET_ADDRESS_BY_INDEX,       /* get address by index */
    FEE_READ_GET_BLOCKNO_PAGENO,         /* get block no page no */
    FEE_READ_COPYDATA,                   /* data copy */
    FEE_READ_COPYDATA_CHECK,             /* check result of data copy */
    FEE_READ_END                         /* end of periodic processing */
} Fee_ReadProcType;

/* for Fee_MainInvalidate() */
typedef enum {
    FEE_MAIN_INVAL_START = FEE_PROC_START,    /* entry of periodic processing */
    FEE_MAIN_INVAL_CHECK_SECTORS,             /* check sectors */
    FEE_MAIN_INVAL_SET_ERASING_SECTOR,        /* set erasing sector */
    FEE_MAIN_INVAL_PROC,                      /* execute periodic processing of invalidating */
    FEE_MAIN_INVAL_END                        /* end of periodic processing */
} Fee_MainInvalProcType;

/* for Fee_MainInvalidateProc() */
typedef enum {
    FEE_INVAL_START = FEE_PROC_START,               /* entry of periodic processing */
    FEE_INVAL_CHECK_BLOCK_ADDRESS_INDEX,            /* check block address index */
    FEE_INVAL_PRE_CHECK_EMPTY_SIZE,                 /* distinguish invalidate date before checking empty space size */
    FEE_INVAL_CHECK_EMPTY_SIZE,                     /* check empty size */
    FEE_INVAL_GET_SECTOR_FOR_RECYCLE,               /* get sector number for recycling */
    FEE_INVAL_RECYCLE_START,                        /* recycle sector start*/
    FEE_INVAL_RECYCLE,                              /* recycle sector */
    FEE_INVAL_RECYCLE_CHECK,                        /* check result of recycling */
    FEE_INVAL_DISABLE,                              /* invalidate block */
    FEE_INVAL_DISABLE_CHECK,                        /* check result of invalidating block */
    FEE_INVAL_END                                   /* end of periodic processing */
} Fee_InvalProcType;

/* for Fee_MainClear */
typedef enum {
    FEE_CLEAR_START = FEE_PROC_START,    /* entry of periodic processing */
    FEE_CLEAR_ERASE_SECTOR,              /* erase sector */
    FEE_CLEAR_END                        /* end of periodic processing */
} Fee_ClearProcType;

/* for Fee_EraseProc */
typedef enum {
    FEE_ERASE_START = FEE_PROC_START,                /* entry of periodic processing */
    FEE_ERASE_GET_ERASE_SECTOR,                      /* search erase sector */
    FEE_ERASE_ERASE_SECTOR,                          /* erase sector */
    FEE_ERASE_END                                    /* end of periodic processing */
} Fee_EraseProcType;

/* for Fee_WriteEraseCompleteFlag */
typedef enum {
    FEE_WRITE_FLAG_START = FEE_PROC_START,    /* entry of periodic processing */
    FEE_WRITE_FLAG_WRITE,                     /* write flag */
    FEE_WRITE_FLAG_CHECK,                     /* check result of writing erase complete flag */
    FEE_WRITE_FLAG_END                        /* end of periodic processing */
} Fee_WriteFlagProcType;

/* for Fee_Recover */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 25 */
typedef enum {
    FEE_RECOVER_START = FEE_PROC_START,  /* entry of periodic processing */
    FEE_RECOVER_CHECK_OLD_CONFIG,        /* check old config */
    FEE_RECOVER_CHECK_ODD_SECTORS,       /* check odd sector */
    FEE_RECOVER_CHECK_RECYCLE_NEED,      /* check recycle need */
    FEE_RECOVER_GET_DISABLE_SECTOR,      /* get disable sector */
    FEE_RECOVER_ERASE_FOR_NOW,           /* erase sector */
    FEE_RECOVER_REGET_DISABLE_SECTOR,    /* re-get disable sector */
    FEE_RECOVER_OVERWRITE_ERASE_FLAG,    /* overwrite erase complete flag of disable sector */
    FEE_RECOVER_OVERWRITE_ERASE_FLAG_CHECK, /* check overwrite erase complete flag */
    FEE_RECOVER_SET_PSC,                 /* set psc */
    FEE_RECOVER_SET_PSC_CHECK,           /* check result of writing psc */
    FEE_RECOVER_SET_ENABLE_SECTOR,       /* set enable sector */
    FEE_RECOVER_OVERWRITE_ENABLESECTOR,  /* overwrite enable sector */
    FEE_RECOVER_SET_ERASING_SECTOR,      /* set erasing sector */
    FEE_RECOVER_GET_BLANK_AREA,          /* get and check blank area on valid flash */
    FEE_RECOVER_OVERWRITE_ENABLE_STATUS, /* overwrite sector status flag1 when the valid sector has no block */
    FEE_RECOVER_CREATE_BLOCK_INDEX,      /* create index for blocks */
    FEE_RECOVER_OVERWRITE_BLOCK_FLAG,    /* Overwrite invalid flag for all invalid blocks and valid flag for the last valid block */
    FEE_RECOVER_RECYCLE_START,           /* check empty block */
    FEE_RECOVER_RECYCLE,                 /* recycle sector */
    FEE_RECOVER_RECYCLE_CHECK,           /* check result of recycling */
    FEE_RECOVER_ADJUSTING_WORK_FLASH,    /* configuration is changed, adjusting work flash */
    FEE_RECOVER_END                      /* end of periodic processing */
} Fee_RecoverProcType;

/* for Fee_RecyclePolling */
typedef enum {
    FEE_RECYCLE_START = FEE_PROC_START,  /* entry of periodic processing */
    FEE_RECYCLE_FLAG_GET,                /* get recycle flag */
    FEE_RECYCLE_FLAG_SET,                /* set recycle flag */
    FEE_RECYCLE_READY_FOR_ERASE_GARBAGE_SECTOR, /* ready for erase former recycling source sector */
    FEE_RECYCLE_ERASE_GARBAGE_SECTOR,    /* erase garbage sector */
    FEE_RECYCLE_SET_MOVING_SECTOR,       /* set moving sector */
    FEE_RECYCLE_GET_DST_SECTOR,          /* get destination sector */
    FEE_RECYCLE_SET_PSC,                 /* set psc */
    FEE_RECYCLE_SET_PSC_CHECK,           /* check result of writing psc */
    FEE_RECYCLE_RECREATE_BLOCK_INDEX,    /* re-create block index */
    FEE_RECYCLE_GET_WRITESTARTFLAG,      /* get write start flag blank or not */
    FEE_RECYCLE_GET_BNUMANDPNUM,         /* get blocknumber and page number blank or not */
    FEE_RECYCLE_GET_VALIDFLAG,           /* get valid flag blank or not */
    FEE_RECYCLE_GET_INVALIDFLG,          /* get invalid flag blank or not */
    FEE_RECYCLE_SAVE_BLOCK_INFOR,        /* save block infor to variable */
    FEE_RECYCLE_GET_ENABLE_DATA,         /* search enable block from destination sector */
    FEE_RECYCLE_GET_BLOCKNO_PAGENO,      /* get block no page no */
    FEE_RECYCLE_SET_ERASING_SECTORDST,   /* set erasing sector destination */
    FEE_RECYCLE_COPY_TO_BUFFER_FOR_LAST_VALID_BLOCK, /* copy src data to buffer for last valid block */
    FEE_RECYCLE_WRITE_BLOCK,             /* write block */
    FEE_RECYCLE_BLOCK_INVALID,           /* invalid multi valid blocks */
    FEE_RECYCLE_BLOCK_INVALID_CHECK,     /* check the result of invaliding multi valid blocks  */
    FEE_RECYCLE_WRITE_BLOCK_UPDATE_INDEX,/* update index after block copy */
    FEE_RECYCLE_SET_ENABLE_SECTOR,       /* set enable sector */
    FEE_RECYCLE_SET_ERASING_SECTORSRC,   /* set erasing sector source */
    FEE_RECYCLE_CHANGE_BLK_IDX_STATUS,   /* change block index status */
    FEE_RECYCLE_END                      /* end of periodic processing */
} Fee_RecycleProcType;

/* for Fee_WriteBlock */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 15 */
typedef enum {
    FEE_WRITEBLK_START = FEE_PROC_START, /* entry of periodic processing */
    FEE_WRITEBLK_BLKWRITEFLAG,           /* write write flag */
    FEE_WRITEBLK_BLKWRITEFLAG_CHECK,     /* check result of write write flag */
    FEE_WRITEBLK_BLKNUMPAGENUM,          /* write Block Number and Page Number */
    FEE_WRITEBLK_BLKNUMPAGENUM_CHECK,    /* check result of write Block Number and Page Number */
    FEE_WRITEBLK_DATA,                   /* write data */
    FEE_WRITEBLK_TRIGGER_WRITE_DATA,     /* trigger write data */
    FEE_WRITEBLK_DATA_CHECK,             /* check result of write data */
    FEE_WRITEBLK_TRIGGER_WRITE_DATA_FOR_SECOND_PART, /* trigger write data for second part */
    FEE_WRITEBLK_DATA_CHECK_FOR_SECOND_PART, /* check result of write data for second part */
    FEE_WRITEBLK_VALIDSTAT,              /* write Valid Status */
    FEE_WRITEBLK_VALIDSTAT_CHECK,        /* check result of write Valid Status */
    FEE_WRITEBLK_DISABLE,                /* invalidate block */
    FEE_WRITEBLK_DISABLE_CHECK,          /* check result of invalidate block */
    FEE_WRITEBLK_END                     /* end of periodic processing */
} Fee_WriteBlkProcType;

/* for Fee_MemCpy1 */
typedef enum {
    FEE_MEMCPY1_START = FEE_PROC_START,  /* entry of periodic processing */
    FEE_MEMCPY1_CPY,                     /* copy memory */
    FEE_MEMCPY1_PAD                      /* pad remainder */
} Fee_Memcpy1ProcType;

/* for Fee_SetSector */
typedef enum {
    FEE_SET_STATUS_START = FEE_PROC_START, /* entry of periodic processing */
    FEE_SET_STATUS_SET,                  /* set sector status */
    FEE_SET_STATUS_SET_FINAL,            /* check completion of writing sector status */
    FEE_SET_STATUS_CHECK,                /* check result of writing sector status */
    FEE_SET_STATUS_RECHECK,              /* re-check result of writing sector status */
    FEE_SET_STATUS_RECYCLE_FLAG_CHECK,   /* check result of writing recycle flag */
    FEE_SET_STATUS_END                   /* end of periodic processing */
} Fee_SetStatusProcType;

/* for Fee_BlockIndexCheck() */
typedef enum {
    FEE_BLOCK_INDEX_CHECK_START = FEE_PROC_START,   /* entry of periodic processing */
    FEE_BLOCK_INDEX_GET_SECTOR_NO,                  /* get sector no */
    FEE_BLOCK_INDEX_CHECK_CHECK,                    /* check block address index */
    FEE_BLOCK_INDEX_CHECK_REFRESH_ADDRESS_INDEX,    /* refresh address index */
    FEE_BLOCK_INDEX_CHECK_BLANK_CHECK,              /* block blank check */
    FEE_BLOCK_INDEX_CHECK_END                       /* end of periodic processing */
} Fee_BlockIndexCheckProcType;

/* for Fee_OverWriteBlockFlag() */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 8 */
typedef enum {
    FEE_OVERWRITE_BLOCK_FLAG_START = FEE_PROC_START,   /* entry of periodic processing */
    FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG,       /* write invalid flag */
    FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG_CHECK, /* check result of write invalid flag */
    FEE_OVERWRITE_BLOCK_FLAG_WRITE_LAST_VALID,         /* write the lasted valid flag */
    FEE_OVERWRITE_BLOCK_FLAG_WRITE_LAST_VALID_CHECK,   /* check result of valid write flag */
    FEE_OVERWRITE_BLOCK_FLAG_END                       /* end of periodic processing */
} Fee_OverwriteBlockFlagProcType;

/* for Fee_EraseSectorProc */
typedef enum {
    FEE_ERASE_SECTOR_START = FEE_PROC_START,         /* entry of periodic processing */
    FEE_ERASE_SECTOR_LAST_SECTOR,                    /* erase erase_flag physics sector */
    FEE_ERASE_SECTOR_TRIGGER_ERASE,                  /* trigger erase */
    FEE_ERASE_SECTOR_LAST_SECTOR_CHECK,              /* check result of erase erase_flag physics sector */
    FEE_ERASE_SECTOR_REST_SECTOR,                    /* erase sectors except erase_falg physics sector */
    FEE_ERASE_SECTOR_REST_SECTOR_CHECK,              /* check result of erasing sector */
    FEE_ERASE_SECTOR_WRITE_FLAG,                     /* write erase complete flag */
    FEE_ERASE_SECTOR_WRITE_FLAG_CHECK,               /* check result of writing erase complete flag */
    FEE_ERASE_SECTOR_END                             /* end of periodic processing */
} Fee_EraseSectorProcType;

/* for Fee_MainCommon */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 7 */
typedef enum {
    FEE_MAIN_COMMON_START = FEE_PROC_START,          /* entry of periodic processing */
    FEE_MAIN_COMMON_CHECK_STATUS_MIRROR,             /* check sector status and sector status mirror */
    FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG,     /* update sector status in config */
    FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG_EX,  /* update sector status in config ex */
    FEE_MAIN_COMMON_END                              /* end of periodic processing */
} Fee_MainCommonProcType;

/* for Fee_GetSectorFirst */
typedef enum {
    FEE_SECTOR_FIRST_START = FEE_PROC_START,          /* entry of periodic processing */
    FEE_SECTOR_FIRST_CHK_ERASE_FLAG,                  /* check erase complete flag */
    FEE_SECTOR_FIRST_CHK_GARBAGE_FLAG,                /* check garbage flag */
    FEE_SECTOR_FIRST_CHK_MOVING_FLAG,                 /* check moving flag */
    FEE_SECTOR_FIRST_CHK_VALID_FLAG,                  /* check valid flag */
    FEE_SECTOR_FIRST_CHK_BLOCK_HEAD_INFO,             /* check block head information */
    FEE_SECTOR_FIRST_END                              /* end of periodic processing */
} Fee_SectorFirstProcType;

/* for cancel write */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 10 */
typedef enum {
    FEE_CANCEL_WRITE_START = FEE_PROC_START,          /* entry of periodic processing */
    FEE_CANCEL_WRITE_WRITE_FLAG_CHECK,                /* check write start flag */
    FEE_CANCEL_WRITE_BID_PID_WRITE,                   /* write Block ID and Page ID */
    FEE_CANCEL_WRITE_BID_PID_WRITE_CHECK,             /* check write Block ID and Page ID complete */
    FEE_CANCEL_WRITE_INVALID_FLAG_WRITE,              /* write invalid flag */
    FEE_CANCEL_WRITE_INVALID_FLAG_WRITE_CHECK,        /* check write invalid flag complete */
    FEE_CANCEL_WRITE_UPDATE_EMPTY_SIZE,               /* update empty area size */
    FEE_CANCEL_WRITE_END                              /* end of periodic processing */
} Fee_CancelWriteProcType;

/* for Fee_AdjustingWorkFlash */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 34 */
typedef enum {
    FEE_ADJUSTING_WORK_FLASH_START = FEE_PROC_START,          /* entry of periodic processing */
    FEE_ADJUSTING_WORK_FLASH_RESTART_INIT_STACK,              /* after OLD_CONSTRUCTION_MOVING, restart */
    FEE_ADJUSTING_WORK_FLASH_RESTART,                         /* after OLD_CONSTRUCTION_MOVING, restart */
    FEE_ADJUSTING_WORK_FLASH_ERASE_SECTOR,                    /* erase other sectors except the source sector */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING1_GET_ERASE_TARGET,        /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2_CHK_RET,        /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2A_SET_EFLAG,     /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2B_CHK_EFLAG,     /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING3_SET_MOVE,       /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4_CHK_BLK,        /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4A_MEMORY_COPY,   /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING5_WRT_BLK,        /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING6_CHK_PSC,        /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING7_SET_ENABLE,     /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING8_SET_GARBAGE,    /* move data from source to destination via old construction when there only two sector and no sector to erase */
    FEE_ADJUSTING_WORK_FLASH_SET_MOVING_SECTOR,               /* set source sector to moving */
    FEE_ADJUSTING_WORK_FLASH_GET_DST_SECTOR,                  /* get destination sector */
    FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG,              /* get write start flag blank or not */
    FEE_ADJUSTING_WORK_FLASH_GET_BNUMANDPNUM,                 /* get blocknumber and page number blank or not */
    FEE_ADJUSTING_WORK_FLASH_GET_VALIDFLAG,                   /* get valid flag blank or not */
    FEE_ADJUSTING_WORK_FLASH_GET_INVALIDFLG,                  /* get invalid flag blank or not */
    FEE_ADJUSTING_WORK_SAVE_BLOCK_INFOR,                      /* save block infor to variable */
    FEE_ADJUSTING_WORK_FLASH_GET_ENABLE_DATA,                 /* search enable block from source sector */
    FEE_ADJUSTING_WORK_FLASH_GET_BLOCKNO_PAGENO,              /* get block no page no */
    FEE_ADJUSTING_WORK_COPY_TO_BUFFER_FOR_LAST_VALID_BLOCK,   /* copy src data to buffer for last valid block */
    FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK,                     /* write block */
    FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK_UPDATE_INDEX,        /* update index after block copy */
    FEE_ADJUSTING_WORK_FLASH_WRITE_DISABLE,                   /* invalidate old block */
    FEE_ADJUSTING_WORK_FLASH_WRITE_DISABLE_CHECK,             /* check result of invalidating old block */
    FEE_ADJUSTING_WORK_FLASH_SET_PSC,                         /* set PSC(physical sector count) */
    FEE_ADJUSTING_WORK_FLASH_SET_PSC_CHECK,                   /* check result of writing */
    FEE_ADJUSTING_WORK_FLASH_SET_ENABLE_SECTOR,               /* set enable sector */
    FEE_ADJUSTING_WORK_FLASH_ERASING_SECTORSRC,               /* erasing sector source */
    FEE_ADJUSTING_WORK_FLASH_CHANGE_BLK_IDX_STATUS,           /* change block index status */
    FEE_ADJUSTING_WORK_FLASH_END                              /* end of periodic processing */
} Fee_AdjustingWorkFlashProcType;

/* for Fee_SetOldSector */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 7 */
typedef enum {
    FEE_SET_OLD_SECTOR_TO_MOVING_START = FEE_PROC_START, /* entry of periodic processing */
    FEE_SET_OLD_SECTOR_TO_MOVING_SET,                    /* set sector status */
    FEE_SET_OLD_SECTOR_TO_MOVING_SET_FINAL,              /* check completion of writing sector status */
    FEE_SET_OLD_SECTOR_TO_MOVING_CHECK,                  /* check result of writing sector status */
    FEE_SET_OLD_SECTOR_TO_MOVING_END                     /* end of periodic processing */
} Fee_SetOldSectorToMovingProcType;

/* for Fee_CheckOldConfigAndCompare */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 8 */
typedef enum {
    FEE_CHK_OLD_CONFIG_AND_COMPARE_START = FEE_PROC_START,          /* entry of periodic processing */
    FEE_CHK_OLD_CONFIG_AND_COMPARE_CALC,                            /* caculate sector status */    
    FEE_CHK_OLD_CONFIG_AND_COMPARE_FIND_EFFECTIVE,                  /* look for effective sector */
    FEE_CHK_OLD_CONFIG_AND_COMPARE_COMPARE,                         /* compare psc of new and old */
    FEE_CHK_OLD_CONFIG_AND_COMPARE_ERASE_ALL,                       /* erase all sectors */
    FEE_CHK_OLD_CONFIG_AND_COMPARE_END                              /* end of periodic processing */
} Fee_CheckOldConfigAndCompareProcType;

/* for Fee_CaculateOldSectorStatus */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 10 */
typedef enum {
    FEE_CACULATE_OLD_SECTOR_STATUS_START = FEE_PROC_START,      /* entry of periodic processing */
    FEE_CACULATE_OLD_SECTOR_STATUS_FLAG1,                       /* get flag1 */
    FEE_CACULATE_OLD_SECTOR_STATUS_FLAG2,                       /* get flag2 */
    FEE_CACULATE_OLD_SECTOR_STATUS_FLAG3,                       /* get flag3 */
    FEE_CACULATE_OLD_SECTOR_STATUS_JUDGE,                       /* judge sector status */
    FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_PSC,                   /* check psc */
    FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_ERASE_FLAG,            /* check erase flag */
    FEE_CACULATE_OLD_SECTOR_STATUS_END                          /* end of periodic processing */
} Fee_CaculateOldSectorStatusProcType;

/* for Fee_InitSearchBlockindexUpdate */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 6 */
typedef enum {
    FEE_INIT_SEARCH_BLOCKINDEX_START = FEE_PROC_START,         /* entry of periodic processing */
    FEE_INIT_SEARCH_BLOCKINDEX_GET_BLOCKNO_PAGENO,             /* get block no and page no */
    FEE_INIT_SEARCH_BLOCKINDEX_BLANKCHECK,                     /* blank check and judge result */
    FEE_INIT_SEARCH_BLOCKINDEX_END                             /* end of periodic processing */
}Fee_InitSearchBlockindexUpdateProcType;

/* Fee_CreateBlockByInit */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 10 */
typedef enum {
    FEE_SEARCH_CREATE_START = FEE_PROC_START,   /* entry of periodic processing */
    FEE_SEARCH_CREATE_ACTION,                   /* search action */
    FEE_SEARCH_CREATE_BLANK_CHECK,              /* blank check */
    FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD,      /* search block index and update */
    FEE_SEARCH_CREATE_WRITE_INVALID_FLAG,       /* write invalid flag */
    FEE_SEARCH_CREATE_WRITE_INVALID_FLAG_CHECK, /* check result of write invalid flag */
    FEE_SEARCH_CREATE_CHECK_EMPTY_AREA,         /* check empty area */
    FEE_SEARCH_CREATE_END                       /* end of periodic processing */
} Fee_SearchCreateBlockProcType;

/* for Fee_SearchValidBlock */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 5 */
typedef enum {
    FEE_SEARCH_VALID_START = FEE_PROC_START,   /* entry of periodic processing */
    FEE_SEARCH_VALID_ACTION,                   /* search action */
    FEE_SEARCH_VALID_END                       /* end of periodic processing */
} Fee_SearchValidProcType;

/* for Fee_SearchValidBlockOldConfig */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 7 */
typedef enum {
    FEE_SEARCH_VALID_OLD_START = FEE_PROC_START,  /* entry of periodic processing */
    FEE_SEARCH_VALID_OLD_PRE_GET_BLOCKNO_PAGENO,  /* pre get block no page no */
    FEE_SEARCH_VALID_OLD_GET_BLOCKNO_PAGENO,      /* get block no page no */
    FEE_SEARCH_VALID_OLD_ACTION,                  /* search action */
    FEE_SEARCH_VALID_OLD_END                      /* end of periodic processing */
} Fee_SearchValidOldProcType;

/* for Fee_SearchBlankArea */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 6 */
typedef enum {
    FEE_SEARCH_BLANK_START = FEE_PROC_START,      /* entry of periodic processing */
    FEE_SEARCH_BLANK_ACTION,                      /* search action */
    FEE_SEARCH_BLANK_OLD_GET_BLOCKNO_PAGENO,      /* get block no page no */
    FEE_SEARCH_BLANK_END                          /* end of periodic processing */
} Fee_SearchBlankProcType;

/* for Fee_SearchNewData */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 7 */
typedef enum {
    FEE_SEARCH_NEW_DATA_START = FEE_PROC_START,   /* entry of periodic processing */
    FEE_SEARCH_NEW_DATA_ACTION,                   /* search action */
    FEE_SEARCH_NEW_GET_BLOCKNO_PAGENO,            /* get block no page no */
    FEE_SEARCH_NEW_DATA_CHECK_BLK,                /* search the target block */
    FEE_SEARCH_NEW_DATA_END                       /* end of periodic processing */
} Fee_SearchNewDataProcType;

/* for Fee_BlockBlankCheckAndRewrite */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the macro names has no problem. */
/* PRQA S 779 7 */
typedef enum {
    FEE_BLOCK_BLANKCHECKANDWRITE_START = FEE_PROC_START,   /* entry of periodic processing */
    FEE_BLOCK_BLANKCHECKANDWRITE_ACTION,                   /* block blank check action */
    FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE,                  /* rewrite block status of given block */
    FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE_CHECK,            /* check result of rewrite block status of given block */
    FEE_BLOCK_BLANKCHECKANDWRITE_END                       /* end of periodic processing */
} Fee_BlockBlankCheckProcType;

/*****************************************************************************/
/* Global variable declarations ('extern', definition in C source)           */
/*****************************************************************************/
/*==================*/
/* variable         */
/*==================*/
/*****************************************************************************/
/* Global function prototypes ('extern', definition in C source)             */
/*****************************************************************************/
/*==================*/
/* functions        */
/*==================*/
#define FEE_START_SEC_CODE_ASIL_B
#include "Fee_MemMap.h"

/* Periodic processing of initializing. */
extern FUNC(void, FEE_CODE) Fee_MainInit(void);

/* Periodic processing of writing. */
extern FUNC(void, FEE_CODE) Fee_MainWrite(void);

/* Periodic processing of reading. */
extern FUNC(void, FEE_CODE) Fee_MainRead(void);

/* Periodic processing of invalidating. */
extern FUNC(void, FEE_CODE) Fee_MainInvalidate(void);

/* Initialize internal variable for periodic processing and cancel processing under operation. */
extern FUNC(void, FEE_CODE) Fee_Reset(
  VAR(uint8, AUTOMATIC) mode);

/* If Fee_SectorStatus[] is initial value, get sector status from FEE. */
extern FUNC(uint8, FEE_CODE) Fee_GetSectorFirst(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) sector_no);

/* Periodic common processing of LIB layer. */
extern FUNC(uint8, FEE_CODE) Fee_MainCommon(void);

/* Check correctness of block index("block address on flash"). */
extern FUNC(uint8, FEE_CODE) Fee_BlockIndexCheck(void);

/* Start periodic processing of recycling. */
extern FUNC(void, FEE_CODE) Fee_RecycleStart(
  VAR(uint8, AUTOMATIC) sector_no);

/* Periodic processing of recycling. */
extern FUNC(uint8, FEE_CODE) Fee_RecyclePolling(void);

/* End periodic processing of recycling. */
extern FUNC(uint8, FEE_CODE) Fee_RecycleFinal(void);

/* Recover sector. */
extern FUNC(uint8, FEE_CODE) Fee_Recover(void);

/* Get read or recycle source sector. */
extern FUNC(uint8, FEE_CODE) Fee_GetSector(
  VAR(uint8, AUTOMATIC) status);

/* Set specified status or recycle flag to sector of specified sector number. */
extern FUNC(uint8, FEE_CODE) Fee_SetSector(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint8, AUTOMATIC) status);

/* Write block in FEE area. */
extern FUNC(uint8, FEE_CODE) Fee_WriteBlock(
  VAR(uint8, AUTOMATIC) sector_no,
  P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_APPL_DATA) addr_ptr,
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) data_ptr,
  VAR(uint8, AUTOMATIC) old_or_new_struct);

/* Set position of the processing that should be executed next time. */
extern FUNC(void, FEE_CODE) Fee_PushProc(
  VAR(uint8, AUTOMATIC) proc);

/* Get position of the processing that should be executed this time. */
extern FUNC(uint8, FEE_CODE) Fee_PopProc(void);

/* Execute user callback. */
extern FUNC(void, FEE_CODE) Fee_CallCbk(
  VAR(MemIf_JobResultType, AUTOMATIC) result);

/* Return the index by a block number. */
extern FUNC(uint16, FEE_CODE) Fee_BlockNumberToIndex(
  VAR(uint16, AUTOMATIC) block_no);

/* Reset address index of blocks */
extern FUNC(void, FEE_CODE) Fee_ResetBlockIndex(void);

/* calculate page size aligned block size */
extern FUNC(uint16, FEE_CODE) Fee_GetPageSizeAlignSize(
  VAR(uint16, AUTOMATIC) size);

/* calculate page size aligned block size */
extern FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_CalPhysicalAddrFromPageNo(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint16, AUTOMATIC) page_no);

/* Erase one logical sector. */
extern FUNC(uint8, FEE_CODE) Fee_EraseSector(
  VAR(uint8, AUTOMATIC) sector_no);

/* Copies the values of size from source to destination.(1byte unit) */
extern FUNC(uint8, FEE_CODE) Fee_MemCpy1(
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) dst_ptr,
  P2CONST(uint8, AUTOMATIC, FEE_APPL_CONST) src_ptr,
  VAR(uint16, AUTOMATIC) size);

/* blank check block management area */
extern FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_BlockBlankCheck(
  VAR(uint16, AUTOMATIC) blk_idx,
  VAR(uint8, AUTOMATIC) restore);

/* blank check block management area and rewrite status flag */
extern FUNC(uint8, FEE_CODE) Fee_BlockBlankCheckAndRewrite(
  VAR(uint16, AUTOMATIC) blk_idx);

/* calculate address of "erase complete flag" by sector number */
extern FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_GetFlashSectorEraseFlagAddr(
  VAR(uint8, AUTOMATIC) sector_no);

/* calculate page size aligned block size */
extern FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_CalPhysicalAddrFromPageNoOldConfig(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint16, AUTOMATIC) page_no);

/* calculate address of "erase complete flag" by sector number */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.1
   Justification: After analysis, the name has no problem. */
/* PRQA S 777 2 */
extern FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_GetFlashSectorEraseFlagAddrOldConfig(
  VAR(uint8, AUTOMATIC) sector_no);

/* Get disable sector.when there is difference in new and old config */
extern FUNC(uint8, FEE_CODE) Fee_GetDisableSector(
  VAR(uint32,AUTOMATIC) sector_start_addrss_of_old_config,
  VAR(uint32,AUTOMATIC) sector_end_addrss_of_old_config);


#define FEE_STOP_SEC_CODE_ASIL_B
#include "Fee_MemMap.h"


#endif /*!defined(FEE_INTERNAL_H_INCLUDED)*/

