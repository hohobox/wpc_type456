/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file contains the implementation of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "Fee_Data.h"

/*****************************************************************************/
/* Local pre-processor symbols/macros ('#define')                            */
/*****************************************************************************/
/*****************************************************************************/
/* Global variable definitions (declared in header file with 'extern')       */
/*****************************************************************************/
/*****************************************************************************/
/* Local variable definitions ('static')                                     */
/*****************************************************************************/

#define FEE_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
#include "Fee_MemMap.h"

VAR(Fee_ModuleStateType, FEE_INTERNAL_VAR_CLEARED)          Fee_ModuleState;             /* state of FEE */
VAR(Fee_ModuleStateType, FEE_INTERNAL_VAR_CLEARED)          Fee_ModuleStateMirror;       /* mirror of Fee_ModuleState for fail-safe */
VAR(uint32, FEE_INTERNAL_VAR_CLEARED)                       Fee_Counter;                 /* counter for periodic processing */
VAR(MemIf_JobResultType, FEE_INTERNAL_VAR_CLEARED)          Fee_JobResult;               /* result of operation */
VAR(Fee_JobDataType, FEE_INTERNAL_VAR_CLEARED)              Fee_Job;                     /* job information of operation */


VAR(Fee_BlockManagementInfoType, FEE_INTERNAL_VAR_CLEARED)  Fee_BlkMgtInfoBuffer;        /* block management information buffer for write block */

VAR(uint32, FEE_INTERNAL_VAR_CLEARED)                       Fee_InfoDataBuffer;          /* short data buffer for write block status */

VAR(uint16, FEE_INTERNAL_VAR_CLEARED)                       Fee_ImmDataReserveSize[FEE_CONFIG_MAX_NUM];   /* array of immediate date reserve size */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                        Fee_CurrentConfigNo;         /* current configuration number, value is 1 or 2 */

VAR(Fee_PeriodicInfoType, FEE_INTERNAL_VAR_CLEARED)         Fee_PeriInfo;                /* informations of periodic */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                        Fee_MainProc[FEE_PROC_SIZE];    /* Stack for position of the processing */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                        Fee_MainStack[FEE_STACK_SIZE];  /* Stack for periodic processing */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                        Fee_RecycleFlag;                /* recycle flag is ON or OFF, be careful, it can only be set in recover(init/cleanupanderase) */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                        Fee_RecycleImmediateFlag;       /* recycle immediate flag is ON or OFF, be careful, it can only be set in recover(init/cleanupanderase */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                        Fee_ConfigUnmatchFlag;                /* Fee_ConfigUnmatchFlag is ON or OFF, be careful, it can only be set in recover(init/cleanupanderase) */

VAR(Fee_ConfigurationInfoType, FEE_INTERNAL_VAR_CLEARED)   Fee_ConfigInfoOld[FEE_CONFIG_MAX_NUM]; /* old config infomation */

VAR(Fee_OldSectorStatusType, FEE_INTERNAL_VAR_CLEARED)     Fee_OldSectorStatusArray[FEE_OLD_EFFECTIVE_MAX];  /* old effective sector infomation*/

VAR(uint16,FEE_INTERNAL_VAR_CLEARED)                       Fee_PageNoFront;                  /* Page No of front */

VAR(Fee_BlockManagementInfoType,FEE_INTERNAL_VAR_CLEARED)  Fee_BlkMgtInfoForReadBlockNoPageNo;                /* block management information buffer for write block to read block no and page no */

VAR(uint32, FEE_INTERNAL_VAR_CLEARED)                      Fee_InfoDataBufferArray[FEE_FLAG_MAX_NUM];         /* data buffer for readout flags */

VAR(uint8, FEE_INTERNAL_VAR_CLEARED)                       Fee_BlockIndexAlreadyUpdated;          /* it indicates that block index has already been updated or not */

#define FEE_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"
/*****************************************************************************/
/* Local function prototypes ('static')                                      */
/*****************************************************************************/
/*****************************************************************************/
/* Function implementation - global ('extern') and local ('static')          */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/** \brief Fee_SetCurrentConfigNo
**
** set variable Fee_CurrentConfigNo.
**
** \param[in]  current_config_no       current configuration number
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_SetCurrentConfigNo(
  VAR(uint8, AUTOMATIC) current_config_no)
{
    Fee_CurrentConfigNo = current_config_no;

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_GetSecTopAddr
 **
 ** get variable Fee_SecTopAddr.
 **
 ** \return     Fee_SecTopAddr
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetSecTopAddr(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr;
}


/**
 ******************************************************************************
 ** \fn Fee_GetNoOfSec
 **
 ** get variable Fee_NoOfSec.
 **
 ** \return     Fee_NoOfSec
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetNoOfSec(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfSec;
}


/**
 ******************************************************************************
 ** \fn Fee_GetNoOfBlocks
 **
 ** get variable Fee_NoOfBlocks.
 **
 ** \return     Fee_NoOfBlocks
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetNoOfBlocks(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfBlocks;
}

/**
 ******************************************************************************
 ** \fn Fee_GetSectorSize
 **
 ** get variable Fee_SecSize.
 **
 ** \return     Fee_SecSize
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetSectorSize(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize;
}

/**
 ******************************************************************************
 ** \fn Fee_GetRemainSize
 **
 ** get variable Fee_RemainSize.
 **
 ** \return     Fee_RemainSize
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetRemainSize(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_RemainSize;
}

/**
 ******************************************************************************
 ** \fn Fee_GetBlkCfg
 **
 ** get variable Fee_BlkCfg.
 **
 ** \param index [in] - index.
 **
 ** \return     Fee_BlkCfg
 **
*****************************************************************************/
FUNC(Fee_BlockConfigType, FEE_CODE) Fee_GetBlkCfg(
  VAR(uint16, AUTOMATIC) index)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_BlkCfgPtr[index];
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlockAddrIndex
 **
 ** get variable Fee_BlockAddrIndex.
 **
 ** \param index            [in] - index.
 **
 ** \return     Fee_BlockAddrIndex
 **
*****************************************************************************/
FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_GetBlockAddrIndex(
  VAR(uint16, AUTOMATIC) index)
{
    return Fee_GetBlockAddrIndexElementWithCfg(Fee_CurrentConfigNo, index);
}


/**
 ******************************************************************************
 ** \fn Fee_SetBlockAddrIndex
 **
 ** set variable Fee_BlockAddrIndex.
 **
 ** \param index            [in] - index.
 ** \param block_addr_index [in] - index of blocks.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlockAddrIndex(
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockAddrIndexType, AUTOMATIC) block_addr_index)
{
    Fee_SetBlockAddrIndexElementWithCfg(Fee_CurrentConfigNo, index, block_addr_index);
    Fee_SetBlockAddrIndexMirrorElementWithCfg(Fee_CurrentConfigNo, index, block_addr_index);

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlockAddrIndexMirror
 **
 ** get variable Fee_BlockAddrIndexMirror.
 **
 ** \param index            [in] - index.
 **
 ** \return     Fee_BlockAddrIndexMirror
 **
*****************************************************************************/
FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_GetBlockAddrIndexMirror(
  VAR(uint16, AUTOMATIC) index)
{
    return Fee_GetBlockAddrIndexMirrorElementWithCfg(Fee_CurrentConfigNo, index);
}


/** \brief Fee_GetSectorStatus
**
**  get variable Fee_SectorStatus.
**
** \param[in]  index               index
**
** \return     Fee_SectorStatus
**
*/
FUNC(uint8, FEE_CODE) Fee_GetSectorStatus(
  VAR(uint8, AUTOMATIC) index)
{
    return Fee_GetSectorStatusElementWithCfg(Fee_CurrentConfigNo, index);
}


/** \brief Fee_SetSectorStatus
**
** set variable Fee_SectorStatus.
**
** \param[in]  index               index
** \param[in]  sector_status       sector status
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_SetSectorStatus(
  VAR(uint8, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) sector_status)
{
    Fee_SetSectorStatusElementWithCfg(Fee_CurrentConfigNo, index, sector_status);

    return;
}


/** \brief Fee_GetSectorStatusMirror
**
**  get variable Fee_SectorStatusMirror.
**
** \param[in]  index               index
**
** \return     Fee_SectorStatusMirror
**
*/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1503 2 */
FUNC(uint8, FEE_CODE) Fee_GetSectorStatusMirror(
  VAR(uint8, AUTOMATIC) index)
{
    return Fee_GetSectorStatusMirrorElementWithCfg(Fee_CurrentConfigNo, index);
}


/** \brief Fee_SetSectorStatusMirror
**
** set variable Fee_SectorStatusMirror.
**
** \param[in]  index                      index
** \param[in]  sector_status_mirror       sector status mirror
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_SetSectorStatusMirror(
  VAR(uint8, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) sector_status_mirror)

{
    Fee_SetSectorStatusMirrorElementWithCfg(Fee_CurrentConfigNo, index, sector_status_mirror);

    return;
}


/** \brief Fee_GetBlkMgtAreaEmptyAddr
**
**  get variable Fee_BlkMgtAreaEmptyAddrPtr.
**
** \param      none
**
** \return     Fee_BlkMgtAreaEmptyAddr
**
*/
FUNC_P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_CODE) Fee_GetBlkMgtAreaEmptyAddr(void)
{
    return Fee_GetBlkMgtAreaEmptyAddrElementWithCfg(Fee_CurrentConfigNo - (uint8)1);
}


/** \brief Fee_SetBlkMgtAreaEmptyAddr
**
** set variable Fee_BlkMgtAreaEmptyAddrPtr.
**
** \param[in]  blk_mgt_area_empty_addr       pointer to empty address for block management area
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_SetBlkMgtAreaEmptyAddr(
  P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_APPL_DATA) blk_mgt_area_empty_addr_ptr)
{
    Fee_SetBlkMgtAreaEmptyAddrElementWithCfg(Fee_CurrentConfigNo - (uint8)1, blk_mgt_area_empty_addr_ptr);

    return;
}


/** \brief Fee_GetBlkPageAreaEmptyAddr
**
**  get variable Fee_BlkPageAreaEmptyAddrPtr.
**
** \param      none
**
** \return     Fee_BlkPageAreaEmptyAddr
**
*/
FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetBlkPageAreaEmptyAddr(void)
{
    return Fee_GetBlkPageAreaEmptyAddrElementWithCfg(Fee_CurrentConfigNo - (uint8)1);
}


/** \brief Fee_SetBlkPageAreaEmptyAddr
**
** set variable Fee_BlkPageAreaEmptyAddrPtr.
**
** \param[in]  blk_page_area_empty_addr       pointer to empty address for page area
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_SetBlkPageAreaEmptyAddr(
  P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) blk_page_area_empty_addr_ptr)
{
    Fee_SetBlkPageAreaEmptyAddrElementWithCfg(Fee_CurrentConfigNo - (uint8)1, blk_page_area_empty_addr_ptr);

    return;
}


/** \brief Fee_GetBlkEmptySize
**
**  get variable Fee_BlkEmptySize.
**
** \param      none
**
** \return     Fee_BlkEmptySize
**
*/
FUNC(uint16, FEE_CODE) Fee_GetBlkEmptySize(void)
{
    return Fee_GetBlkEmptySizeElementWithCfg(Fee_CurrentConfigNo - (uint8)1);
}


/** \brief Fee_SetBlkEmptySize
**
** set variable Fee_BlkEmptySize.
**
** \param[in]  blk_empty_size       empty size
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_SetBlkEmptySize(
  VAR(uint16, AUTOMATIC) blk_empty_size)
{
    Fee_SetBlkEmptySizeElementWithCfg(Fee_CurrentConfigNo - (uint8)1, blk_empty_size);

    return;
}

/** \brief Fee_SetConfigInfoOld
**
** set variable Fee_BlkEmptySize.
**
** \param[in]  Fee_NormalSectorCount       old normal sector count(psc1) 
** \param[in]  Fee_LastSectorCount         old last sector count(psc2)
**
** \return     none
**
*/
FUNC(void,FEE_CODE) Fee_SetConfigInfoOld(
  VAR(uint16, AUTOMATIC) fee_normalsectorcount,
  VAR(uint16, AUTOMATIC) fee_lastsectorcount,
  VAR(uint32, AUTOMATIC) fee_checksum)
{
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr = Fee_GetSecTopAddr();
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfBlocks = Fee_GetNoOfBlocks();
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecEndAddr = Fee_GetSecEndAddr();
    /* Deviation from MISRA-C:2012 Rule-10.3
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4461 2 */
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NormalSectorCount = fee_normalsectorcount;
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_LastSectorCount = fee_lastsectorcount;
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_PSCCheckSum = fee_checksum;
    /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4491 1 */
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize = fee_normalsectorcount * Fee_GetWflashLgSectorSize();
    /* Deviation from MISRA-C:2012 Rule-10.3
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4461 1 */
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfSec = ((Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecEndAddr - Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr)) / Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize;
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_RemainSize =    ((Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecEndAddr - Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr)) % Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize;
    /* Deviation from MISRA-C:2012 Rule-10.3
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4461 1 */
    Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SectorSizeLessThan800 = (uint16)(( Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_RemainSize ) % Fee_GetWflashLgSectorSize());

    return;
}

/** \brief Fee_InitOldSectorStatusArray
**
** init array Fee_OldSectorStatusArray.
**
** \param[in]  void       
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_InitOldSectorStatusArray(void)
{
    VAR(uint8, AUTOMATIC) cnt;

    for(cnt = 0; cnt < FEE_OLD_EFFECTIVE_MAX; cnt++)
    {
        Fee_OldSectorStatusArray[cnt].FeeOldLogicalNumber = 0;
        Fee_OldSectorStatusArray[cnt].FeePsc1 = 0;
        Fee_OldSectorStatusArray[cnt].FeePsc2 = 0;
        Fee_OldSectorStatusArray[cnt].FeeSectorAddress = 0;
        Fee_OldSectorStatusArray[cnt].FeeSectorStatus = 0;
        Fee_OldSectorStatusArray[cnt].FeePscChecksum = 0;
    }

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_GetSecEndAddr
 **
 ** get variable Fee_SecEndAddr.
 **
 ** \return     Fee_SecEndAddr
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetSecEndAddr(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_SecEndAddr;
}

/**
 ******************************************************************************
 ** \fn Fee_GetNormalSectorCount
 **
 ** get variable Fee_NormalSectorCount.
 **
 ** \return     Fee_NormalSectorCount
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetNormalSectorCount(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_NormalSectorCount;
}

/**
 ******************************************************************************
 ** \fn Fee_GetLastSectorCount
 **
 ** get variable Fee_LastSectorCount.
 **
 ** \return     Fee_LastSectorCount
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetLastSectorCount(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_LastSectorCount;
}

/**
 ******************************************************************************
 ** \fn Fee_GetPSCChecksum
 **
 ** get variable Fee_PSCCheckSum.
 **
 ** \return     Fee_PSCCheckSum
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetPSCChecksum(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_PSCCheckSum;
}

/**
 ******************************************************************************
 ** \fn Fee_GetSectorSizeLessThan800
 **
 ** get variable Fee_SectorSizeLessThan800.
 **
 ** \return     Fee_SectorSizeLessThan800
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetSectorSizeLessThan800(void)
{
    return Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_SectorSizeLessThan800;
}


#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

