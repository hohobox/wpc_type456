/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file contains the implementation of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "Fee_Internal.h"

/*****************************************************************************/
/* Local pre-processor symbols/macros ('#define')                            */
/*****************************************************************************/
/*****************************************************************************/
/* Global variable definitions (declared in header file with 'extern')       */
/*****************************************************************************/
/*****************************************************************************/
/* Local variable definitions ('static')                                     */
/*****************************************************************************/
#define FEE_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
#include "Fee_MemMap.h"

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: An area of this variable must be maintained even out of a function scope. */
/* PRQA S 3218 9 */
static VAR(Fee_MainCommonProcType, AUTOMATIC) Fee_MainCommonProc = FEE_MAIN_COMMON_START;
static VAR(Fee_MainCommonProcType, AUTOMATIC) Fee_MainCommonProcNext = FEE_MAIN_COMMON_START;
static VAR(Fee_CancelWriteProcType, AUTOMATIC) Fee_CancelWriteProc = FEE_CANCEL_WRITE_START;
static VAR(Fee_CancelWriteProcType, AUTOMATIC) Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_START;
static VAR(uint8, AUTOMATIC) Fee_SectorCountForConfig   = (uint8)1U;
static VAR(uint8, AUTOMATIC) Fee_SectorCountForConfigEx = (uint8)1U;
static VAR(uint8, AUTOMATIC) Fee_CurrentConfigNoTemp    = FEE_CONFIG_SET_1;
static VAR(uint16, AUTOMATIC) Fee_BlockNumberForCancel  = (uint16)FEE_BLOCK_INITIAL_BLOCK_NO;        /* block number for storing the cancelled block */
static VAR(uint16, AUTOMATIC) Fee_BlockIndexForCancel   = (uint16)FEE_BLOCK_INITIAL_BLOCK_INDEX;     /* block index for storing the cancelled block */


#define FEE_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


#define FEE_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: An area of this variable must be maintained even out of a function scope. */
/* PRQA S 3218 1 */
static VAR(Fee_BlockManagementInfoType, AUTOMATIC) Fee_BlkMgtInfoBufferForCancel;        /* block management information buffer for write block */

#define FEE_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


/*****************************************************************************/
/* Local function prototypes ('static')                                      */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/* Periodic processing of writing. */
static FUNC(uint8, FEE_CODE) Fee_MainWriteProc(void);

/* Periodic processing of invalidating. */
static FUNC(uint8, FEE_CODE) Fee_MainInvalidateProc(void);

/* modify blk_mgt_area_empty_addr , blk_page_area_empty_addr and blk_empty_size */
static FUNC(uint8, FEE_CODE) Fee_SearchBlankArea( 
  VAR(uint8, AUTOMATIC) sector_no);

/*Seach new Block*/
static FUNC(uint8, FEE_CODE) Fee_SearchNewData(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint16, AUTOMATIC) target_block_no);

/* update the 2 empty pointer on valid sector after write a block. */
static FUNC(void, FEE_CODE) Fee_UpdateEmptyAreaPtrAfterWriteBlock(void);

/* update the management area pointer via different cases. */
static FUNC(void, FEE_CODE) Fee_UpdateTheTwoPointerByDiffCase(
  P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_APPL_DATA) block_ptr);

/* Clear management area pointer and data area pointer */
static FUNC(void, FEE_CODE) Fee_ClearMngPtrAndDatePtr(void);

#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/*****************************************************************************/
/* Function implementation - global ('extern') and local ('static')          */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


/** \brief Fee_MainInit
**
** Periodic processing of initializing.
** Execute callback function when complete initializing.
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_MainInit(void)
{
    VAR(Fee_InitProcType, AUTOMATIC)        proc;                      /* position of the processing */
    VAR(uint8, AUTOMATIC)                   result;                    /* result of execute */
    VAR(uint16, AUTOMATIC)                  cnt;                       /* loop counter */
    VAR(uint8, AUTOMATIC)                   cnt_config;                /* loop counter */
    VAR(uint16, AUTOMATIC)                  cnt_block;                 /* loop counter */
    VAR(uint16, AUTOMATIC)                  imm_data_reserve_size;     /* immediate date reserve size */
    VAR(uint16, AUTOMATIC)                  no_of_blocks;              /* Number of defined blocks */
    VAR(Fee_BlockConfigType, AUTOMATIC)     blk_cfg;                   /* Block configuration array */

    cnt_config = (uint8)FEE_ZERO;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_InitProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_INIT_START )
    {
        /* => 1.select target configuration area */
        proc = FEE_INIT_SELECT_CONFIG_AREA;
    }
    else
    {
        FEE_POP_STACK_UCHAR(cnt_config)
        FEE_POP_STACK_USHORT(cnt_block)
        FEE_POP_STACK_USHORT(imm_data_reserve_size)
    }

/* 1.select target configuration area */
    if( proc == FEE_INIT_SELECT_CONFIG_AREA )
    {
        if( cnt_config < Fee_GetCfgNum() )
        {
            Fee_SetCurrentConfigNo((uint8)cnt_config + 1U);

            /* set value of Fee_ConfigInfoOld with new Config infomation  */
            Fee_SetConfigInfoOld(Fee_GetNormalSectorCount(),Fee_GetLastSectorCount(),Fee_GetPSCChecksum());

            /* Init the value of Fee_OldSectorStatusArray */
            Fee_InitOldSectorStatusArray();

            /* Init Fee_PageNoFront */
            Fee_PageNoFront = FEE_ZERO;

            imm_data_reserve_size = (uint16)FEE_NULL;
            cnt_block = (uint16)FEE_NULL;

            /* => 2.get initial value of immediate date reserve size */
            proc = FEE_INIT_GET_IMMDATA_INITIAL_VALUE;
        }
        else
        {
            /* => X.end of periodic processing */
            proc = FEE_INIT_END;
        }
    }

/* 2.get initial value of immediate date reserve size */
    if( proc == FEE_INIT_GET_IMMDATA_INITIAL_VALUE )
    {
        if(STD_OFF == Fee_GetDefinedThresholdPageSize())
        {
            no_of_blocks = Fee_GetNoOfBlocks();
            for( cnt = (uint16)FEE_ZERO; (cnt_block < no_of_blocks) && (cnt < FEE_BLKCFGCHK_MAX); cnt++ )
            {
                blk_cfg = Fee_GetBlkCfg(cnt_block);
                if( blk_cfg.FeeImmediateData == TRUE )
                {
                    imm_data_reserve_size += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                }
                cnt_block++;
            }

            if( cnt_block == (uint16)no_of_blocks )
            {
                /* ensure the least Fee_ImmDataReserveSize is FEE_BLOCK_MANAGE_SIZE(16bytes) */
                imm_data_reserve_size += FEE_BLOCK_MANAGE_SIZE;
                Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] = imm_data_reserve_size;

                /* => 3.recover the target area */
                FEE_SET_PROC(FEE_INIT_RECOVER)
            }
        }
        else
        {
            /* => 3.recover the target area */
            FEE_SET_PROC(FEE_INIT_RECOVER)
        }
    }

/* 3.recover the target area */
    if( proc == FEE_INIT_RECOVER )
    {
        if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_RECOVERING) == FEE_MAIN_STATE_RECOVERING )
        {
            /* recovering */
            result = Fee_Recover();

            switch(result)
            {
            case FEE_OK:
                Fee_JobResult = MEMIF_JOB_OK;

                cnt_config++;
                /* => 1.select target configuration area */
                FEE_SET_PROC(FEE_INIT_SELECT_CONFIG_AREA)
                break;
            case FEE_NG:
            case FEE_INVALID_SECTOR_NO:
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                /* => X.end of periodic processing */
                proc = FEE_INIT_END;
                break;
            default: /* FEE_CONT */
                break;
            }
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_INIT_END )
    {
        if( Fee_JobResult == MEMIF_JOB_FAILED )
        {
            FEE_STATE_SET(FEE_STAT_UNINIT)
        }
        /* => 0.entry of periodic processing */
        FEE_PUSH_PROC(FEE_INIT_START)
        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;      /* clear main state */

        Fee_Counter = FEE_NULL;
        if( Fee_ModuleState != FEE_STAT_UNINIT )
        {
            FEE_STATE_SET(FEE_STAT_NOP)
        }
    }
    else
    {
        FEE_PUSH_PROC(proc)
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          The imm_data_reserve_size is initialized by the former mainfunction. */
        /* PRQA S 2962 1*/
        FEE_PUSH_STACK_USHORT(imm_data_reserve_size)
        FEE_PUSH_STACK_USHORT(cnt_block)
        FEE_PUSH_STACK_UCHAR(cnt_config)
    }

    return;
}


/** \brief Fee_MainWrite
**
** Periodic processing of writing.
** Execute callback function when complete writing.
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_MainWrite(void)
{
    VAR(Fee_MainWriteProcType, AUTOMATIC)                         proc;                             /* position of the processing */
    VAR(uint8, AUTOMATIC)                                         result;                           /* result of execute */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)      proc_block_ptr;                   /* temporarily block area */
    VAR(uint8, AUTOMATIC)                                         sector_no;                        /* number of sector */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                           data_ptr;                         /* block data buffer for write block */
    VAR(Fee_BlockConfigType, AUTOMATIC)                           blk_cfg;                          /* Block configuration array */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)      blk_mgt_area_empty_addr_ptr;      /* pointer to empty address for block management area */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                           blk_page_area_empty_addr_ptr;     /* pointer to empty address for page area */
    VAR(uint16, AUTOMATIC)                                        blk_empty_size;                   /* empty size */
    VAR(uint32, AUTOMATIC)                                        write_flag;                       /* write flag */
    VAR(uint32, AUTOMATIC)                                        valid_status;                     /* valid flag */
    VAR(uint32, AUTOMATIC)                                        blockid_pageid;                   /* blockid and pageid */
    VAR(Fee_ConfigType, AUTOMATIC)                                fee_cfg;                          /* fee configuration */
    VAR(uint16, AUTOMATIC)                                        used_pages_size;                  /* size counter of used pages for calculating Fee_BlkPageAreaEmptyAddr and page number of Fee_BlkMgtInfoBuffer */
    VAR(MemIf_JobResultType, AUTOMATIC)                           retjob;                           /* result of fls job */
    VAR(Fee_FaultType, AUTOMATIC)                                 fee_fault;                        /* get fault information from FLS */
    VAR(Fee_BlockAttributeType, AUTOMATIC)                        blk_attri;                        /* block attribute */
    VAR(uint8, AUTOMATIC)                                         retval;                           /* return value of Fee_SearchBlankArea */

    if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_DATACOPY) == FEE_MAIN_STATE_DATACOPY )
    {
        data_ptr         = Fee_GetData();
        blk_cfg      = Fee_GetBlkCfg(Fee_Job.BlockIndex);
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
           Justification: Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 310 1*/
        result = Fee_MemCpy1((uint8*)data_ptr, Fee_Job.DataBufferPtr.WriteBufferPtr, (uint16)blk_cfg.FeeBlockSize);

        if( result != FEE_CONT )
        {
            Fee_PeriInfo.Fee_MainState &= (uint16)(~FEE_MAIN_STATE_DATACOPY);

            Fee_JobResult = MEMIF_JOB_PENDING;
        }
    }
    else if( (Fee_ModuleState == FEE_STAT_WRITE_CANCEL)
     || (Fee_ModuleState == FEE_STAT_WRITE_WAIT_WRITE)
     || (Fee_ModuleState == FEE_STAT_READ_WAIT_WRITE)
     || (Fee_ModuleState == FEE_STAT_INVAL_WAIT_WRITE)
     || (Fee_ModuleState == FEE_STAT_RECYC_WAIT_WRITE) )
    {
        /* cancelling */

        Fee_CancelWriteProc = Fee_CancelWriteProcNext;

        /* 0.entry of periodic processing */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_START )
        {
            blk_mgt_area_empty_addr_ptr  = Fee_GetBlkMgtAreaEmptyAddr();
            blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
            if( (blk_mgt_area_empty_addr_ptr == (Fee_BlockManagementInfoType*)FEE_NULL)
             || (blk_page_area_empty_addr_ptr == (uint32*)FEE_NULL) )
            {
                /* => X.end of periodic processing */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;
            }
            else
            {
                /* => 1.check write start flag */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_WRITE_FLAG_CHECK;
            }
        }

        /* 1.check write start flag */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_WRITE_FLAG_CHECK )
        {
            proc_block_ptr  = Fee_GetBlkMgtAreaEmptyAddr();
            
            /* Because it is cancelling, it needs to do blank check */
            
            /* check write flag */

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 2 */
            write_flag = Fee_FlsGetReadAddr((uint32)proc_block_ptr); /*check WriteFlag */
            valid_status = Fee_FlsGetReadAddr((uint32)proc_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */

            if( write_flag == FEE_NULL )
            {
                /* write flag has not been written */

                /* => X.end of periodic processing */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;
            }
            else if(( valid_status != FEE_NULL ) && ( Fee_BlockIndexAlreadyUpdated == FEE_BLOCK_INDEX_UPDATED_YES ))
            {
                /* => X.end of periodic processing */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;
            }
            else if(( valid_status != FEE_NULL ) && ( Fee_BlockIndexAlreadyUpdated == FEE_BLOCK_INDEX_UPDATED_NO ))
            {
                /* update block index */
                /* => 6.update empty area size */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_UPDATE_EMPTY_SIZE;
            }
            else
            {
                /* => 2.write Block ID and Page ID */
                Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_BID_PID_WRITE;
            }
        }

        /* 2.write Block ID and Page ID */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_BID_PID_WRITE )
        {
            proc_block_ptr = Fee_GetBlkMgtAreaEmptyAddr();
            /* blank check BlockId and Page ID */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blockid_pageid = Fee_FlsGetReadAddr((uint32)(proc_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE); /*check BNumAndPNum */

            if( blockid_pageid == FEE_NULL )
            {
                blk_mgt_area_empty_addr_ptr  = Fee_GetBlkMgtAreaEmptyAddr();
                blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
                blk_empty_size               = Fee_GetBlkEmptySize();
                /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                if( (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr) == blk_empty_size )
                {
                    blk_cfg = Fee_GetBlkCfg(Fee_BlockIndexForCancel);
                    fee_cfg = Fee_GetCfg();
                    sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);
                    /* calculate the sum size of pages for page number : sum = (already existed page size) + (new write target page size) */
                    /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
                        Justification: Cast between a pointer to object and an integral type.
                        This deviation is due to doing pointer arithmetic.
                        This deviation is due to an integer type cast to do pointer arithmetic. */
                    /* PRQA S 306,488,3395 1 */
                    used_pages_size = (uint16)((uint32)(Fee_GetFlashSectorEraseFlagAddr(sector_no)) - (uint32)blk_page_area_empty_addr_ptr) + Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize);

                    /* set write start flag */
                    Fee_BlkMgtInfoBufferForCancel.WriteFlag = FEE_BLOCK_INITIAL_WRITEFLAG;
                    /* set block number */
                    Fee_BlkMgtInfoBufferForCancel.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = Fee_BlockNumberForCancel;
                    /* set page number */
                    /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8
                    Justification: Casting to different type for consistency. */
                    /* PRQA S 4391 1 */
                    Fee_BlkMgtInfoBufferForCancel.BlkNumAndPageNum.BNumAndPNumBitField.PageNum = (uint16)(used_pages_size/fee_cfg.FeeVirtualPageSize);

                    /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
                    Justification: Cast between a pointer to object and an integral type.
                        Casting to different object pointer type. And this casting is safety by judgment. */
                    /* PRQA S 306,310 1 */
                    (void)Fee_FlsWrite((uint32)proc_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE, (uint8*)&Fee_BlkMgtInfoBufferForCancel.BlkNumAndPageNum.BNumAndPNum, (uint32)( FEE_BLOCK_BLKNUMPAGENUM_SIZE)); /* BNumAndPNum */

                    /* => 3.check write Block ID and Page ID complete */
                    Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_BID_PID_WRITE_CHECK;
                }
                else
                {
                    sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);
                    retval = Fee_SearchBlankArea(sector_no);
                    switch(retval)
                    {
                    case FEE_OK:
                        blk_cfg = Fee_GetBlkCfg(Fee_BlockIndexForCancel);
                        fee_cfg = Fee_GetCfg();
                        sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);
                        /* calculate the sum size of pages for page number : sum = (already existed page size) + (new write target page size) */
                        /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
                            Justification: Cast between a pointer to object and an integral type.
                            This deviation is due to doing pointer arithmetic.
                            This deviation is due to an integer type cast to do pointer arithmetic. */
                        /* PRQA S 306,488,3395 1 */
                        used_pages_size = (uint16)((uint32)(Fee_GetFlashSectorEraseFlagAddr(sector_no)) - (uint32)blk_page_area_empty_addr_ptr) + Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize);

                        /* set write start flag */
                        Fee_BlkMgtInfoBufferForCancel.WriteFlag = FEE_BLOCK_INITIAL_WRITEFLAG;
                        /* set block number */
                        Fee_BlkMgtInfoBufferForCancel.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = Fee_BlockNumberForCancel;
                        /* set page number */
                        /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8
                        Justification: Casting to different type for consistency. */
                        /* PRQA S 4391 1 */
                        Fee_BlkMgtInfoBufferForCancel.BlkNumAndPageNum.BNumAndPNumBitField.PageNum = (uint16)(used_pages_size/fee_cfg.FeeVirtualPageSize);

                        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
                        Justification: Cast between a pointer to object and an integral type.
                            Casting to different object pointer type. And this casting is safety by judgment. */
                        /* PRQA S 306,310 1 */
                        (void)Fee_FlsWrite((uint32)proc_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE, (uint8*)&Fee_BlkMgtInfoBufferForCancel.BlkNumAndPageNum.BNumAndPNum, (uint32)( FEE_BLOCK_BLKNUMPAGENUM_SIZE)); /* BNumAndPNum */

                        /* => 3.check write Block ID and Page ID complete */
                        Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_BID_PID_WRITE_CHECK;
                        break;
                    case FEE_NG:
                        Fee_CallCbk(MEMIF_JOB_FAILED);
                        Fee_JobResult = MEMIF_JOB_FAILED;
                        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
                        Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                        /* => X.end of periodic processing */
                        Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;
                        break;
                    default: /* FEE_CONT */
                        /* continue */
                        break;
                    }
                }
            }
            else
            {
                /*do not rewrite, only write invalid flag */
                Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                Fee_FlsEnableDMA();
                /* ReadOperation */
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                    Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                Fee_FlsReadImmediateSync((uint32)(proc_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                fee_fault = Fee_GetFlsFault();
                if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
                {
                    Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                }
                Fee_FlsDisableDMA();

                blk_attri = Fee_BlockNumberToAttribute( Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum );

                if( blk_attri.FeeBlockIndex != FEE_BLOCK_INITIAL_BLOCK_NO )
                {
                    Fee_BlockIndexForCancel = blk_attri.FeeBlockIndex;
                }

                /* => 4.write invalid flag */
                Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_INVALID_FLAG_WRITE;
            }
        }

        /* 3.check write Block ID and Page ID complete */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_BID_PID_WRITE_CHECK )
        {
            retjob = Fee_FlsGetJobResult();    /* get result of operation */
            
            switch(retjob)
            {
            case MEMIF_JOB_OK:

                /* => 4.write invalid flag */
                Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_INVALID_FLAG_WRITE;
                break;
            
            case MEMIF_JOB_FAILED:
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );

                /* => X.end of periodic processing */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;
                break;
            
            default: /* MEMIF_JOB_PENDING */
                break;
            }
        }

        /* 4.write invalid flag */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_INVALID_FLAG_WRITE )
        {
            proc_block_ptr  = Fee_GetBlkMgtAreaEmptyAddr();

            /* block has been valid */
            Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;

            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 306,310 1 */
            (void)Fee_FlsWrite((uint32)proc_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */
            /* => 5.check write invalid flag complete */
            Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_INVALID_FLAG_WRITE_CHECK;
        }

        /* 5.check write invalid flag complete */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_INVALID_FLAG_WRITE_CHECK )
        {
            retjob = Fee_FlsGetJobResult();    /* get result of operation */
            
            switch(retjob)
            {
            case MEMIF_JOB_OK:
                /* => 6.update empty area size */
                Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_UPDATE_EMPTY_SIZE;

                break;
            
            case MEMIF_JOB_FAILED:
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );

                /* => X.end of periodic processing */
                Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;
                break;
            
            default: /* MEMIF_JOB_PENDING */
                break;
            }
        }

        /* 6.update empty area size */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_UPDATE_EMPTY_SIZE )
        {
            /* updata the 2 empty address pointers and block empty size */
            blk_cfg = Fee_GetBlkCfg(Fee_BlockIndexForCancel);
            blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
            /* in this case it is possiable that data has been written to flash. so blk_page_area_empty_addr should minus these area */
            /* Deviation from MISRA-C:2004 rule 10.3, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-10.8
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different type for consistency. */
            /* PRQA S 306,4391 1 */
            blk_page_area_empty_addr_ptr  = (uint32*)((uint32)blk_page_area_empty_addr_ptr - (uint32)Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize));
            Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);

            blk_mgt_area_empty_addr_ptr  = Fee_GetBlkMgtAreaEmptyAddr();

            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            blk_mgt_area_empty_addr_ptr = (Fee_BlockManagementInfoType*)((uint8*)blk_mgt_area_empty_addr_ptr + FEE_BLOCK_MANAGE_SIZE);
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);

            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);
            
            /* => X.end of periodic processing */
            Fee_CancelWriteProc = FEE_CANCEL_WRITE_END;

        }

        /* X.end of periodic processing */
        if( Fee_CancelWriteProc == FEE_CANCEL_WRITE_END )
        {
            /* completed cancel process */
            Fee_PeriInfo.Fee_MainState |= FEE_MAIN_STATE_CANCELING;   /* set main state */

            Fee_CancelWriteProc = FEE_CANCEL_WRITE_START;
            Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_START;
        }

    }
    else
    {
        /* excluding cancelling */
        /* Deviation from MISRA-C:2012 Rule-10.5
           Justification: This is stack pop/push. It is necessary. */
        /* PRQA S 4342 1 */
        FEE_POP_PROC(proc, Fee_MainWriteProcType)

/* 0.entry of periodic processing */
        if( proc == FEE_MAIN_WRITE_START )
        {
            /* => 1.check sectors */
            proc = FEE_MAIN_WRITE_CHECK_SECTORS;
        }
        else
        {
            FEE_POP_STACK_UCHAR(sector_no)
        }

/* 1.check sectors */
        if( proc == FEE_MAIN_WRITE_CHECK_SECTORS )
        {
            sector_no = Fee_GetSector(FEE_SECTOR_ENABLE);

            if( sector_no == FEE_NONE_SECTOR )
            {
                /* no enable sector, that means there is one moving sector */
                /* => 3.execute periodic processing of writing */
                proc = FEE_MAIN_WRITE_PROC;
            }
            else
            {
                /* enable sector exist, then check whether there is also one moving sector exist */
                sector_no = Fee_GetSector(FEE_SECTOR_MOVING);

                if( sector_no == FEE_NONE_SECTOR )
                {
                    /* one enable sector and no moving sector */
                    /* => 3.execute periodic processing of writing */
                    proc = FEE_MAIN_WRITE_PROC;
                }
                else
                {
                    /* one enable sector and one moving sector exist */
                    /* => 2.set erasing sector */
                    proc = FEE_MAIN_WRITE_SET_ERASING_SECTOR;
                }
            }
        }

/* 2.set erasing sector */
        if( proc == FEE_MAIN_WRITE_SET_ERASING_SECTOR )
        {
            result = Fee_SetSector(sector_no, FEE_SECTOR_GARBAGE);

            if( result == FEE_OK )
            {
                /* => 3.execute periodic processing of writing */
                proc = FEE_MAIN_WRITE_PROC;
            }
            else if( result == FEE_NG )
            {
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                /* => X.end of periodic processing */
                proc = FEE_MAIN_WRITE_END;
            }
            else
            {
                /* continue */
            }
        }

/* 3.execute periodic processing of writing */
        if( proc == FEE_MAIN_WRITE_PROC )
        {
            result = Fee_MainWriteProc();

            if( result != FEE_CONT )
            {
                /* => X.end of periodic processing */
                proc = FEE_MAIN_WRITE_END;
            }
        }

/* X.end of periodic processing */
        if( proc == FEE_MAIN_WRITE_END )
        {
            /* => 0.entry of periodic processing */
            FEE_PUSH_PROC(FEE_MAIN_WRITE_START)

            Fee_CallCbk(Fee_JobResult);
        }
        else
        {
            FEE_PUSH_PROC(proc)
            /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
               Justification: The sector_no is only used after it is initialized by the former mainfunction. */
            /* PRQA S 2962 1*/
            FEE_PUSH_STACK_UCHAR(sector_no)
        }
    }

    return;
}


/** \brief Fee_MainWriteProc
**
** Periodic processing of writing.
**
**
** \return     state of processing
** \retval     FEE_OK     success
** \retval     FEE_CONT   continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
static FUNC(uint8, FEE_CODE) Fee_MainWriteProc(void)
{
    VAR(Fee_WriteProcType, AUTOMATIC)                         proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                     retval;                       /* return value */
    VAR(uint16, AUTOMATIC)                                    block_no;                     /* block number */
    VAR(uint8, AUTOMATIC)                                     sector_no;                    /* sector number */
    VAR(uint8, AUTOMATIC)                                     sector_no_tmp;                /* temp sector number */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                        write_data_ptr;               /* pointer to write data or read data */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  new_block_ptr;                /* pointer to new block */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  old_block_ptr;                /* pointer to old block */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                        src_data_ptr;                 /* source data */
    VAR(uint16, AUTOMATIC)                                    used_pages_size;              /* size counter of used pages for calculating Fee_BlkPageAreaEmptyAddr and page number of Fee_BlkMgtInfoBuffer */
    VAR(uint32, AUTOMATIC)                                    invalid_status;               /* check invalid status */
    VAR(MemIf_JobResultType, AUTOMATIC)                       retjob;                       /* result of fls job */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                       data_ptr;                     /* block data buffer for write block */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                    block_addr_index;             /* index of blocks */
    VAR(Fee_BlockConfigType, AUTOMATIC)                       blk_cfg;                      /* Block configuration array */
    VAR(uint16, AUTOMATIC)                                    blk_empty_size;               /* empty size */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                       blk_page_area_empty_addr_ptr; /* pointer to empty address for page area */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  blk_mgt_area_empty_addr_ptr;  /* pointer to empty address for block management area */
    VAR(Fee_ConfigType, AUTOMATIC)                            fee_cfg;                      /* fee configuration */
    VAR(Fee_FaultType, AUTOMATIC)                             fee_fault;                    /* get fault information from FLS */
    VAR(uint8, AUTOMATIC)                                     recycle_first_flag;           /* recycle first flag */
    VAR(uint8, AUTOMATIC)                                     sector_count;                 /* used for secor_no update */
    VAR(uint32, AUTOMATIC)                                    sector_size_for_caculate;     /* sector size for caculate */
    VAR(uint8, AUTOMATIC)                                     ret_sector_first;             /* return value of Fee_GetSectorFirst */


    data_ptr = Fee_GetData();

    retval          = FEE_CONT;
    block_no        = Fee_Job.BlockNumber;
    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: Casting to different object pointer type. And this casting is safety by judgment. */
    /* PRQA S 310 1*/
    write_data_ptr  = (uint8*)data_ptr;
    sector_no       = FEE_NONE_SECTOR;
    new_block_ptr   = (Fee_BlockManagementInfoType*)FEE_NULL;
    old_block_ptr   = (Fee_BlockManagementInfoType*)FEE_NULL;
    used_pages_size = (uint16)FEE_ZERO;
    retjob          = MEMIF_JOB_OK;
    recycle_first_flag = FEE_OFF;
    sector_size_for_caculate = (uint32)FEE_ZERO;
    ret_sector_first = FEE_OK;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_WriteProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_WRITE_START )
    {
        if( STD_ON == Fee_GetDefinedThresholdPageSize() )
        {
            /* => 0-1.clear global variable */
            proc = FEE_WRITE_CLEAR_GLOBAL_VAR;
        }
        else
        {
            if( Fee_GetDelayRecycleOperation() == FEE_ON )
            {
                /* delay recycle operation is on, do not recycle */
                
                if((Fee_RecycleFlag == FEE_ON) || (Fee_RecycleImmediateFlag == FEE_ON))
                {
                    /* => 4.get sector number for recycling */
                    proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                }
                else
                {
                    /* => 0-1.clear global variable */
                    proc = FEE_WRITE_CLEAR_GLOBAL_VAR;
                }
            }
            else
            {
                /* default : delay recycle operation is off, do recycle */
                /* => 0-1.clear global variable */
                proc = FEE_WRITE_CLEAR_GLOBAL_VAR;
            }
        }
    }
    else
    {
        /* If periodic processing is continued, pop related data under processing. */
        FEE_POP_STACK_UCHAR(sector_no)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(new_block_ptr, Fee_BlockManagementInfoType)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(old_block_ptr, Fee_BlockManagementInfoType)
        /* save the flag that show if recycle first or not. */
        FEE_POP_STACK_UCHAR(recycle_first_flag)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_POP_STACK_ULONG(sector_size_for_caculate)
    }

/* 0-1.clear global variable */
    if( proc == FEE_WRITE_CLEAR_GLOBAL_VAR )
    {
        Fee_BlockIndexAlreadyUpdated = FEE_BLOCK_INDEX_UPDATED_NO;
        /* => 1.check block address index */
        proc = FEE_WRITE_CHECK_BLOCK_ADDRESS_INDEX;
    }

/* 1.check block address index */
    if( proc == FEE_WRITE_CHECK_BLOCK_ADDRESS_INDEX )
    {
        retval = Fee_BlockIndexCheck();

        switch(retval)
        {
        case FEE_OK:
            /* => 2.distinguish write date before checking empty space size */
            proc = FEE_WRITE_PRE_CHECK_EMPTY_SIZE;
            break;
        case FEE_NG:
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_WRITE_END;
            break;
        default: /* FEE_CONT */
            /* continue */
            break;
        }
    }

/* 2.distinguish write date before checking empty space size */
    if( proc == FEE_WRITE_PRE_CHECK_EMPTY_SIZE )
    {
        blk_cfg              = Fee_GetBlkCfg(Fee_Job.BlockIndex);
        block_addr_index     = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
        /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
           Justification: This implementation is adopted for avoiding more nesting.
           It is no problem because side effects cannot be caused. */
        /* PRQA S 3415 1 */
        if(( blk_cfg.FeeImmediateData == TRUE ) && (Fee_GetDefinedThresholdPageSize() == STD_OFF))
        {
            if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
            {
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_ErrorCallout( FEE_EVENT_IMMEDIATEDATASPACE_UNAVAILABLE );
                /* => X.end of periodic processing */
                proc = FEE_WRITE_END;
            }
            else
            {
                /* => 7.make block */
                proc = FEE_WRITE_MAKE_BLOCK;
            }
        }
        else
        {
            /* => 3.check empty space size */
            proc = FEE_WRITE_CHECK_EMPTY_SIZE;
        }
    }

/* 3.check empty space size. */
    if( proc == FEE_WRITE_CHECK_EMPTY_SIZE )
    {
        blk_empty_size        = Fee_GetBlkEmptySize();
        blk_cfg               = Fee_GetBlkCfg(Fee_Job.BlockIndex);

        if(STD_ON == Fee_GetDefinedThresholdPageSize())
        {
            /* blk_empty_size is the real empty size in physical address. */
            /* [blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE] is current writing block size. */
            /* FEE_BLOCK_MANAGE_SIZE is the border between block manage area and block data area. */
            if( blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE) )
            {
                recycle_first_flag = FEE_ON;
                /* empty size is insufficient, recycle must be excuted before write */
                /* => 4.get sector number for recycling */
                proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
            }
            else
            {
                /* For immediate block, do write firstly. */
                /* After writing, check empty size. */
                if( blk_cfg.FeeImmediateData == TRUE )
                {
                    recycle_first_flag = FEE_OFF;
                    block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                    if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                    {
                        /* => 5 get old block page no */
                        proc = FEE_WRITE_GET_OLD_BLOCK_PAGENO;
                    }
                    else
                    {
                        /* => 7.make block */
                        proc = FEE_WRITE_MAKE_BLOCK;
                    }
                }
                else
                {
                    /* For normal block, check the empty size firstly. */
                    if( blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE + Fee_GetThresholdPageSize(Fee_CurrentConfigNo)) )
                    {
                        recycle_first_flag = FEE_ON;
                        /* => 4.get sector number for recycling */
                        proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                    }
                    else
                    {
                        recycle_first_flag = FEE_OFF;
                        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                        if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                        {
                            /* => 5 get old block page no */
                            proc = FEE_WRITE_GET_OLD_BLOCK_PAGENO;
                        }
                        else
                        {
                            /* => 7.make block */
                            proc = FEE_WRITE_MAKE_BLOCK;
                        }
                    }
                }
            }
        }
        else
        {
            if( blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1]) )
            {
                /* => 4.get sector number for recycling */
                proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
            }
            else
            {
                block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                {
                    /* => 5 get old block page no */
                    proc = FEE_WRITE_GET_OLD_BLOCK_PAGENO;
                }
                else
                {
                    /* => 7.make block */
                    proc = FEE_WRITE_MAKE_BLOCK;
                }
            }
        }
    }

/* 4.get sector number for recycling */
    if( proc == FEE_WRITE_GET_SECTOR_FOR_RECYCLE )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);    /* get sector number for recycling */

        if( (sector_no == FEE_INVALID_SECTOR_NO) || (sector_no == FEE_NONE_SECTOR) )
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            proc = FEE_WRITE_END;
        }
        else
        {
            /* => 4-a.recycle sector start */
            proc = FEE_WRITE_RECYCLE_START;
        }
    }

/* 4-a.recycle sector start */
    if( proc == FEE_WRITE_RECYCLE_START )
    {
        Fee_RecycleStart(sector_no);
        /* => 4-b.recycle sector */
        FEE_SET_PROC(FEE_WRITE_RECYCLE)
    }

/* 4-b.recycle sector */
    if( proc == FEE_WRITE_RECYCLE )
    {
        /* recycling */
        retval = Fee_RecyclePolling();
        if( retval != FEE_CONT )
        {
            /* => 4-c.check result of recycling */
            FEE_SET_PROC(FEE_WRITE_RECYCLE_CHECK)
        }
    }

/* 4-c.check result of recycling */
    if( proc == FEE_WRITE_RECYCLE_CHECK )
    {
        retval = Fee_RecycleFinal();

        if( retval == FEE_OK )
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                if( FEE_ON == recycle_first_flag )
                {
                    /* recycle_first_flag is on. So, write operation has not done when recycle finished. */
                    /* Needs to go to write. */
                    blk_empty_size        = Fee_GetBlkEmptySize();
                    blk_cfg               = Fee_GetBlkCfg(Fee_Job.BlockIndex);
                    if(blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE + Fee_GetThresholdPageSize(Fee_CurrentConfigNo)))
                    {
                        /* This is for fail-safe. After recycle, do check empty size agian. */
                        /* => 4.get sector number for recycling */
                        proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                    }
                    else
                    {
                        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                        if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                        {
                            /* => 5 get old block page no */
                            proc = FEE_WRITE_GET_OLD_BLOCK_PAGENO;
                        }
                        else
                        {
                            /* => 7.make block */
                            proc = FEE_WRITE_MAKE_BLOCK;
                        }
                        recycle_first_flag = FEE_OFF;
                    }
                }
                else /* FEE_OFF == recycle_first_flag */
                {
                    /* recycle_first_flag is off. So, write operation has done when recycle finished. */
                    /* Needs to go to finish the write. */
                    blk_empty_size        = Fee_GetBlkEmptySize();
                    blk_cfg               = Fee_GetBlkCfg(Fee_Job.BlockIndex);
                    if(blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE + Fee_GetThresholdPageSize(Fee_CurrentConfigNo)))
                    {
                        /* This is for fail-safe. After recycle, do check empty size agian. */
                        /* => 4.get sector number for recycling */
                        proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                    }
                    else
                    {
                        Fee_JobResult = MEMIF_JOB_OK;
                        /* => X.end of periodic processing */
                        proc = FEE_WRITE_END;
                    }
                }
            }
            else /* STD_OFF == Fee_GetDefinedThresholdPageSize() */
            {
                if( Fee_GetDelayRecycleOperation() == FEE_ON )
                {
                    /* delay recycle operation is on, do not recycle */
                    /* 0-1.clear global variable */
                    proc = FEE_WRITE_CLEAR_GLOBAL_VAR;
                }
                else
                {
                    /* default : delay recycle operation is off, do recycle */
                    blk_empty_size        = Fee_GetBlkEmptySize();
                    blk_cfg               = Fee_GetBlkCfg(Fee_Job.BlockIndex);
                    if( blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + (Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1])) )
                    {
                        /* This is for fail-safe. After recycle, do check empty size agian. */
                        /* => 4.get sector number for recycling */
                        proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                    }
                    else
                    {
                        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                        if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                        {
                            /* => 5 get old block page no */
                            proc = FEE_WRITE_GET_OLD_BLOCK_PAGENO;
                        }
                        else
                        {
                            /* => 7.make block */
                            proc = FEE_WRITE_MAKE_BLOCK;
                        }
                    }
                }
            }
        }
        else
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_WRITE_END;
        }
    }

/* 5 get old block page no  */
    if(proc == FEE_WRITE_GET_OLD_BLOCK_PAGENO)
    {
        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        old_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);

        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)old_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();
        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            /* If 1bit/2bit ECC occurs when it reads old block number, ignore the old block and write new block. */
            /* And the old block will be invalidated in proc10. */

            /* => 7.make block */
            proc = FEE_WRITE_MAKE_BLOCK;
        }
        else
        {
            /* => 6.check same block */
            proc = FEE_WRITE_CHECK_SAME_BLOCK;
        }
    }

/* 6.check same block */
    if( proc == FEE_WRITE_CHECK_SAME_BLOCK )
    {
        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
        sector_no_tmp = Fee_GetSector(FEE_SECTOR_EFFECTIVE);

        if( (sector_no_tmp == FEE_INVALID_SECTOR_NO) || (sector_no_tmp == FEE_NONE_SECTOR) )
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            proc = FEE_WRITE_END;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            old_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested. */
            /* PRQA S 306,488,1840,1860 1 */
            src_data_ptr = Fee_CalPhysicalAddrFromPageNo(sector_no_tmp, Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);

            blk_cfg = Fee_GetBlkCfg(Fee_Job.BlockIndex);

            Fee_SetFlsDedErrorNotificationVar((uint8)FEE_OFF);
            Fee_SetFlsSedErrorNotificationVar((uint8)FEE_OFF);

            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            (void)Fee_FlsCompare((uint32)src_data_ptr, write_data_ptr, (uint32)blk_cfg.FeeBlockSize);

            /* => 6-a.check result of check same block */
            FEE_SET_PROC(FEE_WRITE_CHECK_SAME_BLOCK_CHECK)
        }
    }

/* 6-a.check result of check same block */
    if( proc == FEE_WRITE_CHECK_SAME_BLOCK_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
               Justification: This implementation is adopted for avoiding more nesting.
               It is no problem because side effects cannot be caused. */
            /* PRQA S 3415 1 */
            if((Fee_GetFlsDedErrorNotificationVar() == (uint8)FEE_ON) || (Fee_GetFlsSedErrorNotificationVar() == (uint8)FEE_ON))
            {
                /* => 7.make block */
                proc = FEE_WRITE_MAKE_BLOCK;
            }
            else
            {
                /* not need write because data is corresponding */
                Fee_JobResult = MEMIF_JOB_OK;
                /* => X.end of periodic processing */
                proc = FEE_WRITE_END;
            }        
            break;

        case MEMIF_BLOCK_INCONSISTENT:
        case MEMIF_JOB_FAILED:
            /* => 7.make block */
            proc = FEE_WRITE_MAKE_BLOCK;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 7.make block */
    if( proc == FEE_WRITE_MAKE_BLOCK )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);

        if( (sector_no == FEE_INVALID_SECTOR_NO) || (sector_no == FEE_NONE_SECTOR) )
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            proc = FEE_WRITE_END;
        }
        else
        {
            /* make block */
            blk_cfg                      = Fee_GetBlkCfg(Fee_Job.BlockIndex);
            blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
            fee_cfg = Fee_GetCfg();
            /* calculate the sum size of pages for page number : sum = (already existed page size) + (new write target page size) */
            /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic. */
            /* PRQA S 306,488,3395 1 */
            used_pages_size = (uint16)((uint32)(Fee_GetFlashSectorEraseFlagAddr(sector_no)) - (uint32)blk_page_area_empty_addr_ptr) + Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize);

            if( sector_no == Fee_GetNoOfSec() ) /* If the sector is the last one, it needs to add remaining size. */
            {
                sector_size_for_caculate = Fee_GetSectorSize() + Fee_GetRemainSize();
            }
            else
            {
                sector_size_for_caculate = Fee_GetSectorSize();
            }
            if(used_pages_size < sector_size_for_caculate)
            {
                /* set block write flag */
                Fee_BlkMgtInfoBuffer.WriteFlag = (uint32)FEE_BLOCK_INITIAL_WRITEFLAG;
                /* set block number */
                Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = (uint16)block_no;
                /* set page number */
                /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8
                Justification: Casting to different type for consistency. */
                /* PRQA S 4391 1 */
                Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.PageNum = (uint16)(used_pages_size/fee_cfg.FeeVirtualPageSize);
                /* set Valid Block status */
                Fee_BlkMgtInfoBuffer.ValidStat   = FEE_BLOCK_VALID_BLOCK;

                /* => 8.check empty address before writing block */
                proc = FEE_WRITE_PRE_WRITE_BLOCK;
            }
            else
            {
                /* update sector_no */
                for( sector_count = (uint8)1; sector_count <= Fee_ConfigInfo[FEE_CONFIG_SET_1 - (uint8)1].Fee_NoOfSec; sector_count++ )
                {
                    ret_sector_first = Fee_GetSectorFirst(FEE_CONFIG_SET_1, sector_count);
                }
                if( FEE_CONFIG_SET_2 == Fee_GetCfgNum() )
                {
                    for( sector_count = (uint8)1; sector_count <= Fee_ConfigInfo[FEE_CONFIG_SET_2 - (uint8)1].Fee_NoOfSec; sector_count++ )
                    {
                        ret_sector_first = Fee_GetSectorFirst(FEE_CONFIG_SET_2, sector_count);
                    }
                }
                if( FEE_OK == ret_sector_first )
                {
                    /* => 8-a.search blank area(resetting variable) */
                    proc = FEE_WRITE_SEARCH_BLANK_AREA;
                }
                else
                {
                    Fee_JobResult = MEMIF_JOB_FAILED;
                    Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                    /* => X.end of periodic processing */
                    proc = FEE_WRITE_END;
                }
            }
        }
    }

/* 8.check empty address before writing block */
    if( proc == FEE_WRITE_PRE_WRITE_BLOCK )
    {
        blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
        blk_mgt_area_empty_addr_ptr  = Fee_GetBlkMgtAreaEmptyAddr();
        blk_empty_size               = Fee_GetBlkEmptySize();
        /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        if( (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr) == blk_empty_size )
        {
            new_block_ptr = blk_mgt_area_empty_addr_ptr;

            /* => 9.write block  */
            proc = FEE_WRITE_WRITE_BLOCK;
        }
        else
        {
            /* data of empty address is corruption */
            /* => 8-a.search blank area(resetting variable) */
            proc = FEE_WRITE_SEARCH_BLANK_AREA;
        }
    }

/* 8-a.search blank area(resetting variable) */
    if( proc == FEE_WRITE_SEARCH_BLANK_AREA )
    {
        retval = Fee_SearchBlankArea(sector_no);

        switch(retval)
        {
        case FEE_OK:
            /* => 7.make block */
            proc = FEE_WRITE_MAKE_BLOCK;
            break;
        case FEE_NG:
            /* => 4-a.recycle sector start */
            proc = FEE_WRITE_RECYCLE_START;
            break;
        default: /* FEE_CONT */
            /* continue */
            break;
        }
    }

/* 9.write block */
    if( proc == FEE_WRITE_WRITE_BLOCK )
    {
        retval = Fee_WriteBlock(sector_no, new_block_ptr, write_data_ptr, FEE_ADJUSTING_USE_NEW_STRUCT);

        if( retval == FEE_OK )
        {
            block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
            if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
            {
                /* old block exist */
                /* => 10.invalidate old block */
                FEE_SET_PROC(FEE_WRITE_DISABLE)
            }
            else
            {
                /* no old block */
                /* updata the 2 empty address pointers and block empty size */
                Fee_UpdateEmptyAreaPtrAfterWriteBlock();

                /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                   Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306,488 1 */
                block_addr_index.BlkAddr       = (uint32)new_block_ptr;
                block_addr_index.BlkStatus     = FEE_BLKIDX_VALID_BLOCK;
                block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);
                Fee_BlockIndexAlreadyUpdated = FEE_BLOCK_INDEX_UPDATED_YES;

                blk_cfg = Fee_GetBlkCfg(Fee_Job.BlockIndex);
                if((STD_ON == Fee_GetDefinedThresholdPageSize()) && (TRUE == blk_cfg.FeeImmediateData))
                {
                    blk_empty_size = Fee_GetBlkEmptySize();
                    /* [blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE] is a whole block size. */
                    /* FEE_BLOCK_MANAGE_SIZE is border between management area and data area. */
                    /* Fee_GetThresholdPageSize is the reserved area for immediate block. */
                    if(blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE + Fee_GetThresholdPageSize(Fee_CurrentConfigNo)))
                    {
                        /* => 4.get sector number for recycling */
                        proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                    }
                    else
                    {
                        Fee_JobResult = MEMIF_JOB_OK;
                        /* => X.end of periodic processing */
                        proc = FEE_WRITE_END;
                    }
                }
                else
                {
                    if( blk_cfg.FeeImmediateData == TRUE )
                    {
                        Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] -= (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                    }
                    Fee_JobResult = MEMIF_JOB_OK;
                    /* => X.end of periodic processing */
                    proc = FEE_WRITE_END;
                }
            }
        }
        else if( retval == FEE_NG )
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_WRITE_END;
        }
        else
        {
            /* continue */
        }
    }

/* 10.invalidate old block */
    if( proc == FEE_WRITE_DISABLE )
    {
        Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;

        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)old_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */

        /* => 10-a.check result of invalidating old block */
        FEE_SET_PROC(FEE_WRITE_DISABLE_CHECK)
    }

/* 10-a.check result of invalidating old block */
    if( proc == FEE_WRITE_DISABLE_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* updata the 2 empty address pointers and block empty size */
            Fee_UpdateEmptyAreaPtrAfterWriteBlock();

            /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            block_addr_index.BlkAddr       = (uint32)new_block_ptr;
            block_addr_index.BlkStatus     = FEE_BLKIDX_VALID_BLOCK;
            block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
            Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);
            Fee_BlockIndexAlreadyUpdated = FEE_BLOCK_INDEX_UPDATED_YES;

            blk_cfg = Fee_GetBlkCfg(Fee_Job.BlockIndex);
            if((STD_ON == Fee_GetDefinedThresholdPageSize()) && (TRUE == blk_cfg.FeeImmediateData))
            {
                blk_empty_size = Fee_GetBlkEmptySize();
                /* [blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE] is a whole block size. */
                /* FEE_BLOCK_MANAGE_SIZE is border between management area and data area. */
                /* Fee_GetThresholdPageSize is the reserved area for immediate block. */
                if(blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE + Fee_GetThresholdPageSize(Fee_CurrentConfigNo)))
                {
                    /* => 4.get sector number for recycling */
                    proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                }
                else
                {
                    Fee_JobResult = MEMIF_JOB_OK;
                    /* => X.end of periodic processing */
                    proc = FEE_WRITE_END;
                }
            }
            else
            {
                Fee_JobResult = MEMIF_JOB_OK;
                /* => X.end of periodic processing */
                proc = FEE_WRITE_END;
            }
            break;

        case MEMIF_JOB_FAILED:
            /* updata the 2 empty address pointers and block empty size */
            Fee_UpdateEmptyAreaPtrAfterWriteBlock();

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            invalid_status = Fee_FlsGetReadAddr((uint32)old_block_ptr  + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

            if( invalid_status != FEE_NULL )
            {
                /*the old block has been invalid, need to update index to the new one*/

                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                   Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306,488 1 */
                block_addr_index.BlkAddr       = (uint32)new_block_ptr;
                block_addr_index.BlkStatus     = FEE_BLKIDX_VALID_BLOCK;
                block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);
                Fee_BlockIndexAlreadyUpdated = FEE_BLOCK_INDEX_UPDATED_YES;
            }

            blk_cfg = Fee_GetBlkCfg(Fee_Job.BlockIndex);
            if((STD_ON == Fee_GetDefinedThresholdPageSize()) && (TRUE == blk_cfg.FeeImmediateData))
            {
                blk_empty_size = Fee_GetBlkEmptySize();
                /* [blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE] is a whole block size. */
                /* FEE_BLOCK_MANAGE_SIZE is border between management area and data area. */
                /* Fee_GetThresholdPageSize is the reserved area for immediate block. */
                if(blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + FEE_BLOCK_MANAGE_SIZE + Fee_GetThresholdPageSize(Fee_CurrentConfigNo)))
                {
                    /* => 4.get sector number for recycling */
                    proc = FEE_WRITE_GET_SECTOR_FOR_RECYCLE;
                }
                else
                {
                    Fee_JobResult = MEMIF_JOB_FAILED;
                    Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                    /* => X.end of periodic processing */
                    proc = FEE_WRITE_END;
                }
            }
            else
            {
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                /* => X.end of periodic processing */
                proc = FEE_WRITE_END;
            }
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* X.end of periodic processing  */
    if( proc == FEE_WRITE_END )
    {
        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;        /* clear main state */
        proc = FEE_WRITE_START;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_PUSH_STACK_ULONG(sector_size_for_caculate)
        FEE_PUSH_STACK_UCHAR(recycle_first_flag)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(old_block_ptr)

        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(new_block_ptr)
        FEE_PUSH_STACK_UCHAR(sector_no)
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    if( proc == FEE_WRITE_START )
    {
        retval = FEE_OK;
    }
    else
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_MainRead
**
** Periodic processing of reading.
** Execute callback function when complete reading.
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_MainRead(void)
{
    VAR(Fee_ReadProcType, AUTOMATIC)                               proc;               /* position of the processing */
    VAR(uint8, AUTOMATIC)                                          result;             /* result of execute */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                             read_data_ptr;      /* pointer to read data */
    VAR(uint16, AUTOMATIC)                                         offset;             /* read offset */
    VAR(uint16, AUTOMATIC)                                         length;             /* length */
    VAR(uint8, AUTOMATIC)                                          sector_no;          /* sector number */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                             src_data_ptr;       /* source data */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)       read_block_ptr;     /* pointer to block */
    VAR(MemIf_JobResultType, AUTOMATIC)                            retjob;             /* result of fls job */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                         block_addr_index;   /* index of blocks */
    VAR(Fee_FaultType, AUTOMATIC)                                  fee_fault;          /* get fault information from FLS */

    read_data_ptr   = Fee_Job.DataBufferPtr.ReadBufferPtr;
    offset          = Fee_Job.BlockOffset;
    length          = Fee_Job.Length;
    src_data_ptr    = (uint8*)FEE_NULL;
    read_block_ptr  = (Fee_BlockManagementInfoType*)FEE_NULL;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_ReadProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_READ_START )
    {
        /* => 1.check block address index */
        proc = FEE_READ_CHECK_BLOCK_ADDRESS_INDEX;
        Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. 
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(read_block_ptr, Fee_BlockManagementInfoType)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(src_data_ptr, uint8)
        FEE_POP_STACK_UCHAR(sector_no)
    }

/* 1.check block address index */
    if( proc == FEE_READ_CHECK_BLOCK_ADDRESS_INDEX )
    {
        result = Fee_BlockIndexCheck();

        switch(result)
        {
        case FEE_OK:
            /* => 2.get the address by index */
            proc = FEE_READ_GET_ADDRESS_BY_INDEX;
            break;
        case FEE_NG:
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_READ_END;
            break;
        default: /* FEE_CONT */
            /* continue */
            break;
        }
    }

/* 2.get the address by index */
    if( proc == FEE_READ_GET_ADDRESS_BY_INDEX )
    {
        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);

        if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
        {
            sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);       /* get reading or moving sector */

            if( (sector_no == FEE_INVALID_SECTOR_NO) || (sector_no == FEE_NONE_SECTOR) )
            {
                /* => X.end of periodic processing */
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                proc = FEE_READ_END;
            }
            else
            {
                /* => 3.get block no page no */
                proc = FEE_READ_GET_BLOCKNO_PAGENO;
            }
        }
        else
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_BLOCK_INVALID;
            proc = FEE_READ_END;
        }
    }

/* 3.get block no page no */
    if(proc == FEE_READ_GET_BLOCKNO_PAGENO)
    {
        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);

        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        read_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);

        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)read_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if(fee_fault == FEE_FAULT_DED) /* 2bit ECC error */
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_2BIT_ECC_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_READ_END;
        }
        else if(fee_fault == FEE_FAULT_SED) /* 1bit ECC error */
        {
            Fee_ErrorCallout( FEE_EVENT_1BIT_ECC_ERROR_OCCURRED );

            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested.*/
            /* PRQA S 306,488,1840,1860 1 */
            src_data_ptr = Fee_CalPhysicalAddrFromPageNo(sector_no, Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum) + offset;
            
            /* => 4.data copy */
            proc = FEE_READ_COPYDATA;
        }
        else if(fee_fault == FEE_FAULT_NONE)
        {
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested.*/
            /* PRQA S 306,488,1840,1860 1 */
            src_data_ptr = Fee_CalPhysicalAddrFromPageNo(sector_no, Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum) + offset;
            
            /* => 4.data copy */
            proc = FEE_READ_COPYDATA;
        }
        else /* other error */
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_READ_END;
        }
    }

/* 4.data copy */
    if( proc == FEE_READ_COPYDATA )
    {
        Fee_SetFlsDedErrorNotificationVar((uint8)FEE_OFF);
        Fee_SetFlsSedErrorNotificationVar((uint8)FEE_OFF);

        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        (void)Fee_FlsRead((uint32)src_data_ptr, read_data_ptr, (uint32)length);

        /* => 4-a.check result of data copy */
        FEE_SET_PROC(FEE_READ_COPYDATA_CHECK)
    }

/* 4-a.check result of data copy */
    if( proc == FEE_READ_COPYDATA_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            if(Fee_GetFlsDedErrorNotificationVar() == (uint8)FEE_ON)
            {
                Fee_ErrorCallout( FEE_EVENT_2BIT_ECC_ERROR_OCCURRED );
                Fee_JobResult = MEMIF_JOB_FAILED;
            }
            else if(Fee_GetFlsSedErrorNotificationVar() == (uint8)FEE_ON)
            {
                Fee_ErrorCallout( FEE_EVENT_1BIT_ECC_ERROR_OCCURRED );
                Fee_JobResult = MEMIF_JOB_OK;
            }
            else
            {
                Fee_JobResult = MEMIF_JOB_OK;
            }

            /* => X.end of periodic processing */
            proc = FEE_READ_END;
            break;

        case MEMIF_JOB_FAILED:
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_READ_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_READ_END )
    {
        /* => 0.entry of periodic processing */
        FEE_PUSH_PROC(FEE_READ_START)
        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;

        Fee_CallCbk(Fee_JobResult);
    }
    else
    {
        FEE_PUSH_PROC(proc)
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The sector_no is only used after it is initialized by the former mainfunction. */
        /* PRQA S 2962 1 */
        FEE_PUSH_STACK_UCHAR(sector_no)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(src_data_ptr)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(read_block_ptr)
    }

    return;
}


/** \brief Fee_MainInvalidate
**
** Periodic processing of invalidating.
** Execute callback function when complete invalidating.
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_MainInvalidate(void)
{
    VAR(Fee_MainInvalProcType, AUTOMATIC)  proc;           /* position of the processing */
    VAR(uint8, AUTOMATIC)                  result;         /* result of execute */
    VAR(uint8, AUTOMATIC)                  sector_no;      /* number of sector */

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_MainInvalProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_MAIN_INVAL_START )
    {
        /* =>1.check sectors */
        proc = FEE_MAIN_INVAL_CHECK_SECTORS;
    }
    else
    {
        FEE_POP_STACK_UCHAR(sector_no)
    }

/* 1.check sectors */
    if( proc == FEE_MAIN_INVAL_CHECK_SECTORS )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_ENABLE);

        if( sector_no == FEE_NONE_SECTOR )
        {
            /* no enable sector, that means there is one moving sector */
            /* => 3.execute periodic processing of invalidating */
            proc = FEE_MAIN_INVAL_PROC;
        }
        else
        {
            /* enable sector exist, then check whether there is also one moving sector exist */
            sector_no = Fee_GetSector(FEE_SECTOR_MOVING);

            if( sector_no == FEE_NONE_SECTOR )
            {
                /* one enable sector and no moving sector */
                /* => 3.execute periodic processing of invalidating */
                proc = FEE_MAIN_INVAL_PROC;
            }
            else
            {
                /* one enable sector and one moving sector exist */
                /* =>2.set erasing sector */
                proc = FEE_MAIN_INVAL_SET_ERASING_SECTOR;
            }
        }
    }

/* 2.set erasing sector */
    if( proc == FEE_MAIN_INVAL_SET_ERASING_SECTOR )
    {
        result = Fee_SetSector(sector_no, FEE_SECTOR_GARBAGE);

        if( result == FEE_OK )
        {
            /* => 3.execute periodic processing of invalidating */
            proc = FEE_MAIN_INVAL_PROC;
        }
        else if( result == FEE_NG )
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_MAIN_INVAL_END;
        }
        else
        {
            /* continue */
        }
    }

/* 3.execute periodic processing of invalidating */
    if( proc == FEE_MAIN_INVAL_PROC )
    {
        result = Fee_MainInvalidateProc();

        if( result != FEE_CONT )
        {
            /* => X.end of periodic processing */
            proc = FEE_MAIN_INVAL_END;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_MAIN_INVAL_END )
    {
        /* => 0.entry of periodic processing */
        FEE_PUSH_PROC(FEE_MAIN_INVAL_START)

        Fee_CallCbk(Fee_JobResult);
    }
    else
    {
        FEE_PUSH_PROC(proc)
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The sector_no is only used after it is initialized by the former mainfunction. */
        /* PRQA S 2962 1 */
        FEE_PUSH_STACK_UCHAR(sector_no)
    }

    return;
}


/** \brief Fee_MainInvalidateProc
**
** Periodic processing of invalidating.
**
**
** \return     state of processing
** \retval     FEE_OK     success
** \retval     FEE_CONT   continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
static FUNC(uint8, FEE_CODE) Fee_MainInvalidateProc(void)
{
    VAR(Fee_InvalProcType, AUTOMATIC)                          proc;                     /* position of the processing */
    VAR(uint8, AUTOMATIC)                                      retval;                   /* return value */
    VAR(uint8, AUTOMATIC)                                      sector_no;                /* sector number */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)   inval_block_ptr;          /* pointer to block for invalidating */
    VAR(uint32, AUTOMATIC)                                     invalid_status;           /* check invalid status */
    VAR(MemIf_JobResultType, AUTOMATIC)                        retjob;                   /* result of fls job */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                     block_addr_index;         /* index of blocks */
    VAR(uint16, AUTOMATIC)                                     blk_empty_size;           /* empty size */
    VAR(Fee_BlockConfigType, AUTOMATIC)                        blk_cfg;                  /* Block configuration array */

    sector_no          = FEE_NONE_SECTOR;
    inval_block_ptr    = (Fee_BlockManagementInfoType*)FEE_NULL;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_InvalProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_INVAL_START )
    {
        /* => 1.check block address index */
        proc = FEE_INVAL_CHECK_BLOCK_ADDRESS_INDEX;
    }
    else
    {
        FEE_POP_STACK_UCHAR(sector_no)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(inval_block_ptr, Fee_BlockManagementInfoType)
    }

/* 1.check block address index */
    if( proc == FEE_INVAL_CHECK_BLOCK_ADDRESS_INDEX )
    {
        retval = Fee_BlockIndexCheck();

        switch(retval)
        {
        case FEE_OK:
            /* => 2.distinguish invalidate date before checking empty space size */
            FEE_SET_PROC(FEE_INVAL_PRE_CHECK_EMPTY_SIZE)
            break;
        case FEE_NG:
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_INVAL_END;
            break;
        default: /* FEE_CONT */
            /* continue */
            break;
        }
    }

/* 2.distinguish invalidate date before checking empty space size */
    if( proc == FEE_INVAL_PRE_CHECK_EMPTY_SIZE )
    {
        blk_cfg                  = Fee_GetBlkCfg(Fee_Job.BlockIndex);
        block_addr_index         = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
        if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
        {
            if( blk_cfg.FeeImmediateData == TRUE )
            {
                /* => 3.check empty size */
                proc = FEE_INVAL_CHECK_EMPTY_SIZE;
            }
            else
            {
                /* => 5.invalidate block */
                proc = FEE_INVAL_DISABLE;
            }
        }
        else
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_BLOCK_INVALID;
            proc = FEE_INVAL_END;
        }
    }

/* 3.check empty size */
    if( proc == FEE_INVAL_CHECK_EMPTY_SIZE )
    {
        if(STD_ON == Fee_GetDefinedThresholdPageSize())
        {
            /* => 5.invalidate block */
            proc = FEE_INVAL_DISABLE;
        }
        else
        {
            blk_cfg                   = Fee_GetBlkCfg(Fee_Job.BlockIndex);
            blk_empty_size            = Fee_GetBlkEmptySize();
            if( blk_empty_size < (blk_cfg.FeeBlockSize + FEE_BLOCK_MANAGE_SIZE + Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1]) )
            {
                /* => 4.get sector number for recycling */
                proc = FEE_INVAL_GET_SECTOR_FOR_RECYCLE;
            }
            else
            {
                /* => 5.invalidate block */
                proc = FEE_INVAL_DISABLE;
            }
        }
    }

/* 4.get sector number for recycling */
    if( proc == FEE_INVAL_GET_SECTOR_FOR_RECYCLE )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);    /* get sector number for recycling */

        if( (sector_no == FEE_INVALID_SECTOR_NO) || (sector_no == FEE_NONE_SECTOR) )
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            proc = FEE_INVAL_END;
        }
        else
        {
            /* => 4-a.recycle sector start */
            proc = FEE_INVAL_RECYCLE_START;
        }
    }

/* 4-a.recycle sector start */
    if( proc == FEE_INVAL_RECYCLE_START )
    {
        Fee_RecycleStart(sector_no);
        /* => 4-b.recycle sector */
        FEE_SET_PROC(FEE_INVAL_RECYCLE)
    }

/* 4-b.recycle sector */
    if( proc == FEE_INVAL_RECYCLE )
    {
        /* recycling */
        retval = Fee_RecyclePolling();
        if( retval != FEE_CONT )
        {
            /* => 4-c.check result of recycling */
            FEE_SET_PROC(FEE_INVAL_RECYCLE_CHECK)
        }
    }

/* 4-c.check result of recycling */
    if( proc == FEE_INVAL_RECYCLE_CHECK )
    {
        retval = Fee_RecycleFinal();

        if( retval == FEE_OK )
        {
            /* => 5.invalidate block */
            FEE_SET_PROC(FEE_INVAL_DISABLE)
        }
        else
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_INVAL_END;
        }
    }

/* 5.invalidate block */
    if( proc == FEE_INVAL_DISABLE )
    {
        block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
        sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);

        if( (sector_no == FEE_INVALID_SECTOR_NO) || (sector_no == FEE_NONE_SECTOR) )
        {
            /* => X.end of periodic processing */
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            proc = FEE_INVAL_END;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            inval_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);
            Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;

            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 306,310 1 */
            (void)Fee_FlsWrite((uint32)inval_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */

            /* => 6.check result of invalidating block */
            FEE_SET_PROC(FEE_INVAL_DISABLE_CHECK)
        }
    }

/* 6.check result of invalidating block */
    if( proc == FEE_INVAL_DISABLE_CHECK )
    {
        retjob = Fee_FlsGetJobResult();

        blk_cfg = Fee_GetBlkCfg(Fee_Job.BlockIndex);

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            Fee_JobResult = MEMIF_JOB_OK;

            block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306,488 1 */
            block_addr_index.BlkAddr   = (uint32)inval_block_ptr;
            block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
            Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);
            if(STD_OFF == Fee_GetDefinedThresholdPageSize())
            {
                if( blk_cfg.FeeImmediateData == TRUE )
                {
                    Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                }
            }
            /* => X.end of periodic processing */
            proc = FEE_INVAL_END;

            break;

        case MEMIF_JOB_FAILED:
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            invalid_status = Fee_FlsGetReadAddr((uint32)inval_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

            if( invalid_status != FEE_NULL )
            {
                /* the block has been invalid, need to update index to invalid */
                block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                   Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306,488 1 */
                block_addr_index.BlkAddr   = (uint32)inval_block_ptr;
                block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);
                if(STD_OFF == Fee_GetDefinedThresholdPageSize())
                {
                    if( blk_cfg.FeeImmediateData == TRUE )
                    {
                        Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                    }
                }
            }

            /* => X.end of periodic processing */
            proc = FEE_INVAL_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_INVAL_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_INVAL_START;

        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
        retval = FEE_OK;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(inval_block_ptr)
        FEE_PUSH_STACK_UCHAR(sector_no)
        
        retval = FEE_CONT;
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    return retval;
}


/** \brief Fee_MainRecycle
**
** Periodic processing of recycling.
** Execute callback function when complete recycling.
**
** \return     none
**
*/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: This is an API function. */
/* PRQA S 1503 1 */
FUNC(void, FEE_CODE) Fee_MainRecycle(void)
{
    VAR(uint8, AUTOMATIC) result; /* result of execute */

    result = Fee_Recover();
    switch(result)
    {
    case FEE_OK:
        Fee_JobResult = MEMIF_JOB_OK;
        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
        Fee_CallCbk(Fee_JobResult);
        break;
    case FEE_NG:
    case FEE_INVALID_SECTOR_NO:
        Fee_JobResult = MEMIF_JOB_FAILED;
        Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;
        Fee_CallCbk(Fee_JobResult);
        break;
    default: /* FEE_CONT */
        break;
    }

    return;
}


/** \brief Fee_MainClear
**
** Periodic processing of clearing.
** Execute callback function when complete clearing.
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_MainClear(void)
{
    VAR(Fee_ClearProcType, AUTOMATIC)    proc;            /* position of the processing */
    VAR(uint8, AUTOMATIC)                cnt_sector;      /* loop counter */
    VAR(uint8, AUTOMATIC)                no_of_sec;       /* Number of defined sectors */
    VAR(uint8, AUTOMATIC)                retval;          /* return value */

    cnt_sector = (uint8)FEE_ZERO;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_ClearProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_CLEAR_START )
    {
        /* 1.erase sector */
        proc = FEE_CLEAR_ERASE_SECTOR;
    }
    else
    {
        FEE_POP_STACK_UCHAR(cnt_sector)
    }

/* 1.erase sector */
    if( proc == FEE_CLEAR_ERASE_SECTOR )
    {
        no_of_sec = Fee_GetNoOfSec();
        if( cnt_sector < no_of_sec )
        {
            retval = Fee_EraseSector(cnt_sector + FEE_SECTOR_STATUS_OFFSET);

            switch(retval)
            {
            case FEE_OK:
                cnt_sector++;
                break;

            case FEE_NG:
                Fee_JobResult = MEMIF_JOB_FAILED;
                Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
                /* => X.end of periodic processing */
                proc = FEE_CLEAR_END;
                break;

            default: /* FEE_CONT */
                /* do nothing */
                break;
            }
        }
        else
        {
            Fee_JobResult = MEMIF_JOB_OK;
            /* => X.end of periodic processing */
            proc = FEE_CLEAR_END;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_CLEAR_END )
    {
        if( Fee_JobResult == MEMIF_JOB_FAILED )
        {
            /* initialize array of sector status when the job failed */
            for( cnt_sector = (uint8)FEE_ZERO; cnt_sector < (uint8)Fee_ConfigInfo[Fee_Job.ConfigSetNumber - (uint8)1].Fee_NoOfSec; cnt_sector++ )
            {
                Fee_SetSectorStatusElementWithCfg(Fee_Job.ConfigSetNumber, cnt_sector, FEE_SECTOR_NOSTATUS);
                Fee_SetSectorStatusMirrorElementWithCfg(Fee_Job.ConfigSetNumber, cnt_sector, FEE_SECTOR_NOSTATUS);
            }
        }
        /* => 0.entry of periodic processing */
        FEE_PUSH_PROC(FEE_CLEAR_START)
        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;

        Fee_CallCbk(Fee_JobResult);
    }
    else
    {
        FEE_PUSH_PROC(proc)
        FEE_PUSH_STACK_UCHAR(cnt_sector)
    }

    return;
}


/** \brief Fee_MainCommon
**
** Periodic common processing of LIB layer.
** If FLS layer is active, execute periodic processing of driver.
** If FLS layer is not active, check corruption in Fee_SectorStatus[].
**
** \return     result
** \retval     FEE_NG     failure
** \retval     FEE_OK     success
** \retval     FEE_CONT   continue
**
*/
FUNC(uint8, FEE_CODE) Fee_MainCommon(void)
{
    VAR(uint8, AUTOMATIC) retval;                        /* return value */
    VAR(uint8, AUTOMATIC) cnt;                           /* loop counter */
    VAR(uint8, AUTOMATIC) cnt_sub;                       /* loop counter */
    VAR(uint8, AUTOMATIC) ret_sector_first;              /* return value of Fee_GetSectorFirst */

    retval = FEE_CONT;
    ret_sector_first = FEE_OK;
    Fee_MainCommonProc = Fee_MainCommonProcNext;

/* 0.entry of periodic processing */
    if( Fee_MainCommonProc == FEE_MAIN_COMMON_START )
    {
        /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
           Justification: This implementation is adopted for avoiding more nesting.
           It is no problem because side effects cannot be caused. */
        /* PRQA S 3415 1 */
        if( (MEMIF_IDLE == Fee_FlsGetStatus()) && (MEMIF_IDLE == Fee_FlsGetStatusSub()) )
        {
            /* 1.check sector status and sector status mirror */
            Fee_MainCommonProc = FEE_MAIN_COMMON_CHECK_STATUS_MIRROR;
        }
        Fee_CurrentConfigNoTemp = Fee_CurrentConfigNo;
    }
    else
    {
        /* do nothing */
    }

/* 1.check sector status and sector status mirror */
    if( Fee_MainCommonProc == FEE_MAIN_COMMON_CHECK_STATUS_MIRROR )
    {
        /* check sector status and sector status mirror */
        for( cnt = (uint8)FEE_ZERO; cnt < (uint8)Fee_GetCfgNum(); cnt++ )
        {
            if( Fee_GetSectorStatusElementWithCfg(cnt + (uint8)1, FEE_ZERO) == FEE_SECTOR_NOSTATUS )
            {
                /* Deviation from MISRA-C:2012 Rule-14.2
                   Justification: This implementation is adopted for algrithm. */
                /* PRQA S 2469 1 */
                cnt = Fee_GetCfgNum();          /* break loop */
    
                /* 2.update sector status in config */
                Fee_MainCommonProc = FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG;
                Fee_MainCommonProcNext = FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG;
            }
            else
            {
                for( cnt_sub = (uint8)FEE_ZERO; cnt_sub < (uint8)Fee_ConfigInfo[cnt].Fee_NoOfSec; cnt_sub++ )
                {
                    if( Fee_GetSectorStatusElementWithCfg(cnt + (uint8)1, cnt_sub) != Fee_GetSectorStatusMirrorElementWithCfg(cnt + (uint8)1, cnt_sub) )
                    {
                        /* Deviation from MISRA-C:2012 Rule-14.2
                           Justification: This implementation is adopted for algrithm. */
                        /* PRQA S 2469 1 */
                        cnt_sub = Fee_ConfigInfo[cnt].Fee_NoOfSec;        /* break loop */

                        /* 2.update sector status in config */
                        Fee_MainCommonProcNext = FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG;
                    }
                }
                if( Fee_MainCommonProcNext == FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG )
                {
                    /* Deviation from MISRA-C:2012 Rule-14.2
                       Justification: This implementation is adopted for algrithm. */
                    /* PRQA S 2469 1 */
                    cnt = Fee_GetCfgNum();          /* break loop */
                }
            }
        }

        if(( Fee_MainCommonProc != FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG ) && ( Fee_MainCommonProcNext != FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG ))
        {
            /* => X.end of periodic processing */
            Fee_MainCommonProc = FEE_MAIN_COMMON_END;
        }
    }

/* 2.update sector status in config */
    if( Fee_MainCommonProc == FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG )
    {
        if( Fee_SectorCountForConfig <= Fee_ConfigInfo[FEE_CONFIG_SET_1 - (uint8)1].Fee_NoOfSec )
        {
            Fee_CurrentConfigNo = FEE_CONFIG_SET_1;

            ret_sector_first = Fee_GetSectorFirst(FEE_CONFIG_SET_1, Fee_SectorCountForConfig);
            
            if( FEE_OK == ret_sector_first )
            {
                Fee_SectorCountForConfig++;
            }
            if( FEE_NG == ret_sector_first )
            {
                /* X.end of periodic processing */
                Fee_MainCommonProc = FEE_MAIN_COMMON_END;
            }
        }
        else
        {
            Fee_SectorCountForConfig = (uint8)1;
            if( FEE_CONFIG_SET_2 == Fee_GetCfgNum() )
            {
                /* 3.update sector status in config ex */
                Fee_MainCommonProc = FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG_EX;
                Fee_MainCommonProcNext = FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG_EX;
            }
            else
            {
                /* X.end of periodic processing */
                Fee_MainCommonProc = FEE_MAIN_COMMON_END;
            }
        }
    }

/* 3.update sector status in config ex */
    if( Fee_MainCommonProc == FEE_MAIN_COMMON_UPDATE_SECTOR_STATUS_CONFIG_EX )
    {
        if( Fee_SectorCountForConfigEx <= Fee_ConfigInfo[Fee_GetCfgNum() - (uint8)1].Fee_NoOfSec )
        {
            Fee_CurrentConfigNo = FEE_CONFIG_SET_2;

            ret_sector_first = Fee_GetSectorFirst(FEE_CONFIG_SET_2, Fee_SectorCountForConfigEx);

            if( FEE_OK == ret_sector_first )
            {
                Fee_SectorCountForConfigEx++;
            }
            if( FEE_NG == ret_sector_first )
            {
                /* X.end of periodic processing */
                Fee_MainCommonProc = FEE_MAIN_COMMON_END;
            }
        }
        else
        {
            Fee_SectorCountForConfigEx = (uint8)1;
            /* X.end of periodic processing */
            Fee_MainCommonProc = FEE_MAIN_COMMON_END;
        }
    }

/* X.end of periodic processing  */
    if( Fee_MainCommonProc == FEE_MAIN_COMMON_END )
    {
        if( FEE_NG == ret_sector_first )
        {
             retval = FEE_NG;
        }
        else
        {
            retval = FEE_OK;
        }
        Fee_CurrentConfigNo = Fee_CurrentConfigNoTemp;
        Fee_MainCommonProc = FEE_MAIN_COMMON_START;
        Fee_MainCommonProcNext = FEE_MAIN_COMMON_START;
    }
    else
    {
        /* do nothing */
    }

    return retval;
}


/** \brief Fee_BlockIndexCheck
**
** Check correctness of block index("block address on flash").
** If block index is incorrect, update the block index.
**
**
** \return     state of processing
** \retval     FEE_OK     success
** \retval     FEE_NG     failed
** \retval     FEE_CONT   continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
FUNC(uint8, FEE_CODE) Fee_BlockIndexCheck(void)
{
    VAR(Fee_BlockIndexCheckProcType, AUTOMATIC)     proc;                       /* position of the processing */
    VAR(uint8, AUTOMATIC)                           retval;                     /* return value */
    VAR(uint16, AUTOMATIC)                          block_no;                   /* block number */
    VAR(uint8, AUTOMATIC)                           sector_no;                  /* sector number */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)          block_addr_index;           /* index of blocks */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)          block_addr_index_mirror;    /* index of blocks */

    retval          = FEE_CONT;
    block_no        = Fee_Job.BlockNumber;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_BlockIndexCheckProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_BLOCK_INDEX_CHECK_START )
    {
        /* => 1.get sector no */
        proc = FEE_BLOCK_INDEX_GET_SECTOR_NO;
    }
    else
    {
        /* If periodic processing is continued, pop related data under processing. */
        FEE_POP_STACK_UCHAR(sector_no)
    }

/* 1.get sector no */
    if( proc == FEE_BLOCK_INDEX_GET_SECTOR_NO )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);

        if( (sector_no == FEE_INVALID_SECTOR_NO) || (sector_no == FEE_NONE_SECTOR) )
        {
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_INDEX_CHECK_END;
        }
        else
        {
            /* => 2.check block address index */
            proc = FEE_BLOCK_INDEX_CHECK_CHECK;
        }
    }

/* 2.check block address index */
    if( proc == FEE_BLOCK_INDEX_CHECK_CHECK )
    {
        block_addr_index        = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
        block_addr_index_mirror = Fee_GetBlockAddrIndexMirror(Fee_Job.BlockIndex);
        if( ( block_addr_index.BlkAddr != block_addr_index_mirror.BlkAddr) ||
            ( block_addr_index.BlkStatus != block_addr_index_mirror.BlkStatus) ||
            ( block_addr_index.BlkBlankCheck != block_addr_index_mirror.BlkBlankCheck) ||
            ( block_addr_index.BlkStatus == FEE_BLKIDX_NEED_REFRESH ) ||
            ( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE) )
        {
            /* => 3.refresh address index */
            proc = FEE_BLOCK_INDEX_CHECK_REFRESH_ADDRESS_INDEX;
        }
        else
        {
            /* => 4.block blank check */
            proc = FEE_BLOCK_INDEX_CHECK_BLANK_CHECK;
        }
    }

/* 3.refresh address index */
    if( proc == FEE_BLOCK_INDEX_CHECK_REFRESH_ADDRESS_INDEX )
    {
        retval = Fee_SearchNewData(sector_no, block_no);    /* search new data  */

        if( retval != FEE_CONT )
        {
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_INDEX_CHECK_END;
        }
    }

/* 4.block blank check */
    if( proc == FEE_BLOCK_INDEX_CHECK_BLANK_CHECK )
    {
        if( FEE_OFF == Fee_GetBlockBlankCheckOff() )
        {
            retval = Fee_BlockBlankCheckAndRewrite(Fee_Job.BlockIndex);
            switch(retval)
            {
                case FEE_OK:
                    block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                    if(block_addr_index.BlkStatus == FEE_BLKIDX_NEED_REFRESH)
                    {
                        /* => 3.refresh address index */
                        proc = FEE_BLOCK_INDEX_CHECK_REFRESH_ADDRESS_INDEX;
                    }
                    else
                    {
                        retval = FEE_OK;
                        /* => X.end of periodic processing */
                        proc = FEE_BLOCK_INDEX_CHECK_END;
                    }

                    break;

                case FEE_NG:
                    retval = FEE_NG;
                    /* => X.end of periodic processing */
                    proc = FEE_BLOCK_INDEX_CHECK_END;
                    break;

                default: /* FEE_CONT */
                    /* do nothing */
                    break;
            }
        }
        else
        {
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_INDEX_CHECK_END;
        }
    }

/* X.end of periodic processing  */
    if( proc == FEE_BLOCK_INDEX_CHECK_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_BLOCK_INDEX_CHECK_START;
    }
    else
    {
        FEE_PUSH_STACK_UCHAR(sector_no)
        retval = FEE_CONT;
    }

    FEE_PUSH_PROC(proc)        /* evacuate processing */

    return retval;
}


/** \brief Fee_Reset
**
** Initialize internal variable for periodic processing and
** cancel processing under operation.
**
** \param[in]  mode       type of initialization
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_Reset(
  VAR(uint8, AUTOMATIC) mode)
{
    VAR(uint16, AUTOMATIC)                                    cnt;                         /* loop counter */
    VAR(uint16, AUTOMATIC)                                    cnt_sub;                     /* loop counter */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  new_block_ptr;               /* pointer to new block */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  old_block_ptr;               /* pointer to old block */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  inval_block_ptr;             /* pointer to invalidate block */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                    block_addr_index;            /* index of blocks */
    VAR(Fee_BlockConfigType, AUTOMATIC)                       blk_cfg;                     /* Block configuration array */
    VAR(uint32, AUTOMATIC)                                    invalid_status;              /* check invalid status */

    if( mode == FEE_RESET_INIT )
    {
        for( cnt = (uint16)FEE_ZERO; cnt < (uint16)Fee_GetCfgNum(); cnt++ )
        {
            /* initialize array of sector status */
            for( cnt_sub = (uint16)FEE_ZERO; cnt_sub < (uint16)Fee_ConfigInfo[cnt].Fee_NoOfSec; cnt_sub++ )
            {
                Fee_SetSectorStatusElementWithCfg((uint8)cnt + (uint8)1, (uint8)cnt_sub, FEE_SECTOR_NOSTATUS);
                Fee_SetSectorStatusMirrorElementWithCfg((uint8)cnt + (uint8)1, (uint8)cnt_sub, FEE_SECTOR_NOSTATUS);
            }

            /* initialize pointer to empty address and empty size */
            /* Deviation from MISRA-C:2012 Rule-11.9
               Justification: It needs to clear pointer to null. */
            /* PRQA S 3004 2 */
            Fee_SetBlkMgtAreaEmptyAddrElementWithCfg((uint8)cnt, FEE_NULL);
            Fee_SetBlkPageAreaEmptyAddrElementWithCfg((uint8)cnt, FEE_NULL);
            Fee_SetBlkEmptySizeElementWithCfg((uint8)cnt, FEE_NULL);

            /* initialize address index of blocks */
            block_addr_index.BlkAddr   = (uint32)FEE_BLKIDX_NO_BLOCK_EXIST;
            block_addr_index.BlkStatus = FEE_BLKIDX_NO_BLOCK_EXIST;
            block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_UNDO;
            for( cnt_sub = (uint16)FEE_ZERO; cnt_sub < (uint16)Fee_ConfigInfo[cnt].Fee_NoOfBlocks; cnt_sub++ )
            {
                Fee_SetBlockAddrIndexElementWithCfg((uint8)cnt + (uint8)1, cnt_sub, block_addr_index);
                Fee_SetBlockAddrIndexMirrorElementWithCfg((uint8)cnt + (uint8)1, cnt_sub, block_addr_index);
                Fee_SetIsNextBlockCorrupt((uint8)cnt + (uint8)1, cnt_sub, FEE_NEXT_BLOCK_IS_NOT_CORRUPT);
            }
        }
        Fee_RecycleFlag = FEE_OFF;
        Fee_RecycleImmediateFlag = FEE_OFF;
        Fee_ConfigUnmatchFlag = FEE_OFF;
    }
    else
    {
        Fee_FlsCancel();

        Fee_BlockNumberForCancel = Fee_Job.BlockNumber;
        Fee_BlockIndexForCancel  = Fee_Job.BlockIndex;

        if( ((Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_RECYCLING) == FEE_MAIN_STATE_RECYCLING) || ((Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_RECOVERING) == FEE_MAIN_STATE_RECOVERING) )
        {
            /* reset address index of blocks */
            Fee_ResetBlockIndex();

            /* reset sector status because maybe the global variable are inconsistent with the real flash since recycle operation was cancelled */
            Fee_SetSectorStatus(FEE_ZERO, FEE_SECTOR_NOSTATUS);
            Fee_SetSectorStatusMirror(FEE_ZERO, FEE_SECTOR_NOSTATUS);
        }
        else
        {
            if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_WRITING) == FEE_MAIN_STATE_WRITING )
            {
                block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                {
                    /* Deviation from MISRA-C:2004 rule 14.3, 14.8, 14.9, MISRA-C:2012 Rule-15.6
                       Justification: This Program is well performed and no other better way to implement. */
                    /* PRQA S 2214,3138 1 */
                    while( Fee_FlsGetStatusSub() != MEMIF_IDLE );

                    /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                       Justification: Cast between a pointer to object and an integral type.
                                      This deviation is due to doing pointer arithmetic. */
                    /* PRQA S 306,488 1 */
                    old_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);
                    new_block_ptr = Fee_GetBlkMgtAreaEmptyAddr();

                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                       Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 1 */
                    invalid_status = Fee_FlsGetReadAddr((uint32)old_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

                    if( invalid_status != FEE_NULL )
                    {
                        /*the old block has been invalid, need to update index to the new one*/

                        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                           Justification: Cast between a pointer to object and an integral type.
                                          This deviation is due to doing pointer arithmetic. */
                        /* PRQA S 306,488 1 */
                        block_addr_index.BlkAddr   = (uint32)new_block_ptr;
                        block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;
                        block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                        Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);

                        /* updata the 2 empty address pointers and block empty size */
                        Fee_UpdateEmptyAreaPtrAfterWriteBlock();
                    }
                }
            }
            if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_INVALIDATING) == FEE_MAIN_STATE_INVALIDATING )
            {
                block_addr_index = Fee_GetBlockAddrIndex(Fee_Job.BlockIndex);
                if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                {
                    /* Deviation from MISRA-C:2004 rule 14.3, 14.8, 14.9, MISRA-C:2012 Rule-15.6
                       Justification: This Program is well performed and no other better way to implement. */
                    /* PRQA S 2214,3138 1 */
                    while( Fee_FlsGetStatusSub() != MEMIF_IDLE );

                    blk_cfg = Fee_GetBlkCfg(Fee_Job.BlockIndex);

                    /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                       Justification: Cast between a pointer to object and an integral type.
                                      This deviation is due to doing pointer arithmetic. */
                    /* PRQA S 306,488 1 */
                    inval_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);

                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                       Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 1 */
                    invalid_status = Fee_FlsGetReadAddr((uint32)inval_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

                    if( invalid_status != FEE_NULL )
                    {
                        /* the block has been invalid, need to update index to invalid */
                        block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
                        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                           Justification: Cast between a pointer to object and an integral type. */
                        /* PRQA S 306,488 1 */
                        block_addr_index.BlkAddr   = (uint32)inval_block_ptr;
                        block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                        Fee_SetBlockAddrIndex(Fee_Job.BlockIndex, block_addr_index);
                        if(STD_OFF == Fee_GetDefinedThresholdPageSize())
                        {
                            /* update immediate data reserve size */
                            if( blk_cfg.FeeImmediateData == TRUE )
                            {
                                Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                            }
                        }
                    }
                }
            }
        }
    }

    /* initialize internal variable for periodic processing */
    Fee_PeriInfo.Fee_MainError          = MEMIF_JOB_OK;
    Fee_PeriInfo.Fee_MainState          = FEE_MAIN_STATE_NONE;
    Fee_PeriInfo.Fee_MainDepth          = (uint8)FEE_ZERO;
    Fee_PeriInfo.Fee_MainStackPos       = (uint8)FEE_ZERO;
    Fee_PeriInfo.Fee_RecycleSrc         = (uint8)FEE_ZERO;
    for( cnt = (uint16)FEE_ZERO; cnt < (uint16)FEE_CALL_DEPTH_MAX; cnt++ )
    {
        Fee_MainProc[(uint8)cnt] = FEE_PROC_NOTINITIALIZE;/* initialize array for periodic processing */
    }
    Fee_CancelWriteProc = FEE_CANCEL_WRITE_START;
    Fee_CancelWriteProcNext = FEE_CANCEL_WRITE_START;

    Fee_InfoDataBuffer = (uint32)FEE_NULL;

    return;
}


/** \brief Fee_WriteBlock
**
** Write block in FEE area.
**
** \param[in]  sector_no            sector number
** \param[in]  addr_ptr             pointer to destination address
** \param[in]  data_ptr             pointer to write data
** \param[in]  old_or_new_struct    use new struct or old struct
**
** \return     state of processing
** \retval     FEE_OK     success
** \retval     FEE_NG     failed
** \retval     FEE_CONT   continue
**
*/
/* Deviation from MISRA-C:2004 rule 16.7, MISRA-C:2012 Rule-8.13
   Justification: This interface have been defined by FD, and there is no impact on performance by judgment. */
/* PRQA S 3673 4 */
FUNC(uint8, FEE_CODE) Fee_WriteBlock(
  VAR(uint8, AUTOMATIC) sector_no,
  P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_APPL_DATA) addr_ptr,
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) data_ptr,
  VAR(uint8, AUTOMATIC) old_or_new_struct)
{
    VAR(Fee_WriteBlkProcType, AUTOMATIC)                       proc;               /* position of the processing */
    VAR(uint8, AUTOMATIC)                                      retval;             /* return value */
    VAR(uint16, AUTOMATIC)                                     length;             /* length of write */
    VAR(uint16, AUTOMATIC)                                     length_first_part;  /* length of write */
    VAR(uint16, AUTOMATIC)                                     length_second_part; /* length of write */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)   block_tmp_ptr;      /* pointer to block */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                         data_area_ptr;      /* pointer to write data */
    VAR(uint16, AUTOMATIC)                                     blk_idx;            /* block number index */
    VAR(MemIf_JobResultType, AUTOMATIC)                        retjob;             /* result of fls job */
    VAR(Fee_BlockConfigType, AUTOMATIC)                        blk_cfg;            /* Block configuration array */
    VAR(Fee_BlockConfigType, AUTOMATIC)                        blk_cfg_on_flash;   /* Block configuration array */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                         data_buffer_ptr;    /* block data buffer for write block */
    VAR(uint16, AUTOMATIC)                                     count;              /* count for writing 0xFF to buffer */
    
    block_tmp_ptr = addr_ptr;
    retval = FEE_OK;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_WriteBlkProcType)               /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_WRITEBLK_START )
    {
        Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;

        /* => 1. write write flag */
        proc = FEE_WRITEBLK_BLKWRITEFLAG;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(data_area_ptr, uint8)
        FEE_POP_STACK_USHORT(length)
        FEE_POP_STACK_USHORT(length_first_part)
        FEE_POP_STACK_USHORT(length_second_part)
    }

/* 1.write write flag */
    if( proc == FEE_WRITEBLK_BLKWRITEFLAG )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)block_tmp_ptr, (uint8*)&Fee_BlkMgtInfoBuffer.WriteFlag, (uint32)FEE_BLOCK_WRITEFLAG_SIZE); /* write WriteFlag */
        /* => 1-a.check result of write write flag */
        FEE_SET_PROC(FEE_WRITEBLK_BLKWRITEFLAG_CHECK)
    }
/* 1-a.check result of write write flag */
    if( proc == FEE_WRITEBLK_BLKWRITEFLAG_CHECK )
    {
        retjob = Fee_FlsGetJobResult(); /* get job result */
        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 2.write Block Number and Page Number */
            proc = FEE_WRITEBLK_BLKNUMPAGENUM;
            break;

        case MEMIF_JOB_FAILED:
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 2.write Block Number and Page Number */
    if( proc == FEE_WRITEBLK_BLKNUMPAGENUM )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)block_tmp_ptr + FEE_BLOCK_WRITEFLAG_SIZE, (uint8*)&Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNum, (uint32)FEE_BLOCK_BLKNUMPAGENUM_SIZE);
        /* => 2-a.check result of write Block Number and Page Number */
        FEE_SET_PROC(FEE_WRITEBLK_BLKNUMPAGENUM_CHECK)
    }

/* 2-a.check result of write Block Number and Page Number */
    if( proc == FEE_WRITEBLK_BLKNUMPAGENUM_CHECK )
    {
        retjob = Fee_FlsGetJobResult(); /* get job result */
        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 3.write data */
            proc = FEE_WRITEBLK_DATA;
            break;

        case MEMIF_JOB_FAILED:
            Fee_UpdateTheTwoPointerByDiffCase(block_tmp_ptr);
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 3.write data */
    if( proc == FEE_WRITEBLK_DATA )
    {
        /* for getting length */
        blk_idx = Fee_BlockNumberToIndex((uint16)Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
        blk_cfg = Fee_GetBlkCfg(blk_idx);
        length = blk_cfg.FeeBlockSize;
        /* for getting destination data address */

        if(old_or_new_struct == FEE_ADJUSTING_USE_NEW_STRUCT)
        {
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested.*/
            /* PRQA S 306,488,1840,1860 1 */
            data_area_ptr = Fee_CalPhysicalAddrFromPageNo(sector_no, Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
        }
        else /* FEE_ADJUSTING_USE_OLD_STRUCT */
        {
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested.*/
            /* PRQA S 306,488,1840,1860 1 */
            data_area_ptr = Fee_CalPhysicalAddrFromPageNoOldConfig(sector_no, Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
        }


        /* => 3-a.trigger write data */
        proc = FEE_WRITEBLK_TRIGGER_WRITE_DATA;
    }

/* 3-a.trigger write data */
    if( proc == FEE_WRITEBLK_TRIGGER_WRITE_DATA )
    {
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The blk_idx is only used after it is initialized by the former mainfunction. */
        /* PRQA S 2962 1*/
        blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);

        if(blk_cfg_on_flash.FeeBlockSize <= Fee_GetPageSizeAlignSize(length))
        {
            length_first_part  = blk_cfg_on_flash.FeeBlockSize;
            length_second_part = Fee_GetPageSizeAlignSize(length) - blk_cfg_on_flash.FeeBlockSize;

            Fee_SetFlsDedErrorNotificationVar((uint8)FEE_OFF);
            Fee_SetFlsSedErrorNotificationVar((uint8)FEE_OFF);
            
            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            (void)Fee_FlsWrite((uint32)data_area_ptr, data_ptr, (uint32)length_first_part);
            /* => 3-b.check result of write data */
            FEE_SET_PROC(FEE_WRITEBLK_DATA_CHECK)
        }
        else
        {
            Fee_UpdateTheTwoPointerByDiffCase(block_tmp_ptr);
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            retval = FEE_NG;
        }
    }

/* 3-b.check result of write data */
    if( proc == FEE_WRITEBLK_DATA_CHECK )
    {
        retjob = Fee_FlsGetJobResult(); /* get job result */
        switch(retjob)
        {
        case MEMIF_JOB_OK:
            if(length_second_part == FEE_ZERO)
            {
                /* => 4.write Valid Status */
                proc = FEE_WRITEBLK_VALIDSTAT;
            }
            else
            {
                /* => 3-c.trigger write data for second part */
                proc = FEE_WRITEBLK_TRIGGER_WRITE_DATA_FOR_SECOND_PART;
            }

            break;

        case MEMIF_JOB_FAILED:
            Fee_ClearMngPtrAndDatePtr();
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 3-c.trigger write data for second part */
    if( proc == FEE_WRITEBLK_TRIGGER_WRITE_DATA_FOR_SECOND_PART )
    {
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
           Justification: Casting to different object pointer type. And this casting is safety by judgment.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 310 1 */
        data_buffer_ptr = (uint8*)Fee_GetDataBuffer();
        for(count = 0; count < Fee_GetPageSizeAlignSize(length_second_part); count++)
        {
            data_buffer_ptr[count] = (uint8)0xFF;
        }

        /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        (void)Fee_FlsWrite((uint32)data_area_ptr + length_first_part, data_buffer_ptr, (uint32)length_second_part);
        /* => 3-d.check result of write data for second part */
        FEE_SET_PROC(FEE_WRITEBLK_DATA_CHECK_FOR_SECOND_PART)
    }

/* 3-d.check result of write data for second part */
    if( proc == FEE_WRITEBLK_DATA_CHECK_FOR_SECOND_PART )
    {
        retjob = Fee_FlsGetJobResult(); /* get job result */
        switch(retjob)
        {
        case MEMIF_JOB_OK:
            blk_idx = Fee_BlockNumberToIndex((uint16)Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
            blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);
            blk_cfg_on_flash.FeeBlockSize = Fee_GetPageSizeAlignSize(length);
            Fee_SetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx, blk_cfg_on_flash);

            /* => 4.write Valid Status */
            proc = FEE_WRITEBLK_VALIDSTAT;

            break;

        case MEMIF_JOB_FAILED:
            Fee_ClearMngPtrAndDatePtr();
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 4.write Valid Status */
    if( proc == FEE_WRITEBLK_VALIDSTAT )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)block_tmp_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE, (uint8*)&Fee_BlkMgtInfoBuffer.ValidStat, (uint32)FEE_BLOCK_STATUS_SIZE); /* write ValidStat */
        /* => 4-a.check result of write Valid Status */
        FEE_SET_PROC(FEE_WRITEBLK_VALIDSTAT_CHECK)
    }

/* 4-a.check result of write Valid Status */
    if( proc == FEE_WRITEBLK_VALIDSTAT_CHECK )
    {
        retjob = Fee_FlsGetJobResult(); /* get job result */
        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            break;

        case MEMIF_JOB_FAILED:
            /* => 5.invalidate block */
            proc = FEE_WRITEBLK_DISABLE;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 5.invalidate block */
    if( proc == FEE_WRITEBLK_DISABLE )
    {
        Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;

        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)block_tmp_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */

        /* => 5-a.check result of invalidate block */
        FEE_SET_PROC(FEE_WRITEBLK_DISABLE_CHECK)
    }

/* 5-a.check result of invalidate block */
    if( proc == FEE_WRITEBLK_DISABLE_CHECK )
    {
        retjob = Fee_FlsGetJobResult(); /* get job result */
        if( retjob != MEMIF_JOB_PENDING )
        {
            Fee_ClearMngPtrAndDatePtr();
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_WRITEBLK_END;
            retval = FEE_NG;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_WRITEBLK_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_WRITEBLK_START;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          The length is only used after it is initialized by the former mainfunction. */
        /* PRQA S 2962 3 */
        FEE_PUSH_STACK_USHORT(length_second_part)
        FEE_PUSH_STACK_USHORT(length_first_part)
        FEE_PUSH_STACK_USHORT(length)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, 9.1, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-9.1
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          The data_area is only used after it is initialized by the former mainfunction. */
        /* PRQA S 306,488,2962 1 */
        FEE_PUSH_STACK_POINTER(data_area_ptr)
    }

    FEE_PUSH_PROC(proc)               /* evacuate processing */

    if( proc != FEE_WRITEBLK_START )
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_MemCpy1
**
** Copies the values of size from source to destination
** and pads the remainder with 0xFF to make it 8bytes/4bytes alignment.(1byte unit)
**
** \param[in]  dst    pointer to the destination of data
** \param[in]  src    pointer to the source of data
** \param[in]  size   number of bytes to copy
**
** \return     result of processing
** \retval     FEE_OK     success
** \retval     FEE_CONT   continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
FUNC(uint8, FEE_CODE) Fee_MemCpy1(
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) dst_ptr,
  P2CONST(uint8, AUTOMATIC, FEE_APPL_CONST) src_ptr,
  VAR(uint16, AUTOMATIC) size)
{
    VAR(Fee_Memcpy1ProcType, AUTOMATIC)              proc;           /* position of the processing */
    VAR(uint8, AUTOMATIC)                            retval;         /* return value */
    VAR(uint16, AUTOMATIC)                           data_size;      /* data size */
    VAR(uint16, AUTOMATIC)                           aligned_size;   /* aligned data size */
    VAR(uint16, AUTOMATIC)                           cnt;            /* loop counter */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)               dst_bak_ptr;    /* pointer for padding remainder */

    dst_bak_ptr = dst_ptr;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_Memcpy1ProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_MEMCPY1_START )
    {
        data_size = size;
        aligned_size = Fee_GetPageSizeAlignSize(size);

        /* => 1.copy memory */
        proc = FEE_MEMCPY1_CPY;
    }
    else
    {
        FEE_POP_STACK_USHORT(data_size)
        FEE_POP_STACK_USHORT(aligned_size)
    }

/* 1.copy memory */
    if( proc == FEE_MEMCPY1_CPY )
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to doing pointer arithmetic. */
        /* PRQA S 488 1 */
        src_ptr += data_size - (uint16)1;
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to doing pointer arithmetic. */
        /* PRQA S 488 1 */
        dst_ptr += data_size - (uint16)1;

        for( cnt = (uint16)FEE_ZERO; (data_size > (uint16)FEE_ZERO) && (cnt < FEE_MEMCPY1_MAX); cnt++ )
        {
            /* comment on following code. reading arbitration error will be detected on the outside of this function */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 12.4, MISRA-C:2012 Rule-12.1, Rule-11.4, Rule-11.6, Rule-13.5
               Justification: It is necessary to do the comparation.
                              Cast between a pointer to object and an integral type.
                              This implementation is adopted for avoiding more nesting.
                              It is no problem because side effects cannot be caused. */
            /* PRQA S 3397,306,3415 1 */
            if(( Fee_GetWorkFlashAbsoluteEndAddress() <= (uint32)src_ptr ) && ( (uint32)src_ptr <= Fee_GetWorkFlashAbsoluteEndAddress() + FEE_BLOCK_SIZE_MAX ))
            {
                *dst_ptr = (uint8)0xFF;
            }
            else
            {
                *dst_ptr = *src_ptr;
            }

            data_size--;

            src_ptr--;
            dst_ptr--;
        }

        if( data_size == (uint16)FEE_ZERO )
        {
            data_size = size;
            /* => 2.pad remainder */
            proc = FEE_MEMCPY1_PAD;
        }
    }

/* 2.pad remainder */
    if( proc == FEE_MEMCPY1_PAD )
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to doing pointer arithmetic. */
        /* PRQA S 488 1 */
        dst_bak_ptr += aligned_size - (uint16)1;

        for( cnt = (uint16)FEE_ZERO; (aligned_size > data_size) && (cnt < FEE_MEMCPY1_MAX); cnt++ )
        {
            *dst_bak_ptr = (uint8)0xFF;
            aligned_size--;
            dst_bak_ptr--;
        }
    }

/* X.end of periodic processing */
    if( data_size == aligned_size )
    {
        proc   = FEE_MEMCPY1_START;
        retval = FEE_OK;
    }
    else
    {
        FEE_PUSH_STACK_USHORT(aligned_size)
        FEE_PUSH_STACK_USHORT(data_size)
        retval = FEE_CONT;
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    return retval;
}


/** \brief Fee_PushProc
**
**  This function is executed at end of periodic processing.
**  Set position of the processing that should be executed next time.
**
** \param[in]  proc       position of the processing
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_PushProc(
  VAR(uint8, AUTOMATIC) proc)
{
    Fee_PeriInfo.Fee_MainDepth--;

    if( Fee_MainProc[Fee_PeriInfo.Fee_MainDepth] == FEE_PROC_NOTINITIALIZE )
    {
        /* if position of the processing is unset, set argument to Fee_MainProc[] */
        Fee_MainProc[Fee_PeriInfo.Fee_MainDepth] = proc;
    }

    return;
}


/** \brief Fee_PopProc
**
**  This function is executed at before periodic processing.
**  Get position of the processing that should be executed this time.
**
**
** \return     position of the processing
** \retval     proc(0x00-0xFF)
*/
FUNC(uint8, FEE_CODE) Fee_PopProc(void)
{
    VAR(uint8, AUTOMATIC)  proc;   /* position of the processing */

    /* get position of the processing */
    proc = Fee_MainProc[Fee_PeriInfo.Fee_MainDepth];
    Fee_MainProc[Fee_PeriInfo.Fee_MainDepth] = FEE_PROC_NOTINITIALIZE; /* unset */
    Fee_PeriInfo.Fee_MainDepth++;

    return proc;
}


/** \brief Fee_CallCbk
**
**  Execute user callback.
**
** \param[in]  result   success or failure of processing
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_CallCbk(
  VAR(MemIf_JobResultType, AUTOMATIC) result)
{
    VAR(Fee_ConfigType, AUTOMATIC)   fee_cfg;

    fee_cfg = Fee_GetCfg();

    if( Fee_ModuleState == FEE_STAT_UNINIT )
    {
        Fee_Counter = FEE_NULL;
    }
    else
    {
        if( Fee_ModuleState != FEE_STAT_WRITE_CANCEL )
        {
            FEE_STATE_SET(FEE_STAT_NOP)
            Fee_Counter = FEE_NULL;
        }
    }

    if( result == MEMIF_JOB_OK )
    {

        if( fee_cfg.FeeNvmJobEndNotification != NULL_PTR )
        {
            (*fee_cfg.FeeNvmJobEndNotification)();
        }
    }
    else
    {
        if( fee_cfg.FeeNvmJobErrorNotification != NULL_PTR )
        {
            (*fee_cfg.FeeNvmJobErrorNotification)();
        }
    }

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_BlockNumberToIndex
 **
 ** Return the index by a block number.
 **
 ** \param block_no [in] - Block number as defined in block configuration.
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_BlockNumberToIndex(
  VAR(uint16, AUTOMATIC) block_no)
{
    VAR(uint16, AUTOMATIC)  retval;
    VAR(uint16, AUTOMATIC)  cnt;

    VAR(uint16, AUTOMATIC)               no_of_blocks;  /* Number of defined blocks */
    VAR(Fee_BlockConfigType, AUTOMATIC)  blk_cfg;       /* Block configuration array */

    no_of_blocks            = Fee_GetNoOfBlocks();

    retval = (uint16)0xFFFF;

    for( cnt = (uint16)FEE_ZERO; cnt < no_of_blocks; cnt++ )
    {
        blk_cfg = Fee_GetBlkCfg(cnt);
        if( block_no == blk_cfg.FeeBlockNumber )
        {
            retval = cnt; /* return the index value */
            /* Deviation from MISRA-C:2004 rule 13.6, MISRA-C:2012 Rule-14.2
               Justification: This implementation is adopted for algrithm. */
            /* PRQA S 2469 1 */
            cnt = no_of_blocks; /* break loop */
        }
    }

    return retval;
}


/** \brief Fee_IsInitializing
**
**  Check whether the Fee_ModuleState.is FEE_STAT_INIT or not.
**
** \return     check result
** \retval      TRUE or FALSE
**
*/
FUNC(boolean, FEE_CODE) Fee_IsInitializing(void)
{
    VAR(boolean, AUTOMATIC) retval;

    if( Fee_ModuleState == FEE_STAT_INIT )
    {
        retval = TRUE;
    }
    else
    {
        retval = FALSE;
    }

    return retval;
}


/** \brief Fee_SearchBlankArea
**
** When blk_page_area_empty_addr - blk_mgt_area_empty_addr != blk_empty_size,
** it indicates that the RAM is corrupted, execute search to
** modify blk_mgt_area_empty_addr , blk_page_area_empty_addr and blk_empty_size.
**
** This function is only called in MainWrite.
**
** \param[in]     sector_no  sector number
**
** \return     result
** \retval     FEE_OK(0)                   Search has reached the blank area and no error during search
** \retval     FEE_NG(1)                   read failure
** \retval     FEE_CONT(255)               continue
**
*/
static FUNC(uint8, FEE_CODE) Fee_SearchBlankArea(
  VAR(uint8, AUTOMATIC) sector_no)
{
    VAR(Fee_SearchBlankProcType, AUTOMATIC)                   proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                     retval;                       /* return value */
    VAR(uint16, AUTOMATIC)                                    block_no;                     /* block number */
    VAR(uint16, AUTOMATIC)                                    blk_idx;                      /* block number index */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  now_block_ptr;                /* pointer to current block */
    VAR(uint16, AUTOMATIC)                                    used_pages_size;              /* size counter of used pages for calculating Fee_BlkPageAreaEmptyAddr */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  blk_mgt_area_empty_addr_ptr;  /* pointer to empty address for block management area */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                       blk_page_area_empty_addr_ptr; /* pointer to empty address for page area */
    VAR(uint16, AUTOMATIC)                                    blk_empty_size;               /* empty size */
    VAR(Fee_BlockConfigType, AUTOMATIC)                       blk_cfg;                      /* Block configuration array */
    VAR(uint32, AUTOMATIC)                                    write_flag;                   /* write flag */
    VAR(uint32, AUTOMATIC)                                    pageid_blkno;                 /* check pageid and block no */
    VAR(uint32, AUTOMATIC)                                    block_start_addr;             /* start address of block mgt area */
    VAR(Fee_FaultType, AUTOMATIC)                             fee_fault;                    /* get fault information from FLS */

    retval          = FEE_CONT;
    used_pages_size = (uint16)FEE_ZERO;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SearchBlankProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_SEARCH_BLANK_START )
    {
        Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
        /* get flash blank address */

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        block_start_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_TOP_BLOCK_OFFSET;

        /* set search position */

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        now_block_ptr = (Fee_BlockManagementInfoType*)block_start_addr;
        /* => 1.search blank block */
        proc = FEE_SEARCH_BLANK_ACTION;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(now_block_ptr, Fee_BlockManagementInfoType)
        FEE_POP_STACK_USHORT(used_pages_size)
    }

/* 1.search blank block */
    if( proc == FEE_SEARCH_BLANK_ACTION )
    {
        /* Blank check has not been executed at empty area yet, this blank check is necessary. */


        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        write_flag = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
            Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        if( FEE_NULL == write_flag )
        {
            /* Search finished at empty area. */
            /* no block to search */
            /* If block number is initial value, search completion */
            /* update empty address and empty size */
            blk_mgt_area_empty_addr_ptr = now_block_ptr;
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 17.4, 12.1, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
                Justification: Cast between a pointer to object and an integral type.
                                Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic.
                                This deviation is due to an integer type cast to do pointer arithmetic. */
            /* PRQA S 306,310,488,3395,3305 1 */
            blk_page_area_empty_addr_ptr = (uint32*)((Fee_GetFlashSectorEraseFlagAddr(sector_no)) - used_pages_size);
            Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);

            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);

            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_SEARCH_BLANK_END;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            pageid_blkno   = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE);        /* check BNumAndPNum */

            if( pageid_blkno != FEE_NULL )
            {
                /* =>2.get old block page no */
                proc = FEE_SEARCH_BLANK_OLD_GET_BLOCKNO_PAGENO;
            }
            else
            {
                /* If pageid_blkno is blank, it is a corrupted block. */
                /* Do not update used_pages_size, but continue searching. */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                now_block_ptr = (Fee_BlockManagementInfoType*)((uint8*)now_block_ptr + FEE_BLOCK_MANAGE_SIZE);
                /* retval is FEE_CONT */
                /* proc is current proc */
            }
        }
    }

/* 2.get old block page no */
    if(proc == FEE_SEARCH_BLANK_OLD_GET_BLOCKNO_PAGENO)
    {
        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
        {
            block_no = (uint16)(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
            
            blk_idx = Fee_BlockNumberToIndex(block_no);
            if( blk_idx != (uint16)0xFFFF )
            {
                blk_cfg = Fee_GetBlkCfg(blk_idx);
                used_pages_size += Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize);
            }
            
            /* get next search position */
            
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            now_block_ptr = (Fee_BlockManagementInfoType*)((uint8*)now_block_ptr + FEE_BLOCK_MANAGE_SIZE);
            /* retval is FEE_CONT */
            /* => 1.search blank block */
            proc = FEE_SEARCH_BLANK_ACTION;
        }
        else /* error */
        {
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_SEARCH_BLANK_END;
        }
    }

/* X.end of periodic processing  */
    if( proc == FEE_SEARCH_BLANK_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_SEARCH_BLANK_START;
    }
    else
    {
        FEE_PUSH_STACK_USHORT(used_pages_size)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(now_block_ptr)
    }

    FEE_PUSH_PROC(proc) /* evacuate processing */

    return retval;
}


/** \brief Fee_SearchNewData
**
** If index is corrupt between BlockIndex and BlockIndexMirror,
** execute search to modify the index of given block.
**
** \param[in]     sector_no  sector number
** \param[in]     block_no   block number
**
** \return     result
**
** \retval     FEE_OK                   found or not found
** \retval     FEE_CONT                 continue searching
**
*/
static FUNC(uint8, FEE_CODE) Fee_SearchNewData(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint16, AUTOMATIC) target_block_no)
{
    VAR(Fee_SearchNewDataProcType, AUTOMATIC)                 proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                     retval;                       /* return value */
    VAR(uint16, AUTOMATIC)                                    block_no;                     /* block number */
    VAR(uint16, AUTOMATIC)                                    blk_idx;                      /* block number index */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  now_block_ptr;                /* pointer to current block */
    VAR(uint32, AUTOMATIC)                                    write_flag;                   /* write flag */
    VAR(uint32, AUTOMATIC)                                    pageid_blkno;                 /* check pageid and block no */
    VAR(uint32, AUTOMATIC)                                    block_start_addr;             /* start address of block mgt area */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                    block_addr_index;             /* block index */
    VAR(Fee_FaultType, AUTOMATIC)                             fee_fault;                    /* get fault information from FLS */
    VAR(uint32, AUTOMATIC)                                    valid_flag;                   /* valid flag */
    VAR(uint32, AUTOMATIC)                                    invalid_flag;                 /* invalid flag */

    retval    = FEE_CONT;
    block_addr_index.BlkStatus     = FEE_BLKIDX_NO_BLOCK_EXIST;
    block_addr_index.BlkAddr       = (uint32)FEE_BLKIDX_NO_BLOCK_EXIST;
    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is initialization. */
    /* PRQA S 2982 1 */
    block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_UNDO;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SearchNewDataProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_SEARCH_NEW_DATA_START )
    {
        Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
        /* get flash blank address */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        block_start_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_TOP_BLOCK_OFFSET;
        /* set search position */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        now_block_ptr = (Fee_BlockManagementInfoType*)block_start_addr;

        /* => 1.search blank block */
        proc = FEE_SEARCH_NEW_DATA_ACTION;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(now_block_ptr, Fee_BlockManagementInfoType)
    }

/* 1.search new data block */
    if( proc == FEE_SEARCH_NEW_DATA_ACTION )
    {
        /* Blank check has not been executed at empty area yet, this blank check is necessary. */

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        write_flag = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
            Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        if( FEE_NULL == write_flag )
        {
            /* Search finished at empty area. */
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_SEARCH_NEW_DATA_END;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            pageid_blkno = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE);        /* check BNumAndPNum */

            if( pageid_blkno != FEE_NULL )
            {
                /* => 2.get block no and page no */
                proc = FEE_SEARCH_NEW_GET_BLOCKNO_PAGENO;
            }
            else
            {
                /* get next search position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic.
                                    This cast is needed for handling with 32-bit type address. */
                /* PRQA S 310,488,3305 1 */
                now_block_ptr = (Fee_BlockManagementInfoType*)((uint8*)now_block_ptr + FEE_BLOCK_MANAGE_SIZE);
                /* proc is current proc */
            }
        }
    }

/* 2.get block no and page no */
    if(proc == FEE_SEARCH_NEW_GET_BLOCKNO_PAGENO)
    {
        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            /* It's just to update the block index. It doesn't need to report 1bit/2bit ECC error. To find the next block. */
            Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        }

        /* =>3.search the target block */
        proc = FEE_SEARCH_NEW_DATA_CHECK_BLK;
    }

/* 3.search the target block */
    if(proc == FEE_SEARCH_NEW_DATA_CHECK_BLK)
    {
        block_no = (uint16)(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
        if( target_block_no == block_no )
        {
            blk_idx = Fee_BlockNumberToIndex(target_block_no);    /* get array index via blockNo */
        
            block_addr_index = Fee_GetBlockAddrIndex(blk_idx);

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306,488 2 */
            invalid_flag = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE);
            valid_flag = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE);

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type.
                                It is no problem by judgement. */
            /* PRQA S 306 1 */
            if( invalid_flag != FEE_NULL ) /* check InvalidStat */
            {
                if( block_addr_index.BlkStatus != FEE_BLKIDX_VALID_BLOCK )
                {
                    block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;

                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                        Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306,488 1 */
                    block_addr_index.BlkAddr = (uint32)now_block_ptr;
                }
            }
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type.
                                It is no problem by judgement. */
            /* PRQA S 306 1 */
            else if( valid_flag != FEE_NULL ) /* check ValidStat */
            {
                block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;

                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                    Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306,488 1 */
                block_addr_index.BlkAddr = (uint32)now_block_ptr;
            }
            else
            {
                /* do nothing */
            }
            block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
            Fee_SetBlockAddrIndex(blk_idx, block_addr_index);
        }
        /* get next search position */
        /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
           Justification: Casting to different object pointer type. And this casting is safety by judgment.
             This deviation is due to doing pointer arithmetic.
             This cast is needed for handling with 32-bit type address. */
        /* PRQA S 310,488,3305 1 */
        now_block_ptr = (Fee_BlockManagementInfoType*)((uint8*)now_block_ptr + FEE_BLOCK_MANAGE_SIZE);
        /* => 1.search new data block */
        proc = FEE_SEARCH_NEW_DATA_ACTION;
    }

/* X.end of periodic processing */
    if( proc == FEE_SEARCH_NEW_DATA_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_SEARCH_NEW_DATA_START;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(now_block_ptr)
    }
    
    FEE_PUSH_PROC(proc)

    return retval;
}

/** \brief Fee_UpdateEmptyAreaPtrAfterWriteBlock
**
**  update the 2 empty pointer on valid sector after write a block.
**
**
** \return
** \retval     None
**
*/
static FUNC(void, FEE_CODE) Fee_UpdateEmptyAreaPtrAfterWriteBlock(void)
{
    VAR(Fee_BlockConfigType, AUTOMATIC)                             blk_cfg;                      /* Block configuration array */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)        blk_mgt_area_empty_addr_ptr;  /* pointer to empty address for block management area */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                             blk_page_area_empty_addr_ptr; /* pointer to empty address for page area */
    VAR(uint16, AUTOMATIC)                                          blk_empty_size;               /* empty size */

    /* updata the 2 empty address pointers and block empty size */
    blk_mgt_area_empty_addr_ptr  = Fee_GetBlkMgtAreaEmptyAddr();
    blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
    blk_cfg                      = Fee_GetBlkCfg(Fee_Job.BlockIndex);

    /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
       Justification: Casting to different object pointer type. And this casting is safety by judgment.
                      This deviation is due to doing pointer arithmetic.
                      This cast is needed for handling with 32-bit type address. */
    /* PRQA S 310,488,3305 1 */
    blk_mgt_area_empty_addr_ptr = (Fee_BlockManagementInfoType*)((uint8*)blk_mgt_area_empty_addr_ptr + FEE_BLOCK_MANAGE_SIZE);
    Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);

    /* Deviation from MISRA-C:2004 rule 10.3, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-10.8
       Justification: Cast between a pointer to object and an integral type.
                      Casting to different type for consistency. */
    /* PRQA S 306,4391 1 */
    blk_page_area_empty_addr_ptr = (uint32*)((uint32)blk_page_area_empty_addr_ptr - (uint32)Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize));
    Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);

    /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: Cast between a pointer to object and an integral type. */
    /* PRQA S 306 1 */
    blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
    Fee_SetBlkEmptySize(blk_empty_size);
}


/** \brief Fee_UpdateTheTwoPointerByDiffCase
**
**  update the management area pointer via different cases.
**  
**  If blockID&pagenumber is written correctly, update both the two pointer "management area pointer" and "data area pointer".
**  If blockID&pagenumber is not written correctly, only update the "management area pointer".
**
**
** \return
** \retval     None
**
*/
/* Deviation from MISRA-C:2004 rule 16.7, MISRA-C:2012 Rule-8.13
   Justification: This interface have been defined by FD, and there is no impact on performance by judgment. */
/* PRQA S 3673 2 */
static FUNC(void, FEE_CODE) Fee_UpdateTheTwoPointerByDiffCase(
  P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_APPL_DATA) block_ptr)
{
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)        blk_mgt_area_empty_addr_ptr;  /* pointer to empty address for block management area */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                             blk_page_area_empty_addr_ptr; /* pointer to empty address for page area */
    VAR(uint16, AUTOMATIC)                                          blk_empty_size;               /* empty size */
    VAR(Fee_FaultType, AUTOMATIC)                                   fee_fault;                    /* get fault information from FLS */

    Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
    Fee_FlsEnableDMA();
    /* ReadOperation */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: Cast between a pointer to object and an integral type. */
    /* PRQA S 306 1 */
    Fee_FlsReadImmediateSync((uint32)(block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
    fee_fault = Fee_GetFlsFault();
    Fee_FlsDisableDMA();
    
    if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
    {
        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
    }

    if(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum == Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNum)
    {
        Fee_ClearMngPtrAndDatePtr();
    }
    else
    {
        if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_WRITING) == FEE_MAIN_STATE_WRITING )
        {
            /* update the management area pointer only. do not update data area pointer. */

            blk_mgt_area_empty_addr_ptr  = Fee_GetBlkMgtAreaEmptyAddr();
            blk_page_area_empty_addr_ptr = Fee_GetBlkPageAreaEmptyAddr();
            
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This cast is needed for handling with 32-bit type address. */
            /* PRQA S 310,488,3305 1 */
            blk_mgt_area_empty_addr_ptr = (Fee_BlockManagementInfoType*)((uint8*)blk_mgt_area_empty_addr_ptr + FEE_BLOCK_MANAGE_SIZE);
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);
            
            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);
        }
    }

    return;
}


/** \brief Fee_GetPageSizeAlignSize
**
**  calculate page size aligned block size
**  blk_cfg: block info
**
** \return
** \retval     Page size aligned size
**
*/
FUNC(uint16, FEE_CODE) Fee_GetPageSizeAlignSize(
  VAR(uint16, AUTOMATIC) size)
{
    VAR(Fee_ConfigType, AUTOMATIC) fee_cfg;                      /* fee configuration */

    fee_cfg = Fee_GetCfg();

    return (size + (fee_cfg.FeeVirtualPageSize - (uint16)1)) & (uint16)(~(fee_cfg.FeeVirtualPageSize - (uint16)1));
}

/** \brief Fee_CalPhysicalAddrFromPageNo
**
**  calculate page size aligned block size
**  sector_no: sector no
**  page_no: page no
**
** \return
** \retval     Physical address of the sepecified page no
**
*/
FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_CalPhysicalAddrFromPageNo(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint16, AUTOMATIC) page_no)
{
    P2VAR(uint8, AUTOMATIC, AUTOMATIC) addr_ptr;                 /* Physical address of the sepecified page no */
    VAR(Fee_ConfigType, AUTOMATIC)     fee_cfg;                  /* fee configuration */

    fee_cfg = Fee_GetCfg();

    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
       Justification: Cast between a pointer to object and an integral type. */
    /* PRQA S 306,488,3395 1 */
    addr_ptr = ((Fee_GetFlashSectorEraseFlagAddr(sector_no)) - fee_cfg.FeeVirtualPageSize) - (fee_cfg.FeeVirtualPageSize * (page_no - 1U));
    
    return addr_ptr;
}

/** \brief Fee_CalPhysicalAddrFromPageNoOldConfig
**
**  calculate page size aligned block size
**  sector_no: sector no
**  page_no: page no
**
** \return
** \retval     Physical address of the sepecified page no
**
*/
FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_CalPhysicalAddrFromPageNoOldConfig(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint16, AUTOMATIC) page_no)
{
    P2VAR(uint8, AUTOMATIC, AUTOMATIC) addr_ptr;                 /* Physical address of the sepecified page no */
    VAR(Fee_ConfigType, AUTOMATIC)     fee_cfg;                  /* fee configuration */

    fee_cfg = Fee_GetCfg();
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
       Justification: Cast between a pointer to object and an integral type. */
    /* PRQA S 306,488,3395 1 */
    addr_ptr = ((Fee_GetFlashSectorEraseFlagAddrOldConfig(sector_no)) - fee_cfg.FeeVirtualPageSize) - (fee_cfg.FeeVirtualPageSize * (page_no - 1U));
    
    return addr_ptr;
}


/** \brief Fee_GetFlashSectorEraseFlagAddr
**
**  calculate address of "erase complete flag" by sector number
**
**  sector_no: sector no  ;  range: 1,2,3,...
**
** \return
** \retval     Absolute address
**
*/
FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_GetFlashSectorEraseFlagAddr(
  VAR(uint8, AUTOMATIC) sector_no)
{
    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is var initialization. */
    /* PRQA S 2981 1 */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC) erase_flag_addr_ptr = (uint8*)FEE_ZERO;

    if( sector_no == Fee_GetNoOfSec() ) /* If the sector is the last one, it needs to add remaining size. */
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        erase_flag_addr_ptr = (uint8*)Fee_GetSecTopAddr() + (Fee_GetSectorSize() * (uint32)sector_no) + Fee_GetRemainSize() - FEE_ERASE_COMPLETE_FLAG_SIZE;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        erase_flag_addr_ptr = (uint8*)Fee_GetSecTopAddr() + (Fee_GetSectorSize() * (uint32)sector_no) - FEE_ERASE_COMPLETE_FLAG_SIZE;
    }

    return erase_flag_addr_ptr;
}

/** \brief Fee_GetFlashSectorEraseFlagAddrOldConfig
**
**  calculate address of "erase complete flag" by sector number
**
**  sector_no: sector no  ;  range: 1,2,3,...
**
** \return
** \retval     Absolute address
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
FUNC_P2VAR(uint8, AUTOMATIC, FEE_CODE) Fee_GetFlashSectorEraseFlagAddrOldConfig(
  VAR(uint8, AUTOMATIC) sector_no)
{
    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is var initialization. */
    /* PRQA S 2981 1 */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC) erase_flag_addr_ptr = (uint8*)FEE_ZERO;

    if( sector_no == Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfSec ) /* If the sector is the last one, it needs to add remaining size. */
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        erase_flag_addr_ptr = (uint8*)(Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr) + ((Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize) * (uint32)sector_no) + (Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_RemainSize) - FEE_ERASE_COMPLETE_FLAG_SIZE;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        erase_flag_addr_ptr = (uint8*)(Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr) + ((Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize) * (uint32)sector_no) - FEE_ERASE_COMPLETE_FLAG_SIZE;
    }

    return erase_flag_addr_ptr;
}


/** \brief Fee_ClearMngPtrAndDatePtr
**
** Clear management area pointer and data area pointer
**
** \param     none
**
** \return    none
**
*/
static FUNC(void, FEE_CODE) Fee_ClearMngPtrAndDatePtr(void)
{
    if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_WRITING) == FEE_MAIN_STATE_WRITING )
    {
        /* clear the 2 empty address pointers when the operation is Write */
        Fee_SetBlkMgtAreaEmptyAddr((Fee_BlockManagementInfoType*)FEE_NULL);
        Fee_SetBlkPageAreaEmptyAddr((uint32*)FEE_NULL);
    }

    return;
}


#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

