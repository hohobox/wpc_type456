/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file contains the implementation of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "Fee_Internal.h"

/*****************************************************************************/
/* Local pre-processor symbols/macros ('#define')                            */
/*****************************************************************************/
/*****************************************************************************/
/* Global variable definitions (declared in header file with 'extern')       */
/*****************************************************************************/
/*****************************************************************************/
/* Local variable definitions ('static')                                     */
/*****************************************************************************/
/*****************************************************************************/
/* Local function prototypes ('static')                                      */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
#include "Fee_MemMap.h"

static FUNC(void, FEE_CODE) Fee_MainFunctionLibProc(void);

#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/*****************************************************************************/
/* Function implementation - global ('extern') and local ('static')          */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/**
 ******************************************************************************
 ** \fn Fee_MainFunctionLib
 **
 ** Library function of Fee_MainFunction. Will execute and finish all pending jobs.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_MainFunctionLib(void)
{
    VAR(MemIf_ModeType, AUTOMATIC)  mode;

    if( Fee_ModuleState != Fee_ModuleStateMirror )
    {
        if( Fee_JobResult == MEMIF_JOB_PENDING )
        {
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
        }

        FEE_STATE_SET(FEE_STAT_NOP)                         /* initialize state */
        Fee_CancelLib();                                    /* cancel periodic processing */

        Fee_Reset(FEE_RESET_INIT);                          /* reset FEE */

        if( Fee_JobResult == MEMIF_JOB_PENDING )
        {
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_Counter = FEE_NULL;

            Fee_CallCbk(MEMIF_JOB_FAILED);                     /* notify users of job failure */
        }
    }
    else
    {
        if( Fee_ModuleState != FEE_STAT_NOP )
        {
            Fee_MainFunctionLibProc();      /* execute periodic processing */
        }

        if( Fee_ModuleState == FEE_STAT_CLEAR )
        {
            Fee_Counter = (uint32)FEE_INITIAL_COUNTER_NUM;  /* set counter to 0 */
            /* no timeout error check when stat is FEE_STAT_CLEAR, so return directly */
        }
        else
        {
            if( Fee_Counter > (uint32)0 )
            {
                Fee_Counter--;
            }
            else
            {
                /* limitation of the frequency is exceeded */

                switch(Fee_ModuleState)
                {
                case FEE_STAT_NOP:
                case FEE_STAT_WRITE_CANCEL:

                    FEE_STATE_SET(FEE_STAT_NOP)                        /* refresh */
                    break;

                case FEE_STAT_INIT:

                    Fee_Reset(FEE_RESET_CANCEL);  /* reset FEE( refresh internal variable when FEE is not active) */

                    Fee_ErrorCallout( FEE_EVENT_TIMEOUT_ERROR_OCCURRED );

                    FEE_STATE_SET(FEE_STAT_UNINIT)                     /* change state */

                    Fee_JobResult = MEMIF_JOB_FAILED;
                    Fee_CallCbk(MEMIF_JOB_FAILED);                        /* callback TIMEOUT */
                    break;

                case FEE_STAT_WRITE:
                case FEE_STAT_READ:
                case FEE_STAT_INVAL:
                case FEE_STAT_RECYC:
                case FEE_STAT_WRITE_WAIT:
                case FEE_STAT_READ_WAIT:
                case FEE_STAT_INVAL_WAIT:
                case FEE_STAT_RECYC_WAIT:
                    
                    Fee_Reset(FEE_RESET_CANCEL);  /* reset FEE( refresh internal variable when FEE is not active) */

                    Fee_ErrorCallout( FEE_EVENT_TIMEOUT_ERROR_OCCURRED );

                    FEE_STATE_SET(FEE_STAT_NOP)                        /* change state */

                    Fee_JobResult = MEMIF_JOB_FAILED;
                    Fee_CallCbk(MEMIF_JOB_FAILED);                        /* callback TIMEOUT */
                    break;

                case FEE_STAT_WRITE_WAIT_WRITE:
                    
                    Fee_Reset(FEE_RESET_CANCEL);  /* reset FEE( refresh internal variable when FEE is not active) */
                    
                    if( MEMIF_IDLE == Fee_FlsGetStatus() )
                    {
                        /* FLS is stop */
                        FEE_STATE_SET(FEE_STAT_WRITE)                  /* change state */
                        Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_WRITING | FEE_MAIN_STATE_DATACOPY;    /* set main state */
                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_WRITE);   /* set counter */
                    }
                    else
                    {
                        /* FLS is active */
                        FEE_STATE_SET(FEE_STAT_WRITE_WAIT)             /* change state */

                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_CANCEL);  /* set counter */
                    }
                    break;

                case FEE_STAT_READ_WAIT_WRITE:
                    
                    Fee_Reset(FEE_RESET_CANCEL);  /* reset FEE( refresh internal variable when FEE is not active) */
                    
                    if( MEMIF_IDLE == Fee_FlsGetStatus() )
                    {
                        /* FLS is stop */
                        FEE_STATE_SET(FEE_STAT_READ)                   /* change state */
                        Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_READING;    /* set main state */
                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_READ);   /* set counter */
                    }
                    else
                    {
                        /* FLS is active */
                        FEE_STATE_SET(FEE_STAT_READ_WAIT)              /* change state */

                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_CANCEL);  /* set counter */
                    }
                    break;

                case FEE_STAT_INVAL_WAIT_WRITE:
                    
                    Fee_Reset(FEE_RESET_CANCEL);  /* reset FEE( refresh internal variable when FEE is not active) */
                    
                    if( MEMIF_IDLE == Fee_FlsGetStatus() )
                    {
                        /* FLS is stop */
                        FEE_STATE_SET(FEE_STAT_INVAL)                  /* change state */
                        Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_INVALIDATING;    /* set main state */
                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_INVAL);       /* set counter */
                    }
                    else
                    {
                        /* FLS is active */
                        FEE_STATE_SET(FEE_STAT_INVAL_WAIT)             /* change state */

                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_CANCEL);  /* set counter */
                    }
                    break;

                case FEE_STAT_RECYC_WAIT_WRITE:
                    
                    Fee_Reset(FEE_RESET_CANCEL);  /* reset FEE( refresh internal variable when FEE is not active) */
                    
                    if( MEMIF_IDLE == Fee_FlsGetStatus() )
                    {
                        /* FLS is stop */
                        FEE_STATE_SET(FEE_STAT_RECYC)                  /* change state */
                        Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                        Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_RECOVERING;    /* set main state */
                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_RECYC);     /* set counter */
                    }
                    else
                    {
                        /* FLS is active */
                        FEE_STATE_SET(FEE_STAT_RECYC_WAIT)             /* change state */

                        Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_CANCEL);  /* set counter */
                    }
                    break;

                default:
                    break;
                }
            }
        }
    }

    mode = Fee_GetModeVar();
    if( mode == MEMIF_MODE_FAST )
    {
        /* If mode is fast, timeout check is disable in FLS. */
        Fls_JobRequest.Fls_MainFunctionTime = (sint32)0x7FFFFFFFUL;
    }

    return;
}


/** \brief fee_main_function_lib_proc
**
**  Execute periodic processing.
**  Change FEE state when wait for FLS idle or complete cancel.
**
** \return     none
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
static FUNC(void, FEE_CODE) Fee_MainFunctionLibProc(void)
{

    VAR(uint8, AUTOMATIC)  ret;             /* return value of Fee_MainCommon() */

    ret = Fee_MainCommon();

    if( FEE_OK == ret )
    {

        switch(Fee_ModuleState)
        {
        case FEE_STAT_INIT:
            Fee_MainInit();
            break;

        case FEE_STAT_WRITE:
            Fee_MainWrite();
            break;

        case FEE_STAT_READ:
            Fee_MainRead();
            break;

        case FEE_STAT_INVAL:
            Fee_MainInvalidate();
            break;

        case FEE_STAT_RECYC:
            if( (Fee_GetLibFuncTable()->MainRecycleFunc) != ((Fee_MainRecycleFuncType)FEE_NULL) )
            {
                Fee_GetLibFuncTable()->MainRecycleFunc();
            }
            break;

        case FEE_STAT_CLEAR:
            if( (Fee_GetLibFuncTable()->MainClearFunc) != ((Fee_MainClearFuncType)FEE_NULL) )
            {
                Fee_GetLibFuncTable()->MainClearFunc();
            }
            break;

        case FEE_STAT_WRITE_WAIT:

            FEE_STATE_SET(FEE_STAT_WRITE)                  /* change state */
            Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

            Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_WRITE);   /* set counter */
            Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_WRITING | FEE_MAIN_STATE_DATACOPY;    /* set mainstate */

            Fee_MainWrite();
            break;

        case FEE_STAT_READ_WAIT:

            FEE_STATE_SET(FEE_STAT_READ)                   /* change state */
            Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

            Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_READ);  /* set counter */
            Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_READING;    /* set mainstate */

            Fee_MainRead();
            break;

        case FEE_STAT_INVAL_WAIT:

            FEE_STATE_SET(FEE_STAT_INVAL)                  /* change state */
            Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

            Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_INVAL);  /* set counter */
            Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_INVALIDATING;    /* set mainstate */

            Fee_MainInvalidate();
            break;

        case FEE_STAT_RECYC_WAIT:

            FEE_STATE_SET(FEE_STAT_RECYC)                   /* change state */
            Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

            Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_RECYC);     /* set counter */
            Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_RECOVERING;    /* set mainstate */

            if( (Fee_GetLibFuncTable()->MainRecycleFunc) != ((Fee_MainRecycleFuncType)FEE_NULL) )
            {
                Fee_GetLibFuncTable()->MainRecycleFunc();
            }
            break;

        case FEE_STAT_WRITE_CANCEL:
        case FEE_STAT_WRITE_WAIT_WRITE:
        case FEE_STAT_READ_WAIT_WRITE:
        case FEE_STAT_INVAL_WAIT_WRITE:
        case FEE_STAT_RECYC_WAIT_WRITE:

            if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_CANCELING) != FEE_MAIN_STATE_CANCELING )
            {
                Fee_MainWrite();
            }
            else
            {
                switch(Fee_ModuleState)
                {
                case FEE_STAT_WRITE_CANCEL:

                    FEE_STATE_SET(FEE_STAT_NOP)                    /* change state */

                    Fee_Counter = (uint32)FEE_INITIAL_COUNTER_NUM; /* clear counter */
                    Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_NONE;    /* clear mainstate */
                    break;

                case FEE_STAT_WRITE_WAIT_WRITE:

                    FEE_STATE_SET(FEE_STAT_WRITE)                  /* change state */
                    Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                    Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_WRITING | FEE_MAIN_STATE_DATACOPY;    /* set mainstate */
                    Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_WRITE);   /* set counter */

                    Fee_MainWrite();
                    break;

                case FEE_STAT_READ_WAIT_WRITE:

                    FEE_STATE_SET(FEE_STAT_READ)                   /* change state */
                    Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                    Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_READING;    /* set mainstate */
                    Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_READ);   /* set counter */

                    Fee_MainRead();
                    break;

                case FEE_STAT_INVAL_WAIT_WRITE:

                    FEE_STATE_SET(FEE_STAT_INVAL)                  /* change state */
                    Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                    Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_INVALIDATING;  /* set mainstate */
                    Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_INVAL);     /* set counter */

                    Fee_MainInvalidate();
                    break;

                case FEE_STAT_RECYC_WAIT_WRITE:

                    FEE_STATE_SET(FEE_STAT_RECYC)                   /* change state */
                    Fee_SetCurrentConfigNo(Fee_Job.ConfigSetNumber);         /* set global variable set */

                    Fee_PeriInfo.Fee_MainState = FEE_MAIN_STATE_RECOVERING;  /* set mainstate */
                    Fee_Counter = Fee_GetTimeoutCount(FEE_ENUMTYPE_RECYC);   /* set counter */

                    if( (Fee_GetLibFuncTable()->MainRecycleFunc) != ((Fee_MainRecycleFuncType)FEE_NULL) )
                    {
                        Fee_GetLibFuncTable()->MainRecycleFunc();
                    }
                    break;

                default:
                    break;
                }
            }

            break;

        default:
            break;
        }

    }
    else if ( FEE_NG == ret )
    {
        /* FAULT_OTHERERROR has been encountered when blank check */
        Fee_CallCbk(MEMIF_JOB_FAILED);
    }
    else /* FEE_CON*/
    {

    }
    return;
}

#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

