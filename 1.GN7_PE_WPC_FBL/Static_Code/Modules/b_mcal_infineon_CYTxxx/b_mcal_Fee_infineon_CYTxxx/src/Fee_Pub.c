/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file contains the implementation of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "Fee.h"
#include "Fee_Pub.h"
#if ( FEE_DEV_ERROR_DETECT == STD_ON )
#include "Det.h"
#endif
#include "SchM_Fee.h"

/*****************************************************************************/
/* Local pre-processor symbols/macros ('#define')                            */
/*****************************************************************************/
/*------------------[AUTOSAR configuration AR version number check]----------*/
#if !FEE_AR_VERSION_CHECK(FEE_GEN_AR_RELEASE_MAJOR_VERSION, FEE_GEN_AR_RELEASE_MINOR_VERSION, FEE_GEN_AR_RELEASE_REVISION_VERSION)
#error AUTOSAR configuration AR version number mismatch
#endif
/*------------------[AUTOSAR configuration SW version number check]----------*/
#if !FEE_SW_VERSION_CHECK(FEE_GEN_SW_MAJOR_VERSION, FEE_GEN_SW_MINOR_VERSION)
#error AUTOSAR configuration SW version number mismatch
#endif
/*------------------[AUTOSAR configuration additional check]-----------------*/
#if !FEE_EXTRA_CHECK(FEE_GEN_MODULE_ID, FEE_GEN_VENDOR_ID)
#error AUTOSAR configuation additional check mismatch
#endif


/*****************************************************************************/
/* Global variable definitions (declared in header file with 'extern')       */
/*****************************************************************************/

/* holds fault information */
/* Deviation from MISRA-C:2004 rule 8.8, 8.12, MISRA-C:2012 Rule-8.5, Rule-8.11
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file.
                  The size of buffer is configuration dependent. */
/* PRQA S 3447,3684 2 */
extern VAR( Fls_FaultType, FLS_VAR_NO_INIT ) Fls_Fault;
extern VAR(uint32, FLS_VAR_NO_INIT) Fls_AuxiliaryBuffer[];

#define FEE_START_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  The variable is expected to be a const variable. */
/* PRQA S 3408,1514 1 */
CONST(uint8, FEE_CONST) Fee_CfgNum = FEE_CONFIG_NUMBER;


#ifndef FEE_NORMAL_PAGE_SIZE
#if ( FEE_USE_CONFIG_EX == STD_OFF )
/* Deviation from MISRA-C:2012 Rule-12.1, Rule-10.3
 Justification: The algrithm is necessary. */
/* PRQA S 3389,4464 15 */
CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[FEE_CONFIG_NUMBER] = {
    {
      /* configuration 1 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_SECTORS_SIZE,
      /*Fee_RemainSize*/    (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE,
      /*Fee_SecEndAddr*/    FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/   (FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE + ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE)) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_SECTORS_SIZE + ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE)) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg1[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX,
      /*Fee_SectorSizeLessThan800*/  ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS,
      /*Fee_NormalSectorCount*/ (FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_SECTORS_SIZE + ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE)) / FEE_WFLASH_LG_SECTOR_SIZE
    }
};
#endif

#if ( FEE_USE_CONFIG_EX == STD_ON ) && ( FEE_SECTOR_START_ADDRESS < FEE_SECTOR_START_ADDRESS_EX )
/* Deviation from MISRA-C:2012 Rule-12.1, Rule-10.3
 Justification: The algrithm is necessary. */
/* PRQA S 3389,4464 28 */
CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[FEE_CONFIG_NUMBER] = {
    {
      /* configuration 1 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_SECTORS_SIZE,
      /*Fee_RemainSize*/    (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE,
      /*Fee_SecEndAddr*/    FEE_SECTOR_START_ADDRESS_EX + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/   (FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE + (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_SECTORS_SIZE + (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg1[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS,
      /*Fee_NormalSectorCount*/ (FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_SECTORS_SIZE + (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE
    },
    {
      /* configuration 2 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS_EX + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_SECTORS_SIZE_EX,
      /*Fee_RemainSize*/    (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX,
      /*Fee_SecEndAddr*/    FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/   (FEE_SECTORS_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE_EX + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_SECTORS_SIZE_EX + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg2[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX_EX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_EX,
      /*Fee_NormalSectorCount*/ (FEE_SECTORS_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_SECTORS_SIZE_EX + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE
    }
};
#endif

#if ( FEE_USE_CONFIG_EX == STD_ON ) && ( FEE_SECTOR_START_ADDRESS > FEE_SECTOR_START_ADDRESS_EX )
/* Deviation from MISRA-C:2012 Rule-12.1, Rule-10.3
 Justification: The algrithm is necessary. */
/* PRQA S 3389,4464 28 */
CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[FEE_CONFIG_NUMBER] = {
    {
      /* configuration 1 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_SECTORS_SIZE,
      /*Fee_RemainSize*/    (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE,
      /*Fee_SecEndAddr*/    FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/       (FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_SECTORS_SIZE + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg1[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS,
      /*Fee_NormalSectorCount*/ (FEE_SECTORS_SIZE / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_SECTORS_SIZE + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_SECTORS_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE
    },
    {
      /* configuration 2 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS_EX + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_SECTORS_SIZE_EX,
      /*Fee_RemainSize*/    (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX,
      /*Fee_SecEndAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/       (FEE_SECTORS_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE_EX + (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_SECTORS_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_SECTORS_SIZE_EX + (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg2[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX_EX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_EX,
      /*Fee_NormalSectorCount*/ (FEE_SECTORS_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_SECTORS_SIZE_EX + (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_SECTORS_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE
    }
};
#endif
#else /* #ifndef FEE_NORMAL_PAGE_SIZE */
#if ( FEE_USE_CONFIG_EX == STD_OFF )
/* Deviation from MISRA-C:2012 Rule-12.1, Rule-10.3
 Justification: The algrithm is necessary. */
/* PRQA S 3389,4464 15 */
CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[FEE_CONFIG_NUMBER] = {
    {
      /* configuration 1 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_NORMAL_PAGE_SIZE,
      /*Fee_RemainSize*/    (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE,
      /*Fee_SecEndAddr*/    FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/   (FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE + ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE)) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_NORMAL_PAGE_SIZE + ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE)) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg1[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX,
      /*Fee_SectorSizeLessThan800*/  ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE,
      /*Fee_NormalSectorCount*/ (FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_NORMAL_PAGE_SIZE + ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE)) / FEE_WFLASH_LG_SECTOR_SIZE
    }
};
#endif

#if ( FEE_USE_CONFIG_EX == STD_ON ) && ( FEE_SECTOR_START_ADDRESS < FEE_SECTOR_START_ADDRESS_EX )
/* Deviation from MISRA-C:2012 Rule-12.1, Rule-10.3
 Justification: The algrithm is necessary. */
/* PRQA S 3389,4464 28 */
CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[FEE_CONFIG_NUMBER] = {
    {
      /* configuration 1 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_NORMAL_PAGE_SIZE,
      /*Fee_RemainSize*/    (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE,
      /*Fee_SecEndAddr*/    FEE_SECTOR_START_ADDRESS_EX + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/   (FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE + (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_NORMAL_PAGE_SIZE + (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg1[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE,
      /*Fee_NormalSectorCount*/ (FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_NORMAL_PAGE_SIZE + (FEE_SECTOR_START_ADDRESS_EX - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE
    },
    {
      /* configuration 2 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS_EX + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_NORMAL_PAGE_SIZE_EX,
      /*Fee_RemainSize*/    (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX,
      /*Fee_SecEndAddr*/    FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/   (FEE_NORMAL_PAGE_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE_EX + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_NORMAL_PAGE_SIZE_EX + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg2[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX_EX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE_EX,
      /*Fee_NormalSectorCount*/ (FEE_NORMAL_PAGE_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_NORMAL_PAGE_SIZE_EX + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE
    }
};
#endif

#if ( FEE_USE_CONFIG_EX == STD_ON ) && ( FEE_SECTOR_START_ADDRESS > FEE_SECTOR_START_ADDRESS_EX )
/* Deviation from MISRA-C:2012 Rule-12.1, Rule-10.3
 Justification: The algrithm is necessary. */
/* PRQA S 3389,4464 28 */
CONST(Fee_ConfigurationInfoType, FEE_CONST) Fee_ConfigInfo[FEE_CONFIG_NUMBER] = {
    {
      /* configuration 1 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_NORMAL_PAGE_SIZE,
      /*Fee_RemainSize*/    (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE,
      /*Fee_SecEndAddr*/    FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/       (FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_NORMAL_PAGE_SIZE + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg1[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE,
      /*Fee_NormalSectorCount*/ (FEE_NORMAL_PAGE_SIZE / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_NORMAL_PAGE_SIZE + (FEE_WORK_FLASH_RELATIVE_END_ADDRESS - FEE_SECTOR_START_ADDRESS) % FEE_NORMAL_PAGE_SIZE) / FEE_WFLASH_LG_SECTOR_SIZE
    },
    {
      /* configuration 2 */
      /*Fee_SecTopAddr*/    FEE_SECTOR_START_ADDRESS_EX + FEE_FLS_BASE_ADDRESS,
      /*Fee_SecSize*/       FEE_NORMAL_PAGE_SIZE_EX,
      /*Fee_RemainSize*/    (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX,
      /*Fee_SecEndAddr*/    FEE_SECTOR_START_ADDRESS + FEE_FLS_BASE_ADDRESS,
      /*Fee_PSCCheckSum*/       (FEE_NORMAL_PAGE_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE_EX + (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE) + ((FEE_NORMAL_PAGE_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE) * ((FEE_NORMAL_PAGE_SIZE_EX + (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE)),
      /*Fee_BlkCfgPtr*/        &Fee_BlkCfg2[0],
      /*Fee_NoOfBlocks*/    FEE_BLOCK_MAX_EX,
      /*Fee_SectorSizeLessThan800*/ ((FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) % FEE_WFLASH_LG_SECTOR_SIZE,
      /*Fee_NoOfSec*/       FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE_EX,
      /*Fee_NormalSectorCount*/ (FEE_NORMAL_PAGE_SIZE_EX / FEE_WFLASH_LG_SECTOR_SIZE),
      /*Fee_LastSectorCount*/   (FEE_NORMAL_PAGE_SIZE_EX + (FEE_SECTOR_START_ADDRESS - FEE_SECTOR_START_ADDRESS_EX) % FEE_NORMAL_PAGE_SIZE_EX) / FEE_WFLASH_LG_SECTOR_SIZE
    }
};
#endif
#endif/* #ifndef FEE_NORMAL_PAGE_SIZE */

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.4, Rule-8.7
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1504 1 */
CONST(Fee_ConfigType, FEE_CONST) Fee_Cfg = FEE_CFG;

/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 1 */
CONST(Fee_BlockConfigType, FEE_CONST) Fee_BlkCfg1[FEE_BLOCK_MAX]    = FEE_BLKCFG;

#if ( FEE_USE_CONFIG_EX == STD_ON )
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 1 */
CONST(Fee_BlockConfigType, FEE_CONST) Fee_BlkCfg2[FEE_BLOCK_MAX_EX] = FEE_BLKCFG_EX;
#endif

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.7, Rule-8.9
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1504,1514 1 */
CONST(uint32, FEE_CONST) Fee_MaxCnt[7U] = {
  (uint32)((FEE_LIMIT_COUNT_INIT         * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U),
  (uint32)((FEE_LIMIT_COUNT_WRITE        * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U),
  (uint32)((FEE_LIMIT_COUNT_READ         * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U),
  (uint32)((FEE_LIMIT_COUNT_INVALIDATE   * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U),
  (uint32)((FEE_LIMIT_COUNT_RECYCLE      * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U),
  (uint32)((FEE_LIMIT_COUNT_WAIT         * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U),
  (uint32)((FEE_LIMIT_COUNT_WRITE_CANCEL * 1000U / FEE_MAIN_FUNCTION_PERIOD) + 1U)
};


/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.7, Rule-8.9
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1504,1514 1 */
CONST(uint32, FEE_CONST) Fee_MaxCnt_NoTimeout[7U] = {
  (uint32)((FEE_LIMIT_COUNT_INIT         * 100U) + 1U),
  (uint32)((FEE_LIMIT_COUNT_WRITE        * 100U) + 1U),
  (uint32)((FEE_LIMIT_COUNT_READ         * 100U) + 1U),
  (uint32)((FEE_LIMIT_COUNT_INVALIDATE   * 100U) + 1U),
  (uint32)((FEE_LIMIT_COUNT_RECYCLE      * 100U) + 1U),
  (uint32)((FEE_LIMIT_COUNT_WAIT         * 100U) + 1U),
  (uint32)((FEE_LIMIT_COUNT_WRITE_CANCEL * 100U) + 1U)
};

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.7, Rule-8.9
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1504,1514 1 */
CONST(Fee_LibFuncTableType, FEE_CONST) Fee_LibFuncTable =
{
#if ( FEE_CLEANUP_AND_ERASE_API == STD_ON )
    (Fee_MainRecycleFuncType)&Fee_MainRecycle,
#else
    (Fee_MainRecycleFuncType)FEE_NULL,
#endif
#if ( FEE_CLEAR_API == STD_ON )
    (Fee_MainClearFuncType)&Fee_MainClear,
#else
    (Fee_MainClearFuncType)FEE_NULL,
#endif
#if ( FEE_INITIALLY_ERASE_EMPTY_SECTORS == STD_ON )
    (Fee_EraseOrWriteFlagFuncType)&Fee_Erase,
#else
    (Fee_EraseOrWriteFlagFuncType)&Fee_WriteEraseCompleteFlag
#endif
};

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1514 5 */
#if defined( FEE_UNMATCHED_BLOCK_CHECK ) && ( FEE_UNMATCHED_BLOCK_CHECK == STD_OFF )
CONST(uint8, FEE_CONST) Fee_UnmatchedBlockCheck = STD_OFF; /* skip the Block check */
#else
CONST(uint8, FEE_CONST) Fee_UnmatchedBlockCheck = STD_ON;  /* Block check exists */
#endif /* #if defined( FEE_UNMATCHED_BLOCK_CHECK ) */

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1514 5 */
#if defined( FEE_INITIALLY_ERASE_EMPTY_SECTORS ) && ( FEE_INITIALLY_ERASE_EMPTY_SECTORS == STD_OFF )
CONST(uint8, FEE_CONST) Fee_InitiallyEraseEmptySectors = STD_OFF; /* skip the erase operation if valid/moving sectors are not found during the check of re-construction, but need user to guarantee the whole work flash is blank before using FEE */
#else
CONST(uint8, FEE_CONST) Fee_InitiallyEraseEmptySectors = STD_ON;  /* default : erase all sectors if valid/moving sectors are not found during the check of re-construction */
#endif /* #if defined( FEE_INITIALLY_ERASE_EMPTY_SECTORS ) */

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1514 5 */
#if defined( FEE_DELAY_RECYCLE_OPERATION ) && ( FEE_DELAY_RECYCLE_OPERATION == STD_ON )
CONST(uint8, FEE_CONST) Fee_DelayRecycleOperation = STD_ON;   /* delay recycle operation is on, delay some recycle */
#else
CONST(uint8, FEE_CONST) Fee_DelayRecycleOperation = STD_OFF;  /* default : delay recycle operation is off, do not delay recyle */
#endif /* #if defined( FEE_FAST_INIT_MODE ) */

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1514 24 */
#if defined( FEE_THRESHOLD_PAGE_SIZE )
CONST(uint8, FEE_CONST)  Fee_DefinedThresholdPageSize = STD_ON;   /* FEE_THRESHOLD_PAGE_SIZE is defined. */
CONST(uint16, FEE_CONST) Fee_ThresholdPageSize = FEE_THRESHOLD_PAGE_SIZE;
CONST(uint16, FEE_CONST) Fee_BlockNoFromRealMaxsize = FEE_BLOCK_NO_FROM_REAL_MAXSIZE;
CONST(uint16, FEE_CONST) Fee_BlockRealMaxsize = FEE_BLOCK_REAL_MAXSIZE;
#if ( FEE_USE_CONFIG_EX == STD_ON )
CONST(uint16, FEE_CONST) Fee_ThresholdPageSizeEx = FEE_THRESHOLD_PAGE_SIZE_EX;
CONST(uint16, FEE_CONST) Fee_BlockNoFromRealMaxsizeEx = FEE_BLOCK_NO_FROM_REAL_MAXSIZE_EX;
CONST(uint16, FEE_CONST) Fee_BlockRealMaxsizeEx = FEE_BLOCK_REAL_MAXSIZE_EX;
#endif
#else/*FEE_THRESHOLD_PAGE_SIZE OFF*/
CONST(uint8, FEE_CONST) Fee_DefinedThresholdPageSize = STD_OFF;  /* FEE_THRESHOLD_PAGE_SIZE is undefined. */
CONST(uint16, FEE_CONST) Fee_ThresholdPageSize = (uint16)FEE_NULL;
CONST(uint16, FEE_CONST) Fee_BlockNoFromRealMaxsize = (uint16)FEE_NULL;
CONST(uint16, FEE_CONST) Fee_BlockRealMaxsize = (uint16)FEE_NULL;
#if ( FEE_USE_CONFIG_EX == STD_ON )
CONST(uint16, FEE_CONST) Fee_ThresholdPageSizeEx = (uint16)FEE_NULL;
CONST(uint16, FEE_CONST) Fee_BlockNoFromRealMaxsizeEx = (uint16)FEE_NULL;
CONST(uint16, FEE_CONST) Fee_BlockRealMaxsizeEx = (uint16)FEE_NULL;
#endif
#endif /* #if defined( FEE_THRESHOLD_PAGE_SIZE ) */

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9, Rule-10.3
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1514,1257 1 */
CONST(uint16, FEE_CONST) Fee_WflashLgSectorSize = FEE_WFLASH_LG_SECTOR_SIZE;

/* Deviation from MISRA-C:2004 rule 8.7, 8.8, MISRA-C:2012 Rule-8.4, Rule-8.9
   Justification: The variable is expected to be a const variable.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 3408,1514 1 */
CONST(uint32, FEE_CONST) Fee_WorkFlashAbsoluteEndAddress = FEE_WORK_FLASH_RELATIVE_END_ADDRESS + FEE_FLS_BASE_ADDRESS;

#define FEE_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


#define FEE_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

#if defined( FEE_DEFAULT_CYCLE_MODE )

VAR(MemIf_ModeType, FEE_INTERNAL_VAR_CLEARED) FeeDefaultCycleMode = (MemIf_ModeType)FEE_DEFAULT_CYCLE_MODE;

#else

VAR(MemIf_ModeType, FEE_INTERNAL_VAR_CLEARED) FeeDefaultCycleMode = MEMIF_MODE_SLOW;

#endif /* #if defined( FeeDefaultCycleMode ) */


#if defined( FEE_BCHK_OFF_BLOCK ) && ( FEE_BCHK_OFF_BLOCK == STD_ON )
VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_BlockBlankCheckOff = STD_ON;   /* skip the block blank check */
#else
VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_BlockBlankCheckOff = STD_OFF;  /* default : execute block blank check */
#endif /* #if defined( FEE_UNMATCHED_BLOCK_CHECK ) */

#if defined( FEE_BCHK_OFF_SECTOR ) && ( FEE_BCHK_OFF_SECTOR == STD_ON )
VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_SectorBlankCheckOff = STD_ON;   /* skip the sector blank check */
#else
VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_SectorBlankCheckOff = STD_OFF;  /* default : execute sector blank check */
#endif /* #if defined( FEE_BCHK_OFF_SECTOR ) */


/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 1 */
static VAR(Fee_BlockConfigType, FEE_INTERNAL_VAR_CLEARED) Fee_BlkCfgOnFlash1[FEE_BLOCK_MAX]    = FEE_BLKCFG;

#if ( FEE_USE_CONFIG_EX == STD_ON )
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 1 */
static VAR(Fee_BlockConfigType, FEE_INTERNAL_VAR_CLEARED) Fee_BlkCfgOnFlash2[FEE_BLOCK_MAX_EX] = FEE_BLKCFG_EX;
#endif

/* the flag indicates DMA status. STD_OFF means DMA disabled. STD_ON means DMA enabled. */
static VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_EnabledDmaFlag = STD_OFF;

/* If Fee_FlsDedErrorNotificationVar is STD_ON, it means that 1bit ECC error is occuring. */
static VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_FlsDedErrorNotificationVar = STD_OFF;

/* If Fee_FlsSedErrorNotificationVar is STD_ON, it means that 2bit ECC error is occuring. */
static VAR(uint8, FEE_INTERNAL_VAR_CLEARED) Fee_FlsSedErrorNotificationVar = STD_OFF;


#define FEE_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/*****************************************************************************/
/* Local variable definitions ('static')                                     */
/*****************************************************************************/
#define FEE_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

#if (FEE_USE_CONFIG_EX == STD_ON) && (FEE_BLOCK_MAXSIZE_EX > FEE_BLOCK_MAXSIZE)
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9, Rule-8.9, Rule-10.4
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  This implmentation is needed for doing a signed cast. */
/* PRQA S 3218,1514,1840 1 */
static VAR(uint64, AUTOMATIC) Fee_Data[(FEE_CACULATE_ALIGN8(FEE_BLOCK_MAXSIZE_EX))>>FEE_SHIFT_BITS];        /* block data buffer for write block */

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9, Rule-8.9, Rule-10.4
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  This implmentation is needed for doing a signed cast. */
/* PRQA S 3218,1514,1840 1 */
static VAR(uint64, AUTOMATIC) Fee_DataBuffer[(FEE_CACULATE_ALIGN8(FEE_BLOCK_MAXSIZE_EX))>>FEE_SHIFT_BITS];  /* block data buffer for recycle */

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9, Rule-8.9, Rule-10.4
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  This implmentation is needed for doing a signed cast. */
/* PRQA S 3218,1514,1840 1 */
static VAR(uint64, AUTOMATIC) Fee_DataBufferRecycle[(FEE_CACULATE_ALIGN8(FEE_BLOCK_MAXSIZE_EX))>>FEE_SHIFT_BITS];  /* block data buffer for recycle for writing last block */
#else
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9, Rule-8.9, Rule-10.4
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  This implmentation is needed for doing a signed cast. */
/* PRQA S 3218,1514,1840 1 */
static VAR(uint64, AUTOMATIC) Fee_Data[(FEE_CACULATE_ALIGN8(FEE_BLOCK_MAXSIZE))>>FEE_SHIFT_BITS];        /* block data buffer for write block */

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9, Rule-8.9, Rule-10.4
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  This implmentation is needed for doing a signed cast. */
/* PRQA S 3218,1514,1840 1 */
static VAR(uint64, AUTOMATIC) Fee_DataBuffer[(FEE_CACULATE_ALIGN8(FEE_BLOCK_MAXSIZE))>>FEE_SHIFT_BITS];  /* block data buffer for recycle for writing 0xFF */

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9, Rule-8.9, Rule-10.4
   Justification: The variable must be declared as static to assure 8-byte-alignment.
                  This implmentation is needed for doing a signed cast. */
/* PRQA S 3218,1514,1840 1 */
static VAR(uint64, AUTOMATIC) Fee_DataBufferRecycle[(FEE_CACULATE_ALIGN8(FEE_BLOCK_MAXSIZE))>>FEE_SHIFT_BITS];  /* block data buffer for recycle for writing last block */
#endif

#ifndef FEE_NORMAL_PAGE_SIZE
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 2 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatus1[FEE_NUMBER_OF_SECTORS];                  /* array of sector status for configuration 1 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatusMirror1[FEE_NUMBER_OF_SECTORS];            /* mirror of Fee_SectorStatus[] for fail-safe for configuration 1 */

#if ( FEE_USE_CONFIG_EX == STD_ON )
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 2 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatus2[FEE_NUMBER_OF_SECTORS_EX];               /* array of sector status for configuration 2 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatusMirror2[FEE_NUMBER_OF_SECTORS_EX];         /* mirror of Fee_SectorStatus[] for fail-safe for configuration 2 */
#endif
#else /* #ifndef FEE_NORMAL_PAGE_SIZE */
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 2 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatus1[FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE];                  /* array of sector status for configuration 1 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatusMirror1[FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE];            /* mirror of Fee_SectorStatus[] for fail-safe for configuration 1 */

#if ( FEE_USE_CONFIG_EX == STD_ON )
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 2 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatus2[FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE_EX];               /* array of sector status for configuration 2 */
static VAR(uint8, AUTOMATIC)  Fee_SectorStatusMirror2[FEE_NUMBER_OF_SECTORS_BY_NORMAL_PAGE_SIZE_EX];         /* mirror of Fee_SectorStatus[] for fail-safe for configuration 2 */
#endif
#endif /* #ifndef FEE_NORMAL_PAGE_SIZE */

/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 3 */
static P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC) Fee_BlkMgtAreaEmptyAddrPtr[FEE_CONFIG_NUMBER];  /* pointer to empty address for block management area for each configuration */
static P2VAR(uint32, AUTOMATIC, AUTOMATIC) Fee_BlkPageAreaEmptyAddrPtr[FEE_CONFIG_NUMBER]; /* pointer to empty address for page area for each configuration */
static VAR(uint16, AUTOMATIC)                       Fee_BlkEmptySize[FEE_CONFIG_NUMBER];         /* empty size for each configuration */

/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504 1 */
static VAR(Fee_BlockAddrIndexType, AUTOMATIC) Fee_BlockAddrIndex1[FEE_BLOCK_MAX];       /* index of blocks for configuration 1 */
/* Deviation from MISRA-C:2004 rule 8.8, 8.10, MISRA-C:2012 Rule-8.7, Rule-8.4
   Justification: The variable is expected to be a static variable and only use in this file.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504,3408 1 */
static VAR(Fee_BlockAddrIndexType, AUTOMATIC) Fee_BlockAddrIndexMirror1[FEE_BLOCK_MAX]; /* index of blocks for configuration 1 */

#if ( FEE_USE_CONFIG_EX == STD_ON )
/* Deviation from MISRA-C:2004 rule 8.8, 8.10, MISRA-C:2012 Rule-8.7, Rule-8.4
   Justification: The variable is expected to be a static variable and only use in this file.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504,3408 2 */
static VAR(Fee_BlockAddrIndexType, AUTOMATIC) Fee_BlockAddrIndex2[FEE_BLOCK_MAX_EX];       /* index of blocks for configuration 2 */
static VAR(Fee_BlockAddrIndexType, AUTOMATIC) Fee_BlockAddrIndexMirror2[FEE_BLOCK_MAX_EX]; /* index of blocks for configuration 2 */
#endif

/* Deviation from MISRA-C:2004 rule 8.8, 8.10, MISRA-C:2012 Rule-8.7, Rule-8.4
   Justification: The variable is expected to be a static variable and only use in this file.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504,3408 1 */
static VAR(uint8, AUTOMATIC) Fee_IsNextBlockCorrupt1[FEE_BLOCK_MAX];       /* indicate the next block is corrupt or not for configuration 1 */
#if ( FEE_USE_CONFIG_EX == STD_ON )
/* Deviation from MISRA-C:2004 rule 8.8, 8.10, MISRA-C:2012 Rule-8.7, Rule-8.4
   Justification: The variable is expected to be a static variable and only use in this file.
                  This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1504,3408 1 */
static VAR(uint8, AUTOMATIC) Fee_IsNextBlockCorrupt2[FEE_BLOCK_MAX_EX];    /* indicate the next block is corrupt or not for configuration 2 */
#endif

#define FEE_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


/*****************************************************************************/
/* Local function prototypes ('static')                                      */
/*****************************************************************************/
/*****************************************************************************/
/* Global function prototypes ('extern')                                      */
/*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC(Fls_AddressType, FLS_CODE) Fls_GetSecTopAddressFromAddress
(
    VAR(Fls_AddressType, AUTOMATIC) TargetAddress
);

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC_P2VAR(void, AUTOMATIC, FLS_CODE) Fls_GetReadAddr
(
 P2VAR(void, AUTOMATIC, FLS_APPL_DATA) addr,
 VAR(FLS_ULONG, AUTOMATIC) length
);

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC(Fls_AddressType, FLS_CODE) Fls_GetBlankAddr
(
    VAR(Fls_AddressType, AUTOMATIC) SourceAddress,
    VAR(Fls_LengthType, AUTOMATIC) Length,
    VAR(Fls_LengthType, AUTOMATIC) BlankLength
);

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC(void, FLS_CODE) Fls_ReadImmediateSync
(
    VAR(Fls_AddressType, AUTOMATIC) SourceAddress,
    P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    VAR(Fls_LengthType, AUTOMATIC) Length
);

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC(void, FLS_CODE) Fls_EnableDMA
(
 void
);

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC(void, FLS_CODE) Fls_DisableDMA
(
 void
);

/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5
   Justification: It is only required for identifiers that need to be used in multiple files.
                  This function is only used in this file. */
/* PRQA S 3447 1 */
extern FUNC(Fls_FaultType, FLS_CODE) Fls_GetFaultInfo(void);
/*****************************************************************************/
/* Function implementation - global ('extern') and local ('static')          */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/**
 ******************************************************************************
 ** \fn Fee_EnterCritiSec
 **
 ** Enters critical section. (call SchM module)
 **
 ** \return     none
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_EnterCritiSec(void)
{
    SchM_Enter_Fee_FEE_EXCLUSIVE_AREA_0();
}

/**
 ******************************************************************************
 ** \fn Fee_ExitCritiSec
 **
 ** Exits critical section. (call SchM module)
 **
 ** \return     none
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_ExitCritiSec(void)
{
    SchM_Exit_Fee_FEE_EXCLUSIVE_AREA_0();
}

/**
 ******************************************************************************
 ** \fn Fee_ErrorCallout
 **
 ** Error callout function.
 **
 ** \param Event [in] - Library internal event IDs.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_ErrorCallout(
  VAR(uint16, AUTOMATIC) Event)
{
    VAR(uint8, AUTOMATIC)               ErrorId;

    switch(Event)
    {
        case FEE_EVENT_HARDWARE_ERROR_OCCURRED:

            ErrorId = FEE_E_HARDWARE_ERROR_OCCURRED;
            break;

        case FEE_EVENT_TIMEOUT_ERROR_OCCURRED:

            ErrorId = FEE_E_TIMEOUT_ERROR_OCCURRED;
            break;

        case FEE_EVENT_IMMEDIATEDATASPACE_UNAVAILABLE:

            ErrorId = FEE_E_IMMEDIATEDATASPACE_UNAVAILABLE;
            break;

        case FEE_EVENT_BLOCKID_UNMATCHED_ERROR_OCCURRED:

            ErrorId = FEE_E_BLOCKID_UNMATCHED_ERROR_OCCURRED;
            break;

        case FEE_EVENT_BLOCKSIZE_UNMATCHED_ERROR_OCCURRED:

            ErrorId = FEE_E_BLOCKSIZE_UNMATCHED_ERROR_OCCURRED;
            break;

        case FEE_EVENT_1BIT_ECC_ERROR_OCCURRED:

            ErrorId = FEE_E_1BIT_ECC_ERROR_OCCURRED;
            break;

        case FEE_EVENT_2BIT_ECC_ERROR_OCCURRED:

            ErrorId = FEE_E_2BIT_ECC_ERROR_OCCURRED;
            break;

        default:
            ErrorId = FEE_E_NO_ERROR;
            break;
    }

    /* ASIL error callout */
    Fee_Det( FEE_MAINFUNCTION_ID, ErrorId );

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_Det
 **
 ** Function to check that DET is enabled and than call the Det_ReportError
 ** Function with wrapped IDs.
 **
 ** \param ApiId [in] - Specifies the API where the DET comes from.
 ** \param ErrorId [in] - Specifies the detected error.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_Det(
  VAR(uint8, AUTOMATIC) ApiId,
  VAR(uint8, AUTOMATIC) ErrorId)
{
    /* ASIL error callout */
    FEE_ERROR_CALLOUT_FUNCTION( FEE_MODULE_ID, FEE_INSTANCE_ID, ApiId, ErrorId );

    /* Check for configured development error.                                  */
#if ( FEE_DEV_ERROR_DETECT == STD_ON )
    (void)Det_ReportError( FEE_MODULE_ID, FEE_INSTANCE_ID, ApiId, ErrorId );
#endif

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_FlsGetStatus
 **
 ** Wrapper function to get the status of the underlying hardware driver.
 **
*****************************************************************************/
FUNC(MemIf_StatusType, FEE_CODE) Fee_FlsGetStatus(void)
{
    return Fls_GetStatus();
}

/**
 ******************************************************************************
 ** \fn Fee_FlsGetStatusSub
 **
 ** Wrapper function to get the hardware status of the underlying hardware driver.
 **
*****************************************************************************/
FUNC(MemIf_StatusType, FEE_CODE) Fee_FlsGetStatusSub(void)
{
    VAR(MemIf_StatusType, AUTOMATIC) retval;

    if( Fls_GetStatusSub() == FLS_STATUS_IDLE )
    {
        retval = MEMIF_IDLE;
    }
    else
    {
        retval = MEMIF_BUSY;
    }

    return retval;
}

/**
 ******************************************************************************
 ** \fn Fee_FlsGetJobResult
 **
 ** Wrapper function to get the status of the underlying hardware driver.
 **
*****************************************************************************/
FUNC(MemIf_JobResultType, FEE_CODE) Fee_FlsGetJobResult(void)
{
    return Fls_GetJobResult();
}

/**
 ******************************************************************************
 ** \fn Fee_FlsRead
 **
 ** Wrapper function of the underlying hardware driver to read data.
 **
 ** \param SourceAddress [in] - Start address to read from.
 ** \param TargetAddressPtr [out] - Pointer to buffer to read to.
 ** \param Length [in] - Number of bytes to be read.
 **
*****************************************************************************/
FUNC(Std_ReturnType, FEE_CODE) Fee_FlsRead(
  VAR(uint32, AUTOMATIC) SourceAddress,
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) TargetAddressPtr,
  VAR(uint32, AUTOMATIC) Length)
{
    return Fls_ReadImmediate( SourceAddress - FEE_FLS_BASE_ADDRESS, TargetAddressPtr, Length );
}


/**
 ******************************************************************************
 ** \fn Fee_FlsReadImmediateSync
 **
 ** Wrapper function of the underlying hardware driver to read data via DMA.
 **
 ** \param SourceAddress [in] - Start address to read from. It is a physical address.
 ** \param TargetAddressPtr [out] - Pointer to buffer to read to.
 ** \param Length [in] - Number of bytes to be read.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_FlsReadImmediateSync(
  VAR(uint32, AUTOMATIC) SourceAddress,
  P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) TargetAddressPtr,
  VAR(uint32, AUTOMATIC) Length)
{
    Fls_AuxiliaryBuffer[0] = (uint32)0xFFFFFFFFU;

    Fls_ReadImmediateSync( SourceAddress, TargetAddressPtr, Length );

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_FlsCompare
 **
 ** Wrapper function of the underlying hardware driver to compare data.
 **
 ** \param SourceAddress [in] - Start address of the data to be compared out of
 ** Flash.
 ** \param TargetAddressPtr [in] - Pointer to buffer which contains the data to
 ** be compared.
 ** \param Length [in] - Number of bytes to compare.
 **
*****************************************************************************/
FUNC(Std_ReturnType, FEE_CODE) Fee_FlsCompare(
  VAR(uint32, AUTOMATIC) SourceAddress,
  P2CONST(uint8, AUTOMATIC, FEE_APPL_CONST) TargetAddressPtr,
  VAR(uint32, AUTOMATIC) Length)
{
    return Fls_Compare( SourceAddress - FEE_FLS_BASE_ADDRESS, TargetAddressPtr, Length );
}

/**
 ******************************************************************************
 ** \fn Fee_FlsWrite
 **
 ** Wrapper function of the underlying hardware driver to write data.
 **
 ** \param TargetAddress [in] - Start address to write to.
 ** \param SourceAddressPtr [in] - Pointer to buffer which contains the data to
 ** write.
 ** \param Length [in] - Number of bytes to be written.
 **
*****************************************************************************/
FUNC(Std_ReturnType, FEE_CODE) Fee_FlsWrite(
  VAR(uint32, AUTOMATIC) TargetAddress,
  P2CONST(uint8, AUTOMATIC, FEE_APPL_CONST) SourceAddressPtr,
  VAR(uint32, AUTOMATIC) Length)
{
    /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
       Justification: Because the value of FeeVirtualPageSize may be change in future, save this calculation. */
    /* PRQA S 2984 1 */
    return Fls_Write( TargetAddress - FEE_FLS_BASE_ADDRESS, SourceAddressPtr, (Length + ((uint32)Fee_Cfg.FeeVirtualPageSize - 1U)) & (uint32)(~((uint32)Fee_Cfg.FeeVirtualPageSize - 1U)) );
}

/**
 ******************************************************************************
 ** \fn Fee_FlsErase
 **
 ** Wrapper function of the underlying hardware driver to erase one ore more
 ** sectors.
 **
 ** \param TargetAddress [in] - Start address of the sector to be erased.
 ** \param Length [in] - Number of bytes to be erased.
 **
*****************************************************************************/
FUNC(Std_ReturnType, FEE_CODE) Fee_FlsErase(
  VAR(uint32, AUTOMATIC) TargetAddress,
  VAR(uint32, AUTOMATIC) Length)
{
    return Fls_Erase( TargetAddress - FEE_FLS_BASE_ADDRESS, Length );
}

/**
 ******************************************************************************
 ** \fn Fee_FlsCancel
 **
 ** Wrapper function of the underlying hardware driver to cancel an ongoing job.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_FlsCancel(void)
{
    Fls_Cancel();
}

/**
 ******************************************************************************
 ** \fn Fee_FlsEnableDMA
 **
 ** Wrapper function of the underlying hardware driver to enable DMA.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_FlsEnableDMA(void)
{
    if(Fee_EnabledDmaFlag == STD_OFF)
    {
        Fls_EnableDMA();
        Fee_EnabledDmaFlag = STD_ON;
    }
}

/**
 ******************************************************************************
 ** \fn Fee_FlsDisableDMA
 **
 ** Wrapper function of the underlying hardware driver to disable DMA.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_FlsDisableDMA(void)
{
    if(Fee_EnabledDmaFlag == STD_ON)
    {
        Fls_DisableDMA();
        Fee_EnabledDmaFlag = STD_OFF;
    }
}

/**
 ******************************************************************************
 ** \fn Fee_BlockNumberToAttribute
 **
 ** Query the structure of the block attribution by BlockNumber and return it.
 **
 ** \param BlockNumber [in] - Block number as defined in block configuration.
 **
*****************************************************************************/
FUNC(Fee_BlockAttributeType, FEE_CODE) Fee_BlockNumberToAttribute(
  VAR(uint16, AUTOMATIC) BlockNumber)
{
    VAR(uint8, AUTOMATIC)   cnt;
    VAR(uint16, AUTOMATIC)  bi;
    VAR(Fee_BlockAttributeType, AUTOMATIC) BlkAttri;

    BlkAttri.FeeBlockIndex = FEE_INVALID_BLOCK_NO;
    BlkAttri.FeeConfigSetNumber = (uint8)FEE_INVALID_BLOCK_NO;

    if( (FEE_INVALID_BLOCK_NO != BlockNumber) && ((uint16)0 != BlockNumber) )
    {
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Dir-4.1
           Justification: Times of loop is changed by user configuration. */
        /* PRQA S 2877 1 */
        for( cnt = 0U; cnt < Fee_GetCfgNum(); cnt++ )
        {
            for( bi = (uint16)0; bi < Fee_ConfigInfo[cnt].Fee_NoOfBlocks; bi++ )
            {
                if( BlockNumber == Fee_ConfigInfo[cnt].Fee_BlkCfgPtr[bi].FeeBlockNumber )
                {
                    BlkAttri.FeeBlockIndex = bi;
                    BlkAttri.FeeConfigSetNumber = (uint8)cnt + (uint8)1;
                    /* Deviation from MISRA-C:2004 rule 13.6, MISRA-C:2012 Rule-14.2
                       Justification: To escape loop, this loop breaked by condition and not via break. */
                    /* PRQA S 2469 1 */
                    bi = Fee_ConfigInfo[cnt].Fee_NoOfBlocks;
                }
            }

            if( BlkAttri.FeeBlockIndex != FEE_INVALID_BLOCK_NO )
            {
                /* Deviation from MISRA-C:2004 rule 13.6, MISRA-C:2012 Rule-14.2
                   Justification: To escape loop, this loop breaked by condition and not via break. */
                /* PRQA S 2469 1 */
                cnt = Fee_GetCfgNum();
            }
        }
    }

    return BlkAttri;
}

/**
 ******************************************************************************
 ** \fn Fee_FlsSetMode
 **
 ** Wrapper function of the underlying hardware driver for setting mode.
 **
*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1503 1 */
FUNC(void, FEE_CODE) Fee_FlsSetMode(VAR(MemIf_ModeType, AUTOMATIC) Mode)
{
    Fls_SetMode( Mode );
}

/**
 ******************************************************************************
 ** \fn Fee_FlsInit
 **
 ** Wrapper function of the underlying hardware driver for initialization.
 **
*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1503 1 */
FUNC(void, FEE_CODE) Fee_FlsInit(void)
{
    Fls_Init( NULL_PTR );
}

/**
 ******************************************************************************
 ** \fn Fee_GetFlsFault
 **
 ** Wrapper function of the underlying hardware driver for get fault type.
 **
*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1503 1 */
FUNC(Fee_FaultType, FEE_CODE) Fee_GetFlsFault(void)
{
    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: The Fee_FaultType and Fls_FaultType is the same define. */
    /* PRQA S 4322 1 */
    return (Fee_FaultType)Fls_GetFaultInfo();
}


/**
 ******************************************************************************
 ** \fn Fee_GetData
 **
 ** get variable Fee_Data.
 **
 ** \return     Fee_Data
 **
*****************************************************************************/
FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetData(void)
{
    return (uint32*)&Fee_Data[0];
}

/**
 ******************************************************************************
 ** \fn Fee_GetDataBuffer
 **
 ** get variable Fee_DataBuffer.
 **
 ** \return     Fee_DataBuffer
 **
*****************************************************************************/
FUNC_P2VAR(uint64, AUTOMATIC, FEE_CODE) Fee_GetDataBuffer(void)
{
    return &Fee_DataBuffer[0];
}

/**
 ******************************************************************************
 ** \fn Fee_GetDataBufferRecycle
 **
 ** get variable Fee_DataBufferRecycle.
 **
 ** \return     Fee_DataBufferRecycle
 **
*****************************************************************************/
FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetDataBufferRecycle(void)
{
    return (uint32*)&Fee_DataBufferRecycle[0];
}

/**
 ******************************************************************************
 ** \fn Fee_GetSectorStatusElementWithCfg
 **
 ** get variable Fee_SectorStatus1 or Fee_SectorStatus2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 **
 ** \return     Fee_SectorStatus
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetSectorStatusElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index)
{
    VAR(uint8, AUTOMATIC)  Fee_SectorStatus;

    Fee_SectorStatus = (uint8)FEE_NULL; /* initialize to FEE_SECTOR_NOSTATUS */

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_SectorStatus = Fee_SectorStatus1[index];
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_SectorStatus = Fee_SectorStatus2[index];
        break;
#endif
    default:
        break;
    }

    return Fee_SectorStatus;
}

/**
 ******************************************************************************
 ** \fn Fee_GetSectorStatusMirrorElementWithCfg
 **
 ** get variable Fee_SectorStatusMirror1 or Fee_SectorStatusMirror2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 **
 ** \return     Fee_SectorStatusMirror
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetSectorStatusMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index)
{
    VAR(uint8, AUTOMATIC)  Fee_SectorStatusMirror;

    Fee_SectorStatusMirror = (uint8)FEE_NULL; /* initialize to FEE_SECTOR_NOSTATUS */

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_SectorStatusMirror = Fee_SectorStatusMirror1[index];
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_SectorStatusMirror = Fee_SectorStatusMirror2[index];
        break;
#endif
    default:
        break;
    }

    return Fee_SectorStatusMirror;
}

/**
 ******************************************************************************
 ** \fn Fee_SetSectorStatusElementWithCfg
 **
 ** set variable Fee_SectorStatus1 or Fee_SectorStatus2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetSectorStatusElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) value)
{
    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_SectorStatus1[index] = value;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_SectorStatus2[index] = value;
        break;
#endif
    default:
        break;
    }

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_SetSectorStatusMirrorElementWithCfg
 **
 ** set variable Fee_SectorStatusMirror1 or Fee_SectorStatusMirror2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetSectorStatusMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) value)
{
    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_SectorStatusMirror1[index] = value;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_SectorStatusMirror2[index] = value;
        break;
#endif
    default:
        break;
    }

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_SetBlkMgtAreaEmptyAddrElementWithCfg
 **
 ** set variable Fee_BlkMgtAreaEmptyAddr1 of Fee_BlkMgtAreaEmptyAddr2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlkMgtAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(Fee_BlockManagementInfoType*, AUTOMATIC) value)
{
    Fee_BlkMgtAreaEmptyAddrPtr[config_no] = value;

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_SetBlkPageAreaEmptyAddrElementWithCfg
 **
 ** set variable Fee_BlkPageAreaEmptyAddr1 or Fee_BlkPageAreaEmptyAddr2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlkPageAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint32*, AUTOMATIC) value)
{
    Fee_BlkPageAreaEmptyAddrPtr[config_no] = value;

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_SetBlkEmptySizeElementWithCfg
 **
 ** set variable Fee_BlkEmptySize1 or Fee_BlkEmptySize2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param value [in] - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlkEmptySizeElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) value)
{
    Fee_BlkEmptySize[config_no] = value;

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_GetBlkMgtAreaEmptyAddrElementWithCfg
 **
 ** get variable Fee_BlkMgtAreaEmptyAddr1 or Fee_BlkMgtAreaEmptyAddr2.
 **
 ** \param config_no [in] - number of configuration.
 **
 ** \return     Fee_BlkMgtAreaEmptyAddr
 **
*****************************************************************************/
FUNC_P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, FEE_CODE) Fee_GetBlkMgtAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no)
{
    return Fee_BlkMgtAreaEmptyAddrPtr[config_no];
}

/**
 ******************************************************************************
 ** \fn Fee_GetBlkPageAreaEmptyAddrElementWithCfg
 **
 ** get variable Fee_BlkPageAreaEmptyAddr1 or Fee_BlkPageAreaEmptyAddr2.
 **
 ** \param config_no [in] - number of configuration.
 **
 ** \return     Fee_BlkPageAreaEmptyAddr
 **
*****************************************************************************/
FUNC_P2VAR(uint32, AUTOMATIC, FEE_CODE) Fee_GetBlkPageAreaEmptyAddrElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no)
{
    return Fee_BlkPageAreaEmptyAddrPtr[config_no];
}

/**
 ******************************************************************************
 ** \fn Fee_GetBlkEmptySizeElementWithCfg
 **
 ** get variable Fee_BlkEmptySize1 or Fee_BlkEmptySize2.
 **
 ** \param config_no [in] - number of configuration.
 **
 ** \return     Fee_BlkEmptySize
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetBlkEmptySizeElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no)
{
    return Fee_BlkEmptySize[config_no];
}

/**
 ******************************************************************************
 ** \fn Fee_SetBlockAddrIndexElementWithCfg
 **
 ** set variable Fee_BlockAddrIndex1 or Fee_BlockAddrIndex2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlockAddrIndexElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockAddrIndexType, AUTOMATIC) value)
{
    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_BlockAddrIndex1[index] = value;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_BlockAddrIndex2[index] = value;
        break;
#endif
    default:
        break;
    }

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_SetBlockAddrIndexMirrorElementWithCfg
 **
 ** set variable Fee_BlockAddrIndexMirror1 or Fee_BlockAddrIndexMirror2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlockAddrIndexMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockAddrIndexType, AUTOMATIC) value)
{
    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_BlockAddrIndexMirror1[index] = value;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_BlockAddrIndexMirror2[index] = value;
        break;
#endif
    default:
        break;
    }

    return;
}

/**
 ******************************************************************************
 ** \fn Fee_GetBlockAddrIndexElementWithCfg
 **
 ** get variable Fee_BlockAddrIndex1 or Fee_BlockAddrIndex2.
 **
 ** \param config_no [in] - number of configuration.
 **
 ** \return     Fee_BlockAddrIndex
 **
*****************************************************************************/
FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_GetBlockAddrIndexElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index)
{
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)  block_addr_index;

    block_addr_index.BlkStatus = (uint8)0xFFU;        /* initialize to FEE_BLKIDX_NO_BLOCK_EXIST */
    block_addr_index.BlkAddr   = (uint32)0xFFU;       /* initialize to FEE_BLKIDX_NO_BLOCK_EXIST */
    block_addr_index.BlkBlankCheck = (uint8)0;        /* initialize to FEE_BLANK_CHECK_UNDO */

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        block_addr_index = Fee_BlockAddrIndex1[index];
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        block_addr_index = Fee_BlockAddrIndex2[index];
        break;
#endif
    default:
        break;
    }

    return block_addr_index;
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlockAddrIndexMirrorElementWithCfg
 **
 ** get variable Fee_BlockAddrIndexMirror1 or Fee_BlockAddrIndex2.
 **
 ** \param config_no [in] - number of configuration.
 **
 ** \return     Fee_BlockAddrIndexMirror
 **
*****************************************************************************/
FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_GetBlockAddrIndexMirrorElementWithCfg(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index)
{
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)  block_addr_index;

    block_addr_index.BlkStatus = (uint8)0xFFU;        /* initialize to FEE_BLKIDX_NO_BLOCK_EXIST */
    block_addr_index.BlkAddr   = (uint32)0xFFU;       /* initialize to FEE_BLKIDX_NO_BLOCK_EXIST */
    block_addr_index.BlkBlankCheck = (uint8)0;        /* initialize to FEE_BLANK_CHECK_UNDO */

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        block_addr_index = Fee_BlockAddrIndexMirror1[index];
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        block_addr_index = Fee_BlockAddrIndexMirror2[index];
        break;
#endif
    default:
        break;
    }

    return block_addr_index;
}

/**
 ******************************************************************************
 ** \fn Fee_GetLibFuncTable
 **
 ** get variable Fee_LibFuncTable.
 **
 ** \return     Fee_LibFuncTable
 **
*****************************************************************************/
FUNC_P2CONST(Fee_LibFuncTableType, FEE_CONST, AUTOMATIC) Fee_GetLibFuncTable(void)
{
    return (const Fee_LibFuncTableType*)&Fee_LibFuncTable;
}


/**
 ******************************************************************************
 ** \fn Fee_GetCfgNum
 **
 ** get variable Fee_CfgNum.
 **
 ** \return     Fee_CfgNum
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetCfgNum(void)
{
    return Fee_CfgNum;
}


/**
 ******************************************************************************
 ** \fn Fee_GetCfg
 **
 ** get variable Fee_Cfg.
 **
 ** \return     Fee_Cfg
 **
*****************************************************************************/
FUNC(Fee_ConfigType, FEE_CODE) Fee_GetCfg(void)
{
    return Fee_Cfg;
}


/**
 ******************************************************************************
 ** \fn Fee_GetModeVar
 **
 ** get variable FeeDefaultCycleMode.
 **
 ** \return     FeeDefaultCycleMode
 **
*****************************************************************************/
FUNC(MemIf_ModeType, FEE_CODE) Fee_GetModeVar(void)
{
    return FeeDefaultCycleMode;
}


/**
 ******************************************************************************
 ** \fn Fee_GetTimeoutCount
 **
 ** \param[in]     FEE current job
 **
 ** \return     count    max count for timeout check
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetTimeoutCount(
  VAR(Fee_EnumTypeCurrentJobType, AUTOMATIC) current_job)
{
    VAR(uint32, AUTOMATIC) count;

    if( FeeDefaultCycleMode == MEMIF_MODE_FAST )
    {
        count = Fee_MaxCnt_NoTimeout[current_job];
    }
    else
    {
        count = Fee_MaxCnt[current_job];
    }

    return count;
}


/**
 ******************************************************************************
 ** \fn Fee_FlsGetSecTopAddressFromAddress
 **
 ** Wrapper function of the underlying hardware driver to get physics sector start
 ** address of given address(The given addres is always the erase flag addrss)
 **
 ** \param TargetAddress [in]  address to find physics sector start address
 **
 ** \return     address    physics start address of target address
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_FlsGetSecTopAddressFromAddress(
  VAR(uint32, AUTOMATIC) TargetAddress)
{
    return (uint32)Fls_GetSecTopAddressFromAddress( TargetAddress );
}


/**
 ******************************************************************************
 ** \fn Fee_FlsGetReadAddr
 **
 ** Wrapper function of the underlying hardware driver to check the 
 ** TargetAddress is blank or not
 **
 ** \param TargetAddress [in]  address to check blank
 **
 ** \return     address    
 **             NULL           TargetAddress is blank
 **             address        TargetAddress is not blank
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_FlsGetReadAddr(
  VAR(uint32, AUTOMATIC) TargetAddress)
{
    VAR(uint32, AUTOMATIC) ret;

    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
       Justification: Cast between a pointer to object and an integral type. */
    /* PRQA S 306 1 */
    ret = (uint32)Fls_GetReadAddr( (void *)TargetAddress, (uint32)(4U) );

    return ret;
}


/**
 ******************************************************************************
 ** \fn Fee_GetUnmatchedBlockCheck
 **
 ** get variable Fee_UnmatchedBlockCheck.
 **
 ** \return     Fee_UnmatchedBlockCheck
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetUnmatchedBlockCheck(void)
{
    return Fee_UnmatchedBlockCheck;
}


/**
 ******************************************************************************
 ** \fn Fee_GetDelayRecycleOperation
 **
 ** get variable Fee_DelayRecycleOperation.
 **
 ** \return     Fee_DelayRecycleOperation
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetDelayRecycleOperation(void)
{
    return Fee_DelayRecycleOperation;
}


/**
 ******************************************************************************
 ** \fn Fee_GetDefinedThresholdPageSize
 **
 ** get variable Fee_DefinedThresholdPageSize.
 **
 ** \return     Fee_DefinedThresholdPageSize
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetDefinedThresholdPageSize(void)
{
    return Fee_DefinedThresholdPageSize;
}


/**
 ******************************************************************************
 ** \fn Fee_GetThresholdPageSize
 **
 ** get variable Fee_ThresholdPageSize/Fee_ThresholdPageSizeEx.
 **
 ** \return     Fee_ThresholdPageSize/Fee_ThresholdPageSizeEx
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetThresholdPageSize(
  VAR(uint8, AUTOMATIC) config_no)
{
    VAR(uint16, AUTOMATIC) threshold_page_size = (uint16)FEE_NULL;

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        threshold_page_size = Fee_ThresholdPageSize;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        threshold_page_size = Fee_ThresholdPageSizeEx;
        break;
#endif
    default:
        break;
    }

    return threshold_page_size;
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlockNoFromRealMaxsize
 **
 ** get variable Fee_BlockNoFromRealMaxsize/Fee_BlockNoFromRealMaxsizeEx.
 **
 ** \return     Fee_BlockNoFromRealMaxsize/Fee_BlockNoFromRealMaxsizeEx
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetBlockNoFromRealMaxsize(
  VAR(uint8, AUTOMATIC) config_no)
{
    VAR(uint16, AUTOMATIC) blockno_from_real_maxsize = (uint16)FEE_NULL;

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        blockno_from_real_maxsize = Fee_BlockNoFromRealMaxsize;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        blockno_from_real_maxsize = Fee_BlockNoFromRealMaxsizeEx;
        break;
#endif
    default:
        break;
    }

    return blockno_from_real_maxsize;
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlockRealMaxsize
 **
 ** get variable Fee_BlockRealMaxsize/Fee_BlockRealMaxsizeEx.
 **
 ** \return     Fee_BlockRealMaxsize/Fee_BlockRealMaxsizeEx
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetBlockRealMaxsize(
  VAR(uint8, AUTOMATIC) config_no)
{
    VAR(uint16, AUTOMATIC) block_real_maxsize = (uint16)FEE_NULL;
    VAR(Fee_ConfigType, AUTOMATIC) fee_cfg;                      /* fee configuration */

    fee_cfg = Fee_GetCfg();

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
           Justification: Because the value of FeeVirtualPageSize may be change in future, save this calculation. */
        /* PRQA S 2984 1 */
        block_real_maxsize = (Fee_BlockRealMaxsize + (fee_cfg.FeeVirtualPageSize - (uint16)1)) & (uint16)(~(fee_cfg.FeeVirtualPageSize - (uint16)1));
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
           Justification: Because the value of FeeVirtualPageSize may be change in future, save this calculation. */
        /* PRQA S 2984 1 */
        block_real_maxsize = (Fee_BlockRealMaxsizeEx + (fee_cfg.FeeVirtualPageSize - (uint16)1)) & (uint16)(~(fee_cfg.FeeVirtualPageSize - (uint16)1));
        break;
#endif
    default:
        break;
    }

    return block_real_maxsize;
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlockBlankCheckOff
 **
 ** get variable Fee_BlockBlankCheckOff.
 **
 ** \return     Fee_BlockBlankCheckOff
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetBlockBlankCheckOff(void)
{
    return Fee_BlockBlankCheckOff;
}


/**
 ******************************************************************************
 ** \fn Fee_GetSectorBlankCheckOff
 **
 ** get variable Fee_SectorBlankCheckOff.
 **
 ** \return     Fee_SectorBlankCheckOff
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetSectorBlankCheckOff(void)
{
    return Fee_SectorBlankCheckOff;
}


/**
 ******************************************************************************
 ** \fn Fee_GetWflashLgSectorSize
 **
 ** get variable Fee_WflashLgSectorSize.
 **
 ** \return     Fee_WflashLgSectorSize
 **
*****************************************************************************/
FUNC(uint16, FEE_CODE) Fee_GetWflashLgSectorSize(void)
{
    return Fee_WflashLgSectorSize;
}


/**
 ******************************************************************************
 ** \fn Fee_GetWorkFlashAbsoluteEndAddress
 **
 ** get variable Fee_WorkFlashAbsoluteEndAddress.
 **
 ** \return     Fee_WorkFlashAbsoluteEndAddress
 **
*****************************************************************************/
FUNC(uint32, FEE_CODE) Fee_GetWorkFlashAbsoluteEndAddress(void)
{
    return Fee_WorkFlashAbsoluteEndAddress;
}


/**
 ******************************************************************************
 ** \fn Fee_GetBlkCfgOnFlash
 **
 ** get variable Fee_BlkCfgOnFlash1 or Fee_BlkCfgOnFlash2.
 **
 ** \parameter config_no: 1 or 2
 ** \parameter index: 0 ~ BlockMaxCount-1
 ** \return     blk_cfg
 **
*****************************************************************************/
FUNC(Fee_BlockConfigType, FEE_CODE) Fee_GetBlkCfgOnFlash(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index)
{
    VAR(Fee_BlockConfigType, AUTOMATIC)  blk_cfg;

    blk_cfg.FeeBlockNumber   = (uint16)0xFFFFU;
    blk_cfg.FeeBlockSize     = (uint16)0x0000U;
    blk_cfg.FeeImmediateData = (uint8)FALSE;

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        blk_cfg = Fee_BlkCfgOnFlash1[index];
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        blk_cfg = Fee_BlkCfgOnFlash2[index];
        break;
#endif
    default:
        break;
    }

    return blk_cfg;
}


/**
 ******************************************************************************
 ** \fn Fee_SetBlkCfgOnFlash
 **
 ** set variable Fee_BlkCfgOnFlash1 or Fee_BlkCfgOnFlash2.
 **
 ** \parameter config_no: 1 or 2
 ** \parameter index: 0 ~ BlockMaxCount-1
 ** \parameter blk_cfg: block configuration information
 ** \return     none
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetBlkCfgOnFlash(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(Fee_BlockConfigType, AUTOMATIC) blk_cfg)
{
    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_BlkCfgOnFlash1[index].FeeBlockNumber   = blk_cfg.FeeBlockNumber;
        Fee_BlkCfgOnFlash1[index].FeeBlockSize     = blk_cfg.FeeBlockSize;
        Fee_BlkCfgOnFlash1[index].FeeImmediateData = blk_cfg.FeeImmediateData;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_BlkCfgOnFlash2[index].FeeBlockNumber   = blk_cfg.FeeBlockNumber;
        Fee_BlkCfgOnFlash2[index].FeeBlockSize     = blk_cfg.FeeBlockSize;
        Fee_BlkCfgOnFlash2[index].FeeImmediateData = blk_cfg.FeeImmediateData;
        break;
#endif
    default:
        break;
    }

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_InitBlkCfgOnFlash
 **
 ** initialize variable Fee_BlkCfgOnFlash1 or Fee_BlkCfgOnFlash2.
 **
 ** \parameter none
 ** \return    none
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_InitBlkCfgOnFlash(void)
{
    uint16 block_cnt;

    for(block_cnt = 0; block_cnt < FEE_BLOCK_MAX; block_cnt++)
    {
        Fee_BlkCfgOnFlash1[block_cnt].FeeBlockNumber     = Fee_BlkCfg1[block_cnt].FeeBlockNumber;
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
           Justification: Because the value of FeeVirtualPageSize may be change in future, save this calculation. */
        /* PRQA S 2984 1 */
        Fee_BlkCfgOnFlash1[block_cnt].FeeBlockSize       = (Fee_BlkCfg1[block_cnt].FeeBlockSize + (Fee_Cfg.FeeVirtualPageSize - (uint16)1)) & (uint16)(~(Fee_Cfg.FeeVirtualPageSize - (uint16)1));
        Fee_BlkCfgOnFlash1[block_cnt].FeeImmediateData   = Fee_BlkCfg1[block_cnt].FeeImmediateData;
    }

#if ( FEE_USE_CONFIG_EX == STD_ON )

    for(block_cnt = 0; block_cnt < FEE_BLOCK_MAX_EX; block_cnt++)
    {
        Fee_BlkCfgOnFlash2[block_cnt].FeeBlockNumber     = Fee_BlkCfg2[block_cnt].FeeBlockNumber;
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
           Justification: Because the value of FeeVirtualPageSize may be change in future, save this calculation. */
        /* PRQA S 2984 1 */
        Fee_BlkCfgOnFlash2[block_cnt].FeeBlockSize       = (Fee_BlkCfg2[block_cnt].FeeBlockSize + (Fee_Cfg.FeeVirtualPageSize - (uint16)1)) & (uint16)(~(Fee_Cfg.FeeVirtualPageSize - (uint16)1));
        Fee_BlkCfgOnFlash2[block_cnt].FeeImmediateData   = Fee_BlkCfg2[block_cnt].FeeImmediateData;
    }
#endif

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_FlsDedErrorNotification
 **
 ** When 2 bit ECC error occurs, this function will be called.
 **
 ** This function needs to be linked to DedErrorNotifFctPtr of Fls_Config_N in Fls_PBcfg.c.
 **
 ** \parameter none
 ** \return    none
 **
*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: It is called in FLS notification. */
/* PRQA S 1503 1 */
FUNC(void, FEE_CODE) Fee_FlsDedErrorNotification(void)
{
    Fee_FlsDedErrorNotificationVar = STD_ON;
    return;
}


/**
 ******************************************************************************
 ** \fn Fee_FlsSedErrorNotification
 **
 ** When 1 bit ECC error occurs, this function will be called.
 **
 ** This function needs to be linked to SedErrorNotifFctPtr of Fls_Config_N in Fls_PBcfg.c.
 **
 ** \parameter none
 ** \return    none
 **
*****************************************************************************/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1
   Justification: It is called in FLS notification. */
/* PRQA S 1503 1 */
FUNC(void, FEE_CODE) Fee_FlsSedErrorNotification(void)
{
    Fee_FlsSedErrorNotificationVar = STD_ON;
    return;
}


/**
 ******************************************************************************
 ** \fn Fee_GetFlsDedErrorNotificationVar
 **
 ** Get variable Fee_FlsDedErrorNotificationVar.
 **
 ** \parameter none
 ** \return    Fee_FlsDedErrorNotificationVar
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetFlsDedErrorNotificationVar(void)
{
    return Fee_FlsDedErrorNotificationVar;
}


/**
 ******************************************************************************
 ** \fn Fee_GetFlsSedErrorNotificationVar
 **
 ** Get variable Fee_FlsSedErrorNotificationVar.
 **
 ** \parameter none
 ** \return    Fee_GetFlsSedErrorNotificationVar
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetFlsSedErrorNotificationVar(void)
{
    return Fee_FlsSedErrorNotificationVar;
}


/**
 ******************************************************************************
 ** \fn Fee_SetFlsDedErrorNotificationVar
 **
 ** Set variable Fee_FlsDedErrorNotificationVar.
 **
 ** \parameter STD_ON, STD_OFF
 ** \return    none
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetFlsDedErrorNotificationVar(
  VAR(uint8, AUTOMATIC) ded_value)
{
    Fee_FlsDedErrorNotificationVar = ded_value;
    return;
}


/**
 ******************************************************************************
 ** \fn Fee_SetFlsSedErrorNotificationVar
 **
 ** Set variable Fee_FlsSedErrorNotificationVar.
 **
 ** \parameter STD_ON, STD_OFF
 ** \return    none
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetFlsSedErrorNotificationVar(
  VAR(uint8, AUTOMATIC) sed_value)
{
    Fee_FlsSedErrorNotificationVar = sed_value;
    return;
}


/**
 ******************************************************************************
 ** \fn Fee_GetInitiallyEraseEmptySectors
 **
 ** get variable Fee_InitiallyEraseEmptySectors.
 **
 ** \return     Fee_InitiallyEraseEmptySectors
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetInitiallyEraseEmptySectors(void)
{
    return Fee_InitiallyEraseEmptySectors;
}


/**
 ******************************************************************************
 ** \fn Fee_SetIsNextBlockCorrupt
 **
 ** set variable Fee_IsNextBlockCorrupt1 or Fee_IsNextBlockCorrupt2.
 **
 ** \param config_no [in] - number of configuration.
 ** \param index [in]     - index of array element.
 ** \param value [in]     - value of array element.
 **
*****************************************************************************/
FUNC(void, FEE_CODE) Fee_SetIsNextBlockCorrupt(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index,
  VAR(uint8, AUTOMATIC) value)
{
    switch(config_no)
    {
    case 1U:  /* configuration1 */
        Fee_IsNextBlockCorrupt1[index] = value;
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        Fee_IsNextBlockCorrupt2[index] = value;
        break;
#endif
    default:
        break;
    }

    return;
}


/**
 ******************************************************************************
 ** \fn Fee_GetIsNextBlockCorrupt
 **
 ** get variable Fee_IsNextBlockCorrupt1 or Fee_IsNextBlockCorrupt2.
 **
 ** \param config_no [in] - number of configuration.
 **
 ** \return     Fee_IsNextBlockCorrupt
 **
*****************************************************************************/
FUNC(uint8, FEE_CODE) Fee_GetIsNextBlockCorrupt(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint16, AUTOMATIC) index)
{
    VAR(uint8, AUTOMATIC)  retval = (uint8)0; /* FEE_NEXT_BLOCK_IS_NOT_CORRUPT */

    switch(config_no)
    {
    case 1U:  /* configuration1 */
        retval = Fee_IsNextBlockCorrupt1[index];
        break;
#if ( FEE_USE_CONFIG_EX == STD_ON )
    case 2U:  /* configuration2 */
        retval = Fee_IsNextBlockCorrupt2[index];
        break;
#endif
    default:
        break;
    }

    return retval;
}


#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

