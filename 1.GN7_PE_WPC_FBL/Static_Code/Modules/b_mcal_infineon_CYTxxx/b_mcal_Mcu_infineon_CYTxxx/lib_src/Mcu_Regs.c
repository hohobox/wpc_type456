/** \brief AUTOSAR Mcu Driver
 **
 ** This file contains the implementation of the AUTOSAR module MCU functions 
 ** for accessing hardware registers.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Mcu_Regs.h>      /* hardware dependent declarations. */

/*==================[macros]=================================================*/

#define MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN                     0x80000000U
#define MCU_REG_MASK_SRSS_CLK_ECO_PRESCALE_ECO_DIV_ENABLED          0x00000001U
#define MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_ENABLE             0x10000000U
#define MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_DISABLE            0x08000000U
#define MCU_REG_MASK_CPUSS_RAM2_PWR_CTL_VECTKEYSTAT                 0xFFFF0000U
#define MCU_REG_MASK_CPUSS_RAM1_PWR_CTL_VECTKEYSTAT                 0xFFFF0000U
#define MCU_REG_MASK_CPUSS_RAM0_PWR_MACRO_CTL_VECTKEYSTAT           0xFFFF0000U
#define MCU_REG_MASK_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT             0xFFFF0000U
#define MCU_REG_VALUE_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT            0x05FA0000U
#define MCU_REG_MASK_CPUSS_RAM0_STATUS_WB_EMPTY                     0x00000001U
#define MCU_REG_MASK_CPUSS_RAM1_STATUS_WB_EMPTY                     0x00000001U
#define MCU_REG_MASK_CPUSS_RAM2_STATUS_WB_EMPTY                     0x00000001U
#define	MCU_REG_MASK_CPUSS_RAM0_CTL_ECC_EN                          0x00010000U
#define	MCU_REG_MASK_CPUSS_RAM1_CTL_ECC_EN                          0x00010000U
#define	MCU_REG_MASK_CPUSS_RAM2_CTL_ECC_EN                          0x00010000U
#define MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_DEEPSLEEP             3U
#define MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_SLEEP                 2U
#define MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_ACTIVE                1U
#define MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_RESET                 0U
#define MCU_REG_MASK_SRSS_PWR_CTL_POWER_MODE                        0x00000003U
#define MCU_REG_MASK_SRSS_PWR_CTL_LPM_READY                         0x00000020U
#define MCU_REG_MASK_SRSS_PWR_CTL_LINREG_DIS                        0x00000001U
#define MCU_REG_MASK_SRSS_PWR_CTL_LINREG_OK                         0x00000002U
#define MCU_REG_MASK_SRSS_PWR_CTL_REFVBUF_DIS                       0x00100000U
#define MCU_REG_MASK_SRSS_PWR_CTL_REFVBUF_OK                        0x00200000U
#define MCU_REG_MASK_SRSS_PWR_CTL_REFI_DIS                          0x01000000U
#define MCU_REG_MASK_SRSS_PWR_CTL_REFI_OK                           0x02000000U
#define MCU_REG_MASK_SRSS_PWR_CTL_BGREF_LPMODE                      0x10000000U
#define MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_HT                      0x0007DF00U
#define MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_EN_HT                   0x00008000U
#define MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_DPSLP_EN_HT             0x00004000U
#define MCU_REG_VALUE_SRSS_PWR_HIBERNATE_TOKEN_VALID                0x000000FFU
#define MCU_REG_VALUE_SSRS_PWR_HIBERNATE_UNLOCK                     0x00003A00U
#define MCU_REG_MASK_SSRS_PWR_HIBERNATE_FREEZE                      0x00020000U
#define MCU_REG_MASK_SSRS_PWR_HIBERNATE_HIBERNATE                   0x80000000U
#define MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL_NONE                     0x00000000U
#define MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL2_NONE                    0x00000000U
#define MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CAUSE_ALL                    0xE0FFFFFFU
#define MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_VSEL                  0x00000010U
#define MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_ACTION                0x000000C0U
#define MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_ENABLE                0x00000100U
#define MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_VSEL                  0x00100000U
#define MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_ACTION                0x00C00000U
#define MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_ENABLE                0x01000000U
#define MCU_REG_MASK_SRSS_INTR_BIT0                                 0x00000001U
#define MCU_REG_MASK_SRSS_INTR_MASK_BIT0                            0x00000001U
#define MCU_REG_MASK_CPUSS_MAINCORE_STATUS_SLEEPDEEP                0x00000002U
#define MCU_REG_MASK_CPUSS_MAINCORE_STATUS_SLEEPING                 0x00000001U
#define MCU_REG_MASK_CPUSS_CM0_STATUS_SLEEPDEEP                     0x00000002U
#define MCU_REG_MASK_CPUSS_CM0_STATUS_SLEEPING                      0x00000001U
#define MCU_REG_MASK_PERI_DIV_24_5_CTL_FRAC5_DIV                    0x000000F8U
#define MCU_REG_MASK_PERI_DIV_24_5_CTL_EN                           0x00000001U
#define MCU_REG_BIT_PERI_DIV_24_5_CTL_INT24_DIV                     8U
#define MCU_REG_BIT_PERI_DIV_24_5_CTL_FRAC5_DIV                     3U
#define MCU_REG_MASK_PERI_DIV_16_5_CTL_FRAC5_DIV                    0x000000F8U
#define MCU_REG_MASK_PERI_DIV_16_5_CTL_EN                           0x00000001U
#define MCU_REG_BIT_PERI_DIV_16_5_CTL_INT16_DIV                     8U
#define MCU_REG_BIT_PERI_DIV_16_5_CTL_FRAC5_DIV                     3U
#define MCU_REG_MASK_PERI_DIV_16_CTL_EN                             0x00000001U
#define MCU_REG_BIT_PERI_DIV_16_CTL_INT16_DIV                       8U
#define MCU_REG_MASK_PERI_DIV_8_CTL_EN                              0x00000001U
#define MCU_REG_BIT_PERI_DIV_8_CTL_INT8_DIV                         8U
#define MCU_REG_VALUE_PERI_DIV_CMD_ENABLE                           0x80000000U
#define MCU_REG_VALUE_PERI_DIV_CMD_DISABLE                          0x40000000U
#define MCU_REG_MASK_PERI_DIV_CMD_PA_TYPE_SEL                       0x03000000U
#define MCU_REG_MASK_PERI_DIV_CMD_TYPE_SEL                          0x00000300U
#define MCU_REG_MASK_PERI_DIV_CTL_EN                                0x00000001U
#define MCU_REG_BIT_PERI_DIV_CMD_ENABLE                             31U
#define MCU_REG_BIT_PERI_DIV_CMD_PA_TYPE_SEL                        24U
#define MCU_REG_BIT_PERI_DIV_CMD_PA_DIV_SEL                         16U
#define MCU_REG_BIT_PERI_DIV_CMD_TYPE_SEL                           8U
#define MCU_REG_MASK_SRSS_BACKUP_STATUS_WCO_OK                      0x00000004U
#define MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN                         0x00000008U
#define MCU_REG_MASK_SRSS_BACKUP_RTC_RW_READ                        0x00000001U
#define MCU_REG_MASK_SRSS_BACKUP_RTC_RW_WRITE                       0x00000002U
#define MCU_REG_MASK_SRSS_CLK_ECO_STATUS_ECO_OK                     0x00000001U
#define MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE                0x80000000U
#define MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE                    0x00008000U
#define MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_DIV                       0x00007000U
#define MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_SEL                       0x00000F00U
#define MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL                      0x00000007U
#define MCU_REG_MASK_SRSS_CLK_PLL_STATUS_LOCKED                     0x00000001U
#define MCU_REG_VALUE_SRSS_CLK_PLL_CONFIG_BYPASS_SEL_PLL_OUT        0x30000000U
#define MCU_REG_VALUE_SRSS_CLK_PLL_CONFIG_BYPASS_SEL_PLL_REF        0x20000000U
#define MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE                     0x80000000U
#define MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_BYPASS_SEL                 0x30000000U
#define MCU_REG_MASK_SRSS_CLK_FLL_STATUS_CCO_READY                  0x00000004U
#define MCU_REG_MASK_SRSS_CLK_FLL_STATUS_LOCKED                     0x00000001U
#define MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_ENABLE                0x80000000U
#define MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_FREQ                  0x01FF0000U
#define MCU_REG_VALUE_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL_FLL_OUT       0x30000000U
#define MCU_REG_VALUE_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL_FLL_REF       0x20000000U
#define MCU_REG_MASK_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL                0x30000000U
#define MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE                 0x80000000U
#define MCU_REG_VALUE_SYSTEM_CM0_SCS_CPUID                          0x0000C600U
#define MCU_REG_VALUE_SYSTEM_CM4_SCS_CPUID                          0x0000C240U
#define MCU_REG_VALUE_SYSTEM_CM7_SCS_CPUID                          0x0000C270U
#define MCU_REG_MASK_SYSTEM_SCS_CPUID_PARTNO                        0x0000FFF0U
#define MCU_REG_VALUE_SYSTEM_CM4_SCS_AIRCR_VECTKEY                  0x05FA0000U
#define MCU_REG_MASK_SYSTEM_CM4_SCS_AIRCR_SYSRESETREQ               0x00000004U
#define MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_DC                          0x00010000U
#define MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_IC                          0x00020000U
#define MCU_REG_VALUE_SYSTEM_CM7_SCS_CCR_DIS_ALL                    0x00000000U
#define MCU_REG_VALUE_SYSTEM_CM7_SCS_CSSELR_DC                      0x00000000U
#define MCU_REG_MASK_SYSTEM_CM7_SCS_CCSIDR_ASSOCIATIVITY            0x00001FF8U
#define MCU_REG_BIT_SYSTEM_CM7_SCS_CCSIDR_ASSOCIATIVITY             3U
#define MCU_REG_MASK_SYSTEM_CM7_SCS_CCSIDR_NUMSETS                  0x0FFFE000U
#define MCU_REG_BIT_SYSTEM_CM7_SCS_CCSIDR_NUMSETS                   13U
#define MCU_REG_BIT_SYSTEM_CM7_SCS_DCSW_WAY                         30U
#define MCU_REG_BIT_SYSTEM_CM7_SCS_DCSW_SET                         5U
#define MCU_REG_VALUE_SYSTEM_CM7_SCS_ICIALLU_INVALIDATE             0x00000000U
#define MCU_REG_VALUE_SRSS_RES_CAUSE2_CLEAR_ALL                     0x0001FFFFU
#define MCU_REG_VALUE_SRSS_RES_CAUSE2_ALL0                          0x00000000U
#define MCU_REG_VALUE_SRSS_RES_CAUSE_CLEAR_ALL                      0x77FF01FFU
#define MCU_REG_VALUE_SRSS_RES_CAUSE_ALL0                           0x00000000U
#define MCU_REG_MASK_SRSS_RES_CAUSE                                 0x77FF01FFU
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_WDT                       0x00000001U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_ACT_FAULT                 0x00000002U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_DPSLP_FAULT               0x00000004U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_TC_DBGRESET               0x00000008U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_SOFT                      0x00000010U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT0                    0x00000020U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT1                    0x00000040U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT2                    0x00000080U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT3                    0x00000100U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_XRES                      0x00010000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVDDD                   0x00020000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVDDA                   0x00040000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVCCD                   0x00080000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVDDD                   0x00100000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVDDA                   0x00200000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVCCD                   0x00400000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_ACT_LINREG            0x00800000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_DPSLP_LINREG          0x01000000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_REGHC                 0x02000000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_PMIC                      0x04000000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_PXRES                     0x10000000U
#define MCU_REG_MASK_SRSS_RES_CAUSE_RESET_STRUCT_XRES               0x20000000U
#define	MCU_REG_MASK_SRSS_RES_CAUSE2                                0x0001FFFFU
#define MCU_REG_MASK_SRSS_RES_CAUSE2_RESET_CSV_HF                   0x0000FFFFU
#define MCU_REG_VALUE_PERI_TIMEOUT_CTL_DEFAULT                      0x0000FFFFU
#define MCU_DIV_8                                                   0x00U
#define MCU_DIV_16                                                  0x01U
#define MCU_DIV_16_5                                                0x02U
#define MCU_DIV_24_5                                                0x03U
#define MCU_REG_MASK_SRSS_CSV_HF_REF_CTL_CSV_EN                     0x80000000U
#define MCU_REG_MASK_SRSS_CSV_REF_REF_CTL_CSV_EN                    0x80000000U
#define MCU_REG_MASK_SRSS_CSV_LF_REF_CTL_CSV_EN                     0x80000000U
#define MCU_REG_MASK_SRSS_CSV_ILO_REF_CTL_CSV_EN                    0x80000000U
#define MCU_REG_MASK_BACKUP_CSV_BAK_REF_CTL_CSV_EN                  0x80000000U
#define MCU_REG_MASK_SRSS_CLK_OUTPUT_FAST_FAST_SEL0                 0x0000000FU
#define MCU_REG_MASK_SRSS_CLK_OUTPUT_FAST_FAST_SEL1                 0x000F0000U
#define MCU_REG_MASK_SRSS_CLK_OUTPUT_SLOW_SLOW_SEL0                 0x0000000FU
#define MCU_REG_MASK_SRSS_CLK_OUTPUT_SLOW_SLOW_SEL1                 0x000000F0U
#define MCU_REG_MASK_SRSS_TST_DDFT_SLOW_CTL_ENABLE0                 0x40000000U
#define MCU_REG_MASK_SRSS_TST_DDFT_SLOW_CTL_ENABLE1                 0x80000000U
#define MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN                     0x80000000U
#define MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE                    0x80000000U
#define MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE                    0x80000000U
#define MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_AGC_EN                     0x00000002U
#define MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS                          0x00000003U
#define MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS                          0x00000300U
#define MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS                         0x00000003U
#define MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS                         0x00000300U
#define MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS                         0x00000003U
#define MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS                         0x00000300U
#define MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS                         0x00000003U
#define MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS                         0x00000300U
#define MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS                       0x0000000FU
#define MCU_REG_MASK_CPUSS_SLOW_CLOCK_CTL_INT_DIV                   0x0000FF00U
#define MCU_REG_MASK_CPUSS_PERI_CLOCK_CTL_INT_DIV                   0xFF000000U
#define MCU_REG_MASK_PERIGROUP_CLOCK_CTL_INT8_DIV                   0x0000FF00U
#define MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_MUX                  0x0000000FU
#define MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV                  0x00000030U
#define MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ENABLE                    0x80000000U
#define MCU_REG_VALUE_SRSS_CLK_ROOT_SELECT_ROOT_MUX_PATH0           0x00000000U
#define MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN                 0x80000000U
#define MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_AMPDET_EN          0x40000000U
#define MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_DIV_ENABLE         0x10000000U
#define MCU_REG_MASK_SRSS_BACKUP_LPECO_PRESCALE_LPECO_DIV_ENABLED   0x00000001U
#define MCU_REG_MASK_SRSS_BACKUP_LPECO_STATUS_LPECO_READY           0x00000002U
#define MCU_REG_MASK_SRSS_BACKUP_LPECO_STATUS_LPECO_AMPDET_OK       0x00000001U
#define MCU_REG_MASK_SRSS_PLL400_STRUCT_STATUS_LOCKED               0x00000001U
#define MCU_REG_VALUE_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL_PLL_OUT  0x30000000U
#define MCU_REG_VALUE_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL_PLL_REF  0x20000000U
#define MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE               0x80000000U
#define MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL           0x30000000U
#define MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_FEEDBACK_DIV         0x000000FFU
#define MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG2_FRAC_DIV            0x00FFFFFFU
#define MCU_REG_VALUE_SRSS_WDT_LOCK_CLR0                            0x00000001U
#define MCU_REG_VALUE_SRSS_WDT_LOCK_CLR1                            0x00000002U
#define MCU_REG_VALUE_SRSS_WDT_LOCK_SET01                           0x00000003U
#define MCU_REG_MASK_SRSS_WDT_LOCK_WDT_LOCK                         0x00000003U
#define MCU_REG_VALUE_SRSS_WDT_LOCK_UNLOCKED                        0x00000000U
#define MCU_REG_MASK_DW_CTL_ENABLED                                 0x80000000U
#define MCU_REG_MASK_DW_CTL_ENABLED_CLEARED                         0x00000000U
#define MCU_REG_MASK_DMAC_CTL_ENABLED                               0x80000000U
#define MCU_REG_MASK_DMAC_CTL_ENABLED_CLEARED                       0x00000000U


/*==================[type definitions]=======================================*/
/*==================[external function declarations]=========================*/
/*==================[internal function declarations]=========================*/
#define MCU_START_SEC_CODE_ASIL_B
#include <Mcu_MemMap.h>

/** \brief Mcu_ClockShutdown_RootSelect_Regs
 **
 ** This function shutdowns Root Select registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE )
Mcu_ClockShutdown_RootSelect_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_ClockShutdown_ClockSelect_Regs
 **
 ** This function shutdowns Clock Select registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE )
Mcu_ClockShutdown_ClockSelect_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_ClockShutdown_TimerClock_Regs
 **
 ** This function shutdowns Timer control registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE )
Mcu_ClockShutdown_TimerClock_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_GetEachPllLockStatus_Regs
 **
 ** This function gets each Pll lock status from CLK_PLL_STATUS register.
 **
 ** \param[in]  PllConfigPtr    The pointer to PLL configuration.
 */
static FUNC(  Mcu_ReturnType, MCU_CODE ) 
Mcu_GetEachPllLockStatus_Regs(
  P2CONST( Mcu_PllConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PllConfigPtr
);


/** \brief Mcu_GetEachSscgLockStatus_Regs
 **
 ** This function gets each SSCG lock status from PLL400_STRUCT.STATUS register.
 **
 ** \param[in]  SscgConfigPtr   The pointer to SSCG configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_GetEachSscgLockStatus_Regs(
  P2CONST( Mcu_SscgConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SscgConfigPtr
);


/** \brief Mcu_UnlockWatchdog_Regs
 **
 ** This function unlocks WDT by accessing WDT_LOCK register.
 **
 */
static FUNC( uint32, MCU_CODE ) 
Mcu_UnlockWatchdog_Regs( void );


/** \brief Mcu_LockWatchdog_Regs
 **
 ** This function restores the WDT_LOCK register to the state before unlocking.
 ** \param[in]  WdtlockRegVal The value of WDT_LOCK register when Mcu_UnlockWatchdog_Regs is called.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_LockWatchdog_Regs(
  VAR( uint32, AUTOMATIC ) WdtlockRegVal
);


/** \brief Mcu_IsUnlockWatchdog_Regs
 **
 ** This function check WDT lock status of WDT_LOCK register.
 **
 ** \retval  TRUE      WDT_LOCK register is unclok status.
 ** \retval  FALSE     WDT_LOCK register is not unclok status.
 **
 */
static FUNC(  boolean, MCU_CODE ) 
Mcu_IsUnlockWatchdog_Regs( void );


/** \brief Mcu_SetROMWaitCycle_Regs
 **
 ** This function sets ROM wait status of CPUSS with configuration.
 **
 ** \param[in] RomCtlRegVal    The value to set FAST_WS and SLOW_WS bit of ROM_CTL register.
 ** \param[in] SetFlag         The flag indicating whether the divider to up or down.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetROMWaitCycle_Regs(
   VAR( uint32, AUTOMATIC ) RomCtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
);


/** \brief Mcu_SetRAM0WaitCycle_Regs
 **
 ** This function sets RAM0 wait status of CPUSS with configuration.
 **
 ** \param[in] Ram0CtlRegVal    The value to set FAST_WS and SLOW_WS bit of RAM0_CTL register.
 ** \param[in] SetFlag          The flag indicating whether the divider to up or down.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetRAM0WaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) Ram0CtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
);


/** \brief Mcu_SetRAM1WaitCycle_Regs
 **
 ** This function sets RAM1 wait status of CPUSS with configuration.
 **
 ** \param[in] Ram1CtlRegVal    The value to set FAST_WS and SLOW_WS bit of RAM1_CTL register.
 ** \param[in] SetFlag          The flag indicating whether the divider to up or down.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetRAM1WaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) Ram1CtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
);


/** \brief Mcu_SetRAM2WaitCycle_Regs
 **
 ** This function sets RAM2 wait status of CPUSS with configuration.
 **
 ** \param[in] Ram2CtlRegVal    The value to set FAST_WS and SLOW_WS bit of RAM2_CTL register.
 ** \param[in] SetFlag          The flag indicating whether the divider to up or down.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetRAM2WaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) Ram2CtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
);


/** \brief Mcu_SetFLASHWaitCycle_Regs
 **
 ** This function sets MAIN wait status of FLASHC with configuration.
 **
 ** \param[in] FlashCtlRegVal    The value to set MAIN_WS bit of FLASH_CTL register.
 ** \param[in] SetFlag           The flag indicating whether the divider to up or down.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetFLASHWaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) FlashCtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
);


/** \brief Mcu_InvalidateCache_Regs
 **
 ** This function invalidates I-cache and D-cache.
 */
static FUNC( void, MCU_CODE ) 
Mcu_InvalidateCache_Regs( void );


/** \brief Mcu_CleanCache_Regs
 **
 ** This function cleans D-cache.
 */
static FUNC( void, MCU_CODE ) 
Mcu_CleanCache_Regs( void );


/** \brief Mcu_SetClockDiv_Regs
 **
 ** This function sets clock control register to configuration value.
 ** 
 ** \param[in]  McuClockAddrPtr  The address pointer to clock register.
 ** \param[in]  McuConfigValue   The configuration value to set.
 ** \param[in]  SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetClockDiv_Regs(
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) McuClockAddrPtr,
  VAR( uint32,  AUTOMATIC )  McuConfigValue,
  VAR( boolean, AUTOMATIC )  SetFlag
);


/** \brief Mcu_SetClockDivMask_Regs
 **
 ** This function sets clock control register to configuration value with bit mask.
 ** 
 ** \param[in]  McuClockAddrPtr  The address pointer to clock register.
 ** \param[in]  McuConfigValue   The configuration value to set.
 ** \param[in]  McuRegMask       The mask value of the clock control register.
 ** \param[in]  SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetClockDivMask_Regs(
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) McuClockAddrPtr,
  VAR( uint32,  AUTOMATIC )  McuConfigValue,
  VAR( uint32,  AUTOMATIC )  McuRegMask,
  VAR( boolean, AUTOMATIC )  SetFlag
);


/** \brief Mcu_EcoClkStabWait_Regs
 **
 ** This function waits stabilization of ECO clock.
 ** If the ECO clock is not stable during EcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] EcoStabilizationCnt         The count value of Eco clock stabilization.
 ** \param[in] ClockFlags                  ECO clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  ECO clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_EcoClkStabWait_Regs(
  VAR( uint32, AUTOMATIC ) EcoStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
);


/** \brief Mcu_EcoPrescaleStabWait_Regs
 **
 ** This function waits stabilization of ECO Prescale clock.
 ** If the ECO Prescale clock is not stable during EcoPrescaleStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] EcoPrescaleStabilizationCnt The count value of Eco Prescale clock stabilization.
 ** \param[in] ClockFlags                  ECO Prescale clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  ECO Prescale clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_EcoPrescaleStabWait_Regs(
  VAR( uint32, AUTOMATIC ) EcoPrescaleStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
);


/** \brief Mcu_LpEcoClkStabWait_Regs
 **
 ** This function waits stabilization of LPECO clock.
 ** If the LPECO clock is not stable during LpEcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] LpEcoStabilizationCnt         The count value of LPECO clock stabilization.
 ** \param[in] ClockFlags                    LPECO clock setting flag.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_LpEcoClkStabWait_Regs(
  VAR( uint32, AUTOMATIC ) LpEcoStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
);


/** \brief Mcu_LpEcoPrescaleStabWait_Regs
 **
 ** This function waits stabilization of LPECO Prescale clock.
 ** If the LPECO Prescale clock is not stable during LpEcoPrescaleStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] LpEcoPrescaleStabilizationCnt The count value of LPECO Prescale clock stabilization.
 ** \param[in] ClockFlags                    LPECO Prescale clock setting flag.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_LpEcoPrescaleStabWait_Regs(
  VAR( uint32, AUTOMATIC ) LpEcoPrescaleStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
);


/** \brief Mcu_WcoClkStabWait_Regs
 **
 ** This function waits stabilization of WCO clock.
 ** If the WCO clock is not stable during WcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] WcoStabilizationCnt         The count value of Wco clock stabilization.
 ** \param[in] ClockFlags                  WCO clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  WCO clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WcoClkStabWait_Regs(
  VAR( uint32, AUTOMATIC ) WcoStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
);



/** \brief Mcu_PowerCtrlEnableWait_Regs
 **
 ** This function waits and returns the specified function status.
 **
 ** \param[in]  EnableToCnt    The counter value for waiting.
 ** \param[in]  PwrCtlRegMask  The mask of which bit to be waiting for.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_PowerCtrlEnableWait_Regs(
  VAR( uint32, AUTOMATIC ) EnableToCnt,
  VAR( uint32, AUTOMATIC ) PwrCtlRegMask
);


/** \brief Mcu_CheckMode_SrssPwrCtl_Regs
 **
 ** This function checks mode settings with SRSS power control HW registers.
 **
 ** \param[in]  McuSysResConfigPtr    The pointer to mode system common resource configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssPwrCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSysResConfigPtr
);


/** \brief Mcu_CheckMode_SrssHvLvd_Regs
 **
 ** This function checks mode settings with SRSS HV low voltage detection HW registers.
 **
 ** \param[in]  McuHvLvdConfigPtr     The pointer to HV low voltage detection mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssHvLvd_Regs(
  P2CONST( Mcu_HvLvdConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuHvLvdConfigPtr
);


/** \brief Mcu_CheckMode_SrssSsvCtl_Regs
 **
 ** This function checks mode settings with SRSS supply supervision control HW registers.
 **
 ** \param[in]  McuSysResConfigPtr    The pointer to mode system common resource configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssSsvCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSysResConfigPtr
);


/** \brief Mcu_CheckMode_CpussDmaCtl_Regs
 **
 ** This function checks mode settings with CPUSS DMA control HW registers.
 **
 ** \param[in]  McuDmaConfigPtr  The pointer to DMA configuration.
 **
 ** \retval  MCU_OK         DMA control mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     DMA control mode settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussDmaCtl_Regs(
  P2CONST( Mcu_DmaConfigDataType, AUTOMATIC, MCU_APPL_CONST ) McuDmaConfigPtr
);


/** \brief Mcu_CheckMode_CpussRamPwr_Regs
 **
 ** This function checks mode settings with CPUSS RAM power HW registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussRamPwr_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_CheckMode_CpussRam0Pwr_Regs
 **
 ** This function checks clock settings with CPUSS RAM0 power macro HW registers.
 **
 ** \param[in]  McuRam0PwrMacroConfigNum  The number of RAM0 power macro mode configuration.
 ** \param[in]  McuRam0PwrMacroConfigPtr  The pointer to RAM0 power macro mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussRam0Pwr_Regs(
  VAR( uint32, AUTOMATIC ) McuRam0PwrMacroConfigNum,
  P2CONST( Mcu_Ram0PwrMacroConfigType, MCU_CONST, MCU_APPL_CONST ) McuRam0PwrMacroConfigPtr
);


/** \brief Mcu_CheckClock_SrssClkOut_Regs
 **
 ** This function checks clock settings with SRSS clock output HW registers.
 **
 ** \param[in]  McuClockOutputConfigPtr  The pointer to clock output clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkOut_Regs(
  P2CONST( Mcu_ClockOutputConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuClockOutputConfigPtr
);


/** \brief Mcu_CheckClock_SrssDsi_Regs
 **
 ** This function checks clock settings with SRSS DSI HW registers.
 **
 ** \param[in]  McuDsiConfigNum        The number of DSI clock configuration.
 ** \param[in]  McuDsiConfigPtr        The pointer to DSI clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssDsi_Regs(
  VAR( uint32, AUTOMATIC ) McuDsiConfigNum,
  P2CONST( Mcu_DsiConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuDsiConfigPtr
);


/** \brief Mcu_CheckClock_SrssClkPath_Regs
 **
 ** This function checks clock settings with SRSS clock path HW registers.
 **
 ** \param[in]  McuClockPathConfigNum  The number of clock path clock configuration.
 ** \param[in]  McuClockPathConfigPtr  The pointer to clock path clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkPath_Regs(
  VAR( uint32, AUTOMATIC ) McuClockPathConfigNum,
  P2CONST( Mcu_ClockPathConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuClockPathConfigPtr
);


/** \brief Mcu_CheckClock_SrssClkRoot_Regs
 **
 ** This function checks clock settings with SRSS clock root HW registers.
 **
 ** \param[in]  McuClockRootConfigNum  The number of clock root clock configuration.
 ** \param[in]  McuClockRootConfigPtr  The pointer to clock root clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkRoot_Regs(
  VAR( uint32, AUTOMATIC ) McuClockRootConfigNum,
  P2CONST( Mcu_ClockRootConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuClockRootConfigPtr
);


/** \brief Mcu_CheckClock_SrssClkTimer_Regs
 **
 ** This function checks clock settings with SRSS timer clock HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkTimer_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_SrssClkPump_Regs
 **
 ** This function checks clock settings with SRSS pump clock HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkPump_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_SrssOsc_Regs
 **
 ** This function checks clock settings with each SRSS oscillator HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssOsc_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_SrssIlo_Regs
 **
 ** This function checks clock settings with each SRSS ILO HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssIlo_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_SrssIlo1_Regs
 **
 ** This function checks clock settings with each SRSS ILO1 HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssIlo1_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_SrssEco_Regs
 **
 ** This function checks clock settings with each SRSS ECO HW register.
 **
 ** \param[in]  McuEcoConfigPtr        The pointer to ECO configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssEco_Regs(
  P2CONST( Mcu_EcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuEcoConfigPtr
);


/** \brief Mcu_CheckClock_SrssEcoPrescale_Regs
 **
 ** This function checks clock settings with each SRSS ECO prescale HW register.
 **
 ** \param[in]  McuEcoConfigPtr        The pointer to ECO configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssEcoPrescale_Regs(
  P2CONST( Mcu_EcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuEcoConfigPtr
);


/** \brief Mcu_CheckClock_SrssLpEco_Regs
 **
 ** This function checks clock settings with each SRSS BACKUP LPECO HW register.
 **
 ** \param[in]  McuLpEcoConfigPtr      The pointer to LPECO configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssLpEco_Regs(
  P2CONST( Mcu_LpEcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuLpEcoConfigPtr
);


/** \brief Mcu_CheckClock_SrssLpEcoPrescale_Regs
 **
 ** This function checks clock settings with each SRSS BACKUP LPECO prescale HW register.
 **
 ** \param[in]  McuLpEcoConfigPtr      The pointer to LPECO configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssLpEcoPrescale_Regs(
  P2CONST( Mcu_LpEcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuLpEcoConfigPtr
);


/** \brief Mcu_CheckClock_SrssFll_Regs
 **
 ** This function checks clock settings with SRSS FLL HW registers.
 **
 ** \param[in]  McuFllConfigPtr        The pointer to FLL clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssFll_Regs(
  P2CONST( Mcu_FllConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuFllConfigPtr
);


/** \brief Mcu_CheckClock_SrssPll_Regs
 **
 ** This function checks clock settings with SRSS PLL HW registers.
 **
 ** \param[in]  McuPllConfigNum        The number of PLL clock configuration.
 ** \param[in]  McuPllConfigPtr        The pointer to PLL clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssPll_Regs(
  VAR( uint32, AUTOMATIC ) McuPllConfigNum,
  P2CONST( Mcu_PllConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuPllConfigPtr
);


/** \brief Mcu_CheckClock_SrssSscg_Regs
 **
 ** This function checks clock settings with SRSS SSCG HW registers.
 **
 ** \param[in]  McuSscgConfigNum       The number of SSCG clock configuration.
 ** \param[in]  McuSscgConfigPtr       The pointer to SSCG clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssSscg_Regs(
  VAR( uint32, AUTOMATIC ) McuSscgConfigNum,
  P2CONST( Mcu_SscgConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSscgConfigPtr
);


/** \brief Mcu_CheckClock_SrssCsv_Regs
 **
 ** This function checks clock settings with each SRSS clock supervisor HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssCsv_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_SrssHfCsv_Regs
 **
 ** This function checks clock settings with SRSS HF clock supervisor HW registers.
 **
 ** \param[in]  McuHfCsvConfigNum      The number of HF clock supervisor clock configuration.
 ** \param[in]  McuHfCsvConfigPtr      The pointer to HF clock supervisor clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssHfCsv_Regs(
  VAR( uint32, AUTOMATIC ) McuHfCsvConfigNum,
  P2CONST( Mcu_HfCsvConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuHfCsvConfigPtr
);


/** \brief Mcu_CheckClock_SrssRefCsv_Regs
 **
 ** This function checks clock settings with each SRSS clock supervisor HW register.
 **
 ** \param[in]  McuCsvConfigPtr        The pointer to clock supervisor clock configuration.
 ** \param[in]  McuCsvRegPtr           The pointer to clock supervisor register.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssRefCsv_Regs(
  P2CONST( Mcu_CsvConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuCsvConfigPtr,
  P2CONST( volatile Mcu_ClkCsvRegType, MCU_CONST, REGSPACE ) McuCsvRegPtr
);


/** \brief Mcu_CheckClock_SrssBackup_Regs
 **
 ** This function checks clock settings with SRSS backup HW registers.
 **
 ** \param[in]  McuBackupConfigPtr     The pointer to backup clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssBackup_Regs(
  P2CONST( Mcu_BackupConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuBackupConfigPtr
);


/** \brief Mcu_CheckClock_CpussCm0_Regs
 **
 ** This function checks clock settings with CPUSS CM0 HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE )
Mcu_CheckClock_CpussCm0_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_CpussMainCore_Regs
 **
 ** This function checks clock settings with CPUSS Main Core HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_CpussMainCore_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_CpussWaitCycle_Regs
 **
 ** This function checks clock settings with each memory control register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_CpussWaitCycle_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CheckClock_PeriPclk_Regs
 **
 ** This function checks clock settings with PERI PCLK HW registers.
 **
 ** \param[in]  PclkGroupConfigPtr      The pointer to PCLK Group clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_PeriPclk_Regs(
  P2CONST( Mcu_PclkGroupConfigDataType, MCU_CONST, MCU_APPL_CONST ) PclkGroupConfigPtr
);


/** \brief Mcu_CheckClock_PeriDivider_Regs
 **
 ** This function checks clock settings with PERI PCLK divider HW registers.
 **
 ** \param[in]  PclkGroupConfigPtr      The pointer to PCLK Group clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_PeriDivider_Regs(
  P2CONST( Mcu_PclkGroupConfigDataType, MCU_CONST, MCU_APPL_CONST ) PclkGroupConfigPtr
);


/** \brief Mcu_CheckClock_PeriGroup_Regs
 **
 ** This function checks clock settings with PERI peripheral group HW registers.
 **
 ** \param[in]  McuPeriGroupConfigNum  The number of peripheral group clock configuration.
 ** \param[in]  McuPeriGroupConfigPtr  The pointer to peripheral group clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_PeriGroup_Regs(
  VAR( uint32, AUTOMATIC ) McuPeriGroupConfigNum,
  P2CONST( Mcu_PeriGroupConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuPeriGroupConfigPtr
);


#define MCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
#define MCU_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

static P2CONST( Mcu_RegBaseAddrType, MCU_CONST, REGSPACE ) 
Mcu_RegBaseAddrPtr = NULL_PTR;

#define MCU_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/*==================[external function definitions]==========================*/
#define MCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/** \brief Mcu_SetBaseAddress_Regs
 **
 ** This function sets base addresses of registers used in MCU module.
 **
 ** \param[in]  McuBaseAddressPtr The pointer to the values of the base addresses used in MCU module.
 **
 ** \pre  McuBaseAddressPtr shall not be a NULL pointer.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetBaseAddress_Regs( 
  P2CONST( Mcu_RegBaseAddrType, AUTOMATIC, REGSPACE ) McuBaseAddressPtr
)
{
  /* Set base address pointer */
  Mcu_RegBaseAddrPtr = McuBaseAddressPtr;

  return;
}


/** \brief Mcu_ClockShutdown_Fll_Regs
 **
 ** This function shutdowns Fll clock registers of SRSS with configuration.
 **
 ** \param[in]  StopFlags  This flag on whether clock stops which is performed 
 **                        before update FLL clock settings when FLL clock is running.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 4 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_Fll_Regs(
  VAR( uint8, AUTOMATIC ) StopFlags
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) BypassWaitCycle;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC )  i;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(StopFlags == STD_ON)
  {
    if ((regSrssAddrPtr->CLK_FLL_CONFIG &
         MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE) ==
         MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE )
    {
      /* CLK_FLL_CONFIG3 */
      regVal = regSrssAddrPtr->CLK_FLL_CONFIG3;
      regVal = ((regVal & ~(uint32)(MCU_REG_MASK_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL)) |
                 MCU_REG_VALUE_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL_FLL_REF);
      /* BYPASS_SEL = FLL_REF*/
      regSrssAddrPtr->CLK_FLL_CONFIG3 = regVal;

      /* Get BypassWaitCycle */
      BypassWaitCycle = Mcu_GetFllBypassWaitCycle();
      /* wait 5cycles (nop) disabling FLL */
      for(i=0U; i<BypassWaitCycle; i++)
      {
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
           Justification: Inline assembler code is necessary. */
        /* PRQA S 1006 1 */
        __asm("nop");
      }

      /* FLL_ENABLE = powered off */
      regSrssAddrPtr->CLK_FLL_CONFIG &= 
        ~(uint32)MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE;

      /* CCO_ENABLE = powered off */
      regSrssAddrPtr->CLK_FLL_CONFIG4 &= 
        ~(uint32)MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_ENABLE;
    }
  }
  /* FllStopEnable is false , nothing to do. */
}


/** \brief Mcu_ClockShutdown_Pll_Regs
 **
 ** This function shutdowns Pll clock registers of SRSS with configuration.
 **
 ** \param[in]  PllRegIdx  The index number of Pll clock register.
 ** \param[in]  StopFlags  This flag on whether clock stops which is performed 
 **                        before update PLL clock settings when PLL clock is running.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 5 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_Pll_Regs( 
  VAR( uint32, AUTOMATIC ) PllRegIdx,
  VAR( uint8, AUTOMATIC ) StopFlags
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) BypassWaitCycle;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC )  i;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(StopFlags == STD_ON)
  {
    /* Read CLK_PLL_CONFIG register value */
      regVal = regSrssAddrPtr->CLK_PLL_CONFIG[PllRegIdx];

    if ((regVal & MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE) ==
         MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE )
    {
      regVal = ((regVal & ~(uint32)(MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_BYPASS_SEL)) |
                MCU_REG_VALUE_SRSS_CLK_PLL_CONFIG_BYPASS_SEL_PLL_REF);

      /* BYPASS_SEL = PLL_REF*/
      regSrssAddrPtr->CLK_PLL_CONFIG[PllRegIdx] = regVal;

      /* Get BypassWaitCycle */
      BypassWaitCycle = Mcu_GetPllBypassWaitCycle(PllRegIdx);
      /* wait 5cycles (nop) disabling PLL */
      for(i=0U; i<BypassWaitCycle; i++)
      {
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
           Justification: Inline assembler code is necessary. */
        /* PRQA S 1006 1 */
        __asm("nop");
      }

      /* CLK_PLL_CONFIG.ENABLE = 0 (disabled) */
      regSrssAddrPtr->CLK_PLL_CONFIG[PllRegIdx] &= 
        ~(uint32)MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE;
    }
  }
  /* PllStopEnable is false , nothing to do. */
}


/** \brief Mcu_ClockShutdown_Sscg_Regs
 **
 ** This function shutdowns SSCG clock registers of SRSS with configuration.
 **
 ** \param[in]  SscgRegIdx The index number of SSCG clock register.
 ** \param[in]  StopFlags  This flag on whether clock stops which is performed 
 **                        before update SSCG clock settings when SSCG clock is running.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 5 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_Sscg_Regs( 
  VAR( uint32, AUTOMATIC ) SscgRegIdx,
  VAR( uint8, AUTOMATIC ) StopFlags
)
{
  P2VAR( volatile Mcu_SscgRegType, AUTOMATIC, REGSPACE ) regSscgAddrPtr;
  VAR( uint32, AUTOMATIC ) BypassWaitCycle;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cnt;

  /* Get SSCG base address pointer */
  regSscgAddrPtr = &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PLL400_STRUCT[SscgRegIdx]);

  if(StopFlags == STD_ON)
  {
    /* Read PLL400_STRUCT.CONFIG register value */
      regVal = regSscgAddrPtr->PLL400_STRUCT_CONFIG;

    /* SSCG is enabled */
    if ((regVal & MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE) ==
         MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE)
    {
      /* BYPASS_SEL = PLL_REF*/
      regVal &= ~(uint32)MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL;
      regVal |=  MCU_REG_VALUE_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL_PLL_REF;
      regSscgAddrPtr->PLL400_STRUCT_CONFIG = regVal;
      /* Get BypassWaitCycle */
      BypassWaitCycle = Mcu_GetSscgBypassWaitCycle(SscgRegIdx);
      /* wait 5cycles (nop) disabling PLL */
      for(cnt=0U; cnt<BypassWaitCycle; cnt++)
      {
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
           Justification: Inline assembler code is necessary. */
        /* PRQA S 1006 1 */
        __asm("nop");
      }
      /* PLL400_STRUCT.CONFIG.ENABLE = 0 (disabled) */
      regSscgAddrPtr->PLL400_STRUCT_CONFIG &= ~(uint32)MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE;
    }
  }
  /* SscgStopEnable is false , nothing to do. */
}


/** \brief Mcu_ClockShutdown_SrssClock_Regs
 **
 ** This function shutdowns clock registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_SrssClock_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  /* Pump clock disable */
  Mcu_ClockShutdown_ClockSelect_Regs(McuClockConfigPtr);

  /* Timer clock disable */
  Mcu_ClockShutdown_TimerClock_Regs(McuClockConfigPtr);

  /* ROOT_SELECT setting : Set path which source is IMO */
  Mcu_ClockShutdown_RootSelect_Regs(McuClockConfigPtr);
}


/** \brief Mcu_ClockShutdown_PeriTimeout_Regs
 **
 ** This function shutdowns timeout control registers of PERI with configuration.
 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_PeriTimeout_Regs(void)
{

  P2VAR( volatile Mcu_PeriRegType, AUTOMATIC, REGSPACE ) regPeriAddrPtr;
  regPeriAddrPtr = Mcu_RegBaseAddrPtr->PeriRegBaseAddr;

  /* set TIMEOUT_CTL to default data (0xffff) */
  regPeriAddrPtr->TIMEOUT_CTL = MCU_REG_VALUE_PERI_TIMEOUT_CTL_DEFAULT;
  (void)regPeriAddrPtr->TIMEOUT_CTL;
}


/** \brief Mcu_ClockShutdown_PeriClock_Regs
 **
 ** This function shutdowns clock registers of PERI with configuration.
 **
 ** \param[in] PclkDividerConfigPtr  The pointer to Pclk configuration.
 ** \param[in] PclkGroupRegIdx       The ID of Pclk Group.
 **
 ** \pre PclkDividerConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_PeriClock_Regs(
  P2CONST( Mcu_PclkDividerConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PclkDividerConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) regDivcmdAddrPtr;
  VAR( boolean, AUTOMATIC ) McuEnDdivStop = FALSE;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  /* Check only the number of configuration.   */
  /* Check the index of the Divider set in the configuration and stop the Divider */
  /* if the Divider is running. */
  /* Stop only the configured Divider. */

  /* The Enable bit is reflected in DIV_X_CTL.EN, so check the DIV_X_CTL register. */
  if(PclkDividerConfigPtr->PclkDividerStopEnable == STD_ON)
  {
    if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_8)
    {
      if((regPclkAddrPtr->DIV_8_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
          MCU_REG_MASK_PERI_DIV_8_CTL_EN) ==
          MCU_REG_MASK_PERI_DIV_8_CTL_EN)
      {
        McuEnDdivStop = TRUE;
      }
      /* already disable -> nothing to do */
    }
    else if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_16)
    {
      if((regPclkAddrPtr->DIV_16_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
          MCU_REG_MASK_PERI_DIV_16_CTL_EN) ==
          MCU_REG_MASK_PERI_DIV_16_CTL_EN)
      {
        McuEnDdivStop = TRUE;
      }
      /* already disable -> nothing to do */
    }
    else if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_16_5)
    {
      if((regPclkAddrPtr->DIV_16_5_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
          MCU_REG_MASK_PERI_DIV_16_5_CTL_EN) ==
          MCU_REG_MASK_PERI_DIV_16_5_CTL_EN)
      {
        McuEnDdivStop = TRUE;
      }
      /* already disable -> nothing to do */
    }
    else if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_24_5)
    {
      if((regPclkAddrPtr->DIV_24_5_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
          MCU_REG_MASK_PERI_DIV_24_5_CTL_EN) ==
          MCU_REG_MASK_PERI_DIV_24_5_CTL_EN)
      {
         McuEnDdivStop = TRUE;
      }
      /* already disable -> nothing to do */
    }
    else
    {
      /* nothing to do */
    }

    if(McuEnDdivStop == TRUE)
    {
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
         Justification: The hardware address is needed to be calculated by pointer arithmetic.
                        And also the hardware access needed to be handled by using pointer. */
      /* PRQA S 303 1 */
      regDivcmdAddrPtr = (volatile uint32 *)((uint32)&regPclkAddrPtr->DIV_CMD + Mcu_RegBaseAddrPtr->DivcmdOffset);
      /* stop enbale is true -> stop pclk */
      /* DIV_CMD diable command */
      *regDivcmdAddrPtr = ((uint32)PclkDividerConfigPtr->PclkDividerIdx | 
                          (((uint32)PclkDividerConfigPtr->PclkDividerType <<
                          MCU_REG_BIT_PERI_DIV_CMD_TYPE_SEL) &
                          MCU_REG_MASK_PERI_DIV_CMD_TYPE_SEL) |
                          MCU_REG_VALUE_PERI_DIV_CMD_DISABLE);
                               
      /* dummy read */
      (void)*regDivcmdAddrPtr;
    }
  }
}


/** \brief Mcu_ClockShutdown_Csv_Regs
 **
 ** This function shutdowns CSV registers.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_Csv_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* CSV  setting is set to default value */

  for(i = 0U; i< McuClockConfigPtr->HfCsvConfigNum; i++ )
  {
    /* HF_CSV REF_CTL:CSV_EN bit set to disable */
    regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].REF_CTL &=
      ~(uint32)MCU_REG_MASK_SRSS_CSV_HF_REF_CTL_CSV_EN;
  }

  if(McuClockConfigPtr->RefCsvConfigPtr != NULL_PTR )
  {
    /* REF_CSV REF_CTL:CSV_EN bit set to disable */
    regSrssAddrPtr->CLK_REF_CSV.REF_CTL &=
      ~(uint32)MCU_REG_MASK_SRSS_CSV_REF_REF_CTL_CSV_EN;
  }

  if(McuClockConfigPtr->LfCsvConfigPtr != NULL_PTR )
  {
    /* LF_CSV REF_CTL:CSV_EN bit set to disable */
    regSrssAddrPtr->CLK_LF_CSV.REF_CTL  &=
      ~(uint32)MCU_REG_MASK_SRSS_CSV_LF_REF_CTL_CSV_EN;
  }

  if(McuClockConfigPtr->IloCsvConfigPtr != NULL_PTR )
  {
    /* ILO_CSV REF_CTL:CSV_EN bit set to disable */
    regSrssAddrPtr->CLK_ILO_CSV.REF_CTL  &=
      ~(uint32)MCU_REG_MASK_SRSS_CSV_ILO_REF_CTL_CSV_EN;
  }

  if(McuClockConfigPtr->BakCsvConfigPtr != NULL_PTR )
  {
    /* BAK_CSV REF_CTL:CSV_EN bit set to disable */
    Mcu_RegBaseAddrPtr->BackupRegBaseAddr->CLK_BAK_CSV.REF_CTL  &=
      ~(uint32)MCU_REG_MASK_BACKUP_CSV_BAK_REF_CTL_CSV_EN;
  }
}


/** \brief Mcu_ClockShutdown_ClockOutput_Regs
 **
 ** This function disables the clock output function.
 */
FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_ClockOutput_Regs( void )
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* FAST_SEL0 and FAST_SEL1 bit of CLK_OUTPUT_FAST is set to NC (0)*/
  /* SLOW_SEL0 and SLOW_SEL1 bit of CLK_OUTPUT_SLOW is set to NC (0)*/
  /* ENABLE0 and ENABLE1 of TST_DDFT_SLOW_CTL is set to 0(disable) */

  regSrssAddrPtr->TST_DDFT_SLOW_CTL &=
    ~(uint32)(MCU_REG_MASK_SRSS_TST_DDFT_SLOW_CTL_ENABLE0 |
              MCU_REG_MASK_SRSS_TST_DDFT_SLOW_CTL_ENABLE1);

  regSrssAddrPtr->CLK_OUTPUT_FAST &= 
    ~(uint32)(MCU_REG_MASK_SRSS_CLK_OUTPUT_FAST_FAST_SEL0 |
              MCU_REG_MASK_SRSS_CLK_OUTPUT_FAST_FAST_SEL1);

  regSrssAddrPtr->CLK_OUTPUT_SLOW &=
    ~(uint32)(MCU_REG_MASK_SRSS_CLK_OUTPUT_SLOW_SLOW_SEL0 |
              MCU_REG_MASK_SRSS_CLK_OUTPUT_SLOW_SLOW_SEL1);

}


/** \brief Mcu_SetIMO_Regs
 **
 ** This function sets CLK_IMO_CONFIG register of SRSS with configuration.
 **
 ** \param[in] McuRegValue  The value to set CLK_IMO_CONFIG register.
 ** \param[in] SetFlag      The flag indicating whether the clock to enable or not.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetIMO_Regs( 
  VAR( uint32, AUTOMATIC ) McuRegValue,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(SetFlag == TRUE)
  {
    if((McuRegValue & MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN) == 
        MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN)
    {
      /* config enable -> set register */
      regSrssAddrPtr->CLK_IMO_CONFIG = McuRegValue;
    }
  }
  else
  {
    /* SetFlag == FALSE */
    if((McuRegValue & MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN) != 
        MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN)
    {
      /* config disable -> set register */
      regSrssAddrPtr->CLK_IMO_CONFIG = McuRegValue;
    }
  }
}


/** \brief Mcu_SetILO_Regs
 **
 ** This function sets CLK_ILO0_CONFIG and CLK_ILO1_CONFIG register of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr  The pointer to clock configuration.
 ** \param[in] SetFlag             The flag indicating whether the clock to enable or not.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetILO_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) retLockVal;
  VAR( boolean, AUTOMATIC ) Ilo0Update = FALSE;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(SetFlag == TRUE)
  {
    /* enable clock setting */
    if((McuClockConfigPtr->ClkIloConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE) == 
        MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE)
    {
      Ilo0Update = TRUE;
    }
    
    if((McuClockConfigPtr->ClkIlo1ConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE) == 
        MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE)
    {
      /* ILO1 setting */
      /* set CLK_ILO1_CONFIG */ 
      regSrssAddrPtr->CLK_ILO1_CONFIG = McuClockConfigPtr->ClkIlo1ConfigRegVal;
    }
  }
  else
  {
    /* SetFlag == FALSE -> disable clock setting */
    if((McuClockConfigPtr->ClkIloConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE) != 
        MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE)
    {
       Ilo0Update = TRUE;
    }
    
    if((McuClockConfigPtr->ClkIlo1ConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE) != 
        MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE)
    {
      /* ILO1 setting */
      /* set CLK_ILO1_CONFIG */ 
      regSrssAddrPtr->CLK_ILO1_CONFIG = McuClockConfigPtr->ClkIlo1ConfigRegVal;
    }
  }
  
  if (Ilo0Update == TRUE)
  {
    /* check UnlockWdtEnable */
    if(McuClockConfigPtr->UnlockWdtEnable == STD_ON)
    {
      /* WDT_LOCK is set to unlock */
      retLockVal = Mcu_UnlockWatchdog_Regs();

      /* set CLK_ILO0_CONFIG */ 
      regSrssAddrPtr->CLK_ILO0_CONFIG = McuClockConfigPtr->ClkIloConfigRegVal;
    
      /* WDT_LOCK is set to lock */
      Mcu_LockWatchdog_Regs(retLockVal);
    }
    else
    {
      /* UnlockWdtEnable is STD_OFF */
      /* check if WDT_LOCK is unlock status. */
      if(Mcu_IsUnlockWatchdog_Regs() == TRUE)
      {
        /* set CLK_ILO0_CONFIG */ 
        regSrssAddrPtr->CLK_ILO0_CONFIG = McuClockConfigPtr->ClkIloConfigRegVal;
      }
    }
  }

}


/** \brief Mcu_SetECO_Regs
 **
 ** This function sets CLK_ECO_CONFIG register of SRSS with configuration.
 **
 ** \param[in] EcoConfigPtr  The pointer to ECO clock configuration.
 ** \param[in] SetFlag       The flag indicating whether the clock to enable or not.
 **
 ** \pre EcoConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetECO_Regs(
  P2CONST( Mcu_EcoConfigDataType, AUTOMATIC, MCU_APPL_CONST ) EcoConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(SetFlag == TRUE)
  {
    if(EcoConfigPtr->ClkEcoConfig2Update == STD_ON) {
      regSrssAddrPtr->CLK_ECO_CONFIG2 = EcoConfigPtr->ClkEcoConfig2RegVal;
    }
    /* enable clock setting */
    if((EcoConfigPtr->ClkEcoConfigRegVal & MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN) ==
        MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN)
    {
      regSrssAddrPtr->CLK_ECO_CONFIG = EcoConfigPtr->ClkEcoConfigRegVal;
    }
  }
  else
  {
    if((EcoConfigPtr->ClkEcoConfigRegVal & MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN) !=
        MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN)
    {
      regSrssAddrPtr->CLK_ECO_CONFIG = EcoConfigPtr->ClkEcoConfigRegVal;
    }
  }
}


/** \brief Mcu_SetECOPrescale_Regs
 **
 ** This function sets CLK_ECO_PRESCALE register of SRSS with configuration.
 **
 ** \param[in] EcoConfigPtr The pointer to ECO clock configuration.
 **
 ** \pre EcoConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetECOPrescale_Regs(
  P2CONST( Mcu_EcoConfigDataType, AUTOMATIC, MCU_APPL_CONST ) EcoConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(EcoConfigPtr->EcoPrescalerEn == STD_ON)
  {
    
    if((regSrssAddrPtr->CLK_ECO_PRESCALE & MCU_REG_MASK_SRSS_CLK_ECO_PRESCALE_ECO_DIV_ENABLED) ==
       MCU_REG_MASK_SRSS_CLK_ECO_PRESCALE_ECO_DIV_ENABLED)
    {
      /* disable command */
      regSrssAddrPtr->CLK_ECO_CONFIG |= MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_DISABLE;
    }
    /* set ECO_FRAC_DIV and ECO_INT_DIV bit of CLK_ECO_PRESCALE */
    regSrssAddrPtr->CLK_ECO_PRESCALE = EcoConfigPtr->ClkEcoPrescalerRegVal;

    /* dummy read */
    (void)regSrssAddrPtr->CLK_ECO_PRESCALE;
    
    /* enable command */
    regSrssAddrPtr->CLK_ECO_CONFIG |= MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_ENABLE;
  }
  else
  {
    /* disable command */
    regSrssAddrPtr->CLK_ECO_CONFIG |= MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_DISABLE;
  }

}


/** \brief Mcu_SetLpEco_Regs
 **
 ** This function sets LPECO_CTL register of SRSS BACKUP with configuration.
 **
 ** \param[in] LpEcoConfigPtr  The pointer to LPECO clock configuration.
 ** \param[in] SetFlag         The flag indicating whether the clock to enable or not.
 **
 ** \pre LpEcoConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetLpEco_Regs(
  P2CONST( Mcu_LpEcoConfigDataType, AUTOMATIC, MCU_APPL_CONST ) LpEcoConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  /* Oscillator enable */
  if (SetFlag == TRUE)
  {
    /* LPECO will be enabled */
    if (LpEcoConfigPtr->LpEcoEn == STD_ON)
    {
      if (LpEcoConfigPtr->LpEcoStopEnable == STD_ON)
      {
        /* LPECO disable */
        regBackupAddrPtr->LPECO_CTL &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN;
        /* dummy read */
        (void)regBackupAddrPtr->LPECO_CTL;
      }
      /* LPECO disabled */
      if ((regBackupAddrPtr->LPECO_CTL & MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN) != 
           MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN)
      {
        /* Set LPECO_CTL register */
        regBackupAddrPtr->LPECO_CTL = LpEcoConfigPtr->LpEcoCtlRegVal;
        /* dummy read */
        (void)regBackupAddrPtr->LPECO_CTL;
        /* LPECO enable*/
        regBackupAddrPtr->LPECO_CTL |= MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN;
      }
    }
  }
  /* Oscillator disable */
  else
  {
    /* LPECO will be disabled */
    if (LpEcoConfigPtr->LpEcoEn == STD_OFF)
    {
      /* LPECO disable */
      regBackupAddrPtr->LPECO_CTL &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN;
      /* dummy read */
      (void)regBackupAddrPtr->LPECO_CTL;
      /* Set LPECO_CTL register */
      regBackupAddrPtr->LPECO_CTL = LpEcoConfigPtr->LpEcoCtlRegVal;
    }
  }
}


/** \brief Mcu_SetLpEcoPrescale_Regs
 **
 ** This function sets LPECO_PRESCALE register of SRSS BACKUP with configuration.
 **
 ** \param[in] LpEcoConfigPtr The pointer to LPECO clock configuration.
 **
 ** \pre LpEcoConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetLpEcoPrescale_Regs(
  P2CONST( Mcu_LpEcoConfigDataType, AUTOMATIC, MCU_APPL_CONST ) LpEcoConfigPtr
)
{
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;
  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  /* LPECO prescaler will be enabled */
  if (LpEcoConfigPtr->LpEcoPrescalerEn == STD_ON)
  {
    /* LPECO prescaler is disabled */
    if ((regBackupAddrPtr->LPECO_PRESCALE & 
         MCU_REG_MASK_SRSS_BACKUP_LPECO_PRESCALE_LPECO_DIV_ENABLED) !=
         MCU_REG_MASK_SRSS_BACKUP_LPECO_PRESCALE_LPECO_DIV_ENABLED)
    {
      /* Set LPECO_PRESCALER register */
      regBackupAddrPtr->LPECO_PRESCALE = LpEcoConfigPtr->LpEcoPrescalerRegVal;
      /* dummy read */
      (void)regBackupAddrPtr->LPECO_PRESCALE;
      /* LPECO prescaler enable command */
      regBackupAddrPtr->LPECO_CTL |= MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_DIV_ENABLE;
    }
  }
  /*  LPECO prescaler cannot be disabled unless LPECO is disabled */
}


/** \brief Mcu_SetWCO_Regs
 **
 ** This function sets CTL register of SRSS BACKUP with configuration.
 **
 ** \param[in] BackupConfigPtr  The pointer to SRSS BACKUP configuration.
 ** \param[in] SetFlag          The flag indicating whether the clock to enable or not.
 **
 ** \pre BackupConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetWCO_Regs(
  P2CONST( Mcu_BackupConfigDataType, AUTOMATIC, MCU_APPL_CONST ) BackupConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  if(SetFlag == TRUE)
  {
    if (BackupConfigPtr->WcoEn == STD_ON)
    {
      /* read CTL register value */
      regVal = regBackupAddrPtr->CTL;
      if ((regVal & MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN) != 
            MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN)
      {
        /* clear update field of CTL register value */
        regVal &= ~(uint32)BackupConfigPtr->CtlRegMask;
        /* CTL setting (expect WCO_EN) */
        regBackupAddrPtr->CTL = 
          (regVal | (BackupConfigPtr->CtlRegVal & BackupConfigPtr->CtlRegMask));
        /* dummy read */
        (void)regBackupAddrPtr->CTL;
        /* WCO enable */
        Mcu_SetWcoEnable_Regs(STD_ON);
      }
    }
  }
  else
  {
    if (BackupConfigPtr->WcoEn == STD_OFF)
    {
      /* WCO disable */
      Mcu_SetWcoEnable_Regs(STD_OFF);
      /* read CTL register value */
      regVal = regBackupAddrPtr->CTL;
      /* clear update field of CTL register value */
      regVal &= ~(uint32)(BackupConfigPtr->CtlRegMask | MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN);
      /* CTL setting */
      regBackupAddrPtr->CTL = 
        (regVal | (BackupConfigPtr->CtlRegVal & BackupConfigPtr->CtlRegMask));
    }
  }
}


/** \brief Mcu_SetWcoEnable_Regs
 **
 ** This function sets CTL.WCO_EN bit of SRSS BACKUP with configuration.
 **
 ** \param[in] EnableFlag       The flag indicating whether enables/disables the WCO.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetWcoEnable_Regs(
  VAR( uint8, AUTOMATIC ) EnableFlag
)
{
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  /* Clear RTC_RW.READ bit */
  regBackupAddrPtr->RTC_RW &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_RTC_RW_READ;
  /* dummy read */
  (void)regBackupAddrPtr->RTC_RW;
  /* Set RTC_RW.WRITE bit */
  regBackupAddrPtr->RTC_RW |= MCU_REG_MASK_SRSS_BACKUP_RTC_RW_WRITE;
  /* dummy read */
  (void)regBackupAddrPtr->RTC_RW;

  /* Update CTL register */
  if (EnableFlag == STD_ON) {
    /* Set CTL.WCO_EN bit */
    regBackupAddrPtr->CTL |= MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN;
  } else {
    /* Clear CTL.WCO_EN bit */
    regBackupAddrPtr->CTL &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN;
  }
  /* dummy read */
  (void)regBackupAddrPtr->CTL;

  /* Clear RTC_RW.WRITE bit */
  regBackupAddrPtr->RTC_RW &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_RTC_RW_WRITE;
  /* dummy read */
  (void)regBackupAddrPtr->RTC_RW;
  /* Set RTC_RW.READ bit */
  regBackupAddrPtr->RTC_RW |= MCU_REG_MASK_SRSS_BACKUP_RTC_RW_READ;
  /* dummy read */
  (void)regBackupAddrPtr->RTC_RW;

  return;
}


/** \brief Mcu_WcoClkDisableWait_Regs
 **
 ** This function waits completion of disabling WCO clock.
 ** If the WCO clock is not disabled during WcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] WcoStabilizationCnt         The count value for monitoring completion of WCO disable.
 **
 ** \retval  MCU_OK      WCO is disabled.
 ** \retval  MCU_NOT_OK  WCO is not disabled.
 **
 ** \pre BackupConfigPtr shall not be a NULL pointer.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WcoClkDisableWait_Regs(
  VAR( uint32, AUTOMATIC ) WcoStabilizationCnt
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) stubcnt;
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  if ((regBackupAddrPtr->CTL & MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN) !=
       MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN)
  {
    /* set stabilization check count */
    stubcnt = WcoStabilizationCnt;

    /* set return value MCU_NOT_OK */
    retVal = MCU_NOT_OK;
    do
    {
      if ((regBackupAddrPtr->STATUS & MCU_REG_MASK_SRSS_BACKUP_STATUS_WCO_OK) !=
           MCU_REG_MASK_SRSS_BACKUP_STATUS_WCO_OK)
      {
        /* set return value MCU_OK */
        retVal = MCU_OK;
        break;
      }
      stubcnt--;
    }
    while( stubcnt > 0U );
  }

  return retVal;

}


/** \brief Mcu_SourceClkStabWait_Regs
 **
 ** This function waits stabilization of ECO, ECO Prescaler, LPECO, LPECO Prescaler and WCO clock.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 ** \param[in]  ClockFlags             ECO, ECO Prescale, LPECO, LPECO Prescaler or WCO clock setting flag.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  ECO, ECO Prescaler, LPECO, LPECO Prescaler or WCO clock stabilization is not success.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SourceClkStabWait_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr,
  VAR( uint8, AUTOMATIC )  ClockFlags
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  if (McuClockConfigPtr->EcoConfigPtr != NULL_PTR)
  {
    /* ECO stabilization wait */
    retVal = Mcu_EcoClkStabWait_Regs(McuClockConfigPtr->EcoConfigPtr->EcoStabToCnt, ClockFlags);
    if (retVal == MCU_OK)
    {
      /* ECO prescale stabilization wait */
      retVal = Mcu_EcoPrescaleStabWait_Regs(McuClockConfigPtr->EcoConfigPtr->EcoPrescalerEnToCnt, ClockFlags);
    }
  }
  if (retVal == MCU_OK)
  {
    if (McuClockConfigPtr->LpEcoConfigPtr != NULL_PTR)
    {
      /* LPECO stabilization wait */
      retVal = Mcu_LpEcoClkStabWait_Regs(McuClockConfigPtr->LpEcoConfigPtr->LpEcoStabToCnt, ClockFlags);
      if (retVal == MCU_OK)
      {
        /* LPECO prescale stabilization wait */
        retVal = Mcu_LpEcoPrescaleStabWait_Regs(McuClockConfigPtr->LpEcoConfigPtr->LpEcoPrescalerEnToCnt, ClockFlags);
      }
    }
  }
  if (retVal == MCU_OK)
  {
    if (McuClockConfigPtr->BackupConfigPtr != NULL_PTR)
    {
      /* WCO stabilization wait */
      retVal = Mcu_WcoClkStabWait_Regs(McuClockConfigPtr->BackupConfigPtr->WcoStabToCnt, ClockFlags);
    }
  }

  return retVal;
}


/** \brief Mcu_SetCsv_Regs
 **
 ** This function sets CSV registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetCsv_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;
  VAR( uint8, AUTOMATIC ) i;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;
  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  /* CSV_REF_SEL */
  regSrssAddrPtr->CSV_REF_SEL = McuClockConfigPtr->CsvRefSelRegVal;

  /* CSV_HF_STRUCTS */
  for(i = 0U; i<McuClockConfigPtr->HfCsvConfigNum; i++)
  {
    regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].REF_LIMIT =
      McuClockConfigPtr->HfCsvConfigPtr[i].HfLimitRegVal;
    regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].MON_CTL =
      McuClockConfigPtr->HfCsvConfigPtr[i].MonCtlRegVal;
    regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].REF_CTL =
      (McuClockConfigPtr->HfCsvConfigPtr[i].HfCtlRegVal &
      ~(uint32)MCU_REG_MASK_SRSS_CSV_HF_REF_CTL_CSV_EN);

    /* CSV_EN bit setting */
    if((McuClockConfigPtr->HfCsvConfigPtr[i].HfCtlRegVal & MCU_REG_MASK_SRSS_CSV_HF_REF_CTL_CSV_EN) ==
      MCU_REG_MASK_SRSS_CSV_HF_REF_CTL_CSV_EN)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].REF_LIMIT;
      (void)regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].MON_CTL;
      (void)regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].REF_CTL;
      /* set CSV_EN bit of CSV_HF_REF_CTL register */
      regSrssAddrPtr->CLK_HF_CSV[McuClockConfigPtr->HfCsvConfigPtr[i].HfCsvRegIdx].REF_CTL |=
        MCU_REG_MASK_SRSS_CSV_HF_REF_CTL_CSV_EN;
    }
    /* PRQA S 491 -- */
  }

  /* CSV_REF_STRUCT */
  if(McuClockConfigPtr->RefCsvConfigPtr != NULL_PTR )
  {
    regSrssAddrPtr->CLK_REF_CSV.REF_LIMIT =
      McuClockConfigPtr->RefCsvConfigPtr->RefLimitRegVal;
    regSrssAddrPtr->CLK_REF_CSV.MON_CTL   =
      McuClockConfigPtr->RefCsvConfigPtr->MonCtlRegVal;
    regSrssAddrPtr->CLK_REF_CSV.REF_CTL   =
      (McuClockConfigPtr->RefCsvConfigPtr->RefCtlRegVal &
      ~(uint32)MCU_REG_MASK_SRSS_CSV_REF_REF_CTL_CSV_EN);

    /* CSV_EN bit setting */
    if((McuClockConfigPtr->RefCsvConfigPtr->RefCtlRegVal &
        MCU_REG_MASK_SRSS_CSV_REF_REF_CTL_CSV_EN) ==
        MCU_REG_MASK_SRSS_CSV_REF_REF_CTL_CSV_EN)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_REF_CSV.REF_LIMIT;
      (void)regSrssAddrPtr->CLK_REF_CSV.MON_CTL;
      (void)regSrssAddrPtr->CLK_REF_CSV.REF_CTL;
      /* set CSV_EN bit of CSV_REF_REF_CTL register */
      regSrssAddrPtr->CLK_REF_CSV.REF_CTL |= MCU_REG_MASK_SRSS_CSV_REF_REF_CTL_CSV_EN;
    }
  }

  /* CSV_LF_STRUCT */
  if(McuClockConfigPtr->LfCsvConfigPtr != NULL_PTR )
  {
    regSrssAddrPtr->CLK_LF_CSV.REF_LIMIT =
      McuClockConfigPtr->LfCsvConfigPtr->RefLimitRegVal;
    regSrssAddrPtr->CLK_LF_CSV.MON_CTL   =
      McuClockConfigPtr->LfCsvConfigPtr->MonCtlRegVal;
    regSrssAddrPtr->CLK_LF_CSV.REF_CTL   =
      (McuClockConfigPtr->LfCsvConfigPtr->RefCtlRegVal &
      ~(uint32)MCU_REG_MASK_SRSS_CSV_LF_REF_CTL_CSV_EN);

    /* CSV_EN bit setting */
    if((McuClockConfigPtr->LfCsvConfigPtr->RefCtlRegVal &
        MCU_REG_MASK_SRSS_CSV_LF_REF_CTL_CSV_EN) ==
        MCU_REG_MASK_SRSS_CSV_LF_REF_CTL_CSV_EN)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_LF_CSV.REF_LIMIT;
      (void)regSrssAddrPtr->CLK_LF_CSV.MON_CTL;
      (void)regSrssAddrPtr->CLK_LF_CSV.REF_CTL;
      /* set CSV_EN bit of CSV_LF_REF_CTL register */
      regSrssAddrPtr->CLK_LF_CSV.REF_CTL |= MCU_REG_MASK_SRSS_CSV_LF_REF_CTL_CSV_EN;
    }
  }

  /* CSV_ILO_STRUCT */
  if(McuClockConfigPtr->IloCsvConfigPtr != NULL_PTR )
  {
    regSrssAddrPtr->CLK_ILO_CSV.REF_LIMIT =
     McuClockConfigPtr->IloCsvConfigPtr->RefLimitRegVal;
    regSrssAddrPtr->CLK_ILO_CSV.MON_CTL   =
      McuClockConfigPtr->IloCsvConfigPtr->MonCtlRegVal;
    regSrssAddrPtr->CLK_ILO_CSV.REF_CTL   =
      (McuClockConfigPtr->IloCsvConfigPtr->RefCtlRegVal &
      ~(uint32)MCU_REG_MASK_SRSS_CSV_ILO_REF_CTL_CSV_EN);

    /* CSV_EN bit setting */
    if((McuClockConfigPtr->IloCsvConfigPtr->RefCtlRegVal &
        MCU_REG_MASK_SRSS_CSV_ILO_REF_CTL_CSV_EN) ==
        MCU_REG_MASK_SRSS_CSV_ILO_REF_CTL_CSV_EN)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_ILO_CSV.REF_LIMIT;
      (void)regSrssAddrPtr->CLK_ILO_CSV.MON_CTL;
      (void)regSrssAddrPtr->CLK_ILO_CSV.REF_CTL;
      /* set CSV_EN bit of CSV_ILO_REF_CTL register */
      regSrssAddrPtr->CLK_ILO_CSV.REF_CTL |= MCU_REG_MASK_SRSS_CSV_ILO_REF_CTL_CSV_EN;
    }
  }

  /* CSV_BAK_STRUCT */
  if(McuClockConfigPtr->BakCsvConfigPtr != NULL_PTR )
  {
    regBackupAddrPtr->CLK_BAK_CSV.REF_LIMIT =
     McuClockConfigPtr->BakCsvConfigPtr->RefLimitRegVal;
    regBackupAddrPtr->CLK_BAK_CSV.MON_CTL   =
      McuClockConfigPtr->BakCsvConfigPtr->MonCtlRegVal;
    regBackupAddrPtr->CLK_BAK_CSV.REF_CTL   =
      (McuClockConfigPtr->BakCsvConfigPtr->RefCtlRegVal &
      ~(uint32)MCU_REG_MASK_BACKUP_CSV_BAK_REF_CTL_CSV_EN);

    /* CSV_EN bit setting */
    if((McuClockConfigPtr->BakCsvConfigPtr->RefCtlRegVal &
        MCU_REG_MASK_BACKUP_CSV_BAK_REF_CTL_CSV_EN) ==
        MCU_REG_MASK_BACKUP_CSV_BAK_REF_CTL_CSV_EN)
    {
      /* dummy read */
      (void)regBackupAddrPtr->CLK_BAK_CSV.REF_LIMIT;
      (void)regBackupAddrPtr->CLK_BAK_CSV.MON_CTL;
      (void)regBackupAddrPtr->CLK_BAK_CSV.REF_CTL;
      /* set CSV_EN bit of CSV_BAK_REF_CTL register */
      regBackupAddrPtr->CLK_BAK_CSV.REF_CTL |= MCU_REG_MASK_BACKUP_CSV_BAK_REF_CTL_CSV_EN;
    }
  }
}


/** \brief Mcu_SetWaitCycle_Regs
 **
 ** This function sets Memory wait status of CPUSS and Flash wait status of FLASHC with configuration.
 **
 ** \param[in] McuClockConfigPtr    The pointer to clock configuration.
 ** \param[in] SetFlag              The flag indicating whether the divider to up or down.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetWaitCycle_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{

  /*ROM_CTL*/
  Mcu_SetROMWaitCycle_Regs(McuClockConfigPtr->RomCtlRegVal, SetFlag);

  /*RAM0_CTL*/
  Mcu_SetRAM0WaitCycle_Regs(McuClockConfigPtr->Ram0CtlRegVal,
                            SetFlag);
  /* If RAM1 exists Ram1CtlRegMask will not be 0U at generate time */
  if (McuClockConfigPtr->Ram1CtlRegMask != 0U) {
    /*RAM1_CTL*/
    Mcu_SetRAM1WaitCycle_Regs(McuClockConfigPtr->Ram1CtlRegVal,
                              SetFlag);
  }
  /* If RAM2 exists Ram2CtlRegMask will not be 0U at generate time */
  if (McuClockConfigPtr->Ram2CtlRegMask != 0U) {
    /*RAM2_CTL*/
    Mcu_SetRAM2WaitCycle_Regs(McuClockConfigPtr->Ram2CtlRegVal,
                              SetFlag);
  }
  /*FLASH_CTL*/
  Mcu_SetFLASHWaitCycle_Regs(McuClockConfigPtr->FlashCtlRegVal,
                             SetFlag);
}


/** \brief Mcu_SetPath_Regs
 **
 ** This function sets CLK_PATH_SELECT register of SRSS with configuration.
 **
 ** \param[in] PathRegIdx   The index number of CLK_PATH_SELECT register.
 ** \param[in] PathRegVal   The value to set CLK_PATH_SELECT register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPath_Regs(
   VAR( uint8, AUTOMATIC ) PathRegIdx,
   VAR( uint32, AUTOMATIC ) PathRegVal
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* register setting : CLK_PATH_SELECT */
  regSrssAddrPtr->CLK_PATH_SELECT[PathRegIdx] = PathRegVal;
}


/** \brief Mcu_SetDsi_Regs
 **
 ** This function sets CLK_DSI_SELECT register of SRSS with configuration.
 **
 ** \param[in] DsiRegIdx   The index number of CLK_DSI_SELECT register.
 ** \param[in] DsiRegVal   The value to set CLK_DSI_SELECT register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDsi_Regs(
 VAR( uint8, AUTOMATIC ) DsiRegIdx,
 VAR( uint32, AUTOMATIC ) DsiRegVal
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* register setting : CLK_DSI_SELECT */
  regSrssAddrPtr->CLK_DSI_SELECT[DsiRegIdx] = DsiRegVal;
}


/** \brief Mcu_SetLf_Regs
 **
 ** This function sets LFCLK_SEL bit of CLK_SELECT register of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetLf_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) retLockVal;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;
  /* Read CLK_SELECT register value */
  regVal = regSrssAddrPtr->CLK_SELECT;

  /* check UnlockWdtEnable */
  if(McuClockConfigPtr->UnlockWdtEnable == STD_ON)
  {
    /* WDT_LOCK is set to unlock */
    retLockVal = Mcu_UnlockWatchdog_Regs();

    /* Update LF_CLK value with config value */
    regVal &= ~(uint32)MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL;
    regVal |= (McuClockConfigPtr->ClkSelectRegVal & MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL);

    regSrssAddrPtr->CLK_SELECT = regVal;

    /* dummy read */
    regSrssAddrPtr->CLK_SELECT;

    /* WDT_LOCK is set to lock */
    Mcu_LockWatchdog_Regs(retLockVal);
  }
  else
  {
    /* UnlockWdtEnable is STD_OFF */
    /* check if WDT_LOCK is unlock status. */
    if(Mcu_IsUnlockWatchdog_Regs() == TRUE)
    {
      /* Update LF_CLK value with config value */
      regVal &= ~(uint32)MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL;
      regVal |= (McuClockConfigPtr->ClkSelectRegVal & MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL);

      regSrssAddrPtr->CLK_SELECT = regVal;

      /* dummy read */
      regSrssAddrPtr->CLK_SELECT;
    }
  }
}


/** \brief Mcu_SetPump_Regs
 **
 ** This function sets PUMP_SEL and PUMP_ENABLE of CLK_SELECT register of SRSS with configuration.
 **
 ** \param[in] ClkSelectRegVal       The value to set CLK_SELECT register.
 ** \param[in] PumpClockEn           The value to set PUMP_ENABLE bit of CLK_SELECT register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPump_Regs(
  VAR( uint32, AUTOMATIC ) ClkSelectRegVal,
  VAR( uint8, AUTOMATIC ) PumpClockEn
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;
  /* Read CLK_SELECT register value */
  regVal = regSrssAddrPtr->CLK_SELECT;

  if ((regVal & MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE) !=
       MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE)
  {
    /* Update PUMP_SEL/PUMP_DIV with config value */
    regVal &= ~(uint32)(MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_DIV | 
                        MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_SEL);
    regVal |= (ClkSelectRegVal & (MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_DIV | 
                                  MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_SEL));
    /* Write CLK_SELECT register value */
    regSrssAddrPtr->CLK_SELECT = regVal;
    /* dummy read */
    (void)regSrssAddrPtr->CLK_SELECT;
    /* Enable pump clock */
    if (PumpClockEn == STD_ON) {
      /* Set PUMP_ENABLE */
      regSrssAddrPtr->CLK_SELECT |= MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE;
    }
  }
}


/** \brief Mcu_SetTimer_Regs
 **
 ** This function sets CLK_TIMER_CTL register of SRSS with configuration.
 **
 ** \param[in] TimerCtlRegVal       The value to set CLK_TIMER_CTL register.
 ** \param[in] TimerCtlEn           The value to set TIMER_ENABLE bit of CLK_TIMER_CTL register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetTimer_Regs(
  VAR( uint32, AUTOMATIC ) TimerCtlRegVal,
  VAR( uint8, AUTOMATIC ) TimerCtlEn
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if ((regSrssAddrPtr->CLK_TIMER_CTL &
       MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE) !=
       MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE)
  {
    /* register setting : CLK_TIMER_CTL (except ENABLE bit) */
    regSrssAddrPtr->CLK_TIMER_CTL = (TimerCtlRegVal &
                                    ~(uint32)MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE);
    if (TimerCtlEn == STD_ON)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_TIMER_CTL;
      /* register setting : CLK_TIMER_CTL.ENABLE bit */
      regSrssAddrPtr->CLK_TIMER_CTL |= MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE;
    }
  }
}


/** \brief Mcu_SetClockOutput_Regs
 **
 ** This function sets DDFT output registers of SRSS with configuration.
 ** (CLK_OUTPUT_FAST, CLK_OUTPUT_SLOW, TST_DDFT_FAST_CTL, TST_DDFT_SLOW_CTL register)
 **
 ** \param[in]  ClockOutputConfigPtr    The pointer to DDFT clock output configuration.
 **
 ** \pre  ClockOutputConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetClockOutput_Regs(
  P2CONST( Mcu_ClockOutputConfigDataType, AUTOMATIC, MCU_APPL_CONST ) ClockOutputConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  regSrssAddrPtr->CLK_OUTPUT_FAST   = ClockOutputConfigPtr->ClkOutputFastRegVal;
  regSrssAddrPtr->CLK_OUTPUT_SLOW   = ClockOutputConfigPtr->ClkOutputSlowRegVal;
  regSrssAddrPtr->TST_DDFT_FAST_CTL = ClockOutputConfigPtr->TstDdftFastCtlRegVal;
  regSrssAddrPtr->TST_DDFT_SLOW_CTL = ClockOutputConfigPtr->TstDdftSlowCtlRegVal;

}


/** \brief Mcu_SetCpussClock_Regs
 **
 ** This function sets clock setting registers of CPUSS with configuration.
 ** (FAST_CLOCK_CTL, SLOW_CLOCK_CTL register)
 ** 
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 ** \param[in]  SetFlag              The flag indicating whether the divider to up or down.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetCpussClock_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_CpussRegType, AUTOMATIC, REGSPACE ) regCpussAddrPtr;
  VAR( uint8,  AUTOMATIC ) cnt;

  regCpussAddrPtr = Mcu_RegBaseAddrPtr->CpussRegBaseAddr;

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    for (cnt=0U; cnt < McuClockConfigPtr->FastClockCtlNum; cnt++) {
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->FAST_CLOCK[cnt].FAST_CLOCK_CTL),
        McuClockConfigPtr->FastClockCtlRegVal[cnt],
        SetFlag
      );
    }

    if (McuClockConfigPtr->MemClockExist == STD_OFF) {
      Mcu_SetClockDivMask_Regs(
        &(regCpussAddrPtr->SLOW_CLOCK_CTL),
        McuClockConfigPtr->SlowClockCtlRegVal,
        MCU_REG_MASK_CPUSS_SLOW_CLOCK_CTL_INT_DIV,
        SetFlag
      );
      Mcu_SetClockDivMask_Regs(
        &(regCpussAddrPtr->SLOW_CLOCK_CTL),
        McuClockConfigPtr->PeriClockCtlRegVal,
        MCU_REG_MASK_CPUSS_PERI_CLOCK_CTL_INT_DIV,
        SetFlag
      );
    } else {
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->MEM_CLOCK_CTL),
        McuClockConfigPtr->MemClockCtlRegVal,
        SetFlag
      );
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->SLOW_CLOCK_CTL),
        McuClockConfigPtr->SlowClockCtlRegVal,
        SetFlag
      );
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->PERI_CLOCK_CTL),
        McuClockConfigPtr->PeriClockCtlRegVal,
        SetFlag
      );
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->FAST_CLOCK[0].TRC_DBG_CLOCK_CTL),
        McuClockConfigPtr->TrcDbgClockCtlRegVal,
        SetFlag
      );
    }
  }
  else
  {
    /* set to up clock divider */
    if (McuClockConfigPtr->MemClockExist == STD_OFF) {
      Mcu_SetClockDivMask_Regs(
        &(regCpussAddrPtr->SLOW_CLOCK_CTL),
        McuClockConfigPtr->PeriClockCtlRegVal,
        MCU_REG_MASK_CPUSS_PERI_CLOCK_CTL_INT_DIV,
        SetFlag
      );
      Mcu_SetClockDivMask_Regs(
        &(regCpussAddrPtr->SLOW_CLOCK_CTL),
        McuClockConfigPtr->SlowClockCtlRegVal,
        MCU_REG_MASK_CPUSS_SLOW_CLOCK_CTL_INT_DIV,
        SetFlag
      );
    } else {
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->FAST_CLOCK[0].TRC_DBG_CLOCK_CTL),
        McuClockConfigPtr->TrcDbgClockCtlRegVal,
        SetFlag
      );
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->PERI_CLOCK_CTL),
        McuClockConfigPtr->PeriClockCtlRegVal,
        SetFlag
      );
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->SLOW_CLOCK_CTL),
        McuClockConfigPtr->SlowClockCtlRegVal,
        SetFlag
      );
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->MEM_CLOCK_CTL),
        McuClockConfigPtr->MemClockCtlRegVal,
        SetFlag
      );
    }

    for (cnt=0U; cnt < McuClockConfigPtr->FastClockCtlNum; cnt++) {
      Mcu_SetClockDiv_Regs(
        &(regCpussAddrPtr->FAST_CLOCK[cnt].FAST_CLOCK_CTL),
        McuClockConfigPtr->FastClockCtlRegVal[cnt],
        SetFlag
      );
    }
  }
}


/** \brief Mcu_SetPeriTimeout_Regs
 **
 ** This function sets TIMEOUT_CTL register of PERI with configuration.
 ** 
 ** \param[in]  TimeoutCnt    The timeout count value to set TIMEOUT_CTL register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPeriTimeout_Regs(
  VAR( uint32, AUTOMATIC )  TimeoutCnt
)
{

  P2VAR( volatile Mcu_PeriRegType, AUTOMATIC, REGSPACE ) regPeriAddrPtr;
  regPeriAddrPtr = Mcu_RegBaseAddrPtr->PeriRegBaseAddr;

  regPeriAddrPtr->TIMEOUT_CTL = TimeoutCnt;
  (void)regPeriAddrPtr->TIMEOUT_CTL;
}


/** \brief Mcu_SetPeriClock_Regs
 **
 ** This function sets CLOCK_CTL register of PERI with configuration.
 ** 
 ** \param[in]  PclkConfigPtr      The pointer to Pclk configuration.
 ** \param[in]  PclkGroupRegIdx    The index number of PCLK Group registers.
 **
 ** \pre  PclkConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPeriClock_Regs(
  P2CONST( Mcu_PclkConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PclkConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  regPclkAddrPtr->CLOCK_CTL[PclkConfigPtr->PclkRegIdx] = PclkConfigPtr->ClockCtlRegVal;

}



/** \brief Mcu_SetDiv80Ctl_Regs
 **
 ** This function sets DIV_8_CTL register of PERI with configuration.
 **
 ** \param[in]  Pclk80DividerConfigPtr   The pointer to Pclk 8 divider configuration.
 ** \param[in]  PclkGroupRegIdx          The index number of PCLK Group registers.
 **
 ** \pre  Pclk80DividerConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDiv80Ctl_Regs(
  P2CONST( Mcu_Pclk80DividerConfigDataType, AUTOMATIC, MCU_APPL_CONST ) Pclk80DividerConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{

  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  if ((regPclkAddrPtr->DIV_8_CTL[Pclk80DividerConfigPtr->Pclk80DividerIdx] &
       MCU_REG_MASK_PERI_DIV_8_CTL_EN) != MCU_REG_MASK_PERI_DIV_8_CTL_EN)
  {
    /* DIV_8_CTL setting */
    regPclkAddrPtr->DIV_8_CTL[Pclk80DividerConfigPtr->Pclk80DividerIdx] =
      ((uint32)Pclk80DividerConfigPtr->Pclk80DividerIntVal <<
      MCU_REG_BIT_PERI_DIV_8_CTL_INT8_DIV);
  }
}


/** \brief Mcu_SetDiv160Ctl_Regs
 **
 ** This function sets DIV_16_CTL register of PERI with configuration.
 **
 ** \param[in]  Pclk160DividerConfigPtr   The pointer to Pclk 16 divider configuration.
 ** \param[in]  PclkGroupRegIdx           The index number of PCLK Group registers.
 **
 ** \pre   Pclk160DividerConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDiv160Ctl_Regs(
  P2CONST( Mcu_Pclk160DividerConfigDataType, AUTOMATIC, MCU_APPL_CONST ) Pclk160DividerConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  if ((regPclkAddrPtr->DIV_16_CTL[Pclk160DividerConfigPtr->Pclk160DividerIdx] &
       MCU_REG_MASK_PERI_DIV_16_CTL_EN) != MCU_REG_MASK_PERI_DIV_16_CTL_EN)
  {
     /* DIV_16_CTL setting */
     regPclkAddrPtr->DIV_16_CTL[Pclk160DividerConfigPtr->Pclk160DividerIdx] =
       ((uint32)Pclk160DividerConfigPtr->Pclk160DividerIntVal <<
       MCU_REG_BIT_PERI_DIV_16_CTL_INT16_DIV);
  }
}


/** \brief Mcu_SetDiv165Ctl_Regs
 **
 ** This function sets DIV_16_5_CTL register of PERI with configuration.
 **
 ** \param[in]  Pclk165DividerConfigPtr   The pointer to Pclk 16.5 divider configuration.
 ** \param[in]  PclkGroupRegIdx           The index number of PCLK Group registers.
 **
 ** \pre   Pclk165DividerConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDiv165Ctl_Regs(
  P2CONST( Mcu_Pclk165DividerConfigDataType, AUTOMATIC, MCU_APPL_CONST ) Pclk165DividerConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  if ((regPclkAddrPtr->DIV_16_5_CTL[Pclk165DividerConfigPtr->Pclk165DividerIdx] &
       MCU_REG_MASK_PERI_DIV_16_5_CTL_EN) != MCU_REG_MASK_PERI_DIV_16_5_CTL_EN)
  {
    /* DIV_165_CTL setting */
    regPclkAddrPtr->DIV_16_5_CTL[Pclk165DividerConfigPtr->Pclk165DividerIdx] = 
      (((uint32)Pclk165DividerConfigPtr->Pclk165DividerIntVal <<
      MCU_REG_BIT_PERI_DIV_16_5_CTL_INT16_DIV) |
      (((uint32)Pclk165DividerConfigPtr->Pclk165DividerFracVal <<
      MCU_REG_BIT_PERI_DIV_16_5_CTL_FRAC5_DIV) &
      MCU_REG_MASK_PERI_DIV_16_5_CTL_FRAC5_DIV));
  }
}


/** \brief Mcu_SetDiv245Ctl_Regs
 **
 ** This function sets DIV_24_5_CTL register of PERI with configuration.
 **
 ** \param[in]  Pclk245DividerConfigPtr   The pointer to Pclk 24.5 divider configuration.
 ** \param[in]  PclkGroupRegIdx           The index number of PCLK Group registers.
 **
 ** \pre  Pclk245DividerConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDiv245Ctl_Regs(
  P2CONST( Mcu_Pclk245DividerConfigDataType, AUTOMATIC, MCU_APPL_CONST ) Pclk245DividerConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  if ((regPclkAddrPtr->DIV_24_5_CTL[Pclk245DividerConfigPtr->Pclk245DividerIdx] &
       MCU_REG_MASK_PERI_DIV_24_5_CTL_EN) != MCU_REG_MASK_PERI_DIV_24_5_CTL_EN)
  {
    /* DIV_245_CTL setting */
    regPclkAddrPtr->DIV_24_5_CTL[Pclk245DividerConfigPtr->Pclk245DividerIdx] =
      ((((uint32)Pclk245DividerConfigPtr->Pclk245DividerFracVal <<
      MCU_REG_BIT_PERI_DIV_24_5_CTL_FRAC5_DIV) &
      MCU_REG_MASK_PERI_DIV_24_5_CTL_FRAC5_DIV) |
      (Pclk245DividerConfigPtr->Pclk245DividerIntVal <<
      MCU_REG_BIT_PERI_DIV_24_5_CTL_INT24_DIV));
  }
}


/** \brief Mcu_SetDivCmd_Regs
 **
 ** This function sets DIV_CMD register of PERI with configuration.
 **
 ** \param[in]  PclkDividerConfigPtr   The pointer to Pclk divider command configuration.
 ** \param[in]  PclkGroupRegIdx        The index number of PCLK Group registers.
 **
 ** \pre  PclkDividerConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDivCmd_Regs(
  P2CONST( Mcu_PclkDividerConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PclkDividerConfigPtr,
  VAR( uint8 , AUTOMATIC ) PclkGroupRegIdx
)
{
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) regDivcmdAddrPtr;
  VAR( boolean, AUTOMATIC ) McuEnDivCmd = FALSE;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupRegIdx]);

  if (PclkDividerConfigPtr->PclkDividerEnable == STD_ON) {
    /* Since DIV_X_CTL.EN is set to disable with Clockshutdown, */
    /* the DIV_X_CTL register whose EN bit is set to enable is not controlled. */
    if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_8)
    {
      if ((regPclkAddrPtr->DIV_8_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
           MCU_REG_MASK_PERI_DIV_8_CTL_EN) != MCU_REG_MASK_PERI_DIV_8_CTL_EN)
      {
        McuEnDivCmd = TRUE;
      }
    }
    else if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_16)
    {
      if ((regPclkAddrPtr->DIV_16_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
           MCU_REG_MASK_PERI_DIV_16_CTL_EN) != MCU_REG_MASK_PERI_DIV_16_CTL_EN)
      {
        McuEnDivCmd = TRUE;
      }
    }
    else if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_16_5)
    {
      if ((regPclkAddrPtr->DIV_16_5_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
           MCU_REG_MASK_PERI_DIV_16_5_CTL_EN) != MCU_REG_MASK_PERI_DIV_16_5_CTL_EN)
      {
        McuEnDivCmd = TRUE;
      }
    }
    else if(PclkDividerConfigPtr->PclkDividerType == MCU_DIV_24_5)
    {
      if ((regPclkAddrPtr->DIV_24_5_CTL[PclkDividerConfigPtr->PclkDividerIdx] &
           MCU_REG_MASK_PERI_DIV_24_5_CTL_EN) != MCU_REG_MASK_PERI_DIV_24_5_CTL_EN)
      {
        McuEnDivCmd = TRUE;
      }
    }
    else
    {
      /* nothing to do */
    }

    if(McuEnDivCmd == TRUE)
    {
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
         Justification: The hardware address is needed to be calculated by pointer arithmetic.
                        And also the hardware access needed to be handled by using pointer. */
      /* PRQA S 303 1 */
      regDivcmdAddrPtr = (volatile uint32 *)((uint32)&regPclkAddrPtr->DIV_CMD + Mcu_RegBaseAddrPtr->DivcmdOffset);
      /* DIV_CMD : execpt ENABLE bit*/
      *regDivcmdAddrPtr = ((uint32)PclkDividerConfigPtr->PclkDividerIdx |
                          (((uint32)PclkDividerConfigPtr->PclkDividerType <<
                          MCU_REG_BIT_PERI_DIV_CMD_TYPE_SEL) &
                          MCU_REG_MASK_PERI_DIV_CMD_TYPE_SEL) |
                          ((uint32)PclkDividerConfigPtr->PclkPaDividerIdx <<
                          MCU_REG_BIT_PERI_DIV_CMD_PA_DIV_SEL) |
                          (((uint32)PclkDividerConfigPtr->PclkPaDividerType <<
                          MCU_REG_BIT_PERI_DIV_CMD_PA_TYPE_SEL) &
                          MCU_REG_MASK_PERI_DIV_CMD_PA_TYPE_SEL) |
                          MCU_REG_VALUE_PERI_DIV_CMD_ENABLE);

      /* dummy read */
      (void)*regDivcmdAddrPtr;
    }
  }
}


/** \brief Mcu_SetPeriGroupClock_Regs
 **
 ** This function sets CLOCK_CTL and SL_CTL register of PERI Group with configuration.
 **
 ** \param[in]  PeriGroupConfigPtr   The pointer to Pclk group clock configuration.
 ** \param[in]  SetFlag              The flag indicating whether the divider to up or down.
 **
 ** \pre  PeriGroupConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPeriGroupClock_Regs(
  P2CONST( Mcu_PeriGroupConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PeriGroupConfigPtr,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_PeriGroupRegType, AUTOMATIC, REGSPACE ) regPeriGroupAddrPtr;
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is needed to be calculated by pointer arithmetic.
                    And also the hardware access needed to be handled by using pointer. */
  /* PRQA S 303 3 */
  regPeriGroupAddrPtr = 
    (volatile Mcu_PeriGroupRegType *)((uint32)&(Mcu_RegBaseAddrPtr->PeriRegBaseAddr->PERI_GROUP[PeriGroupConfigPtr->PeriGroupRegIdx]) + 
                                      (PeriGroupConfigPtr->PeriGroupRegIdx * Mcu_RegBaseAddrPtr->PeriGroupOffset));

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    if( (regPeriGroupAddrPtr->CLOCK_CTL & MCU_REG_MASK_PERIGROUP_CLOCK_CTL_INT8_DIV) >
        (PeriGroupConfigPtr->ClockCtlRegVal & MCU_REG_MASK_PERIGROUP_CLOCK_CTL_INT8_DIV)
      )
    {
      regPeriGroupAddrPtr->CLOCK_CTL = PeriGroupConfigPtr->ClockCtlRegVal;
    }

    regPeriGroupAddrPtr->SL_CTL = 
      ((regPeriGroupAddrPtr->SL_CTL & ~(uint32)PeriGroupConfigPtr->SlCtlRegMask) | PeriGroupConfigPtr->SlCtlRegVal);
  }
  else
  {
    /* set to up clock divider */
    if( (regPeriGroupAddrPtr->CLOCK_CTL & MCU_REG_MASK_PERIGROUP_CLOCK_CTL_INT8_DIV) <
        (PeriGroupConfigPtr->ClockCtlRegVal & MCU_REG_MASK_PERIGROUP_CLOCK_CTL_INT8_DIV)
      )
    {
      regPeriGroupAddrPtr->CLOCK_CTL = PeriGroupConfigPtr->ClockCtlRegVal;
      (void)regPeriGroupAddrPtr->CLOCK_CTL;
    }
  }
}


/** \brief Mcu_SetFllClock_Regs
 **
 ** This function sets FLL clock registers of SRSS with configuration.
 **
 ** \param[in]  FllConfigPtr   The pointer to Fll clock configuration.
 **
 ** \pre  FllConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Clock setting is success.
 ** \retval  MCU_NOT_OK     Clock setting is not success.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetFllClock_Regs(
  P2CONST( Mcu_FllConfigDataType, AUTOMATIC, MCU_APPL_CONST ) FllConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) stubcnt;

  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if((regSrssAddrPtr->CLK_FLL_CONFIG & MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE) !=
      MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE)
  {
    /* Set CLK_FLL_CONFIG4 register except CCO_ENABLE bit */
    regSrssAddrPtr->CLK_FLL_CONFIG4 = (FllConfigPtr->ClkFllConfig4RegVal &
                                      ~(uint32)(MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_ENABLE));
    /* Set CLK_FLL_CONFIG register except FLL_ENABLE bit */
    /* Note: FLL_ENABLE bit is not set to ClkFllConfigRegVal by generate */
    regSrssAddrPtr->CLK_FLL_CONFIG = FllConfigPtr->ClkFllConfigRegVal;
    /* Set CLK_FLL_CONFIG2 register */
    regSrssAddrPtr->CLK_FLL_CONFIG2 = FllConfigPtr->ClkFllConfig2RegVal;
    /* Set CLK_FLL_CONFIG3 register */
    regSrssAddrPtr->CLK_FLL_CONFIG3 = FllConfigPtr->ClkFllConfig3RegVal;
    /* If CCO is enable, enable CCO and FLL w/ waiting for CCO stabilization */
    if ((FllConfigPtr->ClkFllConfig4RegVal & 
         MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_ENABLE) == 
         MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_ENABLE)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_FLL_CONFIG;
      (void)regSrssAddrPtr->CLK_FLL_CONFIG2;
      (void)regSrssAddrPtr->CLK_FLL_CONFIG3;
      (void)regSrssAddrPtr->CLK_FLL_CONFIG4;

      /* Set CCO_ENABLE of CLK_FLL_CONFIG4 register */
      regSrssAddrPtr->CLK_FLL_CONFIG4 |= MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_ENABLE;
    }
    /* If FLL enable, it is necessary to wait CCO stabilization */
    /* Note: If FLL is enabled CCO is also enabled */
    /*       because it is checked by configuration */
    if (FllConfigPtr->FllEn == STD_ON)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_FLL_CONFIG4;
      /* Set CCO stabilization wait counter value */
      if (FllConfigPtr->FllCcoStabToCnt == 0U)
      {
        /* CCO_READY is checked at least 1 time */
        /* even if CCO stabilization wait is disabled */
        /* because FLL shall be enabled after CCO_READY */
        stubcnt = 1U;
      }
      else
      {
        stubcnt = FllConfigPtr->FllCcoStabToCnt;
      }
      /* set return value MCU_NOT_OK */
      retVal = MCU_NOT_OK;
      /* Waiting for CCO_READY bit is set */
      do
      {
        if(( regSrssAddrPtr->CLK_FLL_STATUS & MCU_REG_MASK_SRSS_CLK_FLL_STATUS_CCO_READY ) ==
          MCU_REG_MASK_SRSS_CLK_FLL_STATUS_CCO_READY)
        {
          /* Set ENABLE bit of CLK_FLL_CONFIG register */
          regSrssAddrPtr->CLK_FLL_CONFIG |= MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE;
          /* Update the FLL bypass wait cycle */
          Mcu_SetFllBypassWaitCycle(FllConfigPtr->FllBypassWaitCycle);
          /* set return value MCU_OK */
          retVal = MCU_OK;
          break;
        }
        stubcnt--;
      }
      while(stubcnt > 0U );
    }
    
  }

  return retVal;
}


/** \brief Mcu_SetPllClock_Regs
 **
 ** This function sets PLL clock register of SRSS with configuration.
 **
 ** \param[in]  PllConfigPtr   The pointer to Pll clock configuration.
 **
 ** \pre  PllConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPllClock_Regs(
  P2CONST( Mcu_PllConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PllConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if( (regSrssAddrPtr->CLK_PLL_CONFIG[PllConfigPtr->PllRegIdx] &
    MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE) !=
    MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE)
  {
    /* Set CLK_PLL_CONFIG register except ENABLE bit */
    regSrssAddrPtr->CLK_PLL_CONFIG[PllConfigPtr->PllRegIdx] =
      PllConfigPtr->ClkPllConfigRegVal;

    if (PllConfigPtr->PllEn == STD_ON)
    {
      /* dummy read */
      (void)regSrssAddrPtr->CLK_PLL_CONFIG[PllConfigPtr->PllRegIdx];
      /* ENABLE bit set */
      regSrssAddrPtr->CLK_PLL_CONFIG[PllConfigPtr->PllRegIdx] |=
        MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE;
      /* Update the PLL bypass wait cycle */
      Mcu_SetPllBypassWaitCycle(PllConfigPtr->PllRegIdx, PllConfigPtr->PllBypassWaitCycle);
    }
  }
}


/** \brief Mcu_SetSscgClock_Regs
 **
 ** This function sets SSCG clock register of SRSS with configuration.
 **
 ** \param[in]  SscgConfigPtr  The pointer to SSCG clock configuration.
 **
 ** \pre  SscgConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetSscgClock_Regs(
  P2CONST( Mcu_SscgConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SscgConfigPtr
)
{
  P2VAR( volatile Mcu_SscgRegType, AUTOMATIC, REGSPACE ) regSscgAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  /* Get SSCG base address pointer */
  regSscgAddrPtr = &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PLL400_STRUCT[SscgConfigPtr->SscgRegIdx]);

  /* SSCG is disabled */
  if((regSscgAddrPtr->PLL400_STRUCT_CONFIG &
      MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE) !=
      MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE)
  {
    /* Set PLL400_STRUCT.CONFIG register except ENABLE bit */
    regSscgAddrPtr->PLL400_STRUCT_CONFIG = SscgConfigPtr->Pll400ConfigRegVal;
    /* Set PLL400_STRUCT.CONFIG2 register */
    regSscgAddrPtr->PLL400_STRUCT_CONFIG2 = SscgConfigPtr->Pll400Config2RegVal;
    /* Set PLL400_STRUCT.CONFIG3 register */
    regSscgAddrPtr->PLL400_STRUCT_CONFIG3 = SscgConfigPtr->Pll400Config3RegVal;

    if (SscgConfigPtr->SscgEn == STD_ON)
    {
      /* dummy read */
      (void)regSscgAddrPtr->PLL400_STRUCT_CONFIG;
      (void)regSscgAddrPtr->PLL400_STRUCT_CONFIG2;
      (void)regSscgAddrPtr->PLL400_STRUCT_CONFIG3;
      /* ENABLE bit set */
      regSscgAddrPtr->PLL400_STRUCT_CONFIG |=
        MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE;
      /* Update the PLL bypass wait cycle */
      Mcu_SetSscgBypassWaitCycle(
        SscgConfigPtr->SscgRegIdx, 
        SscgConfigPtr->SscgBypassWaitCycle
      );
    }
  }
  /* SSCG is already enabled */
  else
  {
    /* Only update the fractional divider */
    if ((regSscgAddrPtr->PLL400_STRUCT_CONFIG & 
         MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_FEEDBACK_DIV) == 
        (SscgConfigPtr->Pll400ConfigRegVal & 
         MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_FEEDBACK_DIV))
    {
      /* Set PLL400_STRUCT.CONFIG2.FRAC_DIV */
      regVal = regSscgAddrPtr->PLL400_STRUCT_CONFIG2;
      regVal &= ~(uint32)MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG2_FRAC_DIV;
      regVal |= (SscgConfigPtr->Pll400Config2RegVal & 
                 MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG2_FRAC_DIV);
      regSscgAddrPtr->PLL400_STRUCT_CONFIG2 = regVal;
      /* dummy read */
      (void)regSscgAddrPtr->PLL400_STRUCT_CONFIG2;
    }
  }
}


/** \brief Mcu_PreSetRootSelect_Regs
 **
 ** This function presets clock root setting register of SRSS for accessing another HW IP.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer. **
 */
FUNC( void, MCU_CODE ) 
Mcu_PreSetRootSelect_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  P2CONST( Mcu_ClockRootConfigDataType, MCU_CONST, MCU_APPL_CONST ) clkRootConfigPtr;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint8, AUTOMATIC ) cfgIdx;

  /* Get SRSS register base address */
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* Set clock root settings if clock root is not enabled yet */
  for (cfgIdx=0U; cfgIdx<McuClockConfigPtr->ClockRootConfigNum; cfgIdx++ )
  {
    clkRootConfigPtr = &(McuClockConfigPtr->ClockRootConfigPtr[cfgIdx]);
    /* Get CLK_ROOT_SELECT register value */
    regVal = regSrssAddrPtr->CLK_ROOT_SELECT[clkRootConfigPtr->ClockRootRegIdx];

    /* Only if clock root is not enabled yet, then update CLK_ROOT_SELECT register */
    if ((regVal & MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ENABLE) != 
         MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ENABLE)
    {
      /* If the clock path for the clock root is not set yet, default (IMO) setting is applied */
      regSrssAddrPtr->CLK_ROOT_SELECT[clkRootConfigPtr->ClockRootRegIdx] = 
        ((clkRootConfigPtr->ClkRootSelectRegVal & ~(uint32)MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_MUX) |
         McuClockConfigPtr->ClockPathLastIdx);
      (void)regSrssAddrPtr->CLK_ROOT_SELECT[clkRootConfigPtr->ClockRootRegIdx];
    }
    else
    {
      /* IF FLL is disabled, FLL cannot be configured as source of clock root. */
      /* So, if FLL is needed to be disabled, source of clock root must be switched from FLL to other source. */
      if ((McuClockConfigPtr->FllConfigPtr != NULL_PTR) && (McuClockConfigPtr->FllConfigPtr->FllStopEnable == STD_ON))
      {
        if ((regVal & MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_MUX) == 
            MCU_REG_VALUE_SRSS_CLK_ROOT_SELECT_ROOT_MUX_PATH0)
        {
          /* If current source of clock root is FLL, then it is switched to last PATH tempolary */
          /* Note: Last path is directly routed from some oscillator. */
          /*       So its frequency doesn't exceed the maximum frequency of each supplied clock */
          regSrssAddrPtr->CLK_ROOT_SELECT[clkRootConfigPtr->ClockRootRegIdx] = 
            (regVal | McuClockConfigPtr->ClockPathLastIdx);
          (void)regSrssAddrPtr->CLK_ROOT_SELECT[clkRootConfigPtr->ClockRootRegIdx];
        }
      }
    }
  }
}


/** \brief Mcu_SetRootSelect_Regs
 **
 ** This function sets clock Root setting register of SRSS with configuration.
 **
 ** \param[in]  ClockRootConfigPtr   The pointer to clock Root configuration.
 **
 ** \pre  ClockRootConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetRootSelect_Regs(
  P2CONST( Mcu_ClockRootConfigDataType, AUTOMATIC, MCU_APPL_CONST ) ClockRootConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) regUpdate;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;
  
  regVal = regSrssAddrPtr->CLK_ROOT_SELECT[ClockRootConfigPtr->ClockRootRegIdx];
  /* set to down clock divider */
  if((regVal & MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV) > 
     (ClockRootConfigPtr->ClkRootSelectRegVal & MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV)
    )
  {
    regSrssAddrPtr->CLK_ROOT_SELECT[ClockRootConfigPtr->ClockRootRegIdx] = 
    ClockRootConfigPtr->ClkRootSelectRegVal;
  }
  else
  {
    /* up clock divider -> not change ROOT_DIV bit setting */
    regVal &= MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV;
    regUpdate = ClockRootConfigPtr->ClkRootSelectRegVal &
                ~(uint32)MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV;
    regUpdate |= regVal;
    
    regSrssAddrPtr->CLK_ROOT_SELECT[ClockRootConfigPtr->ClockRootRegIdx] = regUpdate;
  }

}


/** \brief Mcu_SscgLockWait_Regs
 **
 ** This function waits for SSCG lock.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \retval MCU_OK      SSCG status is locked.
 ** \retval MCU_NOT_OK  SSCG status is not locked.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SscgLockWait_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal= MCU_OK;
  VAR( uint8, AUTOMATIC ) cfgIdx, cnt;

  /* If SscgStabToCnt is 0U, this function returns MCU_OK */
  /* because it is not necessary to wait PLL lock for subsequent processes */
  for(cfgIdx=0U; cfgIdx<McuClockConfigPtr->SscgConfigNum; cfgIdx++ )
  {
    for (cnt = 0U; cnt < McuClockConfigPtr->SscgConfigPtr[cfgIdx].SscgStabToCnt; cnt++)
    {
      retVal = Mcu_GetEachSscgLockStatus_Regs(
                 &(McuClockConfigPtr->SscgConfigPtr[cfgIdx])
               );
      if (retVal == MCU_OK)
      {
        break;
      }
    }
    if (retVal == MCU_NOT_OK)
    {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_PllLockWait_Regs
 **
 ** This function waits for Pll lock.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \retval MCU_OK      PLL status is locked.
 ** \retval MCU_NOT_OK  PLL status is not locked.
 */
FUNC(  Mcu_ReturnType, MCU_CODE ) 
Mcu_PllLockWait_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal= MCU_OK;
  VAR( uint8, AUTOMATIC ) i, cnt;

  /* If PllStabToCnt is 0U, this function returns MCU_OK */
  /* because it is not necessary to wait PLL lock for subsequent processes */
  for(i= 0U; i<McuClockConfigPtr->PllConfigNum; i++ )
  {
    for (cnt = 0U; cnt < McuClockConfigPtr->PllConfigPtr[i].PllStabToCnt; cnt++)
    {
      retVal = Mcu_GetEachPllLockStatus_Regs(
                 &(McuClockConfigPtr->PllConfigPtr[i])
               );
      if (retVal == MCU_OK)
      {
        break;
      }
    }
    if (retVal == MCU_NOT_OK)
    {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_FllLockWait_Regs
 **
 ** This function waits for Fll lock.
 **
 ** \param[in]  FllConfigPtr    The pointer to FLL clock configuration.
 **
 ** \retval MCU_OK      FLL status is locked.
 ** \retval MCU_NOT_OK  FLL status is not locked.
 */
FUNC(  Mcu_ReturnType, MCU_CODE ) 
Mcu_FllLockWait_Regs(
  P2CONST( Mcu_FllConfigDataType, AUTOMATIC, MCU_APPL_CONST ) FllConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint8, AUTOMATIC ) cnt;

  /* If FllStabToCnt is 0U, this function returns MCU_OK */
  /* because it is not necessary to wait FLL lock for subsequent processes */
  for (cnt = 0U; cnt < FllConfigPtr->FllStabToCnt; cnt++)
  {
    retVal = Mcu_GetFllLockStatus_Regs(FllConfigPtr);
    if (retVal == MCU_OK)
    {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_GetSscgLockStatus_Regs
 **
 ** This function gets SSCG lock status from PLL400_STRUCT.STATUS register.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \retval MCU_OK      SSCG status is locked.
 ** \retval MCU_NOT_OK  SSCG status is not locked.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_GetSscgLockStatus_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal= MCU_OK;
  VAR( uint8, AUTOMATIC ) cfgIdx;

  for(cfgIdx=0U; cfgIdx<McuClockConfigPtr->SscgConfigNum; cfgIdx++ )
  {
    retVal = Mcu_GetEachSscgLockStatus_Regs(
               &(McuClockConfigPtr->SscgConfigPtr[cfgIdx])
             );
    if (retVal == MCU_NOT_OK)
    {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_GetPllLockStatus_Regs
 **
 ** This function gets Pll lock status from CLK_PLL_STATUS register.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \retval MCU_OK      PLL status is locked.
 ** \retval MCU_NOT_OK  PLL status is not locked.
 */
FUNC(  Mcu_ReturnType, MCU_CODE ) 
Mcu_GetPllLockStatus_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal= MCU_OK;
  VAR( uint8, AUTOMATIC ) i;

  for(i= 0U; i<McuClockConfigPtr->PllConfigNum; i++ )
  {
    retVal = Mcu_GetEachPllLockStatus_Regs(
               &(McuClockConfigPtr->PllConfigPtr[i])
             );
    if (retVal == MCU_NOT_OK)
    {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_GetFllLockStatus_Regs
 **
 ** This function gets Fll lock status from CLK_FLL_STATUS register.
 **
 ** \param[in]  FllConfigPtr    The pointer to Fll clock configuration.
 **
 ** \retval MCU_OK      FLL status is locked.
 ** \retval MCU_NOT_OK  FLL status is not locked.
 */
FUNC(  Mcu_ReturnType, MCU_CODE ) 
Mcu_GetFllLockStatus_Regs(
  P2CONST( Mcu_FllConfigDataType, AUTOMATIC, MCU_APPL_CONST ) FllConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* CLK_FLL_STATUS check: LOCKED bit*/
  if(FllConfigPtr->FllEn == STD_ON)
  {
    if((regSrssAddrPtr->CLK_FLL_STATUS & MCU_REG_MASK_SRSS_CLK_FLL_STATUS_LOCKED) ==
      MCU_REG_MASK_SRSS_CLK_FLL_STATUS_LOCKED)
    {
      /* Set result OK */
      retVal = MCU_OK;
    }
    else
    {
      /* Set result Not OK */
      retVal = MCU_NOT_OK;
    }
  }
  else
  {
    /* FLL is disable -> return MCU_OK */
    retVal = MCU_OK;
  }
  return retVal;
}


/** \brief Mcu_SetSscgClockOut_Regs
 **
 ** This function sets BYPASS_SEL bit of PLL400_STRUCT.CONFIG register to PLL_OUT.
 **
 ** \param[in]  RegIndex  The index number of PLL400_STRUCT register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetSscgClockOut_Regs(
  VAR( uint32, AUTOMATIC ) RegIndex
)
{
  P2VAR( volatile Mcu_SscgRegType, AUTOMATIC, REGSPACE ) regSscgAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  /* Get SSCG base address pointer */
  regSscgAddrPtr = 
    &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PLL400_STRUCT[RegIndex]);

  regVal = regSscgAddrPtr->PLL400_STRUCT_CONFIG;

  if((regVal & MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL) ==
      MCU_REG_VALUE_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL_PLL_REF)
  {
    /* if BYPASS_SEL bit is AUTO or OUT setting, Register setting is not set. */
    regVal &= ~(uint32)MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL;
    regVal |= MCU_REG_VALUE_SRSS_PLL400_STRUCT_CONFIG_BYPASS_SEL_PLL_OUT;
    regSscgAddrPtr->PLL400_STRUCT_CONFIG = regVal;
  }
}


/** \brief Mcu_SetPllClockOut_Regs
 **
 ** This function sets BYPASS_SEL bit of CLK_PLL_CONFIG register to PLL_OUT.
 **
 ** \param[in]  RegIndex  The index number of CLK_PLL_CONFIG register.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPllClockOut_Regs(
  VAR( uint32, AUTOMATIC ) RegIndex
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) PllConfigRegval;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;
  PllConfigRegval = regSrssAddrPtr->CLK_PLL_CONFIG[RegIndex];

  if((PllConfigRegval & MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_BYPASS_SEL) ==
      MCU_REG_VALUE_SRSS_CLK_PLL_CONFIG_BYPASS_SEL_PLL_REF)
  {
    /* if BYPASS_SEL bit is AUTO or OUT setting, Register setting is not set. */
    PllConfigRegval = (PllConfigRegval & 
                      ~(uint32)MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_BYPASS_SEL) |
                      MCU_REG_VALUE_SRSS_CLK_PLL_CONFIG_BYPASS_SEL_PLL_OUT;

    regSrssAddrPtr->CLK_PLL_CONFIG[RegIndex] = PllConfigRegval;
  }
}


/** \brief Mcu_SetFllClockOut_Regs
 **
 ** This function sets BYPASS_SEL bit of CLK_FLL_CONFIG3 register to FLL_OUT.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetFllClockOut_Regs( void )
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) FllConfig3Regval;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;
  FllConfig3Regval = regSrssAddrPtr->CLK_FLL_CONFIG3;

  if((FllConfig3Regval & MCU_REG_MASK_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL) ==
      MCU_REG_VALUE_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL_FLL_REF)
  {
    /* if BYPASS_SEL bit is AUTO or OUT setting, Register setting is not set. */
    FllConfig3Regval = (FllConfig3Regval &
                       ~(uint32)MCU_REG_MASK_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL) |
                       MCU_REG_VALUE_SRSS_CLK_FLL_CONFIG3_BYPASS_SEL_FLL_OUT;

    regSrssAddrPtr->CLK_FLL_CONFIG3 = FllConfig3Regval;
  }
}


/** \brief Mcu_Reset_Regs
 **
 ** This function sets reset register.
 **
 ** \param[in]  McuRegReset  Kind of reset for performing reset.
 */
FUNC( void, MCU_CODE ) 
Mcu_Reset_Regs( 
  VAR( Mcu_RegResetType, AUTOMATIC ) McuRegReset
)
{
  if (McuRegReset == MCU_REG_RESET_TYPE_SW) {
    /* register setting : Unlock Key and reset trigger value */
    Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->AIRCR = 
     (MCU_REG_VALUE_SYSTEM_CM4_SCS_AIRCR_VECTKEY |
     MCU_REG_MASK_SYSTEM_CM4_SCS_AIRCR_SYSRESETREQ);
  }

  return;
}


/** \brief Mcu_GetRawResetReason_Regs
 **
 ** This function returns values of the reset reason registers.
 **
 ** \param[out]  McuRawResetReasonPtr  The pointer to store raw values of the reset reason registers.
 **
 ** \pre  McuRawResetReasonPtr shall not be a NULL pointer.
 */
FUNC( void, MCU_CODE ) 
Mcu_GetRawResetReason_Regs( 
  P2VAR( Mcu_RegRawResetType, AUTOMATIC, REGSPACE ) McuRawResetReasonPtr
)
{
  /* Get RSTCAUSE register value */
  McuRawResetReasonPtr->Reset = (Mcu_RegBaseAddrPtr->SrssRegBaseAddr->RES_CAUSE);

  /* Get RSTCAUSE2 register value */
  McuRawResetReasonPtr->Reset2 = (Mcu_RegBaseAddrPtr->SrssRegBaseAddr->RES_CAUSE2);

  return;
}


/** \brief Mcu_GetResetReasonFromRaw_Regs
 **
 ** This function converts register value to reset reason and returns reset reason value.
 **
 ** \param[in]  McuRawResetReasonPtr  The pointer to raw values of the reset reason registers.
 **
 ** \pre  Mcu_GetRawResetReason_Regs() is called before.
 **
 ** \return  Reset reason value.
 */
FUNC( Mcu_ResetType, MCU_CODE ) 
Mcu_GetResetReasonFromRaw_Regs( 
  P2CONST( Mcu_RegRawResetType, AUTOMATIC, MCU_CONST ) McuRawResetReasonPtr
)
{
  VAR( Mcu_ResetType, AUTOMATIC) retVal = MCU_RESET_UNDEFINED;

  /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-1.1
     Justification: The reset cause register has many fields and must be checked exclusively. */
  /* PRQA S 715 ++ */
  if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE) != 
       MCU_REG_VALUE_SRSS_RES_CAUSE_ALL0) {
    /* A basic WatchDog Timer (WDT) reset */
    if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_WDT) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_WDT) {
      retVal = MCU_WATCHDOG_RESET;
    }
    /* Fault logging system from Active logic reset */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_ACT_FAULT) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_ACT_FAULT) {
      retVal = MCU_ACT_FAULT_RESET;
    }
    /* Fault logging system requested from DeepSleep logic reset */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_DPSLP_FAULT) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_DPSLP_FAULT) {
      retVal = MCU_DPSLP_FAULT_RESET;
    }
    /* Test controller or debugger asserted reset */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_TC_DBGRESET) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_TC_DBGRESET) {
      retVal = MCU_TEST_DEBUG_RESET;
    }
    /* CPU requested system reset */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_SOFT) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_SOFT) {
      retVal = MCU_SW_RESET;
    }
    /* Multi-Counter Watchdog timer reset #0 */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT0) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT0) {
      retVal = MCU_MCWDT0_RESET;
    }
    /* Multi-Counter Watchdog timer reset #1 */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT1) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT1) {
      retVal = MCU_MCWDT1_RESET;
    }
    /* Multi-Counter Watchdog timer reset #2 */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT2) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT2) {
      retVal = MCU_MCWDT2_RESET;
    }
    /* Multi-Counter Watchdog timer reset #3 */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT3) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_MCWDT3) {
      retVal = MCU_MCWDT3_RESET;
    }
    /* External XRES pin was asserted */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_XRES) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_XRES) {
      retVal = MCU_XRES_RESET;
    }
    /* External VDDD supply crossed brown-out limit */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVDDD) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVDDD) {
      retVal = MCU_BOD_VDDD_RESET;
    }
    /* External VDDA supply crossed the brown-out limit */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVDDA) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVDDA) {
      retVal = MCU_BOD_VDDA_RESET;
    }
    /* Internal VCCD core supply crossed the brown-out limit */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVCCD) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_BODVCCD) {
      retVal = MCU_BOD_VCCD_RESET;
    }
    /* Overvoltage detection on the external VDDD supply */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVDDD) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVDDD) {
      retVal = MCU_OVD_VDDD_RESET;
    }
    /* Overvoltage detection on the external VDDA supply */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVDDA) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVDDA) {
      retVal = MCU_OVD_VDDA_RESET;
    }
    /* Overvoltage detection on the internal core VCCD supply */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVCCD) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OVDVCCD) {
      retVal = MCU_OVD_VCCD_RESET;
    }
    /* Overcurrent detection on the internal VCCD supply when supplied by the ACTIVE power mode linear regulator */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_ACT_LINREG) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_ACT_LINREG) {
      retVal = MCU_OCD_ACTIVE_REGULATOR_RESET;
    }
    /* Overcurrent detection on the internal VCCD supply when supplied by the DEEPSLEEP power mode linear regulator */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_DPSLP_LINREG) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_DPSLP_LINREG) {
      retVal = MCU_OCD_DEEPSLEEP_REGULATOR_RESET;
    }
    /* Overcurrent detection from REGHC */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_REGHC) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_OCD_REGHC) {
      retVal = MCU_REGHC_OCD_RESET;
    }
    /* PMIC status triggered a reset */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_PMIC) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_PMIC) {
      retVal = MCU_REGHC_PMIC_RESET;
    }
    /* PXRES triggered */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_PXRES) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_PXRES) {
      retVal = MCU_PXRES_RESET;
    }
    /* Structural reset was asserted */
    else if ((McuRawResetReasonPtr->Reset & MCU_REG_MASK_SRSS_RES_CAUSE_RESET_STRUCT_XRES) == 
         MCU_REG_MASK_SRSS_RES_CAUSE_RESET_STRUCT_XRES) {
      retVal = MCU_STRUCTURAL_XRES_RESET;
    }
    /* Power On Reset */
    else {
      retVal = MCU_POWER_ON_RESET;
    }
  }
  else if ((McuRawResetReasonPtr->Reset2 & MCU_REG_MASK_SRSS_RES_CAUSE2) != 
            MCU_REG_VALUE_SRSS_RES_CAUSE2_ALL0) {
    /* Clock supervision logic requested a reset due to loss or frequency violation of a high-frequency clock */
    if ((McuRawResetReasonPtr->Reset2 & MCU_REG_MASK_SRSS_RES_CAUSE2_RESET_CSV_HF) != 
       MCU_REG_VALUE_SRSS_RES_CAUSE2_ALL0) {
      retVal = MCU_CSV_HF_RESET;
    }
    /* Clock supervision logic requested a reset due to loss or frequency violation of the reference clock source
       that is used to monitor the other HF clock sources */
    else {
      retVal = MCU_CSV_REF_RESET;
    }
  }
  else {
    P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
    regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

    /* Wakeup from hibernate mode */
    if ((regSrssAddrPtr->PWR_HIBERNATE & MCU_REG_VALUE_SRSS_PWR_HIBERNATE_TOKEN_VALID) == 
       MCU_REG_VALUE_SRSS_PWR_HIBERNATE_TOKEN_VALID) {
      retVal = MCU_WAKEUP_RESET;
    }
  }
  /* PRQA S 715 -- */

  return retVal;
}


/** \brief Mcu_ClearResetReason_Regs
 **
 ** This function clears values of the reset reason registers.
 */
FUNC( void, MCU_CODE ) 
Mcu_ClearResetReason_Regs( void )
{
  /* Clear RES_CAUSE register */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->RES_CAUSE = 
    MCU_REG_VALUE_SRSS_RES_CAUSE_CLEAR_ALL;

  /* Clear RES_CAUSE2 register */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->RES_CAUSE2 = 
    MCU_REG_VALUE_SRSS_RES_CAUSE2_CLEAR_ALL;

  return;
}


/** \brief Mcu_SetLvdCtl_Regs
 **
 ** This function sets low voltage detector registers.
 **
 ** \param[in]  SysResConfigPtr  The pointer to system resources configuration.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetLvdCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i;
  VAR( uint32, AUTOMATIC ) intMask;
  P2CONST( Mcu_HvLvdConfigDataType, MCU_CONST, MCU_APPL_CONST ) hvLvdConfigPtr;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) regAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  for(i= 0U; i<SysResConfigPtr->HvLvdConfigNum; i++ )
  {
    hvLvdConfigPtr = &(SysResConfigPtr->HvLvdConfigPtr[i]);
    intMask = ((uint32)MCU_REG_MASK_SRSS_INTR_MASK_BIT0 << hvLvdConfigPtr->LvdType);
    /* Get register address */
    if ( hvLvdConfigPtr->LvdType == MCU_HVLVD_HVLVD1)
    {
      regAddrPtr = (volatile uint32*)&(regSrssAddrPtr->PWR_LVD_CTL);
    }
    else
    {
      regAddrPtr = (volatile uint32*)&(regSrssAddrPtr->PWR_LVD_CTL2);
    }

    if (hvLvdConfigPtr->LvdStopEnable == STD_ON)
    {
      /* Clear HVLVD_EN_HT and HVLVD_DPSLP_EN_HT bits of LVD control register */
      *regAddrPtr &= ~(uint32)(MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_EN_HT | 
                               MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_DPSLP_EN_HT);
    }

    if ((*regAddrPtr & MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_EN_HT) == 0U)
    {
      /* Set LVD control register except HVLVD_EN_HT and HVLVD_DPSLP_EN_HT bits */
      *regAddrPtr = hvLvdConfigPtr->PwrLvdCtlRegVal;

      if (hvLvdConfigPtr->LvdEn == STD_ON)
      {
        /* Clear mask interrupt bit of SRSS_INTR_MASK register */
        regSrssAddrPtr->SRSS_INTR_MASK &= ~(uint32)intMask;
        /* dummy read */
        (void)regSrssAddrPtr->SRSS_INTR_MASK;

        /* Set HVLVD_EN_HT bits of LVD control register */
        *regAddrPtr |= MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_EN_HT;

        if (hvLvdConfigPtr->LvdDpSlpEn == STD_ON) {
          /* Set HVLVD_DPSLP_EN_HT bits of LVD control register */
          *regAddrPtr |= MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_DPSLP_EN_HT;
        }
      }
    }

    if (hvLvdConfigPtr->IntEn == STD_ON) {
      if ((regSrssAddrPtr->SRSS_INTR_MASK & intMask) == 0U) {
        /* Clear interrupt bit of SRSS_INTR register */
        regSrssAddrPtr->SRSS_INTR = 
          ((uint32)MCU_REG_MASK_SRSS_INTR_BIT0 << hvLvdConfigPtr->LvdType);
        /* dummy read */
        (void)regSrssAddrPtr->SRSS_INTR;
        /* Set mask interrupt bit of SRSS_INTR_MASK register */
        regSrssAddrPtr->SRSS_INTR_MASK |= intMask;
      }
    }
    else {
      /* Clear mask interrupt bit of SRSS_INTR_MASK register */
      regSrssAddrPtr->SRSS_INTR_MASK &= ~(uint32)intMask;
      /* dummy read */
      (void)regSrssAddrPtr->SRSS_INTR_MASK;
    }
  }

  return;
}


/** \brief Mcu_SetSrssPowerCtl_Regs
 **
 ** This function sets srss power control registers.
 **
 ** \param[in]  SysResConfigPtr  The pointer to system resources configuration.
 **
 ** \pre  SysResConfigPtr shall not be a NULL pointer.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetSrssPowerCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regValue;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* Get PWR_CTL2 register value */
  regValue = regSrssAddrPtr->PWR_CTL2;

  /* Clear update field of PWR_CTL2 register */
  regValue &= ~(uint32)(SysResConfigPtr->PwrCtlRegMask);

  /* Set PWR_CTL2 register */
  regSrssAddrPtr->PWR_CTL2 = (regValue | SysResConfigPtr->PwrCtlRegVal);

  return;
}


/** \brief Mcu_SetSsvCtl_Regs
 **
 ** This function sets supply supervision control register.
 **
 ** \param[in]  SsvCtlRegVal  The value to set PWR_SSV_CTL register.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetSsvCtl_Regs(
  VAR( uint32, AUTOMATIC ) SsvCtlRegVal
)
{
  VAR( uint32, AUTOMATIC ) regValue;

  /* Get PWR_SSV_CTL register value */
  regValue = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL;

  /* Check whether BODVDDA_VSEL is updated */
  if ((regValue & MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_VSEL) != 
      (SsvCtlRegVal & MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_VSEL)) {
    /* If BODVDDA_VSEL is updated, disable BODVDDA once */
    /* Set BODVDDA_ACTION = NOTHING */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL 
      &= ~(uint32)MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_ACTION;
    /* BODVDDA disable */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL 
      &= ~(uint32)MCU_REG_MASK_SRSS_PWR_SSV_CTL_BODVDDA_ENABLE;
  }
  if ((regValue & MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_VSEL) != 
      (SsvCtlRegVal & MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_VSEL)) {
    /* If OVDVDDA_VSEL is updated, disable OVDVDDA once */
    /* Set OVDVDDA_ACTION = NOTHING */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL 
      &= ~(uint32)MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_ACTION;
    /* OVDVDDA disable */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL 
      &= ~(uint32)MCU_REG_MASK_SRSS_PWR_SSV_CTL_OVDVDDA_ENABLE;
  }
  /* dummy read */
  (void)Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL;

  /* Set PWR_SSV_CTL register */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL = SsvCtlRegVal;

  return;
}


/** \brief Mcu_SetDmaCtl_Regs
 **
 ** This function sets DMA control registers.
 **
 ** \param[in]  McuDmaConfigPtr  The pointer to DMA configuration.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetDmaCtl_Regs(
  P2CONST( Mcu_DmaConfigDataType, AUTOMATIC, MCU_APPL_CONST ) McuDmaConfigPtr
)
{
  if ((McuDmaConfigPtr->DmaValidFlag & MCU_DMA_VALID_FLAG_DW0_VALID) != 0U) {
    /* Set DW0 CTL register */
    if (McuDmaConfigPtr->Dw0En == STD_ON) {
      /* Set ENABLED bit of DW0_CTL register */
      Mcu_RegBaseAddrPtr->Dw0RegBaseAddr->DW_CTL |= MCU_REG_MASK_DW_CTL_ENABLED;
    } else {
      /* Clear ENABLED bitof DW0_CTL register  */
      Mcu_RegBaseAddrPtr->Dw0RegBaseAddr->DW_CTL &= ~MCU_REG_MASK_DW_CTL_ENABLED;
    }
  }
  if ((McuDmaConfigPtr->DmaValidFlag & MCU_DMA_VALID_FLAG_DW1_VALID) != 0U) {
    /* Set DW1 CTL register */
    if (McuDmaConfigPtr->Dw1En == STD_ON) {
      /* Set ENABLED bit of DW1_CTL register */
      Mcu_RegBaseAddrPtr->Dw1RegBaseAddr->DW_CTL |= MCU_REG_MASK_DW_CTL_ENABLED;
    } else {
      /* Clear ENABLED bit of DW1_CTL register  */
      Mcu_RegBaseAddrPtr->Dw1RegBaseAddr->DW_CTL &= ~MCU_REG_MASK_DW_CTL_ENABLED;
    }
  }
  if ((McuDmaConfigPtr->DmaValidFlag & MCU_DMA_VALID_FLAG_DMA_VALID) != 0U) {
    /* Set DMAC CTL register */
    if (McuDmaConfigPtr->DmaEn == STD_ON) {
      /* Set ENABLED bit of DMAC_CTL register */
      Mcu_RegBaseAddrPtr->DmaRegBaseAddr->DMAC_CTL |= MCU_REG_MASK_DMAC_CTL_ENABLED;
    } else {
      /* Clear ENABLED bit of DMAC_CTL register  */
      Mcu_RegBaseAddrPtr->DmaRegBaseAddr->DMAC_CTL &= ~MCU_REG_MASK_DMAC_CTL_ENABLED;
    }
  }

  return;
}


/** \brief Mcu_SetSleepTrigger_Regs
 **
 ** This function sets sleep settings to registers.
 **
 ** \param[in]  ScrRegVal      Specific system control register value.
 ** \param[in]  LowPwrTransEn  The enable flag of low power transition.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 5 */
FUNC( void, MCU_CODE ) 
Mcu_SetSleepTrigger_Regs(
  VAR( uint32, AUTOMATIC ) ScrRegVal,
  VAR( uint8, AUTOMATIC ) LowPwrTransEn
)
{
  /* Clear HIBERNATE bit of PWR_HIBERNATE register */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE &= 
   ~(uint32)MCU_REG_MASK_SSRS_PWR_HIBERNATE_HIBERNATE;

  /* Set CM0/CM4_SCS.SCR register */
  Mcu_RegBaseAddrPtr->Cm0ScsRegBaseAddr->SCR = ScrRegVal;

  (void)Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE;

  if (LowPwrTransEn == STD_ON) {
    /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
       Justification: Inline assembler code is necessary. */
    /* PRQA S 1006 1 */
    __asm("WFI");
  }

  return;
}


/** \brief Mcu_SetRamPwrCtl_Regs
 **
 ** This function sets RAM power control registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetRamPwrCtl_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) cnt;
  VAR( uint32, AUTOMATIC ) regValue;
  VAR( uint8, AUTOMATIC ) regIndex;

  /* Set RAM power up delay control register */
  Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM_PWR_DELAY_CTL = 
    McuModeConfigPtr->RamPwrDelayCtl;

  /* Set RAM0 power control registers */
  for (cnt = 0U; cnt < McuModeConfigPtr->Ram0PwrMacroConfigNum; cnt++) {
    regValue = McuModeConfigPtr->Ram0PwrMacroConfigPtr[cnt].Ram0PwrMacroCtlRegVal;
    regIndex = McuModeConfigPtr->Ram0PwrMacroConfigPtr[cnt].Ram0PwrMacroRegIdx;

    Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_PWR_MACRO_CTL[regIndex] = regValue;
  }

  /* If RAM1 exists Ram1PwrCtlRegVal will not be 0U at generate time */
  if (McuModeConfigPtr->Ram1PwrCtlRegVal != 0U) {
    /* Set RAM1 power control register */
    Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_PWR_CTL = 
      McuModeConfigPtr->Ram1PwrCtlRegVal;
  }
  /* If RAM2 exists Ram2PwrCtlRegVal will not be 0U at generate time */
  if (McuModeConfigPtr->Ram2PwrCtlRegVal != 0U) {
    /* Set RAM2 power control register */
    Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_PWR_CTL = 
      McuModeConfigPtr->Ram2PwrCtlRegVal;
  }

  return;
}


/** \brief Mcu_SetRamPwrStatusAll_Regs
 **
 ** This function sets all RAM power status as specified.
 **
 ** \param[in]  McuHwInfoPtr     The pointer to HW information.
 ** \param[in]  McuResetConfigPtr The pointer to the reset configuration.
 ** \param[in]  McuRamPwrStatus  The RAM power status to be changed.
 **
 ** \pre  McuHwInfoPtr shall not be a NULL pointer.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_SetRamPwrStatusAll_Regs(
  P2CONST( Mcu_HwInfoType, AUTOMATIC, MCU_APPL_CONST ) McuHwInfoPtr,
  P2CONST( Mcu_ResetConfigType, AUTOMATIC, MCU_APPL_CONST ) McuResetConfigPtr,
  VAR( uint32, AUTOMATIC ) McuRamPwrStatus
)
{
  VAR( uint32, AUTOMATIC ) cnt;
  VAR( uint32, AUTOMATIC ) checkBit;
  VAR( uint32, AUTOMATIC ) checkBitmap;

  if (McuResetConfigPtr->Ram0Retained != 0U) {
    checkBitmap = McuResetConfigPtr->Ram0Retained;
    /* Set RAM0 power control registers */
    for (cnt = 0U; cnt < McuHwInfoPtr->Ram0MacroNum; cnt++) {
      /* Deviation from MISRA-C:2004 rule 10.1, 10.5, MISRA-C:2012 Rule-10.6, Rule-10.6
         Justification: As a result of this expression, it will not exceed the essential type. */
      /* PRQA S 4491, 4499 1 */
      checkBit = (1U << cnt);
      if ((McuResetConfigPtr->Ram0Retained & checkBit) != 0U) {
        Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_PWR_MACRO_CTL[cnt] = 
          (uint32)(MCU_REG_VALUE_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT | McuRamPwrStatus);
        checkBitmap &= ~(uint32)checkBit;
      }
      if (checkBitmap == 0U) {
        (void)Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_PWR_MACRO_CTL[cnt];
        break;
      }
    }
  }

  if (McuResetConfigPtr->Ram1Retained != 0U) {
    /* Set RAM1 power control register */
    Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_PWR_CTL = 
      (uint32)(MCU_REG_VALUE_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT | McuRamPwrStatus);
    (void)Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_PWR_CTL;
  }

  if (McuResetConfigPtr->Ram2Retained != 0U) {
    /* Set RAM2 power control register */
    Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_PWR_CTL = 
      (uint32)(MCU_REG_VALUE_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT | McuRamPwrStatus);
    (void)Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_PWR_CTL;
  }

  return;
}


/** \brief Mcu_GetCpuID_Regs
 **
 ** This function gets the CPU ID of the current running CPU.
 **
 ** \return  CPU ID of the current running CPU.
 */
FUNC( uint8, MCU_CODE ) 
Mcu_GetCpuID_Regs( void )
{
  VAR( uint8, AUTOMATIC ) retVal;
  VAR( uint32, AUTOMATIC ) regValue;

  regValue = (Mcu_RegBaseAddrPtr->Cm0ScsRegBaseAddr->CPUID & MCU_REG_MASK_SYSTEM_SCS_CPUID_PARTNO);

  if (regValue == MCU_REG_VALUE_SYSTEM_CM0_SCS_CPUID) {
    /* Set result CM0 */
    retVal = MCU_TARGETCPU_CM0;
  }
  else if (regValue == MCU_REG_VALUE_SYSTEM_CM4_SCS_CPUID) {
    /* Set result CM4 */
    retVal = MCU_TARGETCPU_CM4;
  }
  else if (regValue == MCU_REG_VALUE_SYSTEM_CM7_SCS_CPUID) {
    /* Set result CM7 */
    retVal = MCU_TARGETCPU_CM7;
  }
  else {
    /* Set result invalid */
    retVal = MCU_TARGETCPU_INVALID;
  }

  return retVal;
}


/** \brief Mcu_GetCm0CpuStatus_Regs
 **
 ** This function returns CM0 CPU status.
 **
 ** \return  CM0 CPU status.
 */
FUNC( Mcu_CpuStatusType, MCU_CODE ) 
Mcu_GetCm0CpuStatus_Regs( void )
{
  VAR( uint8, AUTOMATIC ) retVal;
  VAR( uint32, AUTOMATIC ) regValue;

  regValue = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->CM0_STATUS;

  if ((regValue & MCU_REG_MASK_CPUSS_CM0_STATUS_SLEEPING) ==
       MCU_REG_MASK_CPUSS_CM0_STATUS_SLEEPING) {
    if ((regValue & MCU_REG_MASK_CPUSS_CM0_STATUS_SLEEPDEEP) ==
       MCU_REG_MASK_CPUSS_CM0_STATUS_SLEEPDEEP) {
      /* Set result deepsleep */
      retVal = MCU_CPUSTATUS_DEEPSLEEP;
    }
    else {
      /* Set result sleep */
      retVal = MCU_CPUSTATUS_SLEEP;
    }
  }
  else {
    /* Set result active */
    retVal = MCU_CPUSTATUS_ACTIVE;
  }

  return retVal;
}


/** \brief Mcu_GetMainCoreCpuStatus_Regs
 **
 ** This function returns Main Core CPU status.
 **
 ** \param[in]  MainCoreIdx  The index number of Main Core.
 **
 ** \return  Main Core CPU status.
 */
FUNC( Mcu_CpuStatusType, MCU_CODE ) 
Mcu_GetMainCoreCpuStatus_Regs(   
  VAR( uint8, AUTOMATIC ) MainCoreIdx
)
{
  VAR( uint8, AUTOMATIC ) retVal;
  VAR( uint32, AUTOMATIC ) regValue;

  regValue = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_CLOCK[MainCoreIdx].FAST_STATUS;

  if ((regValue & MCU_REG_MASK_CPUSS_MAINCORE_STATUS_SLEEPING) ==
       MCU_REG_MASK_CPUSS_MAINCORE_STATUS_SLEEPING) {
    if ((regValue & MCU_REG_MASK_CPUSS_MAINCORE_STATUS_SLEEPDEEP) ==
       MCU_REG_MASK_CPUSS_MAINCORE_STATUS_SLEEPDEEP) {
      retVal = MCU_CPUSTATUS_DEEPSLEEP;
    }
    else {
      retVal = MCU_CPUSTATUS_SLEEP;
    }
  }
  else {
    retVal = MCU_CPUSTATUS_ACTIVE;
  }

  return retVal;
}


/** \brief Mcu_SetMainCorePwrCtl_Regs
 **
 ** This function sets specific Main Core Power Mode to register.
 **
 ** \param[in]  McuModeConfigPtr The pointer to mode configuration.
 ** \param[in]  MainCoreIdx      The index number of Main Core.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetMainCorePwrCtl_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr,
  VAR( uint8, AUTOMATIC ) MainCoreIdx
)
{
  /* Set FAST_PWR_DELAY_CTL register */
  Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_PWR[MainCoreIdx].FAST_PWR_DELAY_CTL = 
    McuModeConfigPtr->MainCorePwrUpDelayCtlRegVal[MainCoreIdx];
  /* dummy read */
  (void)Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_PWR[MainCoreIdx].FAST_PWR_DELAY_CTL;

  if (McuModeConfigPtr->MainCorePwrMode[MainCoreIdx] != MCU_MAINCOREPOWERMODE_SKIP) {
    /* Set FAST_PWR_CTL register */
    Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_PWR[MainCoreIdx].FAST_PWR_CTL =
      (((uint32)McuModeConfigPtr->MainCorePwrMode[MainCoreIdx]) | 
        MCU_REG_VALUE_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT);
  }

  return;
}


/** \brief Mcu_DisableCache_Regs
 **
 ** This function disables I-cache and D-cache.
 **
 ** \return  Current I-cache and D-cache status.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 2 */
FUNC( uint32, MCU_CODE ) 
Mcu_DisableCache_Regs( void )
{
  VAR( uint32, AUTOMATIC ) regValue;
  VAR( uint32, AUTOMATIC ) cacheStatus;

  /* Get cache control register value */
  regValue = Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CCR;

  /* Get current I-cache and D-cache status */
  cacheStatus = 
    regValue & (MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_IC | MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_DC);

  /* Cache disable will be skipped if all cache is already disabled */
  if (cacheStatus != MCU_REG_VALUE_SYSTEM_CM7_SCS_CCR_DIS_ALL) {
    /* Disable I-cache and D-cache */
    regValue &= ~(uint32)(MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_IC | MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_DC);
    Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CCR = regValue;

    /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
       Justification: Inline assembler code is necessary. */
    /* PRQA S 1006 2 */
    __asm("DSB");
    __asm("ISB");

    /* Cache flush should be skipped if D-cache is already disabled */
    if ((cacheStatus & MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_DC) == MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_DC) {
      /* Clean D-cache */
      Mcu_CleanCache_Regs();
    }
  }

  return cacheStatus;
}


/** \brief Mcu_RestoreCache_Regs
 **
 ** This function restores I-cache and D-cache status.
 **
 ** \param[in]  CacheStatus  Previous I-cache and D-cache status to restore.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 4 */
FUNC( void, MCU_CODE ) 
Mcu_RestoreCache_Regs(
  VAR( uint32, AUTOMATIC ) CacheStatus
)
{
  VAR( uint32, AUTOMATIC ) regValue;

  /* Invalidate I-cache and D-cache */
  Mcu_InvalidateCache_Regs();

  /* Get cache control register value */
  regValue = Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CCR;

  /* Restore I-cache and D-cache */
  regValue &= ~(uint32)(MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_DC | MCU_REG_MASK_SYSTEM_CM7_SCS_CCR_IC);
  regValue |= CacheStatus;
  Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CCR = regValue;

  /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
     Justification: Inline assembler code is necessary. */
  /* PRQA S 1006 2 */
  __asm("DSB");
  __asm("ISB");
}


/** \brief Mcu_SetHibernate_Regs
 **
 ** This function sets hibernate settings to register.
 **
 ** \param[in]  McuHibConfigPtr The pointer to mode configuration related to hibernate mode.
 ** \param[in]  LowPwrTransEn   The enable flag of low power transition.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 5 */
FUNC( void, MCU_CODE ) 
Mcu_SetHibernate_Regs(
  P2CONST( Mcu_HibConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuHibConfigPtr,
  VAR( uint8, AUTOMATIC ) LowPwrTransEn
)
{
  VAR( uint32, AUTOMATIC ) regValue;

  regValue = (McuHibConfigPtr->PwrHibernateRegVal & McuHibConfigPtr->PwrHibernateRegMask);

  /* Set PWR_HIBERNATE unlocks HIB mode */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE = regValue;

  /* Set PWR_HIBERNATE freezes all I/O */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE = regValue;

  if (McuHibConfigPtr->PwrHibWakeCtlRegMask != MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL_NONE) {
    /* Set PWR_HIB_WAKE_CTL register */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIB_WAKE_CTL = McuHibConfigPtr->PwrHibWakeCtlRegVal;
  }

  if (McuHibConfigPtr->PwrHibWakeCtl2RegMask != MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL2_NONE) {
    /* Set PWR_HIB_WAKE_CTL2 register */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIB_WAKE_CTL2 = McuHibConfigPtr->PwrHibWakeCtl2RegVal;
  }

  if ((McuHibConfigPtr->ClearPendingWakeupEn == STD_ON) &&
      ((McuHibConfigPtr->PwrHibWakeCtlRegMask != MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL_NONE) ||
       (McuHibConfigPtr->PwrHibWakeCtl2RegMask != MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL2_NONE))){
    /* Clear all PWR_HIB_WAKE_CAUSE bits */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIB_WAKE_CAUSE = MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CAUSE_ALL;
    /* dummy read */
    (void)Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIB_WAKE_CAUSE;
  }

  if (LowPwrTransEn == STD_ON) {
    /* Set PWR_HIBERNATE initiates trasition */
    Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE |= 
      MCU_REG_MASK_SSRS_PWR_HIBERNATE_HIBERNATE;
    /* dummy read */
    (void)Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE;
    /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
       Justification: Inline assembler code is necessary. */
    /* PRQA S 1006 1 */
    __asm("WFI");
  }

  return;
}


/** \brief Mcu_WaitSrssPowerCtl_Regs
 **
 ** This function waits and returns the low power status.
 **
 ** \param[in]  McuSysResConfigPtr    The pointer to mode system common resource configuration.
 **
 ** \pre  McuSysResConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Low power mode is already ready.
 ** \retval  MCU_NOT_OK_HW  Low power mode is not ready yet.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WaitSrssPowerCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* If linear core regulator is enable, it is necessary to wait it is ready */
  if ((regSrssAddrPtr->PWR_CTL2 & MCU_REG_MASK_SRSS_PWR_CTL_LINREG_DIS) !=
       MCU_REG_MASK_SRSS_PWR_CTL_LINREG_DIS) {
    retVal = Mcu_PowerCtrlEnableWait_Regs(
               SysResConfigPtr->LinRegEnToCnt,
               MCU_REG_MASK_SRSS_PWR_CTL_LINREG_OK
               );
  }

  if (retVal == MCU_OK)
  {
    /* If voltage reference buffer is enable, it is necessary to wait it is ready */
    if ((regSrssAddrPtr->PWR_CTL2 & MCU_REG_MASK_SRSS_PWR_CTL_REFVBUF_DIS) !=
         MCU_REG_MASK_SRSS_PWR_CTL_REFVBUF_DIS) {
      retVal = Mcu_PowerCtrlEnableWait_Regs(
                 SysResConfigPtr->VrefBufRdyToCnt,
                 MCU_REG_MASK_SRSS_PWR_CTL_REFVBUF_OK
                 );
    }

    if (retVal == MCU_OK)
    {
      /* If current reference generator is enable, it is necessary to wait it is ready */
      if ((regSrssAddrPtr->PWR_CTL2 & MCU_REG_MASK_SRSS_PWR_CTL_REFI_DIS) !=
           MCU_REG_MASK_SRSS_PWR_CTL_REFI_DIS) {
        retVal = Mcu_PowerCtrlEnableWait_Regs(
                   SysResConfigPtr->RefIEnToCnt,
                   MCU_REG_MASK_SRSS_PWR_CTL_REFI_OK
                   );
      }
    }
  }

  return retVal;
}


/** \brief Mcu_WaitRamStatus_Regs
 **
 ** This function waits and returns the RAM write buffer status.
 **
 ** \param[in]  RamWbToCnt  The counter value for waiting RAM write buffer status.
 **
 ** \retval  MCU_OK         RAM write buffer is already empty.
 ** \retval  MCU_NOT_OK_HW  RAM write buffer is not empty yet.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WaitRamStatus_Regs(
  VAR( uint32, AUTOMATIC ) RamWbToCnt
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) waitCount;

  /* Check wait is enabled */
  if (RamWbToCnt > 0U) {
    /* Check RAM0 ECC Checking is enabled */
    if (MCU_REG_MASK_CPUSS_RAM0_CTL_ECC_EN == 
       (Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_CTL & 
          MCU_REG_MASK_CPUSS_RAM0_CTL_ECC_EN)) {
      waitCount = RamWbToCnt;

      do
      {
        if (MCU_REG_MASK_CPUSS_RAM0_STATUS_WB_EMPTY == 
           (Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_STATUS & 
              MCU_REG_MASK_CPUSS_RAM0_STATUS_WB_EMPTY)) {
          break;
        }
        /* Decrement wait count */
        waitCount--;
      } while (waitCount > 0U);

      if(waitCount == 0U) {
        retVal = MCU_NOT_OK_HW;
      }
    }

    /* Check RAM1 ECC Checking is enabled */
    if ((retVal == MCU_OK) &&
        (MCU_REG_MASK_CPUSS_RAM1_CTL_ECC_EN == 
        (Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_CTL & 
         MCU_REG_MASK_CPUSS_RAM1_CTL_ECC_EN))) {
      waitCount = RamWbToCnt;

      do
      {
        if (MCU_REG_MASK_CPUSS_RAM1_STATUS_WB_EMPTY == 
           (Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_STATUS & 
            MCU_REG_MASK_CPUSS_RAM1_STATUS_WB_EMPTY)) {
          break;
        }
        /* Decrement wait count */
        waitCount--;
      } while (waitCount > 0U);
      if(waitCount == 0U) {
        retVal = MCU_NOT_OK_HW;
      }
    }

    /* Check RAM2 ECC Checking is enabled */
    if ((retVal == MCU_OK) &&
        (MCU_REG_MASK_CPUSS_RAM2_CTL_ECC_EN == 
        (Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_CTL & 
         MCU_REG_MASK_CPUSS_RAM2_CTL_ECC_EN))) {
      waitCount = RamWbToCnt;

      do
      {
        if (MCU_REG_MASK_CPUSS_RAM2_STATUS_WB_EMPTY == 
           (Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_STATUS & 
            MCU_REG_MASK_CPUSS_RAM2_STATUS_WB_EMPTY)) {
          break;
        }
        /* Decrement wait count */
        waitCount--;
      } while (waitCount > 0U);
      if(waitCount == 0U) {
        retVal = MCU_NOT_OK_HW;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_WaitLowPowerModeReady_Regs
 **
 ** This function waits and returns the low power mode status.
 **
 ** \param[in]  LpmRdyToCnt  The counter value for waiting low power mode status.
 **
 ** \retval  MCU_OK         Low power mode is already ready.
 ** \retval  MCU_NOT_OK_HW  Low power mode is not ready yet.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WaitLowPowerModeReady_Regs(
  VAR( uint32, AUTOMATIC ) LpmRdyToCnt
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) waitCount = LpmRdyToCnt;

  /* Wait for number count */
  if (waitCount > 0U) {
    do
    {
      if (MCU_REG_MASK_SRSS_PWR_CTL_LPM_READY == 
        ((Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_CTL) & 
          MCU_REG_MASK_SRSS_PWR_CTL_LPM_READY)) {
        break;
      }
      /* Decrement wait count */
      waitCount--;
    } while (waitCount > 0U);

    if(waitCount == 0U) {
      retVal = MCU_NOT_OK_HW;
    }
  }
  else {
    if (MCU_REG_MASK_SRSS_PWR_CTL_LPM_READY != 
      ((Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_CTL) & 
        MCU_REG_MASK_SRSS_PWR_CTL_LPM_READY)) {
      retVal = MCU_NOT_OK_HW;
    }
  }

  return retVal;
}


/** \brief Mcu_ClearFreezeIo_Regs
 **
 ** This function clears freeze I/O.
 **
 */
FUNC( void, MCU_CODE ) 
Mcu_ClearFreezeIo_Regs( void )
{
  /* Set PWR_HIBERNATE clears freeze I/O */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE &=
    ~(uint32)(MCU_REG_MASK_SSRS_PWR_HIBERNATE_FREEZE | MCU_REG_VALUE_SSRS_PWR_HIBERNATE_UNLOCK);

  return;
}


/** \brief Mcu_GetSysStatus_Regs
 **
 ** This function returns HW system power status.
 **
 ** \retval  MCU_SYSSTATUS_RESET     RESET system status.
 ** \retval  MCU_SYSSTATUS_ACTIVE    ACTIVE system status.
 ** \retval  MCU_SYSSTATUS_SLEEP     SLEEP system status.
 ** \retval  MCU_SYSSTATUS_DEEPSLEEP DEEPSLEEP system status.
 */
FUNC( Mcu_SysStatusType, MCU_CODE ) 
Mcu_GetSysStatus_Regs(void)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_SysStatusType, AUTOMATIC ) retVal;

  /* Get PWR_CTL register value */
  regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_CTL;
  /* Get PWR_CTL.POWER_MODE field value */
  regVal &= MCU_REG_MASK_SRSS_PWR_CTL_POWER_MODE;
  /* Get system power mode */
  if (regVal == MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_RESET) {
    /* RESET system status */
    retVal = MCU_SYSSTATUS_RESET;
  } else if (regVal == MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_ACTIVE) {
    /* ACTIVE system status */
    retVal = MCU_SYSSTATUS_ACTIVE;
  } else if (regVal == MCU_REG_VALUE_SRSS_PWR_CTL_POWER_MODE_SLEEP) {
    /* SLEEP system status */
    retVal = MCU_SYSSTATUS_SLEEP;
  } else {
    /* DEEPSLEEP system status */
    retVal = MCU_SYSSTATUS_DEEPSLEEP;
  }
  return retVal;
}


/** \brief Mcu_CheckMode_Cpuss_Regs
 **
 ** This function checks CPUSS mode settings with registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CPUSS mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CPUSS mode settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Cpuss_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check DMA control registers */
  retVal = Mcu_CheckMode_CpussDmaCtl_Regs(&(McuModeConfigPtr->DmaConfigData));
  if (retVal == MCU_OK) {
    /* Check CPUSS RAM power control registers */
    retVal = Mcu_CheckMode_CpussRamPwr_Regs(McuModeConfigPtr);
  }

  return retVal;
}


/** \brief Mcu_CheckMode_CpussMainCorePwr_Regs
 **
 ** This function checks mode settings with CPUSS FAST_PWR_CTL HW registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Main Core CPU power mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Main Core CPU power mode settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussMainCorePwr_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( uint8,  AUTOMATIC ) regMainCorePwrMode;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint8,  AUTOMATIC ) cnt;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (cnt=0U; cnt < McuModeConfigPtr->MainCorePwrModeNum; cnt++){
    /* Get FAST_PWR_DELAY_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_PWR[cnt].FAST_PWR_DELAY_CTL;
    /* Check register value with config value */
    if (McuModeConfigPtr->MainCorePwrUpDelayCtlRegVal[cnt] == regVal) {
      if (McuModeConfigPtr->MainCorePwrMode[cnt] != MCU_MAINCOREPOWERMODE_SKIP) {
        /* Get FAST_PWR_CTL register value */
        regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_PWR[cnt].FAST_PWR_CTL;
        regMainCorePwrMode = (uint8)(regVal & ~(uint32)MCU_REG_MASK_CPUSS_MAINCORE_PWR_CTL_VECTKEYSTAT);
        /* Check register value with config value */
        if (McuModeConfigPtr->MainCorePwrMode[cnt] != regMainCorePwrMode) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      }
    } else {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
    if (retVal == MCU_NOT_OK) {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckMode_SysCm0Scs_Regs
 **
 ** This function checks mode settings with SYSTEM CM0_SCS HW registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CM0 CPU system control settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CM0 CPU system control settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SysCm0Scs_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Get CM0_SCS.SCR register value */
  regVal = Mcu_RegBaseAddrPtr->Cm0ScsRegBaseAddr->SCR;
  /* Check register value with config value */
  if (McuModeConfigPtr->ScrRegVal == regVal) {
    /* Set result match */
    retVal = MCU_OK;
  } else {
    /* Set result unmatch */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckMode_SysCm4Scs_Regs
 **
 ** This function checks mode settings with SYSTEM CM4_SCS HW registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CM4 CPU system control settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CM4 CPU system control settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SysCm4Scs_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Get CM4_SCS.SCR register value */
  regVal = Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->SCR;
  /* Check register value with config value */
  if (McuModeConfigPtr->ScrRegVal == regVal) {
    /* Set result match */
    retVal = MCU_OK;
  } else {
    /* Set result unmatch */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckMode_SrssHibernate_Regs
 **
 ** This function checks mode settings related to hibernate mode with registers.
 **
 ** \param[in]  McuHibConfigPtr       The pointer to mode configuration related to hibernate mode.
 **
 ** \retval  MCU_OK         HIBERNATE mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     HIBERNATE mode settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssHibernate_Regs(
  P2CONST( Mcu_HibConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuHibConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match */
  retVal = MCU_OK;

  if (McuHibConfigPtr != NULL_PTR) {
    /* Get PWR_HIBERNATE register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIBERNATE;
    /* Mask register value */
    regVal &= McuHibConfigPtr->PwrHibernateRegMask;
    /* Check register value with config value */
    if (McuHibConfigPtr->PwrHibernateRegVal == regVal) {
      if (McuHibConfigPtr->PwrHibWakeCtlRegMask != 
      	  MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL_NONE) {
        /* Check PWR_HIB_WAKE_CTL register value with config value */
        if (McuHibConfigPtr->PwrHibWakeCtlRegVal != 
            Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIB_WAKE_CTL) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      }
      if (retVal == MCU_OK) {
        if (McuHibConfigPtr->PwrHibWakeCtl2RegMask != 
            MCU_REG_MASK_SRSS_PWR_HIB_WAKE_CTL2_NONE) {
          /* Set PWR_HIB_WAKE_CTL2 register */
          if (McuHibConfigPtr->PwrHibWakeCtl2RegVal != 
              Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_HIB_WAKE_CTL2) {
            /* Set result unmatch */
            retVal = MCU_NOT_OK;
          }
        }
      }
    } else {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_GetLvdIntStatus_Regs
 **
 ** This function gets the LVD interrupt status.
 **
 ** \return  The Lvd interrupt status.
 */
FUNC( uint32, MCU_CODE ) 
Mcu_GetLvdIntStatus_Regs(void)
{
  VAR( uint32, AUTOMATIC ) regVal;

  regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->SRSS_INTR;
  regVal &= (MCU_REG_MASK_SRSS_INTR_HVLVD1 | MCU_REG_MASK_SRSS_INTR_HVLVD2);

  return regVal;
}


/** \brief Mcu_ClearLvdIntStatus_Regs
 **
 ** This function clears Lvd interrupt status.
 **
 ** \param[in]  McuRegValue            The value written to clear Lvd interrupt status.
 */
FUNC( void, MCU_CODE ) 
Mcu_ClearLvdIntStatus_Regs(
  VAR( uint32, AUTOMATIC ) McuRegValue
)
{
  /* Clear interrupt status */
  Mcu_RegBaseAddrPtr->SrssRegBaseAddr->SRSS_INTR
    = (McuRegValue & (MCU_REG_MASK_SRSS_INTR_HVLVD1 | MCU_REG_MASK_SRSS_INTR_HVLVD2));

  (void)Mcu_RegBaseAddrPtr->SrssRegBaseAddr->SRSS_INTR;

  return;
}


/** \brief Mcu_CheckMode_SystemResource_Regs
 **
 ** This function checks mode system common resource settings with registers.
 **
 ** \param[in]  McuSysResConfigPtr    The pointer to mode system common resource configuration.
 **
 ** \pre  McuSysResConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         System resource settings are consistent with registers.
 ** \retval  MCU_NOT_OK     System resource settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SystemResource_Regs(
  P2CONST( Mcu_SysResConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSysResConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;
  VAR( uint32, AUTOMATIC ) idx;

  /* Check power control registers */
  retVal = Mcu_CheckMode_SrssPwrCtl_Regs(McuSysResConfigPtr);
  if (retVal == MCU_OK) {
    /* Check supply supervision registers */
    retVal = Mcu_CheckMode_SrssSsvCtl_Regs(McuSysResConfigPtr);
    if (retVal == MCU_OK) {
      for (idx=0U; idx<McuSysResConfigPtr->HvLvdConfigNum; idx++) {
        /* Check HVLVD registers */
        retVal = Mcu_CheckMode_SrssHvLvd_Regs(&(McuSysResConfigPtr->HvLvdConfigPtr[idx]));
        if (retVal != MCU_OK) {
          break;
        }
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckSourceClockStatus_Regs
 **
 ** This function checks source clock enable settings with SRSS HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Source clock enable settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Source clock enable settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckSourceClockStatus_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  retVal = MCU_OK;
  /* WCO enable check */
  if ((McuClockConfigPtr->BackupConfigPtr != NULL_PTR) &&
      (McuClockConfigPtr->BackupConfigPtr->WcoEn == STD_ON)) {
    retVal = Mcu_CheckClock_SrssBackup_Regs(McuClockConfigPtr->BackupConfigPtr);
  }
  if ((retVal == MCU_OK) && 
      ((McuClockConfigPtr->ClkIloConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE)
        == MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE)) {
    /* Check ILO registers */
    retVal = Mcu_CheckClock_SrssIlo_Regs(McuClockConfigPtr);
  }
  if ((retVal == MCU_OK) && 
      ((McuClockConfigPtr->ClkIlo1ConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE)
        == MCU_REG_MASK_SRSS_CLK_ILO1_CONFIG_ENABLE)) {
    /* Check ILO1 registers */
    retVal = Mcu_CheckClock_SrssIlo1_Regs(McuClockConfigPtr);
  }
  if ((retVal == MCU_OK) && 
      (McuClockConfigPtr->LpEcoConfigPtr != NULL_PTR) && 
      (McuClockConfigPtr->LpEcoConfigPtr->LpEcoEn == STD_ON)) {
    /* Check LPECO registers */
    retVal = Mcu_CheckClock_SrssLpEco_Regs(McuClockConfigPtr->LpEcoConfigPtr);
    if ((retVal == MCU_OK) && 
        (McuClockConfigPtr->LpEcoConfigPtr->LpEcoPrescalerEn == STD_ON)) {
      /* Check LPECO prescale registers */
      retVal = Mcu_CheckClock_SrssLpEcoPrescale_Regs(McuClockConfigPtr->LpEcoConfigPtr);
    }
  }
  if ((retVal == MCU_OK) && 
      (McuClockConfigPtr->EcoConfigPtr != NULL_PTR) && 
      ((McuClockConfigPtr->EcoConfigPtr->ClkEcoConfigRegVal & 
        MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN)
        == MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN)) {
    /* Check ECO registers */
    retVal = Mcu_CheckClock_SrssEco_Regs(McuClockConfigPtr->EcoConfigPtr);
    if ((retVal == MCU_OK) && 
        (McuClockConfigPtr->EcoConfigPtr->EcoPrescalerEn == STD_ON)) {
      /* Check ECO prescale registers */
      retVal = Mcu_CheckClock_SrssEcoPrescale_Regs(McuClockConfigPtr->EcoConfigPtr);
    }
  }
  if ((retVal == MCU_OK) && 
      ((McuClockConfigPtr->ClkImoConfigRegVal & MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN)
        == MCU_REG_MASK_SRSS_CLK_IMO_CONFIG_IMO_EN)) {
    /* Get CLK_IMO_CONFIG register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_IMO_CONFIG;
    /* Check register value with config value */
    if (McuClockConfigPtr->ClkImoConfigRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_Srss_Regs
 **
 ** This function checks clock settings with SRSS HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS clock settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_Srss_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check clock output registers */
  retVal = Mcu_CheckClock_SrssClkOut_Regs(
             McuClockConfigPtr->ClockOutputConfigPtr
           );
  /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-1.1
     Justification: The SRSS has many functions and must be checked exclusively. */
  /* PRQA S 715 ++ */
  if (retVal == MCU_OK) {
    /* Check DSI registers */
    retVal = Mcu_CheckClock_SrssDsi_Regs(
               (uint32)McuClockConfigPtr->DsiConfigNum,
               McuClockConfigPtr->DsiConfigPtr
             );
    if (retVal == MCU_OK) {
      /* Check clock path registers */
      retVal = Mcu_CheckClock_SrssClkPath_Regs(
                 (uint32)McuClockConfigPtr->ClockPathConfigNum,
                 McuClockConfigPtr->ClockPathConfigPtr
               );
      if (retVal == MCU_OK) {
        /* Check clock root registers */
        retVal = Mcu_CheckClock_SrssClkRoot_Regs(
                   (uint32)McuClockConfigPtr->ClockRootConfigNum,
                   McuClockConfigPtr->ClockRootConfigPtr
                 );
        if (retVal == MCU_OK) {
          /* Check timer clock registers */
          retVal = Mcu_CheckClock_SrssClkTimer_Regs(McuClockConfigPtr);
          if (retVal == MCU_OK) {
            /* Check LF/pump clock registers */
            retVal = Mcu_CheckClock_SrssClkPump_Regs(McuClockConfigPtr);
            if (retVal == MCU_OK) {
              /* Check ILO,IMO,ECO registers */
              retVal = Mcu_CheckClock_SrssOsc_Regs(McuClockConfigPtr);
              if (retVal == MCU_OK) {
                /* Check FLL registers */
                retVal = Mcu_CheckClock_SrssFll_Regs(
                           McuClockConfigPtr->FllConfigPtr
                         );
                if (retVal == MCU_OK) {
                  /* Check PLL registers */
                  retVal = Mcu_CheckClock_SrssPll_Regs(
                             (uint32)McuClockConfigPtr->PllConfigNum,
                             McuClockConfigPtr->PllConfigPtr
                           );
                  if (retVal == MCU_OK) {
                    /* Check SSCG registers */
                    retVal = Mcu_CheckClock_SrssSscg_Regs(
                               (uint32)McuClockConfigPtr->SscgConfigNum,
                               McuClockConfigPtr->SscgConfigPtr
                             );
                    if (retVal == MCU_OK) {
                      /* Check CSV registers */
                      retVal = Mcu_CheckClock_SrssCsv_Regs(McuClockConfigPtr);
                      if (retVal == MCU_OK) {
                        /* Check WCO registers */
                        retVal = Mcu_CheckClock_SrssBackup_Regs(
                                   McuClockConfigPtr->BackupConfigPtr
                                 );
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  /* PRQA S 715 -- */

  return retVal;
}


/** \brief Mcu_CheckClock_Cpuss_Regs
 **
 ** This function checks clock settings with CPUSS HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CPUSS clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CPUSS clock settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_Cpuss_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check CM0 clock registers */
  retVal = Mcu_CheckClock_CpussCm0_Regs(McuClockConfigPtr);
  if (retVal == MCU_OK) {
    /* Check Main Core clock registers */
    retVal = Mcu_CheckClock_CpussMainCore_Regs(McuClockConfigPtr);
    if (retVal == MCU_OK) {
      /* Check memory wait cycle registers */
      retVal = Mcu_CheckClock_CpussWaitCycle_Regs(McuClockConfigPtr);
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_Peri_Regs
 **
 ** This function checks clock settings with PERI HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         PERI clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     PERI clock settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_Peri_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8,  AUTOMATIC ) j; /* loop num */
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (j=0U; j<McuClockConfigPtr->PclkGroupConfigNum; j++)
  {
    /* Check PCLK registers */
    retVal = Mcu_CheckClock_PeriPclk_Regs(&(McuClockConfigPtr->PclkGroupConfigPtr[j]));
    if (retVal == MCU_OK) {
    /* Check PCLK divider registers */
      retVal = Mcu_CheckClock_PeriDivider_Regs(&(McuClockConfigPtr->PclkGroupConfigPtr[j]));
    }
    if (retVal != MCU_OK) {
      break;
    }
  }

  if (retVal == MCU_OK) {
    /* Check peripheral group registers */
    retVal = Mcu_CheckClock_PeriGroup_Regs(
      (uint32)McuClockConfigPtr->PeriGroupConfigNum,
      McuClockConfigPtr->PeriGroupConfigPtr
    );
    if (retVal == MCU_OK) {
      /* Get TIMEOUT_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->PeriRegBaseAddr->TIMEOUT_CTL;
      /* Check register value with config value */
      if (McuClockConfigPtr->PeriGroupBusToCnt != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    }
  }

  return retVal;
}


/*==================[internal function definitions]==========================*/
/** \brief Mcu_ClockShutdown_RootSelect_Regs
 **
 ** This function shutdowns Root Select registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer. **
 */
static FUNC( void, MCU_CODE )
Mcu_ClockShutdown_RootSelect_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint8, AUTOMATIC ) i, clockRootRegIdx;
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* ROOT_SELECT setting -> only up ROOT_DIV setting */
  for (i=0U; i<McuClockConfigPtr->ClockRootConfigNum; i++ )
  {
    clockRootRegIdx = McuClockConfigPtr->ClockRootConfigPtr[i].ClockRootRegIdx;
    regVal = regSrssAddrPtr->CLK_ROOT_SELECT[clockRootRegIdx];

    if( (regVal & MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV) <
        (McuClockConfigPtr->ClockRootConfigPtr[i].ClkRootSelectRegVal &
         MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV)
      )
    {
      /* set to up clock divider */
      regVal &= ~(uint32)MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV;
      regVal |= McuClockConfigPtr->ClockRootConfigPtr[i].ClkRootSelectRegVal &
                MCU_REG_MASK_SRSS_CLK_ROOT_SELECT_ROOT_DIV;
      
      regSrssAddrPtr->CLK_ROOT_SELECT[clockRootRegIdx] = regVal;
    }
  }
}


/** \brief Mcu_ClockShutdown_ClockSelect_Regs
 **
 ** This function shutdowns Clock Select registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer. **
 */
static FUNC( void, MCU_CODE )
Mcu_ClockShutdown_ClockSelect_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{

  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* LF and Pump clock setting */
  if(McuClockConfigPtr->PumpClockStopEnable == STD_ON)
  {
    if ((regSrssAddrPtr->CLK_SELECT & MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE) ==
       MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE)
    {
      /* PUMP_ENABLE is seto to 0 */
      regSrssAddrPtr->CLK_SELECT &= ~(uint32)MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE;
    }
    /* PUMP_ENABLE is 0 , nothing to do. */
  }
  /* PumpClockStopEnable is false , nothing to do. */
}


/** \brief Mcu_ClockShutdown_TimerClock_Regs
 **
 ** This function shutdowns Timer control registers of SRSS with configuration.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer. **
 */
static FUNC( void, MCU_CODE )
Mcu_ClockShutdown_TimerClock_Regs(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* Timer Clock setting */
  if(McuClockConfigPtr->TimerClockStopEnable == STD_ON)
  {
    if ((regSrssAddrPtr->CLK_TIMER_CTL & MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE) ==
       MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE)
    {
      /* TIMER_ENABLE is seto to 0 */
      regSrssAddrPtr->CLK_TIMER_CTL &= (uint32)~MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE;
    }
    /* TIMER_ENABLE is 0, nothing to do. */
  }
}


/** \brief Mcu_GetEachPllLockStatus_Regs
 **
 ** This function gets each Pll lock status from CLK_PLL_STATUS register.
 **
 ** \param[in]  PllConfigPtr    The pointer to PLL configuration.
 **
 ** \retval MCU_OK      PLL status is locked.
 ** \retval MCU_NOT_OK  PLL status is not locked.
 */
static FUNC(  Mcu_ReturnType, MCU_CODE ) 
Mcu_GetEachPllLockStatus_Regs(
  P2CONST( Mcu_PllConfigDataType, AUTOMATIC, MCU_APPL_CONST ) PllConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if(PllConfigPtr->PllEn == STD_ON)
  {
    if((regSrssAddrPtr->CLK_PLL_STATUS[PllConfigPtr->PllRegIdx] &
      MCU_REG_MASK_SRSS_CLK_PLL_STATUS_LOCKED) ==
      MCU_REG_MASK_SRSS_CLK_PLL_STATUS_LOCKED)
    {
      /* Set result OK */
      retVal = MCU_OK;
    }
    else
    {
      /* Set result Not OK */
      retVal = MCU_NOT_OK;
    }
  }
  else
  {
    /* PLL is disable -> return MCU_OK */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_GetEachSscgLockStatus_Regs
 **
 ** This function gets each SSCG lock status from PLL400_STRUCT.STATUS register.
 **
 ** \param[in]  SscgConfigPtr   The pointer to SSCG configuration.
 **
 ** \retval MCU_OK      SSCG status is locked.
 ** \retval MCU_NOT_OK  SSCG status is not locked.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_GetEachSscgLockStatus_Regs(
  P2CONST( Mcu_SscgConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SscgConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;
  P2VAR( volatile Mcu_SscgRegType, AUTOMATIC, REGSPACE ) regSscgAddrPtr;

  /* Get SSCG base address pointer */
  regSscgAddrPtr = 
    &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PLL400_STRUCT[SscgConfigPtr->SscgRegIdx]);

  if(SscgConfigPtr->SscgEn == STD_ON)
  {
    if((regSscgAddrPtr->PLL400_STRUCT_STATUS & MCU_REG_MASK_SRSS_PLL400_STRUCT_STATUS_LOCKED) ==
        MCU_REG_MASK_SRSS_PLL400_STRUCT_STATUS_LOCKED)
    {
      /* Set result OK */
      retVal = MCU_OK;
    }
    else
    {
      /* Set result Not OK */
      retVal = MCU_NOT_OK;
    }
  }
  else
  {
    /* SSCG is disable -> return MCU_OK */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_SetROMWaitCycle_Regs
 **
 ** This function sets ROM wait status of CPUSS with configuration.
 **
 ** \param[in] RomCtlRegVal    The value to set FAST_WS and SLOW_WS bit of ROM_CTL register.
 ** \param[in] SetFlag         The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetROMWaitCycle_Regs(
   VAR( uint32, AUTOMATIC ) RomCtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_CpussRegType, AUTOMATIC, REGSPACE ) regCpussAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regCpussAddrPtr = Mcu_RegBaseAddrPtr->CpussRegBaseAddr;

  regVal = regCpussAddrPtr->ROM_CTL;

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS) >
        (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS;
      regVal |= (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS) >
        (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS;
      regVal |= (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS);
    }
    regCpussAddrPtr->ROM_CTL = regVal;
  }
  else
  {
    /* set to up clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS) <
        (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS;
      regVal |= (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS) <
        (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS;
      regVal |= (RomCtlRegVal & MCU_REG_MASK_CPUSS_ROM_CTL_FAST_WS);
    }
    regCpussAddrPtr->ROM_CTL = regVal;
  }
}


/** \brief Mcu_SetRAM0WaitCycle_Regs
 **
 ** This function sets RAM0 wait status of CPUSS with configuration.
 **
 ** \param[in] Ram0CtlRegVal    The value to set FAST_WS and SLOW_WS bit of RAM0_CTL register.
 ** \param[in] SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetRAM0WaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) Ram0CtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_CpussRegType, AUTOMATIC, REGSPACE ) regCpussAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regCpussAddrPtr = Mcu_RegBaseAddrPtr->CpussRegBaseAddr;

  regVal = regCpussAddrPtr->RAM0_CTL;

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS) >
       (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS;
      regVal |= (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS) >
        (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS;
      regVal |= (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS);
    }
    regCpussAddrPtr->RAM0_CTL = regVal;
  }
  else
  {
    /* set to up clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS) <
       (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS;
      regVal |= (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS) <
        (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS;
      regVal |= (Ram0CtlRegVal & MCU_REG_MASK_CPUSS_RAM0_CTL_FAST_WS);
    }
    regCpussAddrPtr->RAM0_CTL = regVal;
  }
}


/** \brief Mcu_SetRAM1WaitCycle_Regs
 **
 ** This function sets RAM1 wait status of CPUSS with configuration.
 **
 ** \param[in] Ram1CtlRegVal    The value to set FAST_WS and SLOW_WS bit of RAM1_CTL register.
 ** \param[in] SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetRAM1WaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) Ram1CtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_CpussRegType, AUTOMATIC, REGSPACE ) regCpussAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regCpussAddrPtr = Mcu_RegBaseAddrPtr->CpussRegBaseAddr;

  regVal = regCpussAddrPtr->RAM1_CTL;

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS) >
       (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS;
      regVal |= (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS) >
        (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS;
      regVal |= (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS);
    }
    regCpussAddrPtr->RAM1_CTL = regVal;
  }
  else
  {
    /* SetFlag == FALSE */
    /* set to up clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS) <
       (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS;
      regVal |= (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS) <
        (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS;
      regVal |= (Ram1CtlRegVal & MCU_REG_MASK_CPUSS_RAM1_CTL_FAST_WS);
    }
    regCpussAddrPtr->RAM1_CTL = regVal;
  }
}


/** \brief Mcu_SetRAM2WaitCycle_Regs
 **
 ** This function sets RAM2 wait status of CPUSS with configuration.
 **
 ** \param[in] Ram2CtlRegVal    The value to set FAST_WS and SLOW_WS bit of RAM2_CTL register.
 ** \param[in] SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetRAM2WaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) Ram2CtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_CpussRegType, AUTOMATIC, REGSPACE ) regCpussAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regCpussAddrPtr = Mcu_RegBaseAddrPtr->CpussRegBaseAddr;

  regVal = regCpussAddrPtr->RAM2_CTL;

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS) >
       (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS;
      regVal |= (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS) >
        (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS;
      regVal |= (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS);
    }
    regCpussAddrPtr->RAM2_CTL = regVal;
  }
  else
  {
    /* SetFlag == FALSE */
    /* set to up clock divider */
    if( (regVal & MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS) <
       (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS;
      regVal |= (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_SLOW_WS);
    }
    if( (regVal & MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS) <
        (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS;
      regVal |= (Ram2CtlRegVal & MCU_REG_MASK_CPUSS_RAM2_CTL_FAST_WS);
    }
    regCpussAddrPtr->RAM2_CTL = regVal;
  }
}


/** \brief Mcu_SetFLASHWaitCycle_Regs
 **
 ** This function sets MAIN wait status of FLASHC with configuration.
 **
 ** \param[in] FlashCtlRegVal    The value to set MAIN_WS bit of FLASH_CTL register.
 ** \param[in] SetFlag           The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetFLASHWaitCycle_Regs(
  VAR( uint32, AUTOMATIC ) FlashCtlRegVal,
  VAR( boolean, AUTOMATIC ) SetFlag
)
{
  P2VAR( volatile Mcu_FlashRegType, AUTOMATIC, REGSPACE ) regFlashAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;

  regFlashAddrPtr = Mcu_RegBaseAddrPtr->FlashRegBaseAddr;

  regVal = regFlashAddrPtr->FLASH_CTL;

  if(SetFlag == TRUE)
  {
    /* set to down clock divider */
    if( (regVal & MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS) >
        (FlashCtlRegVal & MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS)
      )
    {
      regVal &= ~(uint32)MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS;
      regVal |= (FlashCtlRegVal & MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS);
      regFlashAddrPtr->FLASH_CTL = regVal;
    }
  }
  else
  {
    /* set to up clock divider */
    if( (regVal & MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS) <
       (FlashCtlRegVal & MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS))
    {
      regVal &= ~(uint32)MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS;
      regVal |= (FlashCtlRegVal & MCU_REG_MASK_FLASHC_FLASH_CTL_MAIN_WS);
      regFlashAddrPtr->FLASH_CTL = regVal;
    }
  }
}


/** \brief Mcu_InvalidateCache_Regs
 **
 ** This function invalidates I-cache and D-cache.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 2 */
static FUNC( void, MCU_CODE ) 
Mcu_InvalidateCache_Regs( void )
{
  VAR( uint32, AUTOMATIC ) regValue;
  VAR( uint32, AUTOMATIC ) numSet;
  VAR( uint32, AUTOMATIC ) numWay;
  VAR( uint32, AUTOMATIC ) set;
  VAR( uint32, AUTOMATIC ) way;

  /* Set cache size select register to data cache */
  Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CSSELR = MCU_REG_VALUE_SYSTEM_CM7_SCS_CSSELR_DC;

  /* Get Cache size ID register value */
  regValue = Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CCSIDR;

  /* Get number of ways */
  numWay = (regValue & MCU_REG_MASK_SYSTEM_CM7_SCS_CCSIDR_ASSOCIATIVITY) 
             >> MCU_REG_BIT_SYSTEM_CM7_SCS_CCSIDR_ASSOCIATIVITY;

  /* Get number of sets */
  numSet = (regValue & MCU_REG_MASK_SYSTEM_CM7_SCS_CCSIDR_NUMSETS) 
             >> MCU_REG_BIT_SYSTEM_CM7_SCS_CCSIDR_NUMSETS;

  /* Invalidate all D-caches by specifying set and way */
  for (set = 0U; set <= numSet; set++) {
    regValue = set << MCU_REG_BIT_SYSTEM_CM7_SCS_DCSW_SET;
    for (way = 0U; way <= numWay; way++) {
      Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->DCISW = 
        (regValue | (way << MCU_REG_BIT_SYSTEM_CM7_SCS_DCSW_WAY));
      
    }
  }

  /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
     Justification: Inline assembler code is necessary. */
  /* PRQA S 1006 2 */
  __asm("DSB");
  __asm("ISB");

  /* Invalidate all I-caches */
  Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->ICIALLU = 
    MCU_REG_VALUE_SYSTEM_CM7_SCS_ICIALLU_INVALIDATE;

  /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
     Justification: Inline assembler code is necessary. */
  /* PRQA S 1006 2 */
  __asm("DSB");
  __asm("ISB");
}


/** \brief Mcu_CleanCache_Regs
 **
 ** This function cleans D-cache.
 */
#ifdef STACK_ANALYSIS_ENABLE
#pragma ghs static_call 0
#pragma ghs extra_stack (0)
#endif
/* Deviation from MISRA-C:2004 rule 2.1, MISRA-C:2012 Dir-4.3
   Justification: Inline assembler code is necessary. */
/* PRQA S 3006 2 */
static FUNC( void, MCU_CODE ) 
Mcu_CleanCache_Regs( void )
{
  VAR( uint32, AUTOMATIC ) regValue;
  VAR( uint32, AUTOMATIC ) numSet;
  VAR( uint32, AUTOMATIC ) numWay;
  VAR( uint32, AUTOMATIC ) set;
  VAR( uint32, AUTOMATIC ) way;

  /* Set cache size select register to data cache */
  Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CSSELR = MCU_REG_VALUE_SYSTEM_CM7_SCS_CSSELR_DC;

  /* Get Cache size ID register value */
  regValue = Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->CCSIDR;

  /* Get number of ways */
  numWay = (regValue & MCU_REG_MASK_SYSTEM_CM7_SCS_CCSIDR_ASSOCIATIVITY) 
             >> MCU_REG_BIT_SYSTEM_CM7_SCS_CCSIDR_ASSOCIATIVITY;

  /* Get number of sets */
  numSet = (regValue & MCU_REG_MASK_SYSTEM_CM7_SCS_CCSIDR_NUMSETS) 
             >> MCU_REG_BIT_SYSTEM_CM7_SCS_CCSIDR_NUMSETS;

  /* Clean all D-caches by specifying set and way */
  for (set = 0U; set <= numSet; set++) {
    regValue = set << MCU_REG_BIT_SYSTEM_CM7_SCS_DCSW_SET;
    for (way = 0U; way <= numWay; way++) {
      Mcu_RegBaseAddrPtr->Cm4ScsRegBaseAddr->DCCSW = 
        (regValue | (way << MCU_REG_BIT_SYSTEM_CM7_SCS_DCSW_WAY));
      
    }
  }

  /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-4.2, Rule-1.2
     Justification: Inline assembler code is necessary. */
  /* PRQA S 1006 2 */
  __asm("DSB");
  __asm("ISB");
}


/** \brief Mcu_SetClockDiv_Regs
 **
 ** This function sets clock control register to configuration value.
 ** 
 ** \param[in]  McuClockAddrPtr  The address pointer to clock register.
 ** \param[in]  McuConfigValue   The configuration value to set.
 ** \param[in]  SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetClockDiv_Regs(
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) McuClockAddrPtr,
  VAR( uint32,  AUTOMATIC )  McuConfigValue,
  VAR( boolean, AUTOMATIC )  SetFlag
)
{
  if (SetFlag == TRUE) {
    if (*McuClockAddrPtr > McuConfigValue) {
      *McuClockAddrPtr = McuConfigValue;
    }
  } else {
    if (*McuClockAddrPtr < McuConfigValue) {
      *McuClockAddrPtr = McuConfigValue;
    }
  }
}


/** \brief Mcu_SetClockDivMask_Regs
 **
 ** This function sets clock control register to configuration value with bit mask.
 ** 
 ** \param[in]  McuClockAddrPtr  The address pointer to clock register.
 ** \param[in]  McuConfigValue   The configuration value to set.
 ** \param[in]  McuRegMask       The mask value of the clock control register.
 ** \param[in]  SetFlag          The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SetClockDivMask_Regs(
  P2VAR( volatile uint32, AUTOMATIC, REGSPACE ) McuClockAddrPtr,
  VAR( uint32,  AUTOMATIC )  McuConfigValue,
  VAR( uint32,  AUTOMATIC )  McuRegMask,
  VAR( boolean, AUTOMATIC )  SetFlag
)
{
  VAR( uint32,  AUTOMATIC )  regVal;
  regVal = *McuClockAddrPtr;

  if (SetFlag == TRUE) {
    if ((regVal & McuRegMask) > (McuConfigValue & McuRegMask)) {
        regVal &= ~(uint32)McuRegMask;
        regVal |= (McuConfigValue & McuRegMask);
    }
  } else {
    if ((regVal & McuRegMask) < (McuConfigValue & McuRegMask)) {
        regVal &= ~(uint32)McuRegMask;
        regVal |= (McuConfigValue & McuRegMask);
    }
  }

  *McuClockAddrPtr = regVal;
}


/** \brief Mcu_UnlockWatchdog_Regs
 **
 ** This function unlocks WDT by accessing WDT_LOCK register.
 **
 ** \return  The value of previous status of WDT_LOCK register.
 */
static FUNC(  uint32, MCU_CODE ) 
Mcu_UnlockWatchdog_Regs( void )
{

  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( uint32, AUTOMATIC ) regVal;
  
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* store previous status */
  regVal = regSrssAddrPtr->WDT_LOCK;
  
  if((regVal & MCU_REG_MASK_SRSS_WDT_LOCK_WDT_LOCK) != MCU_REG_VALUE_SRSS_WDT_LOCK_UNLOCKED)
  {
    /* unlock WDT_LOCK */
    regSrssAddrPtr->WDT_LOCK = MCU_REG_VALUE_SRSS_WDT_LOCK_CLR0;
    regSrssAddrPtr->WDT_LOCK = MCU_REG_VALUE_SRSS_WDT_LOCK_CLR1;
  }
  return regVal;
}


/** \brief Mcu_LockWatchdog_Regs
 **
 ** This function restores the WDT_LOCK register to the state before unlocking.
 ** \param[in]  WdtlockRegVal The value of WDT_LOCK register when Mcu_UnlockWatchdog_Regs is called.
 **
 */
static FUNC(  void, MCU_CODE ) 
Mcu_LockWatchdog_Regs( 
  VAR( uint32, AUTOMATIC ) WdtlockRegVal
)
{

  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if( (WdtlockRegVal & MCU_REG_MASK_SRSS_WDT_LOCK_WDT_LOCK) != MCU_REG_VALUE_SRSS_WDT_LOCK_UNLOCKED)
  {
    regSrssAddrPtr->WDT_LOCK = MCU_REG_VALUE_SRSS_WDT_LOCK_SET01;
    
    if( (WdtlockRegVal & MCU_REG_MASK_SRSS_WDT_LOCK_WDT_LOCK) != MCU_REG_VALUE_SRSS_WDT_LOCK_SET01)
    {
      regSrssAddrPtr->WDT_LOCK = (~(uint32)WdtlockRegVal & MCU_REG_MASK_SRSS_WDT_LOCK_WDT_LOCK);
    }
  }
}


/** \brief Mcu_IsUnlockWatchdog_Regs
 **
 ** This function check WDT lock status of WDT_LOCK register.
 **
 ** \retval  TRUE      WDT_LOCK register is unclok status.
 ** \retval  FALSE     WDT_LOCK register is not unclok status.
 **
 */
static FUNC(  boolean, MCU_CODE ) 
Mcu_IsUnlockWatchdog_Regs( void )
{

  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( boolean, AUTOMATIC ) retVal;
  
  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if((regSrssAddrPtr->WDT_LOCK & MCU_REG_MASK_SRSS_WDT_LOCK_WDT_LOCK) ==
     MCU_REG_VALUE_SRSS_WDT_LOCK_UNLOCKED)
  {
    /* WDT_LOCK is unlock status */
    retVal = TRUE;
  }
  else
  {
    /* WDT_LOCK is not unlock status */
    retVal = FALSE;
  }
  
  return retVal;

}


/** \brief Mcu_EcoClkStabWait_Regs
 **
 ** This function waits stabilization of ECO clock.
 ** If the ECO clock is not stable during EcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] EcoStabilizationCnt         The count value of Eco clock stabilization.
 ** \param[in] ClockFlags                  ECO clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  ECO clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_EcoClkStabWait_Regs(
  VAR( uint32, AUTOMATIC ) EcoStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) stubcnt;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if ((ClockFlags & MCU_ECO_CLOCK_SETTING_FLAGS ) == 
       MCU_ECO_CLOCK_SETTING_FLAGS)
  {
    if ((regSrssAddrPtr->CLK_ECO_CONFIG & MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN) ==
         MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_EN)
    {
      /* set stabilization check count */
      if (EcoStabilizationCnt == 0U)
      {
        stubcnt = 1U;
      }
      else
      {
        stubcnt = EcoStabilizationCnt;
      }
      /* set return value MCU_NOT_OK */
      retVal = MCU_NOT_OK;
      do
      {
        if ((regSrssAddrPtr->CLK_ECO_STATUS & MCU_REG_MASK_SRSS_CLK_ECO_STATUS_ECO_OK) ==
             MCU_REG_MASK_SRSS_CLK_ECO_STATUS_ECO_OK)
        {
          /* set return value MCU_OK */
          retVal = MCU_OK;
          break;
        }
        stubcnt--;
      }
      while( stubcnt > 0U );
    }
  }

  return retVal;
}


/** \brief Mcu_EcoPrescaleStabWait_Regs
 **
 ** This function waits stabilization of ECO Prescale clock.
 ** If the ECO Prescale clock is not stable during EcoPrescaleStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] EcoPrescaleStabilizationCnt The count value of Eco Prescale clock stabilization.
 ** \param[in] ClockFlags                  ECO Prescale clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  ECO Prescale clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_EcoPrescaleStabWait_Regs(
  VAR( uint32, AUTOMATIC ) EcoPrescaleStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) stubcnt;
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  if ((ClockFlags & MCU_ECO_PRESCALE_SETTING_FLAGS ) == 
       MCU_ECO_PRESCALE_SETTING_FLAGS)
  {
    if ((regSrssAddrPtr->CLK_ECO_CONFIG & 
         MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_ENABLE) ==
         MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_ENABLE)
    {
      /* set stabilization check count */
      if (EcoPrescaleStabilizationCnt == 0U)
      {
        stubcnt = 1U;
      }
      else
      {
        stubcnt = EcoPrescaleStabilizationCnt;
      }
      /* set return value MCU_NOT_OK */
      retVal = MCU_NOT_OK;
      do
      {
        if ((regSrssAddrPtr->CLK_ECO_PRESCALE & 
             MCU_REG_MASK_SRSS_CLK_ECO_PRESCALE_ECO_DIV_ENABLED) ==
             MCU_REG_MASK_SRSS_CLK_ECO_PRESCALE_ECO_DIV_ENABLED)
        {
          /* set return value MCU_OK */
          retVal = MCU_OK;
          break;
        }
        stubcnt--;
      }
      while( stubcnt > 0U );
    }
  }

  return retVal;

}


/** \brief Mcu_LpEcoClkStabWait_Regs
 **
 ** This function waits stabilization of LPECO clock.
 ** If the LPECO clock is not stable during LpEcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] LpEcoStabilizationCnt         The count value of LPECO clock stabilization.
 ** \param[in] ClockFlags                    LPECO clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  LPECO clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_LpEcoClkStabWait_Regs(
  VAR( uint32, AUTOMATIC ) LpEcoStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) stubcnt;
  VAR( uint32, AUTOMATIC ) regCtlVal;
  VAR( uint32, AUTOMATIC ) regStatusVal;
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  if ((ClockFlags & MCU_LPECO_CLOCK_SETTING_FLAGS ) == 
       MCU_LPECO_CLOCK_SETTING_FLAGS)
  {
    if (regBackupAddrPtr != NULL_PTR)
    {
      /* read LPECO_CTL register */
      regCtlVal = regBackupAddrPtr->LPECO_CTL;
      if ((regCtlVal & 
           MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN) ==
           MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN)
      {
        /* set stabilization check count */
        if (LpEcoStabilizationCnt == 0U)
        {
          stubcnt = 1U;
        }
        else
        {
          stubcnt = LpEcoStabilizationCnt;
        }
        /* set return value MCU_NOT_OK */
        retVal = MCU_NOT_OK;
        /* mask LPECO_CTL register value with LPECO_AMPDET_EN bit */
        regCtlVal = (regCtlVal & MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_AMPDET_EN);
        do
        {
          /* read LPECO_STATUS register */
          regStatusVal = regBackupAddrPtr->LPECO_STATUS;
          if ((regStatusVal & 
               MCU_REG_MASK_SRSS_BACKUP_LPECO_STATUS_LPECO_READY) ==
               MCU_REG_MASK_SRSS_BACKUP_LPECO_STATUS_LPECO_READY)
          {
            /* check AMPDET status */
            /* if AMPDET is disabled or amplitude is sufficient */
            if ((regCtlVal != 
                 MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_AMPDET_EN) ||
                ((regStatusVal &
                  MCU_REG_MASK_SRSS_BACKUP_LPECO_STATUS_LPECO_AMPDET_OK) ==
                  MCU_REG_MASK_SRSS_BACKUP_LPECO_STATUS_LPECO_AMPDET_OK))
            {
              /* set return value MCU_OK */
              retVal = MCU_OK;
              break;
            }
          }
          stubcnt--;
        }
        while( stubcnt > 0U );
      }
    }
  }

  return retVal;
}


/** \brief Mcu_LpEcoPrescaleStabWait_Regs
 **
 ** This function waits stabilization of LPECO Prescale clock.
 ** If the LPECO Prescale clock is not stable during LpEcoPrescaleStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] LpEcoPrescaleStabilizationCnt The count value of LPECO Prescale clock stabilization.
 ** \param[in] ClockFlags                    LPECO Prescale clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  LPECO Prescale clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_LpEcoPrescaleStabWait_Regs(
  VAR( uint32, AUTOMATIC ) LpEcoPrescaleStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) stubcnt;
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  if ((ClockFlags & MCU_LPECO_PRESCALE_SETTING_FLAGS ) == 
       MCU_LPECO_PRESCALE_SETTING_FLAGS)
  {
    if (regBackupAddrPtr != NULL_PTR)
    {
      if ((regBackupAddrPtr->LPECO_CTL & 
           MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_DIV_ENABLE) ==
           MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_DIV_ENABLE)
      {
        /* set stabilization check count */
        if (LpEcoPrescaleStabilizationCnt == 0U)
        {
          stubcnt = 1U;
        }
        else
        {
          stubcnt = LpEcoPrescaleStabilizationCnt;
        }
        /* set return value MCU_NOT_OK */
        retVal = MCU_NOT_OK;
        do
        {
          if ((regBackupAddrPtr->LPECO_PRESCALE & 
               MCU_REG_MASK_SRSS_BACKUP_LPECO_PRESCALE_LPECO_DIV_ENABLED) ==
               MCU_REG_MASK_SRSS_BACKUP_LPECO_PRESCALE_LPECO_DIV_ENABLED)
          {
            /* set return value MCU_OK */
            retVal = MCU_OK;
            break;
          }
          stubcnt--;
        }
        while( stubcnt > 0U );
      }
    }
  }
  return retVal;

}


/** \brief Mcu_WcoClkStabWait_Regs
 **
 ** This function waits stabilization of WCO clock.
 ** If the WCO clock is not stable during WcoStabilizationCnt, this function returns MCU_NOT_OK.
 **
 ** \param[in] WcoStabilizationCnt    The count value of Wco clock stabilization.
 ** \param[in] ClockFlags             WCO clock setting flag.
 **
 ** \retval  MCU_OK      Stabilization is success.
 ** \retval  MCU_NOT_OK  WCO clock stabilization is not success.
 **
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WcoClkStabWait_Regs(
  VAR( uint32, AUTOMATIC ) WcoStabilizationCnt,
  VAR( uint8, AUTOMATIC )  ClockFlags
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) stubcnt;
  P2VAR( volatile Mcu_BackupRegType, AUTOMATIC, REGSPACE ) regBackupAddrPtr;

  regBackupAddrPtr = Mcu_RegBaseAddrPtr->BackupRegBaseAddr;

  if ((ClockFlags & MCU_WCO_CLOCK_SETTING_FLAGS ) == 
       MCU_WCO_CLOCK_SETTING_FLAGS)
  {
    if (regBackupAddrPtr != NULL_PTR)
    {
      if ((regBackupAddrPtr->CTL & MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN) ==
           MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN)
      {
        /* set stabilization check count */
        if (WcoStabilizationCnt == 0U)
        {
          stubcnt = 1U;
        }
        else
        {
          stubcnt = WcoStabilizationCnt;
        }
        /* set return value MCU_NOT_OK */
        retVal = MCU_NOT_OK;
        do
        {
          if ((regBackupAddrPtr->STATUS & MCU_REG_MASK_SRSS_BACKUP_STATUS_WCO_OK) ==
               MCU_REG_MASK_SRSS_BACKUP_STATUS_WCO_OK)
          {
            /* set return value MCU_OK */
            retVal = MCU_OK;
            break;
          }
          stubcnt--;
        }
        while( stubcnt > 0U );
      }
    }
  }

  return retVal;

}


/** \brief Mcu_PowerCtrlEnableWait_Regs
 **
 ** This function waits and returns the specified function status.
 **
 ** \param[in]  EnableToCnt    The counter value for waiting.
 ** \param[in]  PwrCtlRegMask  The mask of which bit to be waiting for.
 **
 ** \retval  MCU_OK         Specified function is already ready.
 ** \retval  MCU_NOT_OK_HW  Specified function is not ready yet.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_PowerCtrlEnableWait_Regs(
  VAR( uint32, AUTOMATIC ) EnableToCnt,
  VAR( uint32, AUTOMATIC ) PwrCtlRegMask
)
{
  P2VAR( volatile Mcu_SrssRegType, AUTOMATIC, REGSPACE ) regSrssAddrPtr;
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;
  VAR( uint32, AUTOMATIC ) stubcnt;

  regSrssAddrPtr = Mcu_RegBaseAddrPtr->SrssRegBaseAddr;

  /* check enable timeout count */
  if (EnableToCnt == 0U)
  {
    /* set return value MCU_OK */
    retVal = MCU_OK;
  }
  else
  {
    stubcnt = EnableToCnt;

    /* set return value MCU_NOT_OK_HW */
    retVal = MCU_NOT_OK_HW;
    do
    {
      if((regSrssAddrPtr->PWR_CTL2 & PwrCtlRegMask ) == PwrCtlRegMask)
      {
        /* set return value MCU_OK */
        retVal = MCU_OK;
        break;
      }
      stubcnt--;
    }
    while( stubcnt > 0U );
  }

  return retVal;
}


/** \brief Mcu_CheckMode_SrssPwrCtl_Regs
 **
 ** This function checks mode settings with SRSS power control HW registers.
 **
 ** \param[in]  McuSysResConfigPtr    The pointer to mode system common resource configuration.
 **
 ** \pre  McuSysResConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Power control settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Power control settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssPwrCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSysResConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal = MCU_OK;

  /* Get PWR_CTL2 register value */
  regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_CTL2;
  /* Mask PWR_CTL2 register value */
  regVal &= McuSysResConfigPtr->PwrCtlRegMask;
  /* If PWR_CTL2.BGREF_LPMODE config value is 1, it may not be reflected */
  if ((McuSysResConfigPtr->PwrCtlRegVal & MCU_REG_MASK_SRSS_PWR_CTL_BGREF_LPMODE)
      != MCU_REG_MASK_SRSS_PWR_CTL_BGREF_LPMODE) {
    /* Check register value with config value */
    if (McuSysResConfigPtr->PwrCtlRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckMode_SrssHvLvd_Regs
 **
 ** This function checks mode settings with SRSS HV low voltage detection HW registers.
 **
 ** \param[in]  McuHvLvdConfigPtr     The pointer to HV low voltage detection mode configuration.
 **
 ** \pre  McuHvLvdConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         HVLVD settings are consistent with registers.
 ** \retval  MCU_NOT_OK     HVLVD settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssHvLvd_Regs(
  P2CONST( Mcu_HvLvdConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuHvLvdConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( uint32, AUTOMATIC ) intMask;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check only if stop for update enable */
  /* because it may not be updated when stop for update disable */
  if (McuHvLvdConfigPtr->LvdStopEnable == STD_ON) {
    /* Set result unmatch (initial) */
    retVal = MCU_NOT_OK;
    /* Check HVLVD type */
    if (McuHvLvdConfigPtr->LvdType == MCU_HVLVD_HVLVD1) {
      /* Get PWR_LVD_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_LVD_CTL;
    } else {
      /* Get PWR_LVD_CTL2 register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_LVD_CTL2;
    }
    /* Mask register value */
    regVal &= MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_HT;
    /* Get HVLVD config value */
    cfgVal = McuHvLvdConfigPtr->PwrLvdCtlRegVal;
    /* If LVD enable */
    if (McuHvLvdConfigPtr->LvdEn == STD_ON) {
      /* Set HVLVD_EN bit of config value */
      cfgVal |= MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_EN_HT;
      /* If LVD on DeepSleep enable */
      if (McuHvLvdConfigPtr->LvdDpSlpEn == STD_ON) {
        /* Set HVLVD_DPSLP_EN bit of config value */
        cfgVal |= MCU_REG_MASK_SRSS_PWR_LVD_CTL_HVLVD_DPSLP_EN_HT;
      }
    }
    /* Check register value with config value */
    if (cfgVal == regVal) {
      /* Get interrupt mask register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->SRSS_INTR_MASK;
      /* Set HVLVDn bit */
      intMask = ((uint32)MCU_REG_MASK_SRSS_INTR_MASK_BIT0 << McuHvLvdConfigPtr->LvdType);
      /* If interrupt enable */
      if (McuHvLvdConfigPtr->IntEn == STD_ON) {
        /* if HVLVDn bit is set */
        if ((regVal & intMask) == intMask) {
          /* Set result match */
          retVal = MCU_OK;
        }
      } else {
        /* if HVLVDn bit is not set */
        if ((regVal & intMask) == 0U) {
          /* Set result match */
          retVal = MCU_OK;
        }
      }
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckMode_SrssSsvCtl_Regs
 **
 ** This function checks mode settings with SRSS supply supervision control HW registers.
 **
 ** \param[in]  McuSysResConfigPtr    The pointer to mode system common resource configuration.
 **
 ** \pre  McuSysResConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Supply supervision settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Supply supervision settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_SrssSsvCtl_Regs(
  P2CONST( Mcu_SysResConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSysResConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal = MCU_OK;

  if (McuSysResConfigPtr->PwrSsvCtlNum != 0U) {
    /* Get PWR_SSV_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PWR_SSV_CTL;
    /* Check register value with config value */
    if (McuSysResConfigPtr->PwrSsvCtlRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckMode_CpussDmaCtl_Regs
 **
 ** This function checks mode settings with CPUSS DMA control HW registers.
 **
 ** \param[in]  McuDmaConfigPtr  The pointer to DMA configuration.
 **
 ** \retval  MCU_OK         DMA control mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     DMA control mode settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussDmaCtl_Regs(
  P2CONST( Mcu_DmaConfigDataType, AUTOMATIC, MCU_APPL_CONST ) McuDmaConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal = MCU_OK;

  if ((McuDmaConfigPtr->DmaValidFlag & MCU_DMA_VALID_FLAG_DW0_VALID) == 
      MCU_DMA_VALID_FLAG_DW0_VALID) {
    /* Get ENABLED bit of DW0 control register */
    regVal = (Mcu_RegBaseAddrPtr->Dw0RegBaseAddr->DW_CTL & 
              MCU_REG_MASK_DW_CTL_ENABLED);
    if (McuDmaConfigPtr->Dw0En == STD_ON) {
      cfgVal = MCU_REG_MASK_DW_CTL_ENABLED;
    } else {
      cfgVal = MCU_REG_MASK_DW_CTL_ENABLED_CLEARED;
    }
    if (cfgVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }
  if (retVal == MCU_OK) {
    if ((McuDmaConfigPtr->DmaValidFlag & MCU_DMA_VALID_FLAG_DW1_VALID) == 
        MCU_DMA_VALID_FLAG_DW1_VALID) {
      /* Get ENABLED bit of DW1 control register */
      regVal = (Mcu_RegBaseAddrPtr->Dw1RegBaseAddr->DW_CTL & 
                MCU_REG_MASK_DW_CTL_ENABLED);
      if (McuDmaConfigPtr->Dw1En == STD_ON) {
        cfgVal = MCU_REG_MASK_DW_CTL_ENABLED;
      } else {
        cfgVal = MCU_REG_MASK_DW_CTL_ENABLED_CLEARED;
      }
      if (cfgVal != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    }
    if (retVal == MCU_OK) {
      if ((McuDmaConfigPtr->DmaValidFlag & MCU_DMA_VALID_FLAG_DMA_VALID) == 
          MCU_DMA_VALID_FLAG_DMA_VALID) {
        /* Get ENABLED bit of DMA control register */
        regVal = (Mcu_RegBaseAddrPtr->DmaRegBaseAddr->DMAC_CTL & 
                  MCU_REG_MASK_DMAC_CTL_ENABLED);
        if (McuDmaConfigPtr->DmaEn == STD_ON) {
          cfgVal = MCU_REG_MASK_DMAC_CTL_ENABLED;
        } else {
          cfgVal = MCU_REG_MASK_DMAC_CTL_ENABLED_CLEARED;
        }
        if (cfgVal != regVal) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckMode_CpussRamPwr_Regs
 **
 ** This function checks mode settings with CPUSS RAM power HW registers.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         RAM power mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     RAM power mode settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussRamPwr_Regs(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal = MCU_OK;

  /* Get RAM_PWR_DELAY_CTL register value */
  regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM_PWR_DELAY_CTL;
  /* Check register value with config value */
  if (McuModeConfigPtr->RamPwrDelayCtl == regVal) {
    if (McuModeConfigPtr->Ram1PwrCtlRegVal != 0U) {
      /* Get RAM1_PWR_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_PWR_CTL;
      /* Mask register value */
      regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM1_PWR_CTL_VECTKEYSTAT;
      /* Get config value */
      cfgVal = McuModeConfigPtr->Ram1PwrCtlRegVal;
      /* Mask config value */
      cfgVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM1_PWR_CTL_VECTKEYSTAT;
      /* Check register value with config value */
      if (cfgVal != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    }
    if (retVal == MCU_OK) {
      if (McuModeConfigPtr->Ram2PwrCtlRegVal != 0U) {
        /* Get RAM2_PWR_CTL register value */
        regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_PWR_CTL;
        /* Mask register value */
        regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM2_PWR_CTL_VECTKEYSTAT;
        /* Get config value */
        cfgVal = McuModeConfigPtr->Ram2PwrCtlRegVal;
        /* Mask config value */
        cfgVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM2_PWR_CTL_VECTKEYSTAT;
        /* Check register value with config value */
        if (cfgVal != regVal) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      }
      if (retVal == MCU_OK) {
        /* Check RAM0 power mode registers */
        retVal = Mcu_CheckMode_CpussRam0Pwr_Regs(
                   (uint32)McuModeConfigPtr->Ram0PwrMacroConfigNum,
                   McuModeConfigPtr->Ram0PwrMacroConfigPtr
                 );
      }
    }
  } else {
    /* Set result unmatch */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckMode_CpussRam0Pwr_Regs
 **
 ** This function checks clock settings with CPUSS RAM0 power macro HW registers.
 **
 ** \param[in]  McuRam0PwrMacroConfigNum  The number of RAM0 power macro mode configuration.
 ** \param[in]  McuRam0PwrMacroConfigPtr  The pointer to RAM0 power macro mode configuration.
 **
 ** \pre  McuRam0PwrMacroConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         RAM0 power mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     RAM0 power mode settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussRam0Pwr_Regs(
  VAR( uint32, AUTOMATIC ) McuRam0PwrMacroConfigNum,
  P2CONST( Mcu_Ram0PwrMacroConfigType, MCU_CONST, MCU_APPL_CONST ) McuRam0PwrMacroConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuRam0PwrMacroConfigNum; idx++) {
    /* Get RAM0 power mode control register index */
    regIdx = McuRam0PwrMacroConfigPtr[idx].Ram0PwrMacroRegIdx;
    /* Get RAM0_PWR_MACRO_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_PWR_MACRO_CTL[regIdx];
    /* Mask register value */
    regVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM0_PWR_MACRO_CTL_VECTKEYSTAT;
    /* Get config value */
    cfgVal = McuRam0PwrMacroConfigPtr[idx].Ram0PwrMacroCtlRegVal;
    /* Mask config value */
    cfgVal &= ~(uint32)MCU_REG_MASK_CPUSS_RAM0_PWR_MACRO_CTL_VECTKEYSTAT;
    /* Check register value with config value */
    if (cfgVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssClkOut_Regs
 **
 ** This function checks clock settings with SRSS clock output HW registers.
 **
 ** \param[in]  McuClockOutputConfigPtr  The pointer to clock output clock configuration.
 **
 ** \retval  MCU_OK         SRSS clock output settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS clock output settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkOut_Regs(
  P2CONST( Mcu_ClockOutputConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuClockOutputConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuClockOutputConfigPtr != NULL_PTR) {
    /* Set result unmatch (initial) */
    retVal = MCU_NOT_OK;
    /* Get TST_DDFT_FAST_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->TST_DDFT_FAST_CTL;
    /* Check register value with config value */
    if (McuClockOutputConfigPtr->TstDdftFastCtlRegVal == regVal) {
      /* Get TST_DDFT_SLOW_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->TST_DDFT_SLOW_CTL;
      /* Check register value with config value */
      if (McuClockOutputConfigPtr->TstDdftSlowCtlRegVal == regVal) {
        /* Get CLK_OUTPUT_FAST register value */
        regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_OUTPUT_FAST;
        /* Check register value with config value */
        if (McuClockOutputConfigPtr->ClkOutputFastRegVal == regVal) {
          /* Get CLK_OUTPUT_SLOW register value */
          regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_OUTPUT_SLOW;
          /* Check register value with config value */
          if (McuClockOutputConfigPtr->ClkOutputSlowRegVal == regVal) {
            /* Set result match */
            retVal = MCU_OK;
          }
        }
      }
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssDsi_Regs
 **
 ** This function checks clock settings with SRSS DSI HW registers.
 **
 ** \param[in]  McuDsiConfigNum        The number of DSI clock configuration.
 ** \param[in]  McuDsiConfigPtr        The pointer to DSI clock configuration.
 **
 ** \retval  MCU_OK         DSI clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     DSI clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssDsi_Regs(
  VAR( uint32, AUTOMATIC ) McuDsiConfigNum,
  P2CONST( Mcu_DsiConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuDsiConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuDsiConfigNum; idx++) {
    /* Get DSI select register index */
    regIdx = McuDsiConfigPtr[idx].DsiRegIdx;
    /* Get CLK_DSI_SELECT register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_DSI_SELECT[regIdx];
    /* Check register value with config value */
    if (McuDsiConfigPtr[idx].ClkDsiSelectRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssClkPath_Regs
 **
 ** This function checks clock settings with SRSS clock path HW registers.
 **
 ** \param[in]  McuClockPathConfigNum  The number of clock path clock configuration.
 ** \param[in]  McuClockPathConfigPtr  The pointer to clock path clock configuration.
 **
 ** \retval  MCU_OK         SRSS clock path settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS clock path settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkPath_Regs(
  VAR( uint32, AUTOMATIC ) McuClockPathConfigNum,
  P2CONST( Mcu_ClockPathConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuClockPathConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuClockPathConfigNum; idx++) {
    /* Get clock path select register index */
    regIdx = McuClockPathConfigPtr[idx].ClockPathRegIdx;
    /* Get CLK_PATH_SELECT register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_PATH_SELECT[regIdx];
    /* Check register value with config value */
    if (McuClockPathConfigPtr[idx].ClkPathSelectRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssClkRoot_Regs
 **
 ** This function checks clock settings with SRSS clock root HW registers.
 **
 ** \param[in]  McuClockRootConfigNum  The number of clock root clock configuration.
 ** \param[in]  McuClockRootConfigPtr  The pointer to clock root clock configuration.
 **
 ** \retval  MCU_OK         SRSS clock root settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS clock root settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkRoot_Regs(
  VAR( uint32, AUTOMATIC ) McuClockRootConfigNum,
  P2CONST( Mcu_ClockRootConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuClockRootConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuClockRootConfigNum; idx++) {
    /* Get clock root select register index */
    regIdx = McuClockRootConfigPtr[idx].ClockRootRegIdx;
    /* Get CLK_ROOT_SELECT register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ROOT_SELECT[regIdx];
    /* Check register value with config value */
    if (McuClockRootConfigPtr[idx].ClkRootSelectRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssClkTimer_Regs
 **
 ** This function checks clock settings with SRSS timer clock HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS clock timer settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS clock timer settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkTimer_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* CLK_TIMER_CTL */
  if (McuClockConfigPtr->TimerClockConfigPtr != NULL_PTR) {
    /* Check only if stop for update enable */
    /* because it may not be updated when stop for update disable */
    if (McuClockConfigPtr->TimerClockStopEnable == STD_ON) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      /* Get CLK_TIMER_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_TIMER_CTL;
      /* Get config value */
      cfgVal = McuClockConfigPtr->TimerClockConfigPtr->ClkTimerCtlRegVal;
      if (McuClockConfigPtr->TimerClockEn == STD_ON) {
        /* Set TIMER_ENABLE bit of config value */
        cfgVal |= MCU_REG_MASK_SRSS_CLK_TIMER_CTL_TIMER_ENABLE;
      }
      /* Check register value with config value */
      if (cfgVal == regVal) {
        /* Set result match */
        retVal = MCU_OK;
      }
    } else {
      /* Set result match */
      retVal = MCU_OK;
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssClkPump_Regs
 **
 ** This function checks clock settings with SRSS pump clock HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS pump clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS pump clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssClkPump_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) regCompVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  /* Get CLK_SELECT register value */
  regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_SELECT;
  /* Check pump clock setting only if stop for update enable */
  /* because it may not be updated when stop for update disable */
  if (McuClockConfigPtr->PumpClockStopEnable == STD_ON) {
    /* LFCLK_SEL is not checked because it may not be updated */
    regCompVal = (regVal & ~(uint32)MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL);
    cfgVal = (McuClockConfigPtr->ClkSelectRegVal & 
              ~(uint32)MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL);
    if (McuClockConfigPtr->PumpClockEn == STD_ON) {
        cfgVal |= MCU_REG_MASK_SRSS_CLK_SELECT_PUMP_ENABLE;
    }
    /* Check register value with config value */
    if (cfgVal != regCompVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }
  if (retVal == MCU_OK) {
    /* Check LFCLK settng only if unlock WDT enable */
    /* because it may not be updated when unlock WDT disable */
    if (McuClockConfigPtr->UnlockWdtEnable == STD_ON) {
      regCompVal = (regVal & MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL);
      cfgVal = (McuClockConfigPtr->ClkSelectRegVal & 
                MCU_REG_MASK_SRSS_CLK_SELECT_LFCLK_SEL);
      /* Check register value with config value */
      if (cfgVal != regCompVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssOsc_Regs
 **
 ** This function checks clock settings with each SRSS oscillator HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS oscillator settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS oscillator settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssOsc_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check ILO registers */
  retVal = Mcu_CheckClock_SrssIlo_Regs(McuClockConfigPtr);
  if (retVal == MCU_OK) {
    /* Check ILO1 registers */
    retVal = Mcu_CheckClock_SrssIlo1_Regs(McuClockConfigPtr);
    if (retVal == MCU_OK) {
      /* Check LPECO registers */
      retVal = Mcu_CheckClock_SrssLpEco_Regs(McuClockConfigPtr->LpEcoConfigPtr);
      if (retVal == MCU_OK) {
        /* Check LPECO prescale registers */
        retVal = Mcu_CheckClock_SrssLpEcoPrescale_Regs(McuClockConfigPtr->LpEcoConfigPtr);
        if (retVal == MCU_OK) {
          /* Check ECO registers */
          retVal = Mcu_CheckClock_SrssEco_Regs(McuClockConfigPtr->EcoConfigPtr);
          if (retVal == MCU_OK) {
            /* Check ECO prescale registers */
            retVal = Mcu_CheckClock_SrssEcoPrescale_Regs(McuClockConfigPtr->EcoConfigPtr);
            if (retVal == MCU_OK) {
              /* Get CLK_IMO_CONFIG register value */
              regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_IMO_CONFIG;
              /* Check register value with config value */
              if (McuClockConfigPtr->ClkImoConfigRegVal == regVal) {
                /* Set result match */
                retVal = MCU_OK;
              } else {
                /* Set result unmatch */
                retVal = MCU_NOT_OK;
              }
            }
          }
        }
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssIlo_Regs
 **
 ** This function checks clock settings with each SRSS ILO HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS ILO settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS ILO settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssIlo_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  /* Check ILO0 settng only if unlock WDT enable */
  /* because it may not be updated when unlock WDT disable */
  if (McuClockConfigPtr->UnlockWdtEnable == STD_ON) {
    /* Get CLK_ILO0_CONFIG register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ILO0_CONFIG;
    /* If CLK_ILO0_CONFIG.ENABLE config value is 0, it may not be reflected */
    if ((McuClockConfigPtr->ClkIloConfigRegVal & MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE)
         == MCU_REG_MASK_SRSS_CLK_ILO0_CONFIG_ENABLE) {
      /* Check register value with config value */
      if (McuClockConfigPtr->ClkIloConfigRegVal != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssIlo1_Regs
 **
 ** This function checks clock settings with each SRSS ILO1 HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS ILO1 settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS ILO1 settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssIlo1_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  if (McuClockConfigPtr->Ilo1ConfigNum != 0U) {
    /* Get CLK_ILO01_CONFIG register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ILO1_CONFIG;
    /* Check register value with config value */
    if (McuClockConfigPtr->ClkIlo1ConfigRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssEco_Regs
 **
 ** This function checks clock settings with each SRSS ECO HW register.
 **
 ** \param[in]  McuEcoConfigPtr        The pointer to ECO configuration.
 **
 ** \retval  MCU_OK         SRSS ECO settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS ECO settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssEco_Regs(
  P2CONST( Mcu_EcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuEcoConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuEcoConfigPtr != NULL_PTR) {
    /* Set result unmatch (initial) */
    retVal = MCU_NOT_OK;
    /* Get CLK_ECO_CONFIG register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ECO_CONFIG;
    /* Mask register value */
    regVal &= ~(uint32)(MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_DISABLE | 
                        MCU_REG_MASK_SRSS_CLK_ECO_CONFIG_ECO_DIV_ENABLE);
    /* Check register value with config value */
    if (McuEcoConfigPtr->ClkEcoConfigRegVal == regVal) {
      if (McuEcoConfigPtr->ClkEcoConfig2Update == STD_ON) {
        if (McuEcoConfigPtr->ClkEcoConfig2RegVal == 
            Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ECO_CONFIG2) {
          /* Set result match */
          retVal = MCU_OK;
        }
      } else {
        /* Set result match */
        retVal = MCU_OK;
      }
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssEcoPrescale_Regs
 **
 ** This function checks clock settings with each SRSS ECO prescale HW register.
 **
 ** \param[in]  McuEcoConfigPtr        The pointer to ECO configuration.
 **
 ** \retval  MCU_OK         SRSS ECO prescale settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS ECO prescale settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssEcoPrescale_Regs(
  P2CONST( Mcu_EcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuEcoConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuEcoConfigPtr != NULL_PTR) {
    if (McuEcoConfigPtr->EcoPrescalerNum != 0U) {
      /* Get CLK_ECO_PRESCALE register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ECO_PRESCALE;
      /* Get config value */
      cfgVal = McuEcoConfigPtr->ClkEcoPrescalerRegVal;
      if (McuEcoConfigPtr->EcoPrescalerEn == STD_ON) {
        /* Set ECO_DIV_ENABLED field of config value */
        cfgVal |= MCU_REG_MASK_SRSS_CLK_ECO_PRESCALE_ECO_DIV_ENABLED;
      }
      /* Check register value with config value */
      if (cfgVal == regVal) {
        /* Set result match */
        retVal = MCU_OK;
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    } else {
      /* Set result match */
      retVal = MCU_OK;
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssLpEco_Regs
 **
 ** This function checks clock settings with each SRSS BACKUP LPECO HW register.
 **
 ** \param[in]  McuLpEcoConfigPtr      The pointer to LPECO configuration.
 **
 ** \retval  MCU_OK         SRSS BACKUP LPECO settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS BACKUP LPECO settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssLpEco_Regs(
  P2CONST( Mcu_LpEcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuLpEcoConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuLpEcoConfigPtr != NULL_PTR) {
    if (McuLpEcoConfigPtr->LpEcoStopEnable == STD_ON) {
      /* Get LPECO_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->BackupRegBaseAddr->LPECO_CTL;
      regVal &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_DIV_ENABLE;
      /* Get LPECO config value */
      cfgVal = McuLpEcoConfigPtr->LpEcoCtlRegVal;
      if (McuLpEcoConfigPtr->LpEcoEn == STD_ON) {
        /* Set LPECO_EN bit */
        cfgVal |= MCU_REG_MASK_SRSS_BACKUP_LPECO_CTL_LPECO_EN;
      }
      /* Check register value with config value */
      if (cfgVal == regVal) {
        /* Set result match */
        retVal = MCU_OK;
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    } else {
      /* Set result match */
      retVal = MCU_OK;
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssLpEcoPrescale_Regs
 **
 ** This function checks clock settings with each SRSS BACKUP LPECO prescale HW register.
 **
 ** \param[in]  McuLpEcoConfigPtr      The pointer to LPECO configuration.
 **
 ** \retval  MCU_OK         SRSS BACKUP LPECO prescale settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS BACKUP LPECO prescale settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssLpEcoPrescale_Regs(
  P2CONST( Mcu_LpEcoConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuLpEcoConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuLpEcoConfigPtr != NULL_PTR) {
    if (McuLpEcoConfigPtr->LpEcoPrescalerNum != 0U) {
      if (McuLpEcoConfigPtr->LpEcoPrescalerEn == STD_ON) {
        if (McuLpEcoConfigPtr->LpEcoStopEnable == STD_ON) {
          /* Get LPECO_PRESCALE register value */
          regVal = Mcu_RegBaseAddrPtr->BackupRegBaseAddr->LPECO_PRESCALE;
          regVal &= ~(uint32)MCU_REG_MASK_SRSS_BACKUP_LPECO_PRESCALE_LPECO_DIV_ENABLED;
          /* Check register value with config value */
          if (McuLpEcoConfigPtr->LpEcoPrescalerRegVal == regVal) {
            /* Set result match */
            retVal = MCU_OK;
          } else {
            /* Set result unmatch */
            retVal = MCU_NOT_OK;
          }
        } else {
          /* Set result match */
          retVal = MCU_OK;
        }
      } else {
        /* Set result match */
        retVal = MCU_OK;
      }
    } else {
      /* Set result match */
      retVal = MCU_OK;
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssFll_Regs
 **
 ** This function checks clock settings with SRSS FLL HW registers.
 **
 ** \param[in]  McuFllConfigPtr        The pointer to FLL clock configuration.
 **
 ** \retval  MCU_OK         SRSS FLL clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS FLL clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssFll_Regs(
  P2CONST( Mcu_FllConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuFllConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuFllConfigPtr != NULL_PTR) {
    /* Check only if stop for update enable */
    /* because it may not be updated when stop for update disable */
    if (McuFllConfigPtr->FllStopEnable == STD_ON) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      /* Get CLK_FLL_CONFIG register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_FLL_CONFIG;
      /* Get config value */
      cfgVal = McuFllConfigPtr->ClkFllConfigRegVal;
      if (McuFllConfigPtr->FllEn == STD_ON) {
        /* Set FLL_ENABLE bit of config value */
        cfgVal |= MCU_REG_MASK_SRSS_CLK_FLL_CONFIG_FLL_ENABLE;
      }
      /* Check register value with config value */
      if (cfgVal == regVal) {
        /* Get CLK_FLL_CONFIG2 register value */
        regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_FLL_CONFIG2;
        /* Check register value with config value */
        if (McuFllConfigPtr->ClkFllConfig2RegVal == regVal) {
          /* Get CLK_FLL_CONFIG3 register value */
          regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_FLL_CONFIG3;
          /* Check register value with config value */
          if (McuFllConfigPtr->ClkFllConfig3RegVal == regVal) {
            /* CLK_FLL_CONFIG4 register value except for CCO_FREQ bit which is automatically updated by HW */
            regVal = (Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_FLL_CONFIG4 & ~(uint32)MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_FREQ);
            /* Get config value except for CCO_FREQ bit which is automatically updated by HW */
            cfgVal = (McuFllConfigPtr->ClkFllConfig4RegVal & ~(uint32)MCU_REG_MASK_SRSS_CLK_FLL_CONFIG4_CCO_FREQ);
            /* Check register value with config value */
            if (cfgVal == regVal) {
              /* Set result match */
              retVal = MCU_OK;
            }
          }
        }
      }
    } else {
      /* Set result match */
      retVal = MCU_OK;
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssPll_Regs
 **
 ** This function checks clock settings with SRSS PLL HW registers.
 **
 ** \param[in]  McuPllConfigNum        The number of PLL clock configuration.
 ** \param[in]  McuPllConfigPtr        The pointer to PLL clock configuration.
 **
 ** \retval  MCU_OK         SRSS PLL clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS PLL clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssPll_Regs(
  VAR( uint32, AUTOMATIC ) McuPllConfigNum,
  P2CONST( Mcu_PllConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuPllConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuPllConfigNum; idx++) {
    /* Check only if stop for update enable */
    /* because it may not be updated when stop for update disable */
    if (McuPllConfigPtr[idx].PllStopEnable == STD_ON) {
      /* Get PLL configuration register index */
      regIdx = McuPllConfigPtr[idx].PllRegIdx;
      /* Get CLK_PLL_CONFIG register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_PLL_CONFIG[regIdx];
      /* Get config value */
      cfgVal = McuPllConfigPtr[idx].ClkPllConfigRegVal;
      if (McuPllConfigPtr[idx].PllEn == STD_ON) {
        /* Set PLL_ENABLE bit of config value */
        cfgVal |= MCU_REG_MASK_SRSS_CLK_PLL_CONFIG_ENABLE;
      }
      /* Check register value with config value */
      if (cfgVal != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
        break;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssSscg_Regs
 **
 ** This function checks clock settings with SRSS SSCG HW registers.
 **
 ** \param[in]  McuSscgConfigNum       The number of SSCG clock configuration.
 ** \param[in]  McuSscgConfigPtr       The pointer to SSCG clock configuration.
 **
 ** \retval  MCU_OK         SRSS SSCG clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS SSCG clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssSscg_Regs(
  VAR( uint32, AUTOMATIC ) McuSscgConfigNum,
  P2CONST( Mcu_SscgConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuSscgConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) cfgIdx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;
  P2VAR( volatile Mcu_SscgRegType, AUTOMATIC, REGSPACE ) regSscgAddrPtr;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (cfgIdx=0U; cfgIdx<McuSscgConfigNum; cfgIdx++) {
    /* Check only if stop for update enable */
    /* because it may not be updated when stop for update disable */
    if (McuSscgConfigPtr[cfgIdx].SscgStopEnable == STD_ON) {
      /* Get PLL configuration register index */
      regIdx = McuSscgConfigPtr[cfgIdx].SscgRegIdx;
      /* Get SSCG base address pointer */
      regSscgAddrPtr = 
        &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->PLL400_STRUCT[regIdx]);
      /* Get PLL400_STRUCT.CONFIG register value */
      regVal = regSscgAddrPtr->PLL400_STRUCT_CONFIG;
      /* Get config value */
      cfgVal = McuSscgConfigPtr[cfgIdx].Pll400ConfigRegVal;
      if (McuSscgConfigPtr[cfgIdx].SscgEn == STD_ON) {
        /* Set PLL_ENABLE bit of config value */
        cfgVal |= MCU_REG_MASK_SRSS_PLL400_STRUCT_CONFIG_ENABLE;
      }
      /* Check register value with config value */
      if (cfgVal == regVal) {
        /* Check PLL400_STRUCT.CONFIG2 register */
        if (McuSscgConfigPtr[cfgIdx].Pll400Config2RegVal == 
            regSscgAddrPtr->PLL400_STRUCT_CONFIG2) {
          /* Check PLL400_STRUCT.CONFIG3 register */
          if (McuSscgConfigPtr[cfgIdx].Pll400Config3RegVal != 
              regSscgAddrPtr->PLL400_STRUCT_CONFIG3) {
            /* Set result unmatch */
            retVal = MCU_NOT_OK;
          }
        } else {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
      /* Check register value with config value */
      if (retVal == MCU_NOT_OK) {
        break;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssCsv_Regs
 **
 ** This function checks clock settings with each SRSS clock supervisor HW register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SRSS CSV settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS CSV settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssCsv_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check HF CSV registers */
  retVal = Mcu_CheckClock_SrssHfCsv_Regs(
             (uint32)McuClockConfigPtr->HfCsvConfigNum,
             McuClockConfigPtr->HfCsvConfigPtr
           );
  if (retVal == MCU_OK) {
    /* Check REF CSV registers */
    retVal = Mcu_CheckClock_SrssRefCsv_Regs(
               McuClockConfigPtr->RefCsvConfigPtr,
               &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_REF_CSV)
             );
    if (retVal == MCU_OK) {
      /* Check LF CSV registers */
      retVal = Mcu_CheckClock_SrssRefCsv_Regs(
                 McuClockConfigPtr->LfCsvConfigPtr,
                 &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_LF_CSV)
               );
      if (retVal == MCU_OK) {
        /* Check ILO CSV registers */
        retVal = Mcu_CheckClock_SrssRefCsv_Regs(
                   McuClockConfigPtr->IloCsvConfigPtr,
                   &(Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_ILO_CSV)
                 );
        if (retVal == MCU_OK) {
          /* Check BAK CSV registers */
          retVal = Mcu_CheckClock_SrssRefCsv_Regs(
                     McuClockConfigPtr->BakCsvConfigPtr,
                     &(Mcu_RegBaseAddrPtr->BackupRegBaseAddr->CLK_BAK_CSV)
                   );
          if (retVal == MCU_OK) {
            /* Get CSV_REF_SEL register value */
            regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CSV_REF_SEL;
            /* Check register value with config value */
            if (McuClockConfigPtr->CsvRefSelRegVal != regVal) {
              /* Set result unmatch */
              retVal = MCU_NOT_OK;
            }
          }
        }
      }
    }
  }
  return retVal;
}


/** \brief Mcu_CheckClock_SrssHfCsv_Regs
 **
 ** This function checks clock settings with SRSS HF clock supervisor HW registers.
 **
 ** \param[in]  McuHfCsvConfigNum      The number of HF clock supervisor clock configuration.
 ** \param[in]  McuHfCsvConfigPtr      The pointer to HF clock supervisor clock configuration.
 **
 ** \retval  MCU_OK         SRSS HF clock supervisor settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS HF clock supervisor settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssHfCsv_Regs(
  VAR( uint32, AUTOMATIC ) McuHfCsvConfigNum,
  P2CONST( Mcu_HfCsvConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuHfCsvConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuHfCsvConfigNum; idx++) {
    /* Get HF CSV register index */
    regIdx = McuHfCsvConfigPtr[idx].HfCsvRegIdx;
    /* Get REF_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_HF_CSV[regIdx].REF_CTL;
    /* Check register value with config value */
    if (McuHfCsvConfigPtr[idx].HfCtlRegVal == regVal) {
      /* Get REF_LIMIT register value */
      regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_HF_CSV[regIdx].REF_LIMIT;
      /* Check register value with config value */
      if (McuHfCsvConfigPtr[idx].HfLimitRegVal == regVal) {
        /* Get MON_CTL register value */
        regVal = Mcu_RegBaseAddrPtr->SrssRegBaseAddr->CLK_HF_CSV[regIdx].MON_CTL;
        /* Check register value with config value */
        if (McuHfCsvConfigPtr[idx].MonCtlRegVal != regVal) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    } else {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
    if (retVal == MCU_NOT_OK) {
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssRefCsv_Regs
 **
 ** This function checks clock settings with each SRSS clock supervisor HW register.
 **
 ** \param[in]  McuCsvConfigPtr        The pointer to clock supervisor clock configuration.
 ** \param[in]  McuCsvRegPtr           The pointer to clock supervisor register.
 **
 ** \retval  MCU_OK         SRSS REF clock supervisor settings are consistent with registers.
 ** \retval  MCU_NOT_OK     SRSS REF clock supervisor settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssRefCsv_Regs(
  P2CONST( Mcu_CsvConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuCsvConfigPtr,
  P2CONST( volatile Mcu_ClkCsvRegType, MCU_CONST, REGSPACE ) McuCsvRegPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuCsvConfigPtr != NULL_PTR) {
    /* Set result unmatch */
    retVal = MCU_NOT_OK;
    /* Get REF_CTL register value */
    regVal = McuCsvRegPtr->REF_CTL;
    /* Check register value with config value */
    if (McuCsvConfigPtr->RefCtlRegVal == regVal) {
      /* Get REF_LIMIT register value */
      regVal = McuCsvRegPtr->REF_LIMIT;
      /* Check register value with config value */
      if (McuCsvConfigPtr->RefLimitRegVal == regVal) {
        /* Get MON_CTL register value */
        regVal = McuCsvRegPtr->MON_CTL;
        /* Check register value with config value */
        if (McuCsvConfigPtr->MonCtlRegVal == regVal) {
          /* Set result match */
          retVal = MCU_OK;
        }
      }
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_SrssBackup_Regs
 **
 ** This function checks clock settings with SRSS backup HW registers.
 **
 ** \param[in]  McuBackupConfigPtr     The pointer to backup clock configuration.
 **
 ** \retval  MCU_OK         BACKUP settings are consistent with registers.
 ** \retval  MCU_NOT_OK     BACKUP settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_SrssBackup_Regs(
  P2CONST( Mcu_BackupConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuBackupConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  if (McuBackupConfigPtr != NULL_PTR) {
    if (McuBackupConfigPtr->WcoStopEnable == STD_ON) {
      /* Get CTL register value */
      regVal = (Mcu_RegBaseAddrPtr->BackupRegBaseAddr->CTL & 
                (McuBackupConfigPtr->CtlRegMask | MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN));
      /* Get config value */
      cfgVal = (McuBackupConfigPtr->CtlRegVal & McuBackupConfigPtr->CtlRegMask);
      if (McuBackupConfigPtr->WcoEn == STD_ON) {
        /* Set WCO_EN bit of config value */
        cfgVal |= MCU_REG_MASK_SRSS_BACKUP_CTL_WCO_EN;
      }
      /* Check register value with config value */
      if (cfgVal == regVal) {
        /* Set result match */
        retVal = MCU_OK;
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    } else {
      /* Set result match */
      retVal = MCU_OK;
    }
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_CpussCm0_Regs
 **
 ** This function checks clock settings with CPUSS CM0 HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CPUSS CM0 clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CPUSS CM0 clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE )
Mcu_CheckClock_CpussCm0_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  if (McuClockConfigPtr->MemClockExist == STD_OFF) {
    /* Get SLOW_CLOCK_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->SLOW_CLOCK_CTL;
    /* Check register value with config value */
    if ((McuClockConfigPtr->SlowClockCtlRegVal | McuClockConfigPtr->PeriClockCtlRegVal) != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  } else {
    /* Get SLOW_CLOCK_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->SLOW_CLOCK_CTL;
    /* Check register value with config value */
    if (McuClockConfigPtr->SlowClockCtlRegVal == regVal) {
      /* Get PERI_CLOCK_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->PERI_CLOCK_CTL;
      /* Check register value with config value */
      if (McuClockConfigPtr->PeriClockCtlRegVal == regVal) {
        /* Get MEM_CLOCK_CTL register value */
        regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->MEM_CLOCK_CTL;
        /* Check register value with config value */
        if (McuClockConfigPtr->MemClockCtlRegVal != regVal) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    } else {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_CpussMainCore_Regs
 **
 ** This function checks clock settings with CPUSS Main Core HW registers.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CPUSS Main Core clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CPUSS Main Core clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_CpussMainCore_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) cnt;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (cnt=0U; cnt < McuClockConfigPtr->FastClockCtlNum; cnt++){
    /* Get FAST_CLOCK_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_CLOCK[cnt].FAST_CLOCK_CTL;
    /* Check register value with config value */
    if (McuClockConfigPtr->FastClockCtlRegVal[cnt] != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      break;
    }
  }

  if (retVal == MCU_OK) {
    if (McuClockConfigPtr->MemClockExist == STD_ON) {
      /* Get TRC_DBG_CLOCK_CTL register value */
      regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->FAST_CLOCK[0].TRC_DBG_CLOCK_CTL;
      /* Check register value with config value */
      if (McuClockConfigPtr->TrcDbgClockCtlRegVal != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_CpussWaitCycle_Regs
 **
 ** This function checks clock settings with each memory control register.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         CPUSS wait cycle settings are consistent with registers.
 ** \retval  MCU_NOT_OK     CPUSS wait cycle settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_CpussWaitCycle_Regs(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;

  /* Get ROM_CTL register value */
  regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->ROM_CTL;
  /* Check register value with config value */
  if (McuClockConfigPtr->RomCtlRegVal == regVal) {
    /* Get RAM0_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM0_CTL;
    /* Mask register value */
    regVal &= McuClockConfigPtr->Ram0CtlRegMask;
    /* Check register value with config value */
    if (McuClockConfigPtr->Ram0CtlRegVal == regVal) {
      if (McuClockConfigPtr->Ram1CtlRegMask != 0U) {
        /* Get RAM1_CTL register value */
        regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM1_CTL;
        /* Mask register value */
        regVal &= McuClockConfigPtr->Ram1CtlRegMask;
        /* Check register value with config value */
        if (McuClockConfigPtr->Ram1CtlRegVal != regVal) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      }
      if (retVal == MCU_OK) {
        if (McuClockConfigPtr->Ram2CtlRegMask != 0U) {
          /* Get RAM2_CTL register value */
          regVal = Mcu_RegBaseAddrPtr->CpussRegBaseAddr->RAM2_CTL;
          /* Mask register value */
          regVal &= McuClockConfigPtr->Ram2CtlRegMask;
          /* Check register value with config value */
          if (McuClockConfigPtr->Ram2CtlRegVal != regVal) {
            /* Set result unmatch */
            retVal = MCU_NOT_OK;
          }
        }
        if (retVal == MCU_OK) {
          /* Get FLASH_CTL register value */
          regVal = Mcu_RegBaseAddrPtr->FlashRegBaseAddr->FLASH_CTL;
          /* Mask register value */
          regVal &= McuClockConfigPtr->FlashCtlRegMask;
          /* Check register value with config value */
          if (McuClockConfigPtr->FlashCtlRegVal != regVal) {
            /* Set result unmatch */
            retVal = MCU_NOT_OK;
          }
        }
      }
    } else {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
  } else {
    /* Set result unmatch */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckClock_PeriPclk_Regs
 **
 ** This function checks clock settings with PERI PCLK HW registers.
 **
 ** \param[in]  PclkGroupConfigPtr       The pointer to PCLK clock configuration.
 **
 ** \retval  MCU_OK         PCLK clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     PCLK clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_PeriPclk_Regs(
  P2CONST( Mcu_PclkGroupConfigDataType, MCU_CONST, MCU_APPL_CONST ) PclkGroupConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;

  for (idx=0U; idx<PclkGroupConfigPtr->PclkConfigNum; idx++) {
    /* Get PCLK register index */
    regIdx = PclkGroupConfigPtr->PclkConfigPtr[idx].PclkRegIdx;
    /* Get CLOCK_CTL register value */
    regVal = Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupConfigPtr->PclkGroupRegIdx].CLOCK_CTL[regIdx];
    /* Check register value with config value */
    if (PclkGroupConfigPtr->PclkConfigPtr[idx].ClockCtlRegVal != regVal) {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
      break;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_PeriDivider_Regs
 **
 ** This function checks clock settings with PERI PCLK divider HW registers.
 **
 ** \param[in]  PclkGroupConfigPtr       The pointer to PCLK clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         PERI PCLK divider settings are consistent with registers.
 ** \retval  MCU_NOT_OK     PERI PCLK divider settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_PeriDivider_Regs(
  P2CONST( Mcu_PclkGroupConfigDataType, MCU_CONST, MCU_APPL_CONST ) PclkGroupConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) cfgIdx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( uint32, AUTOMATIC ) cfgVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;
  P2CONST( Mcu_PclkDividerConfigDataType, MCU_CONST, MCU_APPL_CONST ) PclkDivCfgPtr;
  P2VAR( volatile Mcu_PclkRegType, AUTOMATIC, REGSPACE ) regPclkAddrPtr;
  regPclkAddrPtr = &(Mcu_RegBaseAddrPtr->PclkRegBaseAddr[PclkGroupConfigPtr->PclkGroupRegIdx]);

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<PclkGroupConfigPtr->PclkDividerConfigNum; idx++) {
    /* Get pointer of PCLK divider configuration */
    PclkDivCfgPtr = &(PclkGroupConfigPtr->PclkDividerConfigPtr[idx]);
    /* Check only if stop for update enable */
    /* because it may not be updated when stop for update disable */
    if (PclkDivCfgPtr->PclkDividerStopEnable == STD_ON) {
      /* Get PCLK divider register index */
      regIdx = PclkDivCfgPtr->PclkDividerIdx;
      /* Get PCLK divider configuration index */
      cfgIdx = PclkDivCfgPtr->PclkDividerCfgIdx;
      if (PclkDivCfgPtr->PclkDividerType == MCU_DIV_8) {
        /* Get DIV_8_CTL register value */
        regVal = regPclkAddrPtr->DIV_8_CTL[regIdx];
        /* Get config value */
        cfgVal = (uint32)PclkGroupConfigPtr->Pclk80DividerConfigPtr[cfgIdx].Pclk80DividerIntVal
                   << MCU_REG_BIT_PERI_DIV_8_CTL_INT8_DIV;
      } else if (PclkDivCfgPtr->PclkDividerType == MCU_DIV_16) {
        /* Get DIV_16_CTL register value */
        regVal = regPclkAddrPtr->DIV_16_CTL[regIdx];
        /* Get config value */
        cfgVal = (uint32)PclkGroupConfigPtr->Pclk160DividerConfigPtr[cfgIdx].Pclk160DividerIntVal
                   << MCU_REG_BIT_PERI_DIV_16_CTL_INT16_DIV;
      } else if (PclkDivCfgPtr->PclkDividerType == MCU_DIV_16_5) {
        /* Get DIV_16_5_CTL register value */
        regVal = regPclkAddrPtr->DIV_16_5_CTL[regIdx];
        /* Get config value */
        cfgVal = (uint32)PclkGroupConfigPtr->Pclk165DividerConfigPtr[cfgIdx].Pclk165DividerIntVal
                   << MCU_REG_BIT_PERI_DIV_16_5_CTL_INT16_DIV;
        cfgVal |= (uint32)PclkGroupConfigPtr->Pclk165DividerConfigPtr[cfgIdx].Pclk165DividerFracVal
                    << MCU_REG_BIT_PERI_DIV_16_5_CTL_FRAC5_DIV;
      } else if (PclkDivCfgPtr->PclkDividerType == MCU_DIV_24_5) {
        /* Get DIV_24_5_CTL register value */
        regVal = regPclkAddrPtr->DIV_24_5_CTL[regIdx];
        /* Get config value */
        cfgVal = (uint32)PclkGroupConfigPtr->Pclk245DividerConfigPtr[cfgIdx].Pclk245DividerIntVal
                   << MCU_REG_BIT_PERI_DIV_24_5_CTL_INT24_DIV;
        cfgVal |= (uint32)PclkGroupConfigPtr->Pclk245DividerConfigPtr[cfgIdx].Pclk245DividerFracVal
                    << MCU_REG_BIT_PERI_DIV_24_5_CTL_FRAC5_DIV;
      } else {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
      if (retVal == MCU_OK) {
        if (PclkDivCfgPtr->PclkDividerEnable == STD_ON) {
          /* Set EN bit of config value */
          cfgVal |= MCU_REG_MASK_PERI_DIV_CTL_EN;
        }
        /* Check register value with config value */
        if (cfgVal != regVal) {
          /* Set result unmatch */
          retVal = MCU_NOT_OK;
        }
      }
      if (retVal == MCU_NOT_OK) {
        break;
      }
    }
  }

  return retVal;
}


/** \brief Mcu_CheckClock_PeriGroup_Regs
 **
 ** This function checks clock settings with PERI peripheral group HW registers.
 **
 ** \param[in]  McuPeriGroupConfigNum  The number of peripheral group clock configuration.
 ** \param[in]  McuPeriGroupConfigPtr  The pointer to peripheral group clock configuration.
 **
 ** \retval  MCU_OK         Peripheral group clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Peripheral group clock settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClock_PeriGroup_Regs(
  VAR( uint32, AUTOMATIC ) McuPeriGroupConfigNum,
  P2CONST( Mcu_PeriGroupConfigDataType, MCU_CONST, MCU_APPL_CONST ) McuPeriGroupConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) idx;
  VAR( uint32, AUTOMATIC ) regIdx;
  VAR( uint32, AUTOMATIC ) regVal;
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;
  P2VAR( volatile Mcu_PeriGroupRegType, AUTOMATIC, REGSPACE ) regPeriGroupAddrPtr;

  /* Set result match (initial) */
  retVal = MCU_OK;
  for (idx=0U; idx<McuPeriGroupConfigNum; idx++) {
    /* Get PERI group register index */
    regIdx = McuPeriGroupConfigPtr[idx].PeriGroupRegIdx;
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is needed to be calculated by pointer arithmetic.
                      And also the hardware access needed to be handled by using pointer. */
    /* PRQA S 303 3 */
    regPeriGroupAddrPtr = 
      (volatile Mcu_PeriGroupRegType *)((uint32)&(Mcu_RegBaseAddrPtr->PeriRegBaseAddr->PERI_GROUP[regIdx]) + 
                                        (regIdx * Mcu_RegBaseAddrPtr->PeriGroupOffset));
    /* Get CLOCK_CTL register value */
    regVal = regPeriGroupAddrPtr->CLOCK_CTL;
    /* Check register value with config value */
    if (McuPeriGroupConfigPtr[idx].ClockCtlRegVal == regVal) {
      /* Get SL_CTL register value */
      regVal = regPeriGroupAddrPtr->SL_CTL;
      /* Mask register value */
      regVal &= McuPeriGroupConfigPtr[idx].SlCtlRegMask;
      /* Check register value with config value */
      if (McuPeriGroupConfigPtr[idx].SlCtlRegVal != regVal) {
        /* Set result unmatch */
        retVal = MCU_NOT_OK;
      }
    } else {
      /* Set result unmatch */
      retVal = MCU_NOT_OK;
    }
    if (retVal == MCU_NOT_OK) {
      break;
    }
  }

  return retVal;
}


#define MCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 


/*==================[end of file]============================================*/
