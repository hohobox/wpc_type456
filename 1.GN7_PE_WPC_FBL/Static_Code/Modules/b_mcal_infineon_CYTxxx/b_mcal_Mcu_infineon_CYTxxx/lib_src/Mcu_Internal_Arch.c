/** \brief AUTOSAR Mcu Driver
 **
 ** This file contains the implementation of the AUTOSAR module Mcu function
 ** for processing architecture functionality.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Mcu_Internal_Arch.h>     /* Architecture dependent declarations */
#include <Mcu.h>
#include <SchM_Mcu.h>          /* SchM_Mcu declarations */

/*==================[macros]=================================================*/
#define MCU_RAM_ALIGN_0                   0U
#define MCU_RAM_ALIGN_MASK                3U
#define MCU_RAM_ALIGN_SHIFT               2U
#define MCU_RAM_ALIGN_SIZE                4U
#define MCU_RAM_BYTE_SHIFT_1              8U
#define MCU_RAM_BYTE_SHIFT_2              16U
#define MCU_RAM_BYTE_SHIFT_3              24U
#define MCU_WCO_DISABLE_WAIT_COUNT_MAX    1000U

/*==================[type definitions]=======================================*/
/*==================[external function declarations]=========================*/
/*==================[internal function declarations]=========================*/
#define MCU_START_SEC_CODE_ASIL_B
#include <Mcu_MemMap.h>

/** \brief Mcu_ClockShutdown_Arch
 **
 ** This function checks whether clock shutdown is needed or not and shutdown clock.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_Arch( 
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_SourceClockSetting_Arch
 **
 ** This function sets Source clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SourceClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CsvSetting_Arch
 **
 ** This function sets CSV with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_CsvSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_SrssClockSetting_Arch
 **
 ** This function sets clock setting of SRSS with specified clock configurations.
 ** Setting clocks by this function are DSI, LF clock, Pump clock, Timer clock and DDFT.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SrssClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_SrssPathSetting_Arch
 **
 ** This function sets clock Path setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SrssPathSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_CpussSetting_Arch
 **
 ** This function sets clock setting of CPUSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 ** \param[in]  SetFlag              The flag indicating whether the divider to up or down.
 */
static FUNC( void, MCU_CODE ) 
Mcu_CpussSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr,
  VAR( boolean, AUTOMATIC) SetFlag
);


/** \brief Mcu_ClockOutputSetting_Arch
 **
 ** This function sets DDFT clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_ClockOutputSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_PeriClockShutdown_Arch
 **
 ** This function shutdowns clock setting of PERI with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_PeriClockShutdown_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_PeriGroupSetting_Arch
 **
 ** This function sets clock setting of PERI with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_PeriGroupSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_PclkSetting_Arch
 **
 ** This function sets clock setting of PCLK/divider with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_PclkSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_FllClockSetting_Arch
 **
 ** This function sets Fll clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_FllClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_PllClockSetting_Arch
 **
 ** This function sets Pll clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_PllClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_SscgClockSetting_Arch
 **
 ** This function sets SSCG clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_SscgClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_RootSetting_Arch
 **
 ** This function sets clock Root setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( void, MCU_CODE ) 
Mcu_RootSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_UpdateResetReason_Arch
 **
 ** This function updates the internally stored reset reason and clears reset reason register.
 **
 ** \param[in]  McuConfigPtr  The pointer to configuration data.
 */
static FUNC( void, MCU_CODE ) Mcu_UpdateResetReason_Arch(
  P2CONST( Mcu_ConfigType, AUTOMATIC, MCU_APPL_CONST ) McuConfigPtr
);


/** \brief Mcu_CheckResetReasonCsv_Arch
 **
 ** This function checks whether reset reason is due to clock failure.
 **
 ** \param[in]  McuResetReason  Reset reason value.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckResetReasonCsv_Arch( 
  VAR( Mcu_ResetType, AUTOMATIC ) McuResetReason
);


/** \brief Mcu_WaitPllFllLock_Arch
 **
 ** This function waits for SSCG/PLL/Fll lock.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WaitPllFllLock_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_SourceClockDisable_Arch
 **
 ** This function disables clock oscillator with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SourceClockDisable_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
);


/** \brief Mcu_SetModeToActive_Arch
 **
 ** This function sets Active mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToActive_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_SetModeToSleep_Arch
 **
 ** This function sets Sleep mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToSleep_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_SetModeToDeepSleep_Arch
 **
 ** This function sets DeepSleep mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToDeepSleep_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_SetModeToHibernate_Arch
 **
 ** This function sets Hibernate mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToHibernate_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_UpdateSystemResource_Arch
 **
 ** This function updates system resources by specified settings.
 **
 ** \param[in]  SysResConfigPtr  The pointer to system resources configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_UpdateSystemResource_Arch(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
);


/** \brief Mcu_SrssPowerCtl_Arch
 **
 ** This function updates low power control by specified settings.
 **
 ** \param[in]  SysResConfigPtr  The pointer to system resources configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SrssPowerCtl_Arch(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
);


/** \brief Mcu_SetMainCorePowerMode_Arch
 **
 ** This function sets the power mode of CPU Main Core.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetMainCorePowerMode_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_GetHwStatus_Arch
 **
 ** This function gets HW power status.
 **
 ** \param[in]  MainCorePwrModeNum  The number of Main Core for Power Mode.
 ** \param[out] McuStatusPtr        The pointer to store the status.
 */
static FUNC( void, MCU_CODE ) 
Mcu_GetHwStatus_Arch(
  VAR( uint8, AUTOMATIC ) MainCorePwrModeNum,
  P2VAR( Mcu_StatusType, AUTOMATIC, MCU_APPL_DATA ) McuStatusPtr
);


/** \brief Mcu_CheckMode_Active_Arch
 **
 ** This function checks mode status related to active mode.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Active_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_CheckMode_Sleep_Arch
 **
 ** This function checks mode status related to sleep mode.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Sleep_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_CheckMode_Hibernate_Arch
 **
 ** This function checks mode status related to hibernate mode.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Hibernate_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
);


/** \brief Mcu_CheckMode_CpussMainCorePwr_Arch
 **
 ** This function checks Main Core power status.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussMainCorePwr_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
);


#define MCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
#define MCU_START_SEC_VAR_INIT_ASIL_B_BOOLEAN
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/** This data is a flag for whether or not set the clock by Mcu module. */
static VAR( boolean , MCU_VAR_INIT ) Mcu_ClockSettingFlag = FALSE;

#define MCU_STOP_SEC_VAR_INIT_ASIL_B_BOOLEAN
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

#define MCU_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 
/** The reset reason value is stored in this data structure. */
static VAR( Mcu_ResetType, MCU_VAR_NO_INIT ) Mcu_ResetReason;

/** The raw reset reason value is stored in this data structure. */
static VAR( Mcu_RegRawResetType, MCU_VAR_NO_INIT ) Mcu_RawResetReason;

#define MCU_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 
/*==================[external function definitions]==========================*/
#define MCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 
/** \brief Mcu_Init_Arch
 **
 ** This function initializes the Mcu driver.
 **
 ** \param[in]  McuConfigPtr  The pointer to configuration data.
 **
 ** \pre  McuConfigPtr shall not be a NULL pointer.
 */
FUNC( void, MCU_CODE ) 
Mcu_Init_Arch(
  P2CONST( Mcu_ConfigType, AUTOMATIC, MCU_APPL_CONST ) McuConfigPtr
)
{
  /* Update reset reason */
  Mcu_UpdateResetReason_Arch(McuConfigPtr);

  /* McuInitClock check */
  if ((McuConfigPtr->ConfigFlags & MCU_FLAGS_INIT_CLOCK) == MCU_FLAGS_INIT_CLOCK) {
    (void)Mcu_InitClock_Arch(
      MCU_API_SERVICE_INIT,
      &(McuConfigPtr->McuClockConfigPtr[McuConfigPtr->McuDefaultClockSettingId])
      );
  }

  return;
}


/** \brief Mcu_InitClock_Arch
 **
 ** This function initializes clock setting with specified clock configuration.
 **
 ** \param[in]  McuApiId              API ID.
 ** \param[in]  McuClockConfigPtr     The pointer to clock configuration data.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Clock initialization is success.
 ** \retval  MCU_NOT_OK     Clock initialization is failed.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_InitClock_Arch(
  VAR( uint8, AUTOMATIC ) McuApiId,
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_NOT_OK;

  /* Parameter valid check */
  if (McuClockConfigPtr != NULL_PTR) {
    /* Clock source check -> reg setting */
    /* IMO, ECO, ILO, CTL(BackupConfig) */
    retVal = Mcu_SourceClockSetting_Arch(McuClockConfigPtr); 

    /* Check source clock setting */
    /* Returns MCU_NOT_OK when the stabilization count of ECO or WCO becomes 0 */
    if(retVal == MCU_OK)
    {
      /* Preset clock root settings */
      Mcu_PreSetRootSelect_Regs(McuClockConfigPtr);

      /* PCLK shutdown */
      Mcu_PeriClockShutdown_Arch(McuClockConfigPtr);

      /* Enter critical section */
      Mcu_EnterCriticalSection();

      /* set to the clock setting Flag */
      Mcu_SetPllFllSettingFlag_Arch(TRUE);

      /* Check Oscillator status */
      retVal = Mcu_CheckSourceClockStatus_Regs(McuClockConfigPtr);

      if (retVal == MCU_OK)
      {
        /* Clock shutdown */
        Mcu_ClockShutdown_Arch(McuClockConfigPtr);

        /* clk PATH setting */
        Mcu_SrssPathSetting_Arch(McuClockConfigPtr);

        /* FLL setting */
        retVal = Mcu_FllClockSetting_Arch(McuClockConfigPtr);

        if(retVal == MCU_OK)
        {
          /* PLL setting */
          Mcu_PllClockSetting_Arch(McuClockConfigPtr);

          /* SSCG setting */
          Mcu_SscgClockSetting_Arch(McuClockConfigPtr);

          /* clk root setting */
          Mcu_RootSetting_Arch(McuClockConfigPtr);

          /* SRSS clock setting (except PLL/FLL  and PATH) */
          Mcu_SrssClockSetting_Arch(McuClockConfigPtr);

          /* CPUSS clock setting */
          Mcu_CpussSetting_Arch(McuClockConfigPtr, TRUE);

          /* csv setting */
          Mcu_CsvSetting_Arch(McuClockConfigPtr);

          /* peripheral group setting */
          Mcu_PeriGroupSetting_Arch(McuClockConfigPtr);

          /* CLOCK_OUTPUT setting */
          Mcu_ClockOutputSetting_Arch(McuClockConfigPtr);

          /* OSC disable */
          Mcu_SourceClockDisable_Arch(McuClockConfigPtr);

          /* Exit critical section */
          Mcu_ExitCriticalSection();

          /* PCLK/divider setting */
          Mcu_PclkSetting_Arch(McuClockConfigPtr);
        }
        else
        {
          /* Exit critical section */
          Mcu_ExitCriticalSection();
        }
      }
      else
      {
        /* Exit critical section */
        Mcu_ExitCriticalSection();
      }
    }

    if (retVal == MCU_OK) {
      /* wait for PLL/FLL lock */
      retVal = Mcu_WaitPllFllLock_Arch(McuClockConfigPtr);
    }
  }

  /* Check result */
  if (retVal == MCU_OK) {
    /* Report no clock failure error to DEM */
    Mcu_DemReportClockSuccess();
  } else {
    /* Report clock failure error to DEM */
    Mcu_DemReportClockFailure( McuApiId );
  }

  return retVal;
}


/** \brief Mcu_DistributePllClock_Arch
 **
 ** This function starts distribution of SSCG/PLL/FLL clock after SSCG/PLL/FLL clock is locked.
 **
 ** \param[in]  McuClockConfigPtr     The pointer to clock configuration data.
 **
 ** \pre  Mcu_InitClock_Arch() has already been called.
 ** \pre  SSCG/PLL/FLL clock has already been locked.
 */
FUNC( void, MCU_CODE ) 
Mcu_DistributePllClock_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i;
  /* Enter critical section */
  Mcu_EnterCriticalSection();

  /* SSCG clock */
  for(i = 0U; i<McuClockConfigPtr->SscgConfigNum; i++)
  {
    /* set PLL output */
    Mcu_SetSscgClockOut_Regs(
      McuClockConfigPtr->SscgConfigPtr[i].SscgRegIdx
    );
  }
  /* PLL clock */
  for(i = 0U; i<McuClockConfigPtr->PllConfigNum; i++)
  {
    /* set PLL output */
    Mcu_SetPllClockOut_Regs(
      McuClockConfigPtr->PllConfigPtr[i].PllRegIdx
    );
  }
  /* FLL clock */
  Mcu_SetFllClockOut_Regs();

  /* Exit critical section */
  Mcu_ExitCriticalSection();

  return;
}


/** \brief Mcu_GetPllStatus_Arch
 **
 ** This function returns current SSCG/PLL/FLL status.
 **
 ** \param[in]  McuClockConfigPtr     The pointer to clock configuration data.
 **
 ** \pre  Mcu_InitClock_Arch() has already been called.
 **
 ** \retval  MCU_PLL_LOCKED            SSCG/PLL/FLL is already locked.
 ** \retval  MCU_PLL_UNLOCKED          SSCG/PLL/FLL is not locked yet.
 ** \retval  MCU_PLL_STATUS_UNDEFINED  SSCG/PLL/FLL status is undefined.
 */
FUNC( Mcu_PllStatusType, MCU_CODE ) 
Mcu_GetPllStatus_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_PllStatusType, AUTOMATIC ) retVal;
  VAR( Mcu_ReturnType, AUTOMATIC ) LockResult = MCU_OK;
  
  /* PLL and FLL lock status check */
  if(McuClockConfigPtr->FllConfigPtr != NULL_PTR)
  {
    LockResult = Mcu_GetFllLockStatus_Regs(McuClockConfigPtr->FllConfigPtr);
  }

  if (LockResult == MCU_OK)
  {
    /* Returns MCU_NOT_OK if at least one PLL is in the unlock state. */
    LockResult = Mcu_GetPllLockStatus_Regs(McuClockConfigPtr);

    if (LockResult == MCU_OK)
    {
      /* Returns MCU_NOT_OK if at least one SSCG is in the unlock state. */
      LockResult = Mcu_GetSscgLockStatus_Regs(McuClockConfigPtr);
    }
  }

  if(LockResult == MCU_OK)
  {
    /* PLL and FLL is locked */
    /* Set result locked */
    retVal = MCU_PLL_LOCKED;
  }
  else
  {
    /* Set result unlocked */
    retVal = MCU_PLL_UNLOCKED;
  }
  return retVal;
}


/** \brief Mcu_SetPllFllSettingFlag_Arch
 **
 ** This function sets flag on whether clock is set by Mcu module.
 **
 ** \param[in]  SettingFlag  TRUE or FALSE.
 */
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7.
   Justification: This function will be referenced another unit in the future. */
/* PRQA S 1505 ++ */
FUNC( void, MCU_CODE ) 
Mcu_SetPllFllSettingFlag_Arch(
  VAR( boolean, AUTOMATIC ) SettingFlag )
{
  Mcu_ClockSettingFlag = SettingFlag;
}
/* PRQA S 1505 -- */


/** \brief Mcu_GetPllFllSettingFlag_Arch
 **
 ** This function gets flag on whether clock is set by Mcu module.
 **
 ** \retval TRUE   Clock setting by Mcu module is enable.
 ** \retval FALSE  Clock setting by Mcu module is disable.
 **
 */
FUNC( boolean, MCU_CODE ) 
Mcu_GetPllFllSettingFlag_Arch( void )
{
  return Mcu_ClockSettingFlag;
}


/** \brief Mcu_GetResetReason_Arch
 **
 ** This function returns the reset reason.
 **
 ** \pre  Mcu_UpdateResetReason is called before.
 **
 ** \return  Reset reason value.
 */
FUNC( Mcu_ResetType, MCU_CODE ) Mcu_GetResetReason_Arch( void )
{
  return Mcu_ResetReason;
}


/** \brief Mcu_GetResetRawValue_Arch
 **
 ** This function returns the reset reason raw value.
 **
 ** \pre  Mcu_UpdateResetReason is called before.
 **
 ** \return  Raw reset reason value.
 */
FUNC( Mcu_RawResetType, MCU_CODE ) Mcu_GetResetRawValue_Arch( void )
{
  return Mcu_RawResetReason.Reset;
}


/** \brief Mcu_Reset_Arch
 **
 ** This function performs specified reset.
 **
 ** \param[in]  McuRegReset   Reset type value.
 ** \param[in]  McuResetConfigPtr The pointer to the reset configuration.
 **
 ** \pre  McuRegReset is in valid range.
 */
FUNC( void, MCU_CODE ) Mcu_Reset_Arch(
  VAR( Mcu_RegResetType, AUTOMATIC ) McuRegReset,
  P2CONST( Mcu_ResetConfigType, AUTOMATIC, MCU_APPL_CONST ) McuResetConfigPtr
)
{
  VAR( uint32, AUTOMATIC ) cacheStatus;
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;
  P2CONST( Mcu_HwInfoType, AUTOMATIC, MCU_APPL_CONST ) HwInfoPtr;

  /* Enter critical section */
  Mcu_EnterCriticalSection();

  /* Cache disable if configured */
  if (McuResetConfigPtr->ResetCacheFlushEn == STD_ON) {
    cacheStatus = Mcu_DisableCache_Regs();
  }

  /* Wait and check the RAM write buffer status */
  retVal = Mcu_WaitRamStatus_Regs(McuResetConfigPtr->RamWbToCntReset);

  if (retVal == MCU_OK) {
    /* Get HW information */
    HwInfoPtr = Mcu_GetHwInfo();
    /* Set all RAM power status to RETAINED */
    Mcu_SetRamPwrStatusAll_Regs(HwInfoPtr, McuResetConfigPtr, MCU_MAINCOREPOWERMODE_RETAINED);
    /* Exit critical section */
    Mcu_ExitCriticalSection();
    /* Report reset success to DEM */
    Mcu_DemReportResetSuccess();
    /* Set reset trigger */
    Mcu_Reset_Regs(McuRegReset);
  } else {
    /* Exit critical section */
    Mcu_ExitCriticalSection();
    /* Report reset failure to DEM */
    Mcu_DemReportResetFailure( MCU_API_SERVICE_PERFORM_RESET );
    /* Forced reset enable */
    if (McuResetConfigPtr->ForcedResetFlag == STD_ON) {
      /* Set reset trigger */
      Mcu_Reset_Regs(McuRegReset);
    } else {
      /* Cache restore if configured */
      if (McuResetConfigPtr->ResetCacheFlushEn == STD_ON) {
        /* Enter critical section */
        Mcu_EnterCriticalSection();
        /* Restore cache status */
        Mcu_RestoreCache_Regs(cacheStatus);
        /* Exit critical section */
        Mcu_ExitCriticalSection();
      }
    }
  }

  return;
}


/** \brief Mcu_CheckModeConfig_Arch
 **
 ** This function checks compatibility of some configuration parameters.
 **
 ** \param[in]  ModeConfigPtr  The pointer to Mode configuration.
 **
 ** \retval  MCU_OK      All configuration parameters are compatible.
 ** \retval  MCU_NOT_OK  Some configuration parameters are not compatible.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckModeConfig_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) ModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint8, AUTOMATIC ) runningCpu;

  runningCpu = Mcu_GetCpuID_Regs();

  /* Target cpu check */
  if (runningCpu != ModeConfigPtr->TargetCpu) {
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_SetMode_Arch
 **
 ** This function sets MCU to specified mode.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Set specific mode settings successfully.
 ** \retval  MCU_NOT_OK     Parameter is invalid.
 ** \retval  MCU_NOT_OK_HW  Hardware error.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetMode_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint32, AUTOMATIC ) cacheStatus;

  /* Parameter valid check */
  if (McuModeConfigPtr != NULL_PTR) {
    /* Release freeze Io is enabled */
    if (McuModeConfigPtr->FreezeRelEnable == STD_ON) {
      /* Enter critical section */
      Mcu_EnterCriticalSection();

      /* Clear freeze I/O */
      Mcu_ClearFreezeIo_Regs();

      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }

    /* System resource update function is enabled */
    if (McuModeConfigPtr->SysResConfigPtr != NULL_PTR) {
      /* Clock pointer check */
      if (McuModeConfigPtr->SysResConfigPtr->ClockConfigPtr != NULL_PTR) {
        retVal = Mcu_InitClock_Arch(
                   MCU_API_SERVICE_SET_MODE,
                   McuModeConfigPtr->SysResConfigPtr->ClockConfigPtr
                   );
      }

      if (retVal == MCU_OK) {
        /* Update system resources */
        retVal = Mcu_UpdateSystemResource_Arch(
                   McuModeConfigPtr->SysResConfigPtr
                   );
      }
    }

    if (retVal == MCU_OK) {
      /* Set DMA control registers */
      Mcu_SetDmaCtl_Regs(&(McuModeConfigPtr->DmaConfigData));

      /* Wait and check the low power mode status */
      retVal = Mcu_WaitLowPowerModeReady_Regs(McuModeConfigPtr->LpmRdyToCnt);

      if (retVal == MCU_OK) {
        if (McuModeConfigPtr->ModeCacheFlushEn == STD_ON) {
          cacheStatus = Mcu_DisableCache_Regs();
        }

        /* Wait and check the RAM write buffer status */
        retVal = Mcu_WaitRamStatus_Regs(McuModeConfigPtr->RamWbToCnt);

        if (retVal == MCU_OK) {
          /* Set RAM power control registers */
          Mcu_SetRamPwrCtl_Regs(McuModeConfigPtr);

          if (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_ACTIVE) {
            /* Set mode to active */
            retVal = Mcu_SetModeToActive_Arch(McuModeConfigPtr);
          }
          else if (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_SLEEP) {
            /* Set mode to sleep */
            retVal = Mcu_SetModeToSleep_Arch(McuModeConfigPtr);
          }
          else if (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_DEEPSLEEP) {
            /* Set mode to deepsleep */
            retVal = Mcu_SetModeToDeepSleep_Arch(McuModeConfigPtr);
          }
          else if (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_HIBERNATE) {
            /* Set mode to hibernate */
            retVal = Mcu_SetModeToHibernate_Arch(McuModeConfigPtr);
          }
          else {
            /* Set result Not OK */
            retVal = MCU_NOT_OK;
          }
        }
        if (McuModeConfigPtr->ModeCacheFlushEn == STD_ON) {
          Mcu_RestoreCache_Regs(cacheStatus);
        }
      }
    }
  }
  else {
    /* Set result Not OK */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_InitRamSection_Arch
 **
 ** This function initializes RAM section with specified RAM configuration.
 **
 ** \param[in]  McuRamConfigPtr  The pointer to RAM configuration.
 **
 ** \pre  McuRamConfigPtr shall not be a NULL pointer.
 **
 ** \retval  E_OK      RAM initialization is success.
 ** \retval  E_NOT_OK  RAM initialization is failed.
 */
FUNC( Std_ReturnType, MCU_CODE ) 
Mcu_InitRamSection_Arch(
  P2CONST( Mcu_RamConfigType, AUTOMATIC, MCU_APPL_CONST ) McuRamConfigPtr
)
{
  VAR( Std_ReturnType, AUTOMATIC ) retVal = E_NOT_OK;
  VAR( uint32, AUTOMATIC ) cnt;
  VAR( uint32, AUTOMATIC ) startAddress;
  VAR( uint32, AUTOMATIC ) sectionSize;
  VAR( uint8, AUTOMATIC ) defaultValue;
  P2VAR( uint8, AUTOMATIC, MCU_APPL_CONST ) curPtr;
  VAR( uint8, AUTOMATIC ) topAlign;
  VAR( uint8, AUTOMATIC ) topRest = MCU_RAM_ALIGN_0;
  VAR( uint8, AUTOMATIC ) bottomRest;
  VAR( uint32, AUTOMATIC ) alignSectionSize;
  VAR( uint32, AUTOMATIC ) blockSize;
  VAR( uint32, AUTOMATIC ) defaultWordValue;
  P2VAR( uint32, AUTOMATIC, MCU_APPL_CONST ) curWordPtr;

  /* Parameter valid check */
  if (McuRamConfigPtr != NULL_PTR) {
    /* Get RAM section setting from configuration */
    startAddress = McuRamConfigPtr->RamStartAddr;
    sectionSize = McuRamConfigPtr->RamSectionSize;
    defaultValue = McuRamConfigPtr->DefaultData;

    /* Adjust alignment */
    /* Caluculate top alignemnt and top rest */
    topAlign = (uint8)(startAddress & MCU_RAM_ALIGN_MASK);
    if (topAlign != MCU_RAM_ALIGN_0) {
      topRest = MCU_RAM_ALIGN_SIZE - topAlign;
      if (topRest > sectionSize) {
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2.
           Justification: Depending on the configuration, this operation is meaningful. */
        /* PRQA S 2985 1 */
        topRest = (uint8)(sectionSize & MCU_RAM_ALIGN_MASK);
      }
    }

    /* Caluculate RAM block size and bottom rest */
    alignSectionSize = (sectionSize - topRest);
    blockSize = (alignSectionSize >> MCU_RAM_ALIGN_SHIFT);
    bottomRest = (uint8)(alignSectionSize & MCU_RAM_ALIGN_MASK);

    if (topRest > MCU_RAM_ALIGN_0) {
      /* Set pointer to start address */
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
         Justification: The hardware address is provided as integral type by configuration but it is required to be accessed using pointer. */
      /* PRQA S 306 1 */
      curPtr = (uint8*)startAddress;
      /* Initialize RAM section (top rest) with default value */
      for (cnt = 0U; cnt < topRest; cnt++) {
        curPtr[cnt] = defaultValue;
      }
    }

    if (blockSize > 0U) {
      /* Set pointer to RAM word block start address */
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
         Justification: The hardware address is provided as integral type by configuration but it is required to be accessed using pointer. */
      /* PRQA S 306 1 */
      curWordPtr = (uint32*)(startAddress + topRest);
      /* Set word default value */
      defaultWordValue = (uint32)(((uint32)defaultValue << MCU_RAM_BYTE_SHIFT_3) |
                                  ((uint32)defaultValue << MCU_RAM_BYTE_SHIFT_2) |
                                  ((uint32)defaultValue << MCU_RAM_BYTE_SHIFT_1) |
                                  ((uint32)defaultValue));
      /* Initialize RAM section (word block) with default value */
      for (cnt = 0U; cnt < blockSize; cnt++) {
        curWordPtr[cnt] = defaultWordValue;
      }
    }

    if (bottomRest > MCU_RAM_ALIGN_0) {
      /* Set pointer to bottom rest start address */
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
         Justification: The hardware address is provided as integral type by configuration but it is required to be accessed using pointer. */
      /* PRQA S 306 1 */
      curPtr = (uint8*)((startAddress + sectionSize) - bottomRest);
      /* Initialize RAM section (bottom rest) with default value */
      for (cnt = 0U; cnt < bottomRest; cnt++) {
        curPtr[cnt] = defaultValue;
      }
    }

    /* Set result OK */
    retVal = E_OK;
  }

  return retVal;
}


/** \brief Mcu_CheckModeStatus_Arch
 **
 ** This function checks mode status.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 ** \param[out] McuStatusPtr          The pointer to store the status.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Mode settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckModeStatus_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr,
  P2VAR( Mcu_StatusType, AUTOMATIC, MCU_APPL_DATA ) McuStatusPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Set result match (initial) */
  retVal = MCU_OK;
  /* Check if system resource registers are updated */
  if (McuModeConfigPtr->SysResConfigPtr != NULL_PTR) {
    /* Check if clock registers are updated */
    if (McuModeConfigPtr->SysResConfigPtr->ClockConfigPtr != NULL_PTR) {
      /* Check clock registers with config */
      retVal = Mcu_CheckClockStatus_Arch(
                 McuModeConfigPtr->SysResConfigPtr->ClockConfigPtr
               );
    }
  }
  Mcu_EnterCriticalSection();
  /* Get HW status */
  Mcu_GetHwStatus_Arch(
    McuModeConfigPtr->MainCorePwrModeNum, 
    McuStatusPtr
  );
  /* Check if registers are not inconsistent */
  if (retVal == MCU_OK) {
    if (McuModeConfigPtr->SysResConfigPtr != NULL_PTR) {
      /* Check system rsource registers with config */
      retVal = Mcu_CheckMode_SystemResource_Regs(McuModeConfigPtr->SysResConfigPtr);
    }
    if (retVal == MCU_OK) {
      /* Check CPUSS mode registers with config */
      retVal = Mcu_CheckMode_Cpuss_Regs(McuModeConfigPtr);
      if (retVal == MCU_OK) {
        if (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_ACTIVE) {
          /* Check ACTIVE mode specific registers with config */
          retVal = Mcu_CheckMode_Active_Arch(McuModeConfigPtr);
        } else if ((McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_SLEEP) ||
                   (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_DEEPSLEEP)) {
          /* Check SLEEP/DEEPSLEEP mode specific registers with config */
          retVal = Mcu_CheckMode_Sleep_Arch(McuModeConfigPtr);
        } else if (McuModeConfigPtr->CpuPwrMode == MCU_CPUPOWERMODE_HIBERNATE) {
          /* Check HIBERNATE mode specific registers with config */
          retVal = Mcu_CheckMode_Hibernate_Arch(McuModeConfigPtr);
        } else {
          /* Skip checking */
          ;
        }
      }
    }
  }
  Mcu_ExitCriticalSection();

  return retVal;
}


/** \brief Mcu_CheckClockStatus_Arch
 **
 ** This function checks clock status.
 **
 ** \param[in]  McuClockConfigPtr      The pointer to clock configuration data.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Clock settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Clock settings are inconsistent with registers.
 */
FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckClockStatus_Arch(
  P2CONST( Mcu_ClockConfigType, MCU_CONST, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  Mcu_EnterCriticalSection();
  /* Check SRSS clock registers with config */
  retVal = Mcu_CheckClock_Srss_Regs(McuClockConfigPtr);
  if (retVal == MCU_OK) {
    /* Check CPUSS clock registers with config */
    retVal = Mcu_CheckClock_Cpuss_Regs(McuClockConfigPtr);
    if (retVal == MCU_OK) {
      /* Check PERI clock registers with config */
      retVal = Mcu_CheckClock_Peri_Regs(McuClockConfigPtr);
    }
  }
  Mcu_ExitCriticalSection();

  return retVal;
}


/** \brief Mcu_GetVersionInfo_Arch
 **
 ** This function returns version information of MCU driver.
 **
 ** \param[out]  McuVersionInfoPtr  The pointer to store the version information.
 **
 ** \pre  McuVersionInfoPtr shall not be a NULL pointer.
 */
FUNC( void, MCU_CODE ) 
Mcu_GetVersionInfo_Arch(
  P2VAR( Std_VersionInfoType, AUTOMATIC, MCU_APPL_DATA ) McuVersionInfoPtr
)
{
  /* Parameter valid check */
  if (McuVersionInfoPtr != NULL_PTR) {
    McuVersionInfoPtr->vendorID         = MCU_VENDOR_ID;
    McuVersionInfoPtr->moduleID         = MCU_MODULE_ID;
  }

  return;
}


/** \brief Mcu_EnterCriticalSection
 **
 ** This function calls function for entering critical section.
 **
 */
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7.
   Justification: This function will be referenced another unit in the future. */
/* PRQA S 1505 ++ */
FUNC( void, MCU_CODE ) Mcu_EnterCriticalSection( void )
{
  /* Call SchM for enter critical section */
  SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_0();

  return;
}
/* PRQA S 1505 -- */


/** \brief Mcu_ExitCriticalSection
 **
 ** This function calls function for exiting critical section.
 **
 */
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7.
   Justification: This function will be referenced another unit in the future. */
/* PRQA S 1505 ++ */
FUNC( void, MCU_CODE ) Mcu_ExitCriticalSection( void )
{
  /* Call SchM for exit critical section */
  SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_0();

  return;
}
/* PRQA S 1505 -- */


/*==================[internal function definitions]==========================*/
/** \brief Mcu_ClockShutdown_Arch
 **
 ** This function checks whether clock shutdown is needed or not and shutdown clock.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_ClockShutdown_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  /* ClockShutdown */
  /* In case of StopEnable = true: If the clock is enabled, the clock is stopped and the setting is changed */
  /* In case of StopEnable = false: If the clock is enabled, the changing clock is skipped. */
  VAR( uint16, AUTOMATIC ) i;

  if (McuClockConfigPtr->ClockOutputConfigPtr != NULL_PTR)
  {
    /* CLKOUT disable */
    Mcu_ClockShutdown_ClockOutput_Regs();
  }

  /* PERI Timeout control shutdown */
  Mcu_ClockShutdown_PeriTimeout_Regs();

  /* PeriGroup setting */
  for(i=0U; i<McuClockConfigPtr->PeriGroupConfigNum; i++)
  {
    Mcu_SetPeriGroupClock_Regs(&(McuClockConfigPtr->PeriGroupConfigPtr[i]), FALSE);
  }

  /* each CSV setting is set to disable. */
  Mcu_ClockShutdown_Csv_Regs(McuClockConfigPtr);

  /* up CPUSS clock divider / up memory clock divider */
  Mcu_CpussSetting_Arch(McuClockConfigPtr, FALSE);

  /* Srss clock shutdown setting */
  Mcu_ClockShutdown_SrssClock_Regs(McuClockConfigPtr);

  /* Fll clock shutdown */
  if(McuClockConfigPtr->FllConfigPtr != NULL_PTR)
  {
    Mcu_ClockShutdown_Fll_Regs(
      McuClockConfigPtr->FllConfigPtr->FllStopEnable);
  }

  for(i = 0U; i< McuClockConfigPtr->PllConfigNum; i++)
  {
    Mcu_ClockShutdown_Pll_Regs(
      McuClockConfigPtr->PllConfigPtr[i].PllRegIdx,
      McuClockConfigPtr->PllConfigPtr[i].PllStopEnable);
  }

  for(i = 0U; i< McuClockConfigPtr->SscgConfigNum; i++)
  {
    Mcu_ClockShutdown_Sscg_Regs(
      McuClockConfigPtr->SscgConfigPtr[i].SscgRegIdx,
      McuClockConfigPtr->SscgConfigPtr[i].SscgStopEnable);
  }
}


/** \brief Mcu_SourceClockSetting_Arch
 **
 ** This function sets Source clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Source clock setting is success.
 ** \retval  MCU_NOT_OK     Source clock setting is not success.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SourceClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint8, AUTOMATIC ) ClockFlags = 0U;
  
  /* Enter critical section */
  Mcu_EnterCriticalSection();

  /* IMO */
  Mcu_SetIMO_Regs(McuClockConfigPtr->ClkImoConfigRegVal, TRUE);

  /* ILO */
  Mcu_SetILO_Regs(McuClockConfigPtr, TRUE);

  /* ECO */
  if (McuClockConfigPtr->EcoConfigPtr != NULL_PTR)
  {
    ClockFlags = MCU_ECO_CLOCK_SETTING_FLAGS;

    Mcu_SetECO_Regs(McuClockConfigPtr->EcoConfigPtr, TRUE);
    
    /* ECO PRESCALE */
    if (McuClockConfigPtr->EcoConfigPtr->EcoPrescalerNum > 0U)
    {
      /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2.
         Justification: The value is needed to be updated at each condition. */
      /* PRQA S 2984 1 */
      ClockFlags |= MCU_ECO_PRESCALE_SETTING_FLAGS;

      Mcu_SetECOPrescale_Regs(McuClockConfigPtr->EcoConfigPtr);
    }
  }

  /* LPECO */
  if (McuClockConfigPtr->LpEcoConfigPtr != NULL_PTR)
  {
    ClockFlags |= MCU_LPECO_CLOCK_SETTING_FLAGS;

    Mcu_SetLpEco_Regs(McuClockConfigPtr->LpEcoConfigPtr, TRUE);
    
    /* LPECO PRESCALE */
    if (McuClockConfigPtr->LpEcoConfigPtr->LpEcoPrescalerNum > 0U)
    {
      ClockFlags |= MCU_LPECO_PRESCALE_SETTING_FLAGS;

      Mcu_SetLpEcoPrescale_Regs(McuClockConfigPtr->LpEcoConfigPtr);
    }
  }

  /* Exit critical section */
  Mcu_ExitCriticalSection();

  /* WCO (Backup) */
  if (McuClockConfigPtr->BackupConfigPtr != NULL_PTR)
  {
    if ((McuClockConfigPtr->BackupConfigPtr->WcoEn == STD_ON) && 
        (McuClockConfigPtr->BackupConfigPtr->WcoStopEnable == STD_ON)) {
      /* Enter critical section */
      Mcu_EnterCriticalSection();

      /* WCO disable */
      Mcu_SetWcoEnable_Regs(STD_OFF);

      /* Exit critical section */
      Mcu_ExitCriticalSection();

      /* Wait for WCO disable */
      retVal = Mcu_WcoClkDisableWait_Regs(MCU_WCO_DISABLE_WAIT_COUNT_MAX);
    }
    if (retVal == MCU_OK) {
      /* Enter critical section */
      Mcu_EnterCriticalSection();

      ClockFlags |= MCU_WCO_CLOCK_SETTING_FLAGS;

      Mcu_SetWCO_Regs(McuClockConfigPtr->BackupConfigPtr, TRUE);

      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }
  }

  /* Because there is a while loop in Mcu_SourceClkStabWait_Regs, exit the critical section */

  /* ECO , ECO PRESCALE, WCO Stabilization waiting */
  if (ClockFlags != 0U)
  {
    retVal = Mcu_SourceClkStabWait_Regs(
               McuClockConfigPtr,
               ClockFlags
             );
  }

  return retVal;

}


/** \brief Mcu_CsvSetting_Arch
 **
 ** This function sets CSV with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_CsvSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  /* CSV setting */
  Mcu_SetCsv_Regs(McuClockConfigPtr);

}


/** \brief Mcu_SrssClockSetting_Arch
 **
 ** This function sets clock setting of SRSS with specified clock configurations.
 ** Setting clocks by this function are DSI, LF clock, Pump clock, Timer clock and DDFT.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SrssClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  /* Lf clock setting */
  Mcu_SetLf_Regs(McuClockConfigPtr);

  /* Pump clock setting */
  Mcu_SetPump_Regs(
    McuClockConfigPtr->ClkSelectRegVal,
    McuClockConfigPtr->PumpClockEn
    ); /* CLK_SELECT */

  if(McuClockConfigPtr->TimerClockConfigPtr != NULL_PTR)
  {
    Mcu_SetTimer_Regs(
      McuClockConfigPtr->TimerClockConfigPtr->ClkTimerCtlRegVal,
      McuClockConfigPtr->TimerClockEn
      ); /* CLK_TIMER_CTL */
  }
}

/** \brief Mcu_ClockOutputSetting_Arch
 **
 ** This function sets DDFT clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_ClockOutputSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  if (McuClockConfigPtr->ClockOutputConfigPtr != NULL_PTR)
  {
    Mcu_SetClockOutput_Regs(
      McuClockConfigPtr->ClockOutputConfigPtr
      ); /* DDFT clock setting */
  }
}


/** \brief Mcu_SrssPathSetting_Arch
 **
 ** This function sets clock Path setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SrssPathSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i;

  for(i=0U; i<McuClockConfigPtr->DsiConfigNum; i++)
  {
    Mcu_SetDsi_Regs(
      McuClockConfigPtr->DsiConfigPtr[i].DsiRegIdx,
      McuClockConfigPtr->DsiConfigPtr[i].ClkDsiSelectRegVal
      ); /* DSI_SELECT*/
  }

  for (i=0U; i<McuClockConfigPtr->ClockPathConfigNum; i++)
  {
    Mcu_SetPath_Regs(
      McuClockConfigPtr->ClockPathConfigPtr[i].ClockPathRegIdx,
      McuClockConfigPtr->ClockPathConfigPtr[i].ClkPathSelectRegVal
      ); /* PATH_SELECT*/
  }
}


/** \brief Mcu_CpussSetting_Arch
 **
 ** This function sets clock setting of CPUSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 ** \param[in]  SetFlag              The flag indicating whether the divider to up or down.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_CpussSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr,
  VAR( boolean, AUTOMATIC) SetFlag
)
{
  if(SetFlag == TRUE)
  {
    /* Cpuss clock setting (down devider)*/
    Mcu_SetCpussClock_Regs(McuClockConfigPtr, SetFlag);

    /* wait cycle setting (down devider)*/
    Mcu_SetWaitCycle_Regs(McuClockConfigPtr, SetFlag);

  }
  else
  {
    /* wait cycle setting (up devider) */
    Mcu_SetWaitCycle_Regs(McuClockConfigPtr, SetFlag);

    /* Cpuss clock setting (up devider)*/
    Mcu_SetCpussClock_Regs(McuClockConfigPtr, SetFlag);
    
  }

}


/** \brief Mcu_PeriClockShutdown_Arch
 **
 ** This function shutdowns clock setting of PERI with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_PeriClockShutdown_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8,  AUTOMATIC ) j;
  VAR( uint16, AUTOMATIC ) i;

  for(j=0U; j<McuClockConfigPtr->PclkGroupConfigNum; j++)
  {
    /* Peri clock shutdown setting */
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].PclkDividerConfigNum; i++)
    {
      /* Enter critical section */
      Mcu_EnterCriticalSection();
      Mcu_ClockShutdown_PeriClock_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].PclkDividerConfigPtr[i]), 
        McuClockConfigPtr->PclkGroupConfigPtr[j].PclkGroupRegIdx
        );
      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }
  }
}


/** \brief Mcu_PeriGroupSetting_Arch
 **
 ** This function sets clock setting of PERI with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_PeriGroupSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i; /* loop num */

  /* PeriGroup setting */
  for(i=0U; i<McuClockConfigPtr->PeriGroupConfigNum; i++)
  {
    Mcu_SetPeriGroupClock_Regs(&(McuClockConfigPtr->PeriGroupConfigPtr[i]), TRUE);
  }

  /* TIMEOUT_CTL setting */
  Mcu_SetPeriTimeout_Regs(McuClockConfigPtr->PeriGroupBusToCnt);
}


/** \brief Mcu_PclkSetting_Arch
 **
 ** This function sets clock setting of PCLK/divider with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_PclkSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{

  VAR( uint8,  AUTOMATIC ) pclkGroupIdx;
  VAR( uint8,  AUTOMATIC ) j; /* loop num */
  VAR( uint16, AUTOMATIC ) i; /* loop num */

  /* PclkGroup setting */
  for(j=0U; j<McuClockConfigPtr->PclkGroupConfigNum; j++)
  {
    pclkGroupIdx = McuClockConfigPtr->PclkGroupConfigPtr[j].PclkGroupRegIdx;
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].PclkConfigNum; i++)
    {
      /* CLOCK_CTL setting*/
      Mcu_SetPeriClock_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].PclkConfigPtr[i]), 
        pclkGroupIdx
        );
    }

    /* DIV_8_CTL setting */
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk80DividerConfigNum; i++)
    {      
     /* Enter critical section */
     Mcu_EnterCriticalSection();
      Mcu_SetDiv80Ctl_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk80DividerConfigPtr[i]), 
        pclkGroupIdx
        );
      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }

    /* DIV_16_CTL setting */
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk160DividerConfigNum; i++)
    {      
     /* Enter critical section */
     Mcu_EnterCriticalSection();
      Mcu_SetDiv160Ctl_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk160DividerConfigPtr[i]), 
        pclkGroupIdx
        );
      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }

    /* DIV_16_5_CTL setting */
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk165DividerConfigNum; i++)
    {      
      /* Enter critical section */
      Mcu_EnterCriticalSection();
      Mcu_SetDiv165Ctl_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk165DividerConfigPtr[i]), 
        pclkGroupIdx
        );
      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }

    /* DIV_24_5_CTL setting */
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk245DividerConfigNum; i++)
    {      
      /* Enter critical section */
      Mcu_EnterCriticalSection();
      Mcu_SetDiv245Ctl_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].Pclk245DividerConfigPtr[i]), 
        pclkGroupIdx
        );
      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }

    /* DIV_CMD setting */
    for(i=0U; i<McuClockConfigPtr->PclkGroupConfigPtr[j].PclkDividerConfigNum; i++)
    {      
      /* Enter critical section */
      Mcu_EnterCriticalSection();
      Mcu_SetDivCmd_Regs(
        &(McuClockConfigPtr->PclkGroupConfigPtr[j].PclkDividerConfigPtr[i]), 
        pclkGroupIdx
        );
      /* Exit critical section */
      Mcu_ExitCriticalSection();
    }
  }
}


/** \brief Mcu_FllClockSetting_Arch
 **
 ** This function sets Fll clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Fll clock setting is success.
 ** \retval  MCU_NOT_OK     Fll clock setting is not success.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_FllClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  if(McuClockConfigPtr->FllConfigPtr != NULL_PTR)
  {
    retVal = Mcu_SetFllClock_Regs(McuClockConfigPtr->FllConfigPtr);
  }

  return retVal;
}


/** \brief Mcu_PllClockSetting_Arch
 **
 ** This function sets Pll clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_PllClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i;

  for(i=0U; i<McuClockConfigPtr->PllConfigNum; i++)
  {
    Mcu_SetPllClock_Regs(&(McuClockConfigPtr->PllConfigPtr[i]));
  }
}


/** \brief Mcu_SscgClockSetting_Arch
 **
 ** This function sets SSCG clock setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SscgClockSetting_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) cfgIdx;

  for(cfgIdx=0U; cfgIdx<McuClockConfigPtr->SscgConfigNum; cfgIdx++)
  {
    Mcu_SetSscgClock_Regs(&(McuClockConfigPtr->SscgConfigPtr[cfgIdx]));
  }
}


/** \brief Mcu_RootSetting_Arch
 **
 ** This function sets clock Root setting of SRSS with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_RootSetting_Arch(
P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) i;

  for(i=0U; i<McuClockConfigPtr->ClockRootConfigNum; i++)
  {
    Mcu_SetRootSelect_Regs(&(McuClockConfigPtr->ClockRootConfigPtr[i]));
  }
}


/** \brief Mcu_UpdateResetReason_Arch
 **
 ** This function updates the internally stored reset reason and clears reset reason register.
 **
 ** \param[in]  McuConfigPtr  The pointer to configuration data.
 **
 ** \pre  McuConfigPtr shall not be a NULL pointer.
 */
static FUNC( void, MCU_CODE ) 
Mcu_UpdateResetReason_Arch(
  P2CONST( Mcu_ConfigType, AUTOMATIC, MCU_APPL_CONST ) McuConfigPtr
)
{
  /* Get reset reason raw register value */
  Mcu_GetRawResetReason_Regs(&Mcu_RawResetReason);

  /* Clear reset reason registers is enabled */
  if ((McuConfigPtr->ConfigFlags & MCU_FLAGS_CLEAR_RESET_REASON) == 
       MCU_FLAGS_CLEAR_RESET_REASON) {
    /* Clear reset reason */
    Mcu_ClearResetReason_Regs();
  }

  /* Get reset reason */
  Mcu_ResetReason = Mcu_GetResetReasonFromRaw_Regs(&Mcu_RawResetReason);

  /* Check reset reason is due to clock supervisor failure */
  if (Mcu_CheckResetReasonCsv_Arch(Mcu_ResetReason) == MCU_OK) {
    /* Report clock failure to DEM */
    Mcu_DemReportClockFailure( MCU_API_SERVICE_INIT );
  }

  return;
}


/** \brief Mcu_CheckResetReasonCsv_Arch
 **
 ** This function checks whether reset reason is due to clock failure.
 **
 ** \param[in]  McuResetReason  Reset reason value.
 **
 ** \retval  MCU_OK      The reset reason is due to clock failure.
 ** \retval  MCU_NOT_OK  The reset reason isn't due to clock failure.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckResetReasonCsv_Arch( 
  VAR( Mcu_ResetType, AUTOMATIC ) McuResetReason
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;

  if ((McuResetReason == MCU_CSV_HF_RESET) ||
      (McuResetReason == MCU_CSV_REF_RESET)) {
    /* Set reset is occured */
    retVal = MCU_OK;
  } else {
    /* Set reset is not occured */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_WaitPllFllLock_Arch
 **
 ** This function waits for SSCG/PLL/FLL lock.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         SSCG/FLL/PLL status is locked.
 ** \retval  MCU_NOT_OK     SSCG/FLL/PLL status is not locked.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_WaitPllFllLock_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  if(McuClockConfigPtr->FllConfigPtr != NULL_PTR)
  {
    /* wait for FLL lock */
    retVal = Mcu_FllLockWait_Regs(McuClockConfigPtr->FllConfigPtr);
  }

  if (retVal == MCU_OK)
  {
    /* wait for PLL lock */
    retVal = Mcu_PllLockWait_Regs(McuClockConfigPtr);

    if (retVal == MCU_OK)
    {
      /* wait for SSCG lock */
      retVal = Mcu_SscgLockWait_Regs(McuClockConfigPtr);
    }
  }

  return retVal;
}


/** \brief Mcu_SourceClockDisable_Arch
 **
 ** This function disables clock oscillator with specified clock configurations.
 **
 ** \param[in]  McuClockConfigPtr    The pointer to clock configuration.
 **
 ** \pre  McuClockConfigPtr shall not be a NULL pointer.
 **
 */
static FUNC( void, MCU_CODE ) 
Mcu_SourceClockDisable_Arch(
  P2CONST( Mcu_ClockConfigType, AUTOMATIC, MCU_APPL_CONST ) McuClockConfigPtr
)
{
  /* WCO (Backup) */
  if (McuClockConfigPtr->BackupConfigPtr != NULL_PTR)
  {
    Mcu_SetWCO_Regs(McuClockConfigPtr->BackupConfigPtr, FALSE);
  }

  /* ILO0, ILO1 */
  Mcu_SetILO_Regs(McuClockConfigPtr, FALSE);

  /* LPECO */
  if (McuClockConfigPtr->LpEcoConfigPtr != NULL_PTR)
  {
    Mcu_SetLpEco_Regs(McuClockConfigPtr->LpEcoConfigPtr, FALSE);
  }

  /* ECO */
  if (McuClockConfigPtr->EcoConfigPtr != NULL_PTR)
  {
    Mcu_SetECO_Regs(McuClockConfigPtr->EcoConfigPtr, FALSE);
  }
  
  /* IMO */
  Mcu_SetIMO_Regs(McuClockConfigPtr->ClkImoConfigRegVal, FALSE);

}


/** \brief Mcu_SetModeToActive_Arch
 **
 ** This function sets Active mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 **
 ** \retval  MCU_OK         Set Active Mode settings successfully.
 ** \retval  MCU_NOT_OK     Parameter is invalid.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToActive_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  /* Check Target Cpu */
  if (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM0) {
    /* Set Main Core power mode */
    retVal = Mcu_SetMainCorePowerMode_Arch(McuModeConfigPtr);
  }

  return retVal;
}


/** \brief Mcu_SetModeToSleep_Arch
 **
 ** This function sets Sleep mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Set Sleep Mode settings successfully.
 ** \retval  MCU_NOT_OK     Parameter is invalid.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToSleep_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  /* Check Target Cpu */
  if (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM0) {
    /* Set Main Core power mode */
    retVal = Mcu_SetMainCorePowerMode_Arch(McuModeConfigPtr);

    if (retVal == MCU_OK) {
      /* Set SCR registers and execute sleep instruction */
      Mcu_SetSleepTrigger_Regs(
        McuModeConfigPtr->ScrRegVal,
        McuModeConfigPtr->LowPwrTransEn
        );
    }
  }
  else if ((McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM4) ||
           (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM7)) {
    /* Set SCR registers and execute sleep instruction */
    Mcu_SetSleepTrigger_Regs(
      McuModeConfigPtr->ScrRegVal,
      McuModeConfigPtr->LowPwrTransEn
      );
  }
  else {
    /* Set result Not OK */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_SetModeToDeepSleep_Arch
 **
 ** This function sets DeepSleep mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Set Deep Sleep Mode settings successfully.
 ** \retval  MCU_NOT_OK     Parameter is invalid.
 ** \retval  MCU_NOT_OK_HW  Hardware error.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToDeepSleep_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  /* Check Target Cpu */
  if (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM0) {
    /* Set Main Core power mode */
    retVal = Mcu_SetMainCorePowerMode_Arch(McuModeConfigPtr);

    if (retVal == MCU_OK) {
      /* Set SCR registers and execute sleep instruction */
      Mcu_SetSleepTrigger_Regs(
        McuModeConfigPtr->ScrRegVal,
        McuModeConfigPtr->LowPwrTransEn
        );
    }
  }
  else if ((McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM4) ||
           (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM7)) {
    /* Set SCR registers and execute sleep instruction */
    Mcu_SetSleepTrigger_Regs(
      McuModeConfigPtr->ScrRegVal,
      McuModeConfigPtr->LowPwrTransEn
      );
  }
  else {
    /* Set result Not OK */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_SetModeToHibernate_Arch
 **
 ** This function sets Hibernate mode specific settings.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Set Hibernate Mode settings successfully.
 ** \retval  MCU_NOT_OK     Parameter is invalid.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetModeToHibernate_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;

  if (McuModeConfigPtr->HibConfigPtr != NULL_PTR) {
    /* Set HIBERNATE registers */
    Mcu_SetHibernate_Regs(
      McuModeConfigPtr->HibConfigPtr,
      McuModeConfigPtr->LowPwrTransEn
      );
  }
  else {
    /* Set result Not OK */
    retVal = MCU_NOT_OK;
  }

  return retVal;
}


/** \brief Mcu_UpdateSystemResource_Arch
 **
 ** This function updates system resources by specified settings.
 **
 ** \param[in]  SysResConfigPtr  The pointer to system resources configuration.
 **
 ** \pre  SysResConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Update the system resources successfully.
 ** \retval  MCU_NOT_OK_HW  Hardware error.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_UpdateSystemResource_Arch(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;

  /* Enter critical section */
  Mcu_EnterCriticalSection();

  /* Set low voltage detector control registers */
  Mcu_SetLvdCtl_Regs(SysResConfigPtr);

  if (SysResConfigPtr->PwrSsvCtlNum != 0U) {
    /* Set supply supervision control registers */
    Mcu_SetSsvCtl_Regs(SysResConfigPtr->PwrSsvCtlRegVal);
  }

  /* Exit critical section */
  Mcu_ExitCriticalSection();

  /* Set SRSS power control */
  retVal = Mcu_SrssPowerCtl_Arch(SysResConfigPtr);

  return retVal;
}


/** \brief Mcu_SrssPowerCtl_Arch
 **
 ** This function updates low power control by specified settings.
 **
 ** \param[in]  SysResConfigPtr  The pointer to system resources configuration.
 **
 ** \pre  SysResConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Update the low power control successfully.
 ** \retval  MCU_NOT_OK_HW  Hardware error.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SrssPowerCtl_Arch(
  P2CONST( Mcu_SysResConfigDataType, AUTOMATIC, MCU_APPL_CONST ) SysResConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal;

  /* Enter critical section */
  Mcu_EnterCriticalSection();
  /* Set SRSS power control registers */
  Mcu_SetSrssPowerCtl_Regs(SysResConfigPtr);
  /* Exit critical section */
  Mcu_ExitCriticalSection();
  /* Wait for each regulator enabled */
  retVal = Mcu_WaitSrssPowerCtl_Regs(SysResConfigPtr);

  return retVal;
}


/** \brief Mcu_SetMainCorePowerMode_Arch
 **
 ** This function sets the power mode of CPU Main Core.
 **
 ** \param[in]  McuModeConfigPtr  The pointer to Mode configuration.
 **
 ** \retval  MCU_OK         Set specific power mode successfully.
 ** \retval  MCU_NOT_OK     Main Core status is invalid.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_SetMainCorePowerMode_Arch(
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) retVal = MCU_OK;
  VAR( uint8         , AUTOMATIC ) index;

  /* Enter critical section */
  Mcu_EnterCriticalSection();

  for (index=0U; index < McuModeConfigPtr->MainCorePwrModeNum; index++){
    if ((McuModeConfigPtr->MainCorePwrMode[index] == MCU_MAINCOREPOWERMODE_SKIP) || 
        (McuModeConfigPtr->MainCorePwrMode[index] == MCU_MAINCOREPOWERMODE_ENABLED)) {
      /* Set main core power control registers */
      Mcu_SetMainCorePwrCtl_Regs(McuModeConfigPtr, index);
    }
    else {
      if (Mcu_GetMainCoreCpuStatus_Regs(index) == MCU_CPUSTATUS_DEEPSLEEP) {
        /* Set main core power control registers */
        Mcu_SetMainCorePwrCtl_Regs(McuModeConfigPtr, index);
      }
      else {
        /* Set result Not OK */
        retVal = MCU_NOT_OK;
      }
    }
  }

  /* Exit critical section */
  Mcu_ExitCriticalSection();

  return retVal;
}


/** \brief Mcu_GetHwStatus_Arch
 **
 ** This function gets HW power status.
 **
 ** \param[in]  MainCorePwrModeNum  The number of Main Core for Power Mode.
 ** \param[out] McuStatusPtr        The pointer to store the status.
 **
 ** \pre  McuStatus shall not be a NULL pointer.
 */
static FUNC( void, MCU_CODE ) 
Mcu_GetHwStatus_Arch(
  VAR( uint8, AUTOMATIC ) MainCorePwrModeNum,
  P2VAR( Mcu_StatusType, AUTOMATIC, MCU_APPL_DATA ) McuStatusPtr
)
{
  VAR( uint8, AUTOMATIC ) index;  

  /* CM0 CPU power mode */
  McuStatusPtr->Cm0Status = Mcu_GetCm0CpuStatus_Regs();
  /* MainCore CPU power mode */
  for(index=0U; index < MainCorePwrModeNum; index++){
    McuStatusPtr->MainCoreStatus[index] = Mcu_GetMainCoreCpuStatus_Regs(index);
  }
  /* System power mode */
  McuStatusPtr->SysStatus = Mcu_GetSysStatus_Regs();

  return;
}


/** \brief Mcu_CheckMode_Active_Arch
 **
 ** This function checks mode status related to active mode.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Mode settings for ACTIVE mode are consistent with registers.
 ** \retval  MCU_NOT_OK     Mode settings for ACTIVE mode are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Active_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check Main Core CPU power mode */
  retVal = Mcu_CheckMode_CpussMainCorePwr_Arch(McuModeConfigPtr);

  return retVal;
}


/** \brief Mcu_CheckMode_Sleep_Arch
 **
 ** This function checks mode status related to sleep mode.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Mode settings for SLEEP mode are consistent with registers.
 ** \retval  MCU_NOT_OK     Mode settings for SLEEP mode are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Sleep_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check Main Core CPU power mode */
  retVal = Mcu_CheckMode_CpussMainCorePwr_Arch(McuModeConfigPtr);
  if (retVal == MCU_OK) {
    if (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM0) {
      /* Check CM0 CPU system control registers */
      retVal = Mcu_CheckMode_SysCm0Scs_Regs(McuModeConfigPtr);
    } else if ((McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM4) ||
               (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM7)) {
      /* Check CM4 CPU system control registers */
      retVal = Mcu_CheckMode_SysCm4Scs_Regs(McuModeConfigPtr);
    } else {
      ;
    }
  }
  return retVal;
}


/** \brief Mcu_CheckMode_Hibernate_Arch
 **
 ** This function checks mode status related to hibernate mode.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Mode settings for HIBERNATE mode are consistent with registers.
 ** \retval  MCU_NOT_OK     Mode settings for HIBERNATE mode are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_Hibernate_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check HIBERNATE registers */
  retVal = Mcu_CheckMode_SrssHibernate_Regs(McuModeConfigPtr->HibConfigPtr);

  return retVal;
}


/** \brief Mcu_CheckMode_CpussMainCorePwr_Arch
 **
 ** This function checks Main Core power status.
 **
 ** \param[in]  McuModeConfigPtr      The pointer to mode configuration data.
 **
 ** \pre  McuModeConfigPtr shall not be a NULL pointer.
 **
 ** \retval  MCU_OK         Main Core CPU power mode settings are consistent with registers.
 ** \retval  MCU_NOT_OK     Main Core CPU power mode settings are inconsistent with registers.
 */
static FUNC( Mcu_ReturnType, MCU_CODE ) 
Mcu_CheckMode_CpussMainCorePwr_Arch(
  P2CONST( Mcu_ModeConfigType, MCU_CONST, MCU_APPL_CONST ) McuModeConfigPtr
)
{
  VAR( Mcu_ReturnType, AUTOMATIC) retVal;

  /* Check only if target CPU is CM0 */
  if (McuModeConfigPtr->TargetCpu == MCU_TARGETCPU_CM0) {
    /* Check Main Core CPU power mode with register */
    retVal = Mcu_CheckMode_CpussMainCorePwr_Regs(McuModeConfigPtr);
  } else {
    /* Set result match */
    retVal = MCU_OK;
  }

  return retVal;
}


#define MCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/*==================[end of file]============================================*/

