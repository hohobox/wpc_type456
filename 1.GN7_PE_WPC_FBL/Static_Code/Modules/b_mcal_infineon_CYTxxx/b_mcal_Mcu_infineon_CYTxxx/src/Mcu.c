/** \brief AUTOSAR Mcu Driver
 **
 ** This file contains the implementation of the AUTOSAR module Mcu
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/

#include <Mcu.h>               /* Public API */

#if (MCU_DEV_ERROR_DETECT == STD_ON)
#include <Det.h>               /* DET declarations */
#endif /* (MCU_DEV_ERROR_DETECT == STD_ON) */

#if defined(MCU_E_CLOCK_FAILURE_ERROR) || defined(MCU_E_RESET_FAILURE_ERROR)
#include <Dem.h>               /* Dem declarations */
#endif

#include <Mcu_Det.h>               /* Development error declarations      */
#include <Mcu_Internal_Arch.h>     /* Architecture dependent declarations */
#include <Mcu_ExternalInclude.h>   /* External include file               */

/*==================[macros]=================================================*/
/*==================[type definitions]=======================================*/
/*==================[external function declarations]=========================*/
/*==================[internal function declarations]=========================*/
/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
#define MCU_START_SEC_CONST_ASIL_B_UNSPECIFIED
#include <Mcu_MemMap.h> 
static CONST( Mcu_RegBaseAddrType, MCU_CONST )
Mcu_RegBaseAddressData = 
{
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
     Justification: The hardware register address is provided as integral type by configuration but it is required to be accessed using pointer. */
  /* PRQA S 303 ++ */
  ( volatile Mcu_PeriRegType * )    MCU_PERI_PERI_BASE_ADDR, 
  ( volatile Mcu_PclkRegType * )    MCU_PERI_PCLK_BASE_ADDR, 
  ( uint32 )                        MCU_PERI_DIVCMD_OFFSET_VALUE, 
  ( uint32 )                        MCU_PERI_PERIGROUP_OFFSET_VALUE, 
  ( volatile Mcu_CpussRegType * )   MCU_CPUSS_CPUSS_BASE_ADDR, 
  ( volatile Mcu_DwRegType * )      MCU_CPUSS_DW0_BASE_ADDR, 
  ( volatile Mcu_DwRegType * )      MCU_CPUSS_DW1_BASE_ADDR, 
  ( volatile Mcu_DmaRegType * )     MCU_CPUSS_DMAC_BASE_ADDR, 
  ( volatile Mcu_FlashRegType * )   MCU_CPUSS_FLASHC_BASE_ADDR, 
  ( volatile Mcu_SrssRegType * )    MCU_SRSS_SRSS_BASE_ADDR, 
  ( volatile Mcu_BackupRegType * )  MCU_SRSS_BACKUP_BASE_ADDR, 
  ( volatile Mcu_Cm0ScsRegType * )  MCU_SYSTEM_CM0P_SCS_REG_BASE_ADDR, 
  ( volatile Mcu_Cm4ScsRegType * )  MCU_SYSTEM_CM4_SCS_REG_BASE_ADDR
  /* PRQA S 303 -- */
};

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9.
   Justification: This data is accessed from other functions by using pointer. */
/* PRQA S 3218 1 */
static CONST( Mcu_HwInfoType, MCU_CONST ) Mcu_HwInfo = MCU_HW_INFO;

#define MCU_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

#define MCU_START_SEC_CONST_ASIL_B_32
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

#if (MCU_GEN_RESET_TYPE != MCU_REG_RESET_TYPE_DISABLE)
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9.
   Justification: This data is accessed from other functions by using pointer. */
/* PRQA S 3218 1 */
static CONST( Mcu_RegResetType, MCU_CONST ) Mcu_RegReset = MCU_GEN_RESET_TYPE;
#endif

#define MCU_STOP_SEC_CONST_ASIL_B_32
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

#define MCU_START_SEC_VAR_INIT_ASIL_B_8
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

static VAR( Mcu_DriverStatusType, MCU_VAR_INIT )
Mcu_DriverStatus = MCU_S_UNINITIALIZED;

#if (MCU_NO_PLL == STD_OFF)
static VAR( Mcu_ClockType, MCU_VAR_INIT ) 
Mcu_ClockSettingId = 0U;
#endif

#define MCU_STOP_SEC_VAR_INIT_ASIL_B_8
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

#define MCU_START_SEC_VAR_INIT_ASIL_B_32
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

static VAR( uint32, MCU_VAR_INIT ) 
Mcu_FllBypassWaitCycle = MCU_CYCLECOUNT_NUM_BEFORE_FLL_DISABLE;

#ifdef MCU_NUMBER_OF_PLL
static VAR( uint32, MCU_VAR_INIT ) 
Mcu_PllBypassWaitCycle[MCU_NUMBER_OF_PLL] = MCU_CYCLECOUNT_NUM_BEFORE_PLL_DISABLE_DEFAULT;
#endif /* MCU_NUMBER_OF_PLL */

#ifdef MCU_NUMBER_OF_SSCG
static VAR( uint32, MCU_VAR_INIT ) 
Mcu_SscgBypassWaitCycle[MCU_NUMBER_OF_SSCG] = MCU_CYCLECOUNT_NUM_BEFORE_SSCG_DISABLE_DEFAULT;
#endif /* MCU_NUMBER_OF_SSCG */

#define MCU_STOP_SEC_VAR_INIT_ASIL_B_32
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

#define MCU_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

static P2CONST( Mcu_ConfigType, AUTOMATIC, MCU_APPL_CONST ) 
Mcu_ConfigPtr = NULL_PTR;

#define MCU_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
/*==================[external function definitions]==========================*/
#define MCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 

/** \brief Mcu_Init
 ** 
 ** This service initializes the MCU driver.
 **
 ** \pre  No execution of init is done before.
 **
 ** \param[in]  ConfigPtr  Pointer to MCU driver configuration set.
 */
FUNC( void, MCU_CODE ) 
Mcu_Init( P2CONST( Mcu_ConfigType, AUTOMATIC, MCU_APPL_CONST ) ConfigPtr )
{
  /* Driver configuration valid check */
  if (Mcu_CheckConfigPtr(ConfigPtr) == FALSE) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT,
      MCU_E_INIT_FAILED
    );
  }
  else {
    /* Store ConfigPtr to internal data */
    Mcu_ConfigPtr = ConfigPtr;

    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

#if (MCU_NO_PLL == STD_OFF)
    /* Set ClockSettingId */
    if ((Mcu_ConfigPtr->ConfigFlags & MCU_FLAGS_INIT_CLOCK) == MCU_FLAGS_INIT_CLOCK) {
        Mcu_ClockSettingId = Mcu_ConfigPtr->McuDefaultClockSettingId;
    }
#endif
    
    Mcu_Init_Arch(Mcu_ConfigPtr);

    Mcu_DriverStatus = MCU_S_INITIALIZED;
  }
  return;
}


/** \brief Mcu_InitRamSection
 ** This service initializes the RAM section wise.
 **
 ** \pre  Mcu_Init() has already been called.
 ** \pre  DET has to be initialized already.
 ** \pre  pointer to configuration data must not be a NULL pointer.
 **
 ** \param[in]  RamSection  Selects RAM memory section provided in configuration set.
 **
 ** \retval  E_OK      Command has been accepted.
 ** \retval  E_NOT_OK  Command has not been accepted e.g. due to parameter error.
 */
FUNC( Std_ReturnType, MCU_CODE ) 
Mcu_InitRamSection( 
  VAR( Mcu_RamSectionType, AUTOMATIC ) RamSection
)
{
  VAR( Std_ReturnType, AUTOMATIC ) retVal;

  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_RAM_SECTION,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else if( Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_RAM_SECTION,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Parameter valid check */
  else if (Mcu_ConfigPtr->McuRamConfigNum <= RamSection) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_RAM_SECTION,
      MCU_E_PARAM_RAMSECTION
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Configuration valid check */
  else if (Mcu_ConfigPtr->McuRamConfigPtr == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_RAM_SECTION,
      MCU_E_PARAM_RAMSECTION
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else {
    retVal = Mcu_InitRamSection_Arch(&(Mcu_ConfigPtr->McuRamConfigPtr[RamSection]));
  }

  return retVal;
}


#if (MCU_INIT_CLOCK == STD_ON)
/** \brief Mcu_InitClock
 **
 ** This service initializes the PLL and other MCU specific clock options.
 **
 ** \pre  Mcu_Init() has already been called.
 ** \pre  DET has to be initialized already.
 ** \pre  pointer to configuration data must not be a NULL pointer.
 **
 ** \param[in]  ClockSetting  Clock setting.
 ** 
 ** \retval  E_OK      command has been accepted.
 ** \retval  E_NOT_OK  command has not been accepted.
 */
FUNC( Std_ReturnType, MCU_CODE ) 
Mcu_InitClock(
  VAR( Mcu_ClockType, AUTOMATIC ) ClockSetting
)
{
  VAR( Std_ReturnType, AUTOMATIC ) retVal;
  VAR( Mcu_ReturnType, AUTOMATIC ) inRetVal;

  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_CLOCK,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else if( Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_CLOCK,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }

  /* Parameter valid check */
  else if (Mcu_ConfigPtr->McuClockConfigNum <= ClockSetting)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_CLOCK,
      MCU_E_PARAM_CLOCK
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Configuration valid check */
  else if (Mcu_ConfigPtr->McuClockConfigPtr == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_INIT_CLOCK,
      MCU_E_PARAM_CLOCK
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else {
    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);
#if (MCU_NO_PLL == STD_OFF)
    Mcu_ClockSettingId = ClockSetting;
#endif
    inRetVal = Mcu_InitClock_Arch(
      MCU_API_SERVICE_INIT_CLOCK,
      &(Mcu_ConfigPtr->McuClockConfigPtr[ClockSetting])
    );
    /* Check result */
    if (inRetVal == MCU_OK) {
      /* Set result OK */
      retVal = E_OK;
    } else {
      /* Set result fail */
      retVal = E_NOT_OK;
    }
  }

  return retVal;
}
#endif /* (MCU_INIT_CLOCK == STD_ON) */


#if (MCU_NO_PLL == STD_OFF)
/** \brief Mcu_DistributePllClock
 **
 ** This service activates the PLL clock to the MCU clock distribution.
 **
 ** \pre Mcu_Init() has already been called.
 ** \pre Mcu_InitClock() has to be called already.
 ** \pre DET has to be initialized already.
 ** \pre The status of PLL has been detected as locked by Mcu_GetPllStatus().
 ** 
 ** \retval  E_OK      command has been accepted.
 ** \retval  E_NOT_OK  command has not been accepted.
 */
FUNC( Std_ReturnType, MCU_CODE ) Mcu_DistributePllClock( void )
{

  VAR( Std_ReturnType, AUTOMATIC ) retVal = E_OK;

  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_DISTRIBUTE_PLL_CLOCK,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else if( Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_DISTRIBUTE_PLL_CLOCK,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else if(Mcu_GetPllFllSettingFlag_Arch() == FALSE)
  {
    /* Mcu_InitClock not started */
    /*  Set result E_NOT_OK */
    retVal = E_NOT_OK;
  }
  else
  {
    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

    /* PLL status check */
    if (Mcu_GetPllStatus_Arch(&(Mcu_ConfigPtr->McuClockConfigPtr[Mcu_ClockSettingId])) !=
        MCU_PLL_LOCKED)
    {
      /* Report error status */
      Mcu_ReportError(
        MCU_API_SERVICE_DISTRIBUTE_PLL_CLOCK,
        MCU_E_PLL_NOT_LOCKED
      );
      /* Set result fail */
      retVal = E_NOT_OK;
    }
    else {
      Mcu_DistributePllClock_Arch(&(Mcu_ConfigPtr->McuClockConfigPtr[Mcu_ClockSettingId]));
    }
  }
  return retVal;
}
#endif /* (MCU_NO_PLL == STD_OFF) */


/** \brief Mcu_GetPllStatus
 **
 ** This service provides the lock status of the PLL.
 **
 ** \pre  Mcu_Init() has already been called.
 ** \pre  DET has to be initialized already.
 **
 ** \return  PLL status.
 */
FUNC( Mcu_PllStatusType, MCU_CODE ) Mcu_GetPllStatus( void )
{
  VAR( Mcu_PllStatusType, AUTOMATIC ) retVal;


  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_GET_PLL_STATUS,
      MCU_E_UNINIT
    );
    /* Set result undefined */
    retVal = MCU_PLL_STATUS_UNDEFINED;
  }
  else if( Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_GET_PLL_STATUS,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = MCU_PLL_STATUS_UNDEFINED;
  }
  else {
#if (MCU_NO_PLL == STD_OFF)

    if(Mcu_GetPllFllSettingFlag_Arch() == FALSE)
    {
      /* Set result unlocked */
      retVal = MCU_PLL_STATUS_UNDEFINED;
    }
    else
    {
      /* Set register base address pointer */
      Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

      retVal = Mcu_GetPllStatus_Arch(
                 &(Mcu_ConfigPtr->McuClockConfigPtr[Mcu_ClockSettingId])
                 );
    }
#else
    /* Set result fail */
    retVal = MCU_PLL_STATUS_UNDEFINED;
#endif
  }

  return retVal;
}


/** \brief Mcu_GetResetReason
 **
 ** The service reads the reset type from the hardware, if supported.
 **
 ** \pre  Mcu_Init() has already been called.
 ** \pre  DET has to be initialized already.
 **
 ** \return  Reset reason.
 */
FUNC( Mcu_ResetType, MCU_CODE ) Mcu_GetResetReason( void )
{
  VAR( Mcu_ResetType, AUTOMATIC ) retVal;

  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_GET_RESET_REASON,
      MCU_E_UNINIT
    );
    /* Set result undefined */
    retVal = MCU_RESET_UNDEFINED;
  }
  else {
    retVal = Mcu_GetResetReason_Arch();
  }

  return retVal;
}


/** \brief Mcu_GetResetRawValue
 **
 ** The service reads the reset type from the hardware register, if supported.
 **
 ** \pre  Mcu_Init() has already been called.
 ** \pre  DET has to be initialized already.
 **
 ** \return  Reset raw value.
 */
FUNC( Mcu_RawResetType, MCU_CODE ) Mcu_GetResetRawValue( void )
{
  VAR( Mcu_RawResetType, AUTOMATIC ) retVal;

  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_GET_RESET_RAW_VALUE,
      MCU_E_UNINIT
    );

    /* Set result valid */
    retVal = MCU_RESET_RAW_VALUE_INVALID;
  }
  else {
    retVal = Mcu_GetResetRawValue_Arch();
  }

  return retVal;
}


#if (MCU_PERFORM_RESET_API == STD_ON)
/** \brief Mcu_PerformReset
 **
 ** The service performs a microcontroller reset.
 **
 ** \pre  Mcu_Init() has to be called already.
 ** \pre  DET has to be initialized already.
 */
FUNC( void, MCU_CODE ) 
Mcu_PerformReset( void )
{
  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_PERFORM_RESET,
      MCU_E_UNINIT
    );
  } else if( Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_PERFORM_RESET,
      MCU_E_UNINIT
    );
  } else {
#if (MCU_GEN_RESET_TYPE == MCU_REG_RESET_TYPE_DISABLE)
    Mcu_ReportError(
      MCU_API_SERVICE_PERFORM_RESET,
      MCU_E_RESET_NOT_PERFORMED
    );
#else  /* (MCU_GEN_RESET_TYPE == MCU_REG_RESET_TYPE_DISABLE) */
    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

    Mcu_Reset_Arch(Mcu_RegReset, Mcu_ConfigPtr->McuResetConfigPtr);
#endif /* (MCU_GEN_RESET_TYPE == MCU_REG_RESET_TYPE_DISABLE) */
  }

  return;
}
#endif /* (MCU_PERFORM_RESET_API == STD_ON) */


/** \brief Mcu_SetMode
 **
 ** This service activates the MCU power modes.
 **
 ** \pre  Mcu_Init() has already been called.
 ** \pre  DET has to be initialized already.
 ** \pre  pointer to configuration data must not be a NULL pointer.
 **
 ** \param[in]  McuMode  Set different MCU power modes configured in the configuration set.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetMode( 
  VAR( Mcu_ModeType, AUTOMATIC ) McuMode
)
{
  VAR( Mcu_ReturnType, AUTOMATIC ) inRetVal;
  P2CONST( Mcu_ModeConfigType, AUTOMATIC, MCU_APPL_CONST ) modeConfigPtr;

  /* Driver initialization check */
  if (Mcu_DriverStatus != MCU_S_INITIALIZED) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_SET_MODE,
      MCU_E_UNINIT
    );
  }
  /* Driver configuration valid check */
  else if( Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_SET_MODE,
      MCU_E_UNINIT
    );
  }
  /* Parameter valid check */
  else if (Mcu_ConfigPtr->McuModeConfigNum <= McuMode) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_SET_MODE,
      MCU_E_PARAM_MODE
    );
  }
  /* Configuration valid check */
  else if (Mcu_ConfigPtr->McuModeConfigPtr == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_SET_MODE,
      MCU_E_PARAM_MODE
    );
  }
  else {
    modeConfigPtr = &(Mcu_ConfigPtr->McuModeConfigPtr[McuMode]);

    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

    /* Check if mode configuration settings are compatible. */
    if(Mcu_CheckModeConfig_Arch(modeConfigPtr) != MCU_OK) {
      /* Report error status */
       Mcu_ReportError(
         MCU_API_SERVICE_SET_MODE,
         MCU_E_PARAM_MODE
      );
    }
    else {
      inRetVal = Mcu_SetMode_Arch(modeConfigPtr);

      if (inRetVal == MCU_NOT_OK) {
        /* Report error status */
        Mcu_ReportError(
          MCU_API_SERVICE_SET_MODE,
          MCU_E_PARAM_MODE
        );
      }
      else if (inRetVal == MCU_NOT_OK_HW) {
        /* Report error status */
        Mcu_ReportError(
          MCU_API_SERVICE_SET_MODE,
          MCU_E_SYSTEM_RESOURCE_UPDATE_NOT_COMPLETED
        );
      }
      else {
        ;
      }
    }
  }
}


#if (MCU_VERSION_INFO_API == STD_ON)
/** \brief Mcu_GetVersionInfo
 **
 ** This service returns the version information of this module.
 **
 ** \param[out]  versioninfo  Pointer to where to store the version information of this module.
 **
 ** \pre  DET has to be initialized already.
 ** \pre  versioninfo must not be a NULL pointer.
 */
FUNC( void, MCU_CODE ) 
Mcu_GetVersionInfo( 
  P2VAR( Std_VersionInfoType, AUTOMATIC, MCU_APPL_DATA) versioninfo
)
{
  if (versioninfo == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_GET_VERSION_INFO,
      MCU_E_PARAM_POINTER
    );
  }
  else {
    Mcu_GetVersionInfo_Arch(versioninfo);
    versioninfo->sw_major_version = MCU_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = MCU_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = MCU_SW_PATCH_VERSION;
  }

  return;
}
#endif /* (MCU_VERSION_INFO_API == STD_ON) */


#if (MCU_SAFETY_FUNCTION_API == STD_ON)
/** \brief Mcu_CheckClockStatus
 **
 ** This service checks registers with clock configuration.
 **
 ** \pre Mcu_Init() has already been called.
 ** \pre Mcu_InitClock() has to be called already.
 ** \pre DET has to be initialized already.
 **
 ** \param[in]   ClockSettingId   The value of Clock setting id.
 **
 ** \retval  E_OK           Check processing is no error occurred.
 ** \retval  E_NOT_OK       Check processing is error occurred.
 **/
FUNC( Std_ReturnType, MCU_CODE ) 
Mcu_CheckClockStatus(
  VAR( Mcu_ClockType, AUTOMATIC ) ClockSettingId
)
{
  VAR( Std_ReturnType, AUTOMATIC ) retVal;
  VAR( Mcu_ReturnType, AUTOMATIC ) inRetVal;

  /* Driver configuration valid check */
  if (Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_CLOCK_STATUS,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Parameter valid check */
  else if (Mcu_ConfigPtr->McuClockConfigNum <= ClockSettingId) {
    /* Input parameter error */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_CLOCK_STATUS,
      MCU_E_PARAM_CLOCK
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Configuration valid check */
  else if (Mcu_ConfigPtr->McuClockConfigPtr == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_CLOCK_STATUS,
      MCU_E_PARAM_CLOCK
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else {
    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

    inRetVal = Mcu_CheckClockStatus_Arch(
               &(Mcu_ConfigPtr->McuClockConfigPtr[ClockSettingId])
             );

    /* Set result */
    if (inRetVal == MCU_OK) {
      retVal = E_OK;
    } else {
      retVal = E_NOT_OK;
    }
  }

  return retVal;
}


/** \brief Mcu_CheckModeStatus
 **
 ** This service checks registers with mode configuration.
 **
 ** \pre Mcu_Init() has already been called.
 ** \pre DET has to be initialized already.
 **
 ** \param[in]   ModeSettingId    Id of mode setting.
 ** \param[out]  StatusPtr        The pointer to store the status.
 **
 ** \retval  E_OK           Check processing is no error occurred.
 ** \retval  E_NOT_OK       Check processing is error occurred.
 **/
FUNC( Std_ReturnType, MCU_CODE ) 
Mcu_CheckModeStatus(
  VAR( Mcu_ModeType, AUTOMATIC ) ModeSettingId,
  P2VAR( Mcu_StatusType, AUTOMATIC, MCU_APPL_DATA ) StatusPtr
)
{
  VAR( Std_ReturnType, AUTOMATIC ) retVal;
  VAR( Mcu_ReturnType, AUTOMATIC ) inRetVal;

  /* Driver configuration valid check */
  if (Mcu_CheckConfigPtr(Mcu_ConfigPtr) == FALSE)
  {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_MODE_STATUS,
      MCU_E_UNINIT
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Parameter valid check */
  else if (Mcu_ConfigPtr->McuModeConfigNum <= ModeSettingId) {
    /* Input parameter error */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_MODE_STATUS,
      MCU_E_PARAM_MODE
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  /* Configuration valid check */
  else if (Mcu_ConfigPtr->McuModeConfigPtr == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_MODE_STATUS,
      MCU_E_PARAM_MODE
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else if (StatusPtr == NULL_PTR) {
    /* Report error status */
    Mcu_ReportError(
      MCU_API_SERVICE_CHECK_MODE_STATUS,
      MCU_E_PARAM_POINTER
    );
    /* Set result fail */
    retVal = E_NOT_OK;
  }
  else {
    /* Set register base address pointer */
    Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

    inRetVal = Mcu_CheckModeStatus_Arch(
               &(Mcu_ConfigPtr->McuModeConfigPtr[ModeSettingId]),
               StatusPtr
             );

    /* Set result */
    if (inRetVal == MCU_OK) {
      retVal = E_OK;
    } else {
      retVal = E_NOT_OK;
    }
  }

  return retVal;
}
#endif /* (MCU_SAFETY_FUNCTION_API == STD_ON) */


/** \brief Mcu_ReportError
 **
 ** This function reports development error status.
 **
 ** \param[in]  ApiId    Id of the service that detected the error.
 ** \param[in]  ErrorId  Id of the error that was detected.
 */
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7.
   Justification: This function will be referenced another unit in the future. */
/* PRQA S 1505 ++ */
FUNC( void, MCU_CODE ) Mcu_ReportError(
  VAR( uint8, AUTOMATIC ) ApiId,
  VAR( uint8, AUTOMATIC ) ErrorId
)
{
  /* ASIL error callout */
  MCU_ERROR_CALLOUT_FUNCTION(
    MCU_MODULE_ID,
    MCU_INSTANCE_ID,
    ApiId,
    ErrorId );

#if (MCU_DEV_ERROR_DETECT == STD_ON)
  (void)Det_ReportError( MCU_MODULE_ID, MCU_INSTANCE_ID, ApiId, ErrorId);
#endif /* (MCU_DEV_ERROR_DETECT == STD_ON) */
  return;
}
/* PRQA S 1505 -- */


/** \brief Mcu_DemReportClockFailure
 **
 ** This function reports to DEM that clock failure error has occurred.
 **
 ** \param[in]  ApiId    Id of the service that detected the error.
 **
 ** \pre  DEM has to be initialized already.
 */
FUNC( void, MCU_CODE ) Mcu_DemReportClockFailure(
  VAR( uint8, AUTOMATIC ) ApiId
)
{
  /* ASIL error callout */
  MCU_ERROR_CALLOUT_FUNCTION(
    MCU_MODULE_ID,
    MCU_INSTANCE_ID,
    ApiId,
    MCU_E_CLOCK_FAILURE_FOR_CALLOUT );

  if (Mcu_ConfigPtr->ClockFailure == STD_ON) {
#ifdef MCU_E_CLOCK_FAILURE_ERROR
    /* Report clock failure error to DEM */
    (void)Dem_ReportErrorStatus( MCU_E_CLOCK_FAILURE_ERROR, DEM_EVENT_STATUS_FAILED );
#endif
  }

  return;
}


/** \brief Mcu_DemReportClockSuccess
 **
 ** This function reports to DEM that no clock failure error has occurred.
 **
 ** \pre  DEM has to be initialized already.
 */
FUNC( void, MCU_CODE ) Mcu_DemReportClockSuccess( void )
{
  if (Mcu_ConfigPtr->ClockFailure == STD_ON) {
#ifdef MCU_E_CLOCK_FAILURE_ERROR
    /* Report no clock failure error to DEM */
    (void)Dem_ReportErrorStatus( MCU_E_CLOCK_FAILURE_ERROR, DEM_EVENT_STATUS_PASSED );
#endif
  }

  return;
}


/** \brief Mcu_DemReportResetFailure
 **
 ** This function reports to DEM that reset failure error has occurred.
 **
 ** \param[in]  ApiId    Id of the service that detected the error.
 **
 ** \pre  DEM has to be initialized already.
 */
FUNC( void, MCU_CODE ) Mcu_DemReportResetFailure(
  VAR( uint8, AUTOMATIC ) ApiId
)
{
  /* ASIL error callout */
  MCU_ERROR_CALLOUT_FUNCTION(
    MCU_MODULE_ID,
    MCU_INSTANCE_ID,
    ApiId,
    MCU_E_RESET_FAILURE_FOR_CALLOUT );

  if (Mcu_ConfigPtr->ResetFailure == STD_ON) {
#ifdef MCU_E_RESET_FAILURE_ERROR
    /* Report reset failure error to DEM */
    (void)Dem_ReportErrorStatus( MCU_E_RESET_FAILURE_ERROR, DEM_EVENT_STATUS_FAILED );
#endif
  }

  return;
}


/** \brief Mcu_DemReportResetSuccess
 **
 ** This function reports to DEM that no reset failure error has occurred.
 **
 ** \pre  DEM has to be initialized already.
 */
FUNC( void, MCU_CODE ) Mcu_DemReportResetSuccess( void )
{
  if (Mcu_ConfigPtr->ResetFailure == STD_ON) {
#ifdef MCU_E_RESET_FAILURE_ERROR
    /* Report no reset failure error to DEM */
    (void)Dem_ReportErrorStatus( MCU_E_RESET_FAILURE_ERROR, DEM_EVENT_STATUS_PASSED );
#endif
  }

  return;
}


/** \brief Mcu_Lvd_Int_Common
 **
 ** This function handles the LVD interrupts.
 */
FUNC( void, MCU_CODE ) 
Mcu_Lvd_Int_Common(void)
{
  VAR( uint32, AUTOMATIC ) intStatus;
  VAR( uint32, AUTOMATIC ) intCause;

  /* Set register base address */
  Mcu_SetBaseAddress_Regs(&Mcu_RegBaseAddressData);

  /* Get LVD interrupt status */
  intStatus = Mcu_GetLvdIntStatus_Regs();

  /* Check LVD interrupt status */
  if ((intStatus & MCU_REG_MASK_SRSS_INTR_HVLVD1) == MCU_REG_MASK_SRSS_INTR_HVLVD1) {
    /* HVLVD1 interrupt occurs */
#ifdef MCU_HVLVD1_NOTIFICATION
    /* Call notification */
    (void)MCU_HVLVD1_NOTIFICATION();
#endif /* MCU_HVLVD1_NOTIFICATION */
    /* Set interrupt cause */
    intCause = MCU_REG_MASK_SRSS_INTR_HVLVD1;
  } else if ((intStatus & MCU_REG_MASK_SRSS_INTR_HVLVD2) == MCU_REG_MASK_SRSS_INTR_HVLVD2) {
    /* HVLVD2 interrupt occurs */
#ifdef MCU_HVLVD2_NOTIFICATION
    /* Call notification */
    (void)MCU_HVLVD2_NOTIFICATION();
#endif /* MCU_HVLVD2_NOTIFICATION */
    /* Set interrupt cause */
    intCause = MCU_REG_MASK_SRSS_INTR_HVLVD2;
  } else {
    /* Set interrupt cause 0 */
    intCause = 0U;
  }
  /* Check if interrupt is valid */
  if (intCause != 0U) {
    /* Clear interrupt */
    Mcu_ClearLvdIntStatus_Regs(intCause);
  }

  return;
}


/** \brief Mcu_GetHwInfo
 **
 ** This function returns the HW information.
 **
 ** \return  pointer of HW information.
 */
FUNC_P2CONST( Mcu_HwInfoType, MCU_APPL_CONST, MCU_CODE ) 
Mcu_GetHwInfo( void )
{
  return &Mcu_HwInfo;
}


/** \brief Mcu_GetFllBypassWaitCycle
 **
 ** This function returns FLL bypass wait cycle.
 **
 ** \return  Bypass wait cycle.
 */
FUNC( uint32, MCU_CODE ) 
Mcu_GetFllBypassWaitCycle( void )
{
  return Mcu_FllBypassWaitCycle;
}


/** \brief Mcu_GetPllBypassWaitCycle
 **
 ** This function returns PLL bypass wait cycle.
 **
 ** \param[in]  PllRegIdx        The index number of Pll clock.
 **
 ** \return  Bypass wait cycle.
 */
FUNC( uint32, MCU_CODE ) 
Mcu_GetPllBypassWaitCycle(
  VAR( uint32, AUTOMATIC ) PllRegIdx
)
{
#ifdef MCU_NUMBER_OF_PLL
  return Mcu_PllBypassWaitCycle[PllRegIdx];
#else /* MCU_NUMBER_OF_PLL */
  return MCU_CYCLECOUNT_NUM_BEFORE_PLL_DISABLE;
#endif /* MCU_NUMBER_OF_PLL */
}


/** \brief Mcu_GetSscgBypassWaitCycle
 **
 ** This function returns SSCG bypass wait cycle.
 **
 ** \param[in]  SscgRegIdx       The index number of SSCG clock.
 **
 ** \return  Bypass wait cycle.
 */
/* Deviation from QAC-C message 3206, MISRA-C:2012 Rule-2.7.
   Justification: These parameters will be used when McuSscgPllSettings are exist. */
/* PRQA S 3206 3 */
FUNC( uint32, MCU_CODE ) 
Mcu_GetSscgBypassWaitCycle(
  VAR( uint32, AUTOMATIC ) SscgRegIdx
)
{
#ifdef MCU_NUMBER_OF_SSCG
  return Mcu_SscgBypassWaitCycle[SscgRegIdx];
#else /* MCU_NUMBER_OF_SSCG */
  return MCU_CYCLECOUNT_NUM_BEFORE_SSCG_DISABLE;
#endif /* MCU_NUMBER_OF_SSCG */
}


/** \brief Mcu_SetFllBypassWaitCycle
 **
 ** This function sets FLL bypass wait cycle.
 **
 ** \param[in]  BypassWaitCycle  Bypass wait cycle.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetFllBypassWaitCycle(
  VAR( uint32, AUTOMATIC ) BypassWaitCycle
)
{
  Mcu_FllBypassWaitCycle = BypassWaitCycle;

  return;
}


/** \brief Mcu_SetPllBypassWaitCycle
 **
 ** This function sets PLL bypass wait cycle.
 **
 ** \param[in]  PllRegIdx        The index number of Pll clock.
 ** \param[in]  BypassWaitCycle  Bypass wait cycle.
 */
FUNC( void, MCU_CODE ) 
Mcu_SetPllBypassWaitCycle(
  VAR( uint32, AUTOMATIC ) PllRegIdx,
  VAR( uint32, AUTOMATIC ) BypassWaitCycle
)
{
#ifdef MCU_NUMBER_OF_PLL
  Mcu_PllBypassWaitCycle[PllRegIdx] = BypassWaitCycle;
#endif /* MCU_NUMBER_OF_PLL */

  return;
}


/** \brief Mcu_SetSscgBypassWaitCycle
 **
 ** This function sets SSCG bypass wait cycle.
 **
 ** \param[in]  SscgRegIdx       The index number of SSCG clock.
 ** \param[in]  BypassWaitCycle  Bypass wait cycle.
 */
/* Deviation from QAC-C message 3206, MISRA-C:2012 Rule-2.7.
   Justification: These parameters will be used when McuSscgPllSettings are exist. */
/* PRQA S 3206 5 */
FUNC( void, MCU_CODE ) 
Mcu_SetSscgBypassWaitCycle(
  VAR( uint32, AUTOMATIC ) SscgRegIdx,
  VAR( uint32, AUTOMATIC ) BypassWaitCycle
)
{
#ifdef MCU_NUMBER_OF_SSCG
  Mcu_SscgBypassWaitCycle[SscgRegIdx] = BypassWaitCycle;
#endif /* MCU_NUMBER_OF_SSCG */

  return;
}


#define MCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Mcu_MemMap.h> 


/*==================[internal function definitions]==========================*/


/*==================[end of file]============================================*/
