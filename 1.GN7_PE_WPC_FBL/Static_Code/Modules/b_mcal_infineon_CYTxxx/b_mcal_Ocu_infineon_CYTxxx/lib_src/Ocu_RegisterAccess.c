/** \brief AUTOSAR Ocu Driver
 **
 ** This file contains register access function for the AUTOSAR Ocu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Ocu_RegisterAccess.h>   /* Module register types */

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/

/*==================[external constants]=====================================*/

/*==================[internal constants]=====================================*/

/*==================[external data]==========================================*/

/*==================[internal data]==========================================*/

/*==================[external function definitions]==========================*/

#define OCU_START_SEC_CODE_ASIL_B
#include <Ocu_MemMap.h>

/** \brief Ocu_RaInit
 **
 ** Set all one-time settings for a channel.
 **
 ** \param [in] ChannelCfgPtr   Pointer to channel configuration.
 ** \param [in] CountDirection  Count direction for the whole OCU driver.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaInit
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_CountDirectionType, AUTOMATIC ) CountDirection
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
    ( volatile P2VAR ( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );
  VAR( uint32, AUTOMATIC ) CtrlRegValue;
  VAR( uint32, AUTOMATIC ) TrOutSelRegValue;

  /* Init CTRL */
  OcuReg->Ctrl = OCU_REG_VALUE_TCPWM_CTRL;

  /* Init CTRL:MODE and DBG_FREEZE_EN */
  if ( TRUE == ChannelCfgPtr->DebugMode )
  {
    /* Debug enable */
    CtrlRegValue = ( uint32 )( OCU_REG_VALUE_TCPWM_CTRL | OCU_REG_MASK_TCPWM_CTRL_DBG_FREEZE_EN );
  }
  else
  {
    /* Debug disable */
    CtrlRegValue = OCU_REG_VALUE_TCPWM_CTRL;
  }

  /* Init CTRL:UP_DOWN_MODE */
  if ( OCU_UPCOUNTING != CountDirection )
  {
    CtrlRegValue |= OCU_REG_MASK_TCPWM_CTRL_COUNT_DOWN;
  }

  /* Init CTRL:PWM_STOP_ON_KILL and PWM_SYNC_KILL */
  CtrlRegValue |= ( uint32 )( OCU_REG_MASK_TCPWM_CTRL_PWM_STOP_ON_KILL | OCU_REG_MASK_TCPWM_CTRL_PWM_SYNC_KILL );

  /* Init CTRL:PWM_DISABLE_MODE */
  if ( OCU_HIGH == ChannelCfgPtr->OutputPinDefaultState )
  {
    CtrlRegValue |= OCU_REG_MASK_TCPWM_CTRL_PWM_DISABLE_MODE_H;
  }
  else
  {
    CtrlRegValue |= OCU_REG_MASK_TCPWM_CTRL_PWM_DISABLE_MODE_L;
  }

  /* Write to register */
  OcuReg->Ctrl = CtrlRegValue;

  /* Set prescaler value */
  OcuReg->Dt = ( uint32 )( ChannelCfgPtr->Prescale );

  /* Init TR_PWM_CTRL */
  OcuReg->Tr_Pwm_Ctrl = OCU_REG_VALUE_TCPWM_TR_PWM_CTRL;

  /* Init COUNTER */
  OcuReg->Counter = OCU_REG_VALUE_TCPWM_COUNTER;

  /* Init CC0 */
  OcuReg->Cc0 = OCU_REG_VALUE_TCPWM_CC0;

  /* Init CC1 */
  OcuReg->Cc1 = OCU_REG_VALUE_TCPWM_CC1;

  /* Init PERIOD */
  OcuReg->Period = ( uint32 )( ChannelCfgPtr->MaxCounterValue );

  /* Output trigger 0 enable */
  if ( OCU_TRIGGER_OUT0 == ( ChannelCfgPtr->TriggerOutputSelect & OCU_TRIGGER_OUT0 ) )
  {
    /* Set compare match 0 event to generate the output trigger 0 */
    TrOutSelRegValue = ( uint32 )OCU_TRIGGEROUT_CC0_MATCH;
  }
  else
  {
    /* Output trigger 0 disable */
    TrOutSelRegValue = ( uint32 )OCU_TRIGGEROUT_DISABLED;
  }

  /* Output trigger 1 enable */
  if ( OCU_TRIGGER_OUT1 == ( ChannelCfgPtr->TriggerOutputSelect & OCU_TRIGGER_OUT1 ) )
  {
    /* Set compare match 0 event to generate the output trigger 1 */
    TrOutSelRegValue |= ( uint32 )( ( uint32 )OCU_TRIGGEROUT_CC0_MATCH << OCU_REG_BIT_TCPWM_TR_OUT_SEL_OUT1 );
  }
  else
  {
    /* Output trigger 1 disable */
    TrOutSelRegValue |= ( uint32 )( ( uint32 )OCU_TRIGGEROUT_DISABLED << OCU_REG_BIT_TCPWM_TR_OUT_SEL_OUT1 );
  }

  /* Init TR_OUT_SEL */
  OcuReg->Tr_Out_Sel = TrOutSelRegValue;

  /* Init TR_IN_SEL0 */
  OcuReg->Tr_In_Sel0 = OCU_REG_VALUE_TCPWM_TR_IN_SEL0;

  /* Init TR_IN_EDGE_SEL */
  OcuReg->Tr_In_Edge_Sel = OCU_REG_VALUE_TCPWM_TR_IN_EDGE_SEL;

  /* Init INTR */
  OcuReg->Intr = OCU_REG_VALUE_TCPWM_INTR;

  /* Init INTR_MASK */
  OcuReg->Intr_Mask = OCU_REG_VALUE_TCPWM_INTR_MASK;
}

/** \brief Ocu_RaDeInit
 **
 ** This function shall deinitialize the OCU variables and registers that were initialized by Ocu_Init.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaDeInit
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* DeInit CTRL */
  OcuReg->Ctrl = OCU_REG_VALUE_TCPWM_CTRL_RESET;

  /* DeInit COUNTER */
  OcuReg->Counter = OCU_REG_VALUE_TCPWM_COUNTER;

  /* DeInit CC0 */
  OcuReg->Cc0 = OCU_REG_VALUE_TCPWM_CC0;

  /* DeInit CC1 */
  OcuReg->Cc1 = OCU_REG_VALUE_TCPWM_CC1;

  /* DeInit PERIOD */
  OcuReg->Period = OCU_REG_VALUE_TCPWM_PERIOD;

  /* DeInit DT */
  OcuReg->Dt = OCU_REG_VALUE_TCPWM_DT;

  /* DeInit TR_PWM_CTRL */
  OcuReg->Tr_Pwm_Ctrl = OCU_REG_VALUE_TCPWM_TR_PWM_CTRL;

  /* DeInit TR_OUT_SEL */
  OcuReg->Tr_Out_Sel = OCU_REG_VALUE_TCPWM_TR_OUT_SEL_RESET;

  /* DeInit TR_IN_SEL0 */
  OcuReg->Tr_In_Sel0 = OCU_REG_VALUE_TCPWM_TR_IN_SEL0;

  /* DeInit TR_IN_EDGE_SEL */
  OcuReg->Tr_In_Edge_Sel = OCU_REG_VALUE_TCPWM_TR_IN_EDGE_SEL;

  /* DeInit INTR */
  OcuReg->Intr = OCU_REG_VALUE_TCPWM_INTR;

  /* DeInit INTR_MASK */
  OcuReg->Intr_Mask = OCU_REG_VALUE_TCPWM_INTR_MASK;
}

/** \brief Ocu_RaStartChannel
 **
 ** Set necessary register to start the channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaStartChannel
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* Set CC1 */
  OcuReg->Cc1 = OCU_REG_VALUE_TCPWM_CC1;

  /* Set CC0 */
  OcuReg->Cc0 = ( uint32 )( ChannelCfgPtr->ChannelStatusPtr->SettingThreshold );
}

/** \brief Ocu_RaStopChannel
 **
 ** Set necessary register to stop the channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaStopChannel
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* Set CC0 */
  OcuReg->Cc0 = OCU_REG_VALUE_TCPWM_CC0;
}

/** \brief Ocu_RaHwTriggerStart
 **
 ** Set necessary register for hardware trigger channel start.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaHwTriggerStart
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );
  VAR( uint32, AUTOMATIC ) TrInSel0RegValue;

  /* Set start trigger */
  TrInSel0RegValue = OcuReg->Tr_In_Sel0;
  TrInSel0RegValue &= ~OCU_REG_MASK_TCPWM_TR_IN_SEL0_RELOAD_SEL;
  TrInSel0RegValue |= ( uint32 )( ( uint32 )( ChannelCfgPtr->StartTriggerSelectValue )
                      << OCU_REG_BIT_TCPWM_TR_IN_SEL0_RELOAD_SEL );

  /* Write to register */
  OcuReg->Tr_In_Sel0 = TrInSel0RegValue;

  /* Set RELOAD_EDGE bits of TR_IN_EDGE_SEL register */
  OcuReg->Tr_In_Edge_Sel &= ~OCU_REG_MASK_TCPWM_TR_IN_EDGE_SEL_RELOAD_EDGE;

  /* Counter enable */
  OcuReg->Ctrl |= OCU_REG_MASK_TCPWM_CTRL_ENABLED;

  /* Read CTRL register ( This read ensures that the write has been flushed to hardware ) */
  ( void )( OcuReg->Ctrl );
}

/** \brief Ocu_RaStartFreeRunningCounter
 **
 ** Start a free-running counter.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaStartFreeRunningCounter
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* Counter enable */
  OcuReg->Ctrl |= OCU_REG_MASK_TCPWM_CTRL_ENABLED;

  /* Channel start by SW start trigger */
  OcuReg->Tr_Cmd |= OCU_REG_MASK_TCPWM_TR_CMD_START;
}

/** \brief Ocu_RaReloadFreeRunningCounter
 **
 ** Reload a free-running counter.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaReloadFreeRunningCounter
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* Counter enable */
  OcuReg->Ctrl |= OCU_REG_MASK_TCPWM_CTRL_ENABLED;

  /* Channel start by SW reload trigger */
  OcuReg->Tr_Cmd |= OCU_REG_MASK_TCPWM_TR_CMD_RELOAD;
}

/** \brief Ocu_RaStopFreeRunningCounter
 **
 ** Stop a free-running counter.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaStopFreeRunningCounter
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );
  VAR( uint32, AUTOMATIC ) CtrlRegValue;

  /* Read register value */
  CtrlRegValue = OcuReg->Ctrl;

  /* Set PWM_DISABLE_MODE */
  CtrlRegValue &= ~OCU_REG_MASK_TCPWM_CTRL_PWM_DISABLE_MODE;
  CtrlRegValue |= OCU_REG_MASK_TCPWM_CTRL_PWM_DISABLE_MODE_RETAIN;

  /* Write to register */
  OcuReg->Ctrl = CtrlRegValue;

  /* Counter disable */
  OcuReg->Ctrl &= ~OCU_REG_MASK_TCPWM_CTRL_ENABLED;
}

/** \brief Ocu_RaSetPinState
 **
 ** Set necessary register to update pin state.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 ** \param [in] PinState       Type of pin state:
 **                            OCU_LOW or
 **                            OCU_HIGH.
 ** \param [in] CountDirection Count direction for the whole OCU driver.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaSetPinState
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_PinStateType, AUTOMATIC ) PinState,
  VAR( Ocu_CountDirectionType, AUTOMATIC ) CountDirection
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );
  VAR( uint32, AUTOMATIC ) TrPwmCtrlRegValue;

  /* Read register value */
  TrPwmCtrlRegValue = OcuReg->Tr_Pwm_Ctrl;

  /* Set PinState to CC1_MATCH_MODE bits of TR_PWM_CTRL register */
  TrPwmCtrlRegValue &= ~( uint32 )( OCU_TCPWM_TR_PWM_CTRL_NO_CHANGE
                << OCU_REG_BIT_TCPWM_TR_PWM_CTRL_CC1_MATCH_MODE );
  TrPwmCtrlRegValue |= ( uint32 )( ( uint32 )PinState << OCU_REG_BIT_TCPWM_TR_PWM_CTRL_CC1_MATCH_MODE );

  /* Write to register */
  OcuReg->Tr_Pwm_Ctrl = TrPwmCtrlRegValue;

  /* Set CC1 register */
  if ( OCU_UPCOUNTING == CountDirection )
  {
    OcuReg->Cc1 = 0U;
  }
  else
  {
    OcuReg->Cc1 = ( uint32 )( ChannelCfgPtr->MaxCounterValue );
  }
}

/** \brief Ocu_RaSetPinAction
 **
 ** Set necessary register to update pin action.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 ** \param [in] PinAction      Type of pin action:
 **                            OCU_SET_LOW or
 **                            OCU_SET_HIGH or
 **                            OCU_TOGGLE or
 **                            OCU_DISABLE.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaSetPinAction
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_PinActionType, AUTOMATIC ) PinAction
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );
  VAR( uint32, AUTOMATIC ) TrPwmCtrlRegValue;

  /* Read register value */
  TrPwmCtrlRegValue = OcuReg->Tr_Pwm_Ctrl;

  /* Set PinAction value */
  TrPwmCtrlRegValue &= ~OCU_TCPWM_TR_PWM_CTRL_NO_CHANGE;
  TrPwmCtrlRegValue |= ( uint32 )PinAction;

  /* Write to register */
  OcuReg->Tr_Pwm_Ctrl = TrPwmCtrlRegValue;
}

/** \brief Ocu_RaGetCounter
 **
 ** Get the current value of the counter.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  The current value of the counter.
 **
 */
FUNC( Ocu_ValueType, OCU_CODE ) Ocu_RaGetCounter
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  return OcuReg->Counter;
}

/** \brief Ocu_RaSetThresholdValue
 **
 ** Set necessary register to update threshold value.
 **
 ** \param [in] ChannelCfgPtr   Pointer to channel configuration.
 ** \param [in] ThresholdValue  Value to compare with the content of the counter. This value is in ticks.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaSetThresholdValue
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_ValueType, AUTOMATIC ) ThresholdValue
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* Set threshold value */
  OcuReg->Cc0 = ( uint32 )ThresholdValue;
}

/** \brief Ocu_RaDisableNotification
 **
 ** Set registers to disable notification interrupt.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaDisableNotification
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress);

  /* Clear cc0_match interrupt flag */
  OcuReg->Intr = OCU_REG_MASK_TCPWM_INTR_CC0_MATCH;

  /* Read INTR register ( This read ensures that the write has been flushed to hardware ) */
  ( void )( OcuReg->Intr );

  /* Disable cc0_match interrupt */
  OcuReg->Intr_Mask = OCU_REG_VALUE_TCPWM_INTR_MASK;

  /* Read INTR_MASK register ( This read ensures that the write has been flushed to hardware ) */
  ( void )( OcuReg->Intr_Mask );
}

/** \brief Ocu_RaEnableNotification
 **
 ** Set registers to enable notification interrupt.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaEnableNotification
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  /* Clear cc0_match interrupt flag */
  OcuReg->Intr = OCU_REG_MASK_TCPWM_INTR_CC0_MATCH;

  /* Read INTR register ( This read ensures that the write has been flushed to hardware ) */
  ( void )( OcuReg->Intr );

  /* Enable cc0_match interrupt */
  OcuReg->Intr_Mask = OCU_REG_MASK_TCPWM_INTR_MASK_CC0_MATCH;
}

/** \brief Ocu_RaCheckChannelStatus_Common
 **
 ** This function verifies register settings.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  Return TRUE if channel status is valid, else return FALSE.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_RaCheckChannelStatus_Common
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );
  VAR( boolean, AUTOMATIC ) Result = TRUE;

  /* is pre-scaling correct check */
  if ( ( uint32 )( ChannelCfgPtr->ChannelStatusPtr->Prescale ) != OcuReg->Dt )
  {
    Result = FALSE;
  }

  /* is counter running now check */
  if ( ( OCU_REG_MASK_TCPWM_STATUS_RUNNING != ( OcuReg->Status & OCU_REG_MASK_TCPWM_STATUS_RUNNING ) ) &&
       ( OCU_REG_MASK_TCPWM_TR_CMD_START   != ( OcuReg->Tr_Cmd & OCU_REG_MASK_TCPWM_TR_CMD_START ) ) &&
       ( OCU_REG_MASK_TCPWM_TR_CMD_RELOAD  != ( OcuReg->Tr_Cmd & OCU_REG_MASK_TCPWM_TR_CMD_RELOAD ) ) )
  {
    Result = FALSE;
  }

  /* Pin action check */
  if ( ( uint32 )( ChannelCfgPtr->ChannelStatusPtr->PinAction )
  != ( OcuReg->Tr_Pwm_Ctrl & OCU_TCPWM_TR_PWM_CTRL_NO_CHANGE ) )
  {
    Result = FALSE;
  }

  return Result;
}

/** \brief Ocu_RaCheckChannelStatus_Uninit
 **
 ** This function verifies register settings for channel state uninit.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  Return TRUE if channel status is valid, else return FALSE.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_RaCheckChannelStatus_Uninit
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  VAR( boolean, AUTOMATIC ) Result = TRUE;
  VAR( uint32, AUTOMATIC )  RegCtrl;

  /* Read register value */
  RegCtrl = OcuReg->Ctrl;

  /* is counter disabled (default) check */
  if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_ENABLED ) )
  {
    Result = FALSE;
  }

  /* is timer mode (default) check */
  if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_MODE ) )
  {
    Result = FALSE;
  }

  /* is counter up (default) check */
  if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_UP_DOWN_MODE ) )
  {
    Result = FALSE;
  }

  /* is debug mode disable (default) check */
  if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_DBG_FREEZE_EN ) )
  {
    Result = FALSE;
  }

  /* is pwm disable mode (default) check */
  if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_PWM_DISABLE_MODE ) )
  {
    Result = FALSE;
  }

  /* is counter default ( 0 ) check */
  if ( OCU_REG_VALUE_TCPWM_COUNTER != OcuReg->Counter )
  {
    Result = FALSE;
  }

  /* is CC0 default (0xFFFFFFFF(32bit)/0xFFFF(16bit)) check */
  if( OCU_TIMER_WIDTH_32 == ChannelCfgPtr->TimerWide )
  {
    if ( OCU_REG_VALUE_TCPWM_CC0 != OcuReg->Cc0 )
    {
      Result = FALSE;
    }
  }
  else
  {
    if ( ( uint32 )( OCU_REG_VALUE_TCPWM_CC0 & OCU_REG_MASK_TCPWM_16BITS_MASK ) != OcuReg->Cc0 )
    {
      Result = FALSE;
    }
  }

  /* is CC1 default (0xFFFFFFFF(32bit)/0xFFFF(16bit)) check */
  if( OCU_TIMER_WIDTH_32 == ChannelCfgPtr->TimerWide )
  {
    if ( OCU_REG_VALUE_TCPWM_CC1 != OcuReg->Cc1 )
    {
      Result = FALSE;
    }
  }
  else
  {
    if ( ( uint32 )( OCU_REG_VALUE_TCPWM_CC1 & OCU_REG_MASK_TCPWM_16BITS_MASK ) != OcuReg->Cc1 )
    {
      Result = FALSE;
    }
  }

  /* is PERIOD default (0xFFFFFFFF(32bit)/0xFFFF(16bit)) check */
  if( OCU_TIMER_WIDTH_32 == ChannelCfgPtr->TimerWide )
  {
    if ( OCU_REG_VALUE_TCPWM_PERIOD != OcuReg->Period )
    {
      Result = FALSE;
    }
  }
  else
  {
    if ( ( uint32 )( OCU_REG_VALUE_TCPWM_PERIOD & OCU_REG_MASK_TCPWM_16BITS_MASK ) != OcuReg->Period )
    {
      Result = FALSE;
    }
  }

  /* is pre-scaling default ( 0 ) check */
  if ( OCU_REG_VALUE_TCPWM_DT != OcuReg->Dt )
  {
    Result = FALSE;
  }

  /* is input trigger ( default ) check */
  if ( OCU_REG_VALUE_TCPWM_TR_IN_SEL0 != OcuReg->Tr_In_Sel0 )
  {
    Result = FALSE;
  }

  /* is trigger edge up ( default ) check */
  if ( OCU_REG_VALUE_TCPWM_TR_IN_EDGE_SEL != OcuReg->Tr_In_Edge_Sel )
  {
    Result = FALSE;
  }

  /* is output trigger ( default ) check */
  if ( OCU_REG_VALUE_TCPWM_TR_OUT_SEL_RESET != OcuReg->Tr_Out_Sel )
  {
    Result = FALSE;
  }

  /* is enable inter mask ( default ) check */
  if ( OCU_REG_VALUE_TCPWM_INTR_MASK != OcuReg->Intr_Mask )
  {
    Result = FALSE;
  }

  /* is pin action and pin state ( default ) check */
  if ( OCU_REG_VALUE_TCPWM_TR_PWM_CTRL != OcuReg->Tr_Pwm_Ctrl )
  {
    Result = FALSE;
  }

  return Result;
}

/** \brief Ocu_RaSetPrescaler
 **
 ** Set necessary register to update prescaler value.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 ** \param [in] PreValue       Prescaler value.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaSetPrescaler
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( uint8, AUTOMATIC ) PreValue
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( ChannelCfgPtr->BaseAddress );

  /* Set prescaler value */
  OcuReg->Dt = ( uint32 )( PreValue );
}

/** \brief Ocu_RaIsInterruptPending
 **
 ** Check whether interrupt for channel is pending.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return TRUE if channel interrupt is pending, else return FALSE.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_RaIsInterruptPending
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  VAR( boolean, AUTOMATIC ) InterruptDetected;
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );
  VAR( uint32, AUTOMATIC ) IntrMaskedValue = OcuReg->Intr_Masked;

  /* Check interrupt masked value */
  if ( 0U != ( IntrMaskedValue & OCU_REG_MASK_TCPWM_INTR_MASKED_CC0_MATCH ) )
  {
    InterruptDetected = TRUE;
  }
  else
  {
    InterruptDetected = FALSE;
  }

  return InterruptDetected;
}

/** \brief Ocu_RaClearInterruptFlag
 **
 ** Clears interrupt flag(s) of channel.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 */
FUNC( void, OCU_CODE ) Ocu_RaClearInterruptFlag
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  /* Clear interrupt flags */
  OcuReg->Intr = OCU_REG_MASK_TCPWM_INTR;

  /* Read value of INTR register ( This read ensures that the write has been flushed out to the hardware ) */
  ( void ) OcuReg->Intr;
}

/** \brief Ocu_RaGetCtrl
 **
 ** Get Ctrl register value.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return ctrl register value.
 **
 */
FUNC( uint32, OCU_CODE ) Ocu_RaGetCtrl
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  return ( OcuReg->Ctrl );
}

/** \brief Ocu_RaGetIntrMask
 **
 ** Get IntrMask register value.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return IntrMask register value.
 **
 */
FUNC( uint32, OCU_CODE ) Ocu_RaGetIntrMask
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  return ( OcuReg->Intr_Mask );
}

/** \brief Ocu_RaGetTrOutSel
 **
 ** Get TrOutSel register value.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return TrOutSel register value.
 **
 */
FUNC( uint32, OCU_CODE ) Ocu_RaGetTrOutSel
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  return ( OcuReg->Tr_Out_Sel );
}

/** \brief Ocu_RaGetTrPwmCtrl
 **
 ** Get TrPwmCtrl register value.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return TrPwmCtrl register value.
 **
 */
FUNC( uint32, OCU_CODE ) Ocu_RaGetTrPwmCtrl
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  return ( OcuReg->Tr_Pwm_Ctrl );
}

/** \brief Ocu_RaGetStatusRunning
 **
 ** Get counter running status.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  TRUE:  Counter is running.
 **          FALSE: Counter is not running.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_RaGetStatusRunning
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  VAR( boolean, AUTOMATIC ) Result;

  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  /* Counter is running */
  if ( OCU_REG_MASK_TCPWM_STATUS_RUNNING == ( OcuReg->Status & OCU_REG_MASK_TCPWM_STATUS_RUNNING ) )
  {
    Result = TRUE;
  }
  /* Counter is not running */
  else
  {
    Result = FALSE;
  }

  return Result;
}

/** \brief Ocu_RaGetCC0
 **
 ** Get CC0 register value.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return CC0 register value.
 **
 */
FUNC( uint32, OCU_CODE ) Ocu_RaGetCC0
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 Rules 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
     However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) OcuReg =
     ( volatile P2VAR( Ocu_TcpwmRegType, OCU_CONST, REGSPACE ) )( BaseAddress );

  return ( OcuReg->Cc0 );
}

#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[internal function definitions]==========================*/

/*==================[end of file]============================================*/
