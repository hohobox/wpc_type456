/** \brief AUTOSAR Ocu Driver
 **
 ** This file contains the implementation of the AUTOSAR Ocu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Ocu.h>               /* Module public declaration */
#include <Ocu_Internal.h>      /* Module internal declaration */
#include <Ocu_Det.h>           /* Module DET declaration */
#include <SchM_Ocu.h>          /* SchM_Ocu declaration */

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/
#define OCU_START_SEC_CODE_ASIL_B
#include <Ocu_MemMap.h>

/** \brief Ocu_GetConfigPtr
 **
 ** Returns the pointer of the current configuration set.
 **
 ** \return Pointer of data stored current configuration set information.
 */
static FUNC_P2CONST( Ocu_ConfigType, OCU_APPL_CONST, OCU_CODE ) Ocu_GetConfigPtr( void );

#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>
/*==================[external data]==========================================*/

/*==================[external constants]=====================================*/

/*==================[internal data]==========================================*/
#define OCU_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** This data is pointer to actually used configuration set. */
static P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) Ocu_ConfigPtr = NULL_PTR;

#define OCU_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[internal constants]=====================================*/

/*==================[external function definitions]==========================*/

#define OCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** \brief Ocu_Init
 **
 ** Service for OCU initialization.
 **
 ** This function initializes all configured channels.
 ** Start all free-running counters.
 ** Notifications are disabled for all channels.
 ** Triggers are enabled or disabled for all channels by configuration.
 **
 ** Preconditions:
 ** - No Init call should be done before.
 **
 ** \param [in] ConfigPtr  Pointer to configuration set.
 **
 */
FUNC( void, OCU_CODE ) Ocu_Init
(
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigPtr
)
{
  /* Check config data pointer */
  if ( FALSE == Ocu_CheckConfigPtr( ConfigPtr ) )
  {
    Ocu_ReportError( OCU_E_INIT_FAILED, OCU_API_SERVICE_INIT );
  }
  /* Check if module is uninitialized */
  else if ( OCU_S_UNINITIALIZED != Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_ALREADY_INITIALIZED, OCU_API_SERVICE_INIT );
  }
  else
  {
    /* Keep the ConfigPtr which from the upper layer */
    Ocu_ConfigPtr = ConfigPtr;

    Ocu_Init_Internal( Ocu_ConfigPtr );

    /* Setting driver status : OCU_S_INITIALIZED */
    Ocu_SetDriverStatus( OCU_S_INITIALIZED );
  }
}

#if ( OCU_DEINIT_API == STD_ON )
/** \brief Ocu_DeInit
 **
 ** Service for OCU De-Initialization.
 **
 */
FUNC( void, OCU_CODE ) Ocu_DeInit( void )
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber;
  VAR( boolean, AUTOMATIC ) Result;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_DEINIT );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    /* Setting driver status : OCU_S_UNINITIALIZED */
    Ocu_SetDriverStatus( OCU_S_UNINITIALIZED );
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_DEINIT );
  }
  else
  {
    Result = FALSE;
    for ( ChannelNumber = 0U; ChannelNumber < ConfigDataPtr->NumberOfChannels; ChannelNumber++ )
    {
      ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

      /* When current channel status is running, break */
      if ( OCU_CH_RUNNING == ChannelConfigPtr->ChannelStatusPtr->ChannelState )
      {
        Result = TRUE;
        break;
      }
    }
    /* If a channel is still in the RUNNING state */
    if ( FALSE != Result )
    {
      Ocu_ReportError( OCU_E_PARAM_INVALID_STATE, OCU_API_SERVICE_DEINIT );
    }
    else
    {
      Ocu_EnterCriticalSection();

      Ocu_DeInit_Internal( ConfigDataPtr );
      
      /* To distinguish whether the driver was initialized or not, Ocu_ConfigPtr cannot be set to NULL_PTR. */
      
      /* Setting driver status : OCU_S_UNINITIALIZED */
      Ocu_SetDriverStatus( OCU_S_UNINITIALIZED );

      Ocu_ExitCriticalSection();
    }
  }
}
#endif /* ( OCU_DEINIT_API == STD_ON ) */

/** \brief Ocu_StartChannel
 **
 ** Service to start an OCU channel.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 **
 */
FUNC( void, OCU_CODE ) Ocu_StartChannel
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_START_CHANNEL );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_START_CHANNEL );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_START_CHANNEL );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check channel status */
    if ( OCU_CH_RUNNING == ChannelConfigPtr->ChannelStatusPtr->ChannelState )
    {
      Ocu_ReportError( OCU_E_BUSY, OCU_API_SERVICE_START_CHANNEL );
    }
    /* Check counter running status */
    else if ( FALSE == Ocu_GetStatusRunning( ChannelConfigPtr ) )
    {
      Ocu_ReportError( OCU_E_WAITING_TRIGGER, OCU_API_SERVICE_START_CHANNEL );
    }
    else
    {
      Ocu_StartChannel_Internal( ChannelConfigPtr );
    }
  }
}

/** \brief Ocu_StopChannel
 **
 ** Service to stop an OCU channel.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 **
 */
FUNC( void, OCU_CODE ) Ocu_StopChannel
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_STOP_CHANNEL );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_STOP_CHANNEL );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_STOP_CHANNEL );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check channel status */
    if ( OCU_CH_STOPPED == ChannelConfigPtr->ChannelStatusPtr->ChannelState )
    {
      /* If the channel in the state "STOPPED", then the function shall leave without any action. */
    }
    else
    {
      Ocu_StopChannel_Internal( ChannelConfigPtr );
    }
  }
}

#if ( OCU_SET_PIN_STATE_API == STD_ON )
/** \brief Ocu_SetPinState
 **
 ** Service to set immediately the level of the pin associated to an OCU channel.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 ** \param [in] PinState       Type of pin state:
 **                            OCU_LOW or
 **                            OCU_HIGH.
 **
 */
FUNC( void, OCU_CODE ) Ocu_SetPinState
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber,
  VAR( Ocu_PinStateType, AUTOMATIC ) PinState
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_PIN_STATE );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_PIN_STATE );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_SET_PIN_STATE );
  }
  /* Check pin state */
  else if ( ( OCU_HIGH != PinState ) && ( OCU_LOW != PinState ) )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_STATE, OCU_API_SERVICE_SET_PIN_STATE );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check pin association */
    if ( TRUE != ChannelConfigPtr->OuptutPinUsed )
    {
      Ocu_ReportError( OCU_E_PARAM_NO_PIN, OCU_API_SERVICE_SET_PIN_STATE );
    }
    /* Check channel status */
    else if ( OCU_CH_RUNNING == ChannelConfigPtr->ChannelStatusPtr->ChannelState )
    {
      Ocu_ReportError( OCU_E_PARAM_INVALID_STATE, OCU_API_SERVICE_SET_PIN_STATE );
    }
    /* Check counter running status */
    else if ( FALSE == Ocu_GetStatusRunning( ChannelConfigPtr ) )
    {
      Ocu_ReportError( OCU_E_WAITING_TRIGGER, OCU_API_SERVICE_SET_PIN_STATE );
    }
    else
    {
      Ocu_SetPinState_Internal( ChannelConfigPtr, PinState );
    }
  }
}
#endif /* ( OCU_SET_PIN_STATE_API == STD_ON ) */

#if ( OCU_SET_PIN_ACTION_API == STD_ON )
/** \brief Ocu_SetPinAction
 **
 ** Service to indicate the driver what shall be done automatically by hardware upon compare match.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 ** \param [in] PinAction      Type of pin action:
 **                            OCU_SET_LOW or
 **                            OCU_SET_HIGH or
 **                            OCU_TOGGLE or
 **                            OCU_DISABLE.
 **
 */
FUNC( void, OCU_CODE ) Ocu_SetPinAction
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber,
  VAR( Ocu_PinActionType, AUTOMATIC ) PinAction
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_PIN_ACTION );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_PIN_ACTION );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_SET_PIN_ACTION );
  }
  /* Check pin action */
  else if ( ( OCU_SET_HIGH != PinAction ) && ( OCU_SET_LOW != PinAction )
         && ( OCU_TOGGLE   != PinAction ) && ( OCU_DISABLE != PinAction ) )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_ACTION, OCU_API_SERVICE_SET_PIN_ACTION );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check pin association */
    if ( TRUE != ChannelConfigPtr->OuptutPinUsed )
    {
      Ocu_ReportError( OCU_E_PARAM_NO_PIN, OCU_API_SERVICE_SET_PIN_ACTION );
    }
    else
    {
      Ocu_SetPinAction_Internal( ChannelConfigPtr, PinAction );
    }
  }
}
#endif /* ( OCU_SET_PIN_ACTION_API == STD_ON ) */

#if ( OCU_GET_COUNTER_API == STD_ON )
/** \brief Ocu_GetCounter
 **
 ** Service to read the current value of the counter.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 **
 ** \return  Content of the counter in ticks.
 **
 */
FUNC( Ocu_ValueType, OCU_CODE ) Ocu_GetCounter
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber
)
{
  VAR( Ocu_ValueType, AUTOMATIC ) CurrentCounterValue = 0U;
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_GET_COUNTER );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_GET_COUNTER );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_GET_COUNTER );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    CurrentCounterValue = Ocu_GetCounter_Internal( ChannelConfigPtr );
  }

  return CurrentCounterValue;
}
#endif /* ( OCU_GET_COUNTER_API == STD_ON ) */

#if ( OCU_SET_ABSOLUTE_THRESHOLD_API == STD_ON )
/** \brief Ocu_SetAbsoluteThreshold
 **
 ** Service to set the value of the channel threshold using an absolute input data.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the OCU channel.
 ** \param [in] ReferenceValue  Value given by the upper layer and used as a base to determine whether to call
 **                             the notification before the function exits or not.
 ** \param [in] AbsoluteValue   Value to compare with the content of the counter. This value is in ticks.
 **
 ** \return  Return information after setting a new threshold value.
 **          OCU_CM_OUT_REF_INTERVAL: The compare match will not occur inside the current Reference Interval.
 **          OCU_CM_IN_REF_INTERVAL:  The compare match will occur inside the current Reference Interval.
 **
 */
FUNC( Ocu_ReturnType, OCU_CODE ) Ocu_SetAbsoluteThreshold
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber,
  VAR( Ocu_ValueType, AUTOMATIC ) ReferenceValue,
  VAR( Ocu_ValueType, AUTOMATIC ) AbsoluteValue
)
{
  VAR( Ocu_ReturnType, AUTOMATIC ) Result = OCU_CM_OUT_REF_INTERVAL;
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_ABSOLUTE_THRESHOLD );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_ABSOLUTE_THRESHOLD );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_SET_ABSOLUTE_THRESHOLD );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check reference Value */
    if ( ReferenceValue > ChannelConfigPtr->MaxCounterValue )
    {
      Ocu_ReportError( OCU_E_PARAM_REFERENCEVALUE, OCU_API_SERVICE_SET_ABSOLUTE_THRESHOLD );
    }
    /* Check absolute Value */
    else if ( AbsoluteValue > ChannelConfigPtr->MaxCounterValue )
    {
      Ocu_ReportError( OCU_E_PARAM_ABSOLUTETHRESHOLD, OCU_API_SERVICE_SET_ABSOLUTE_THRESHOLD );
    }
    /* Check counter running status */
    else if ( FALSE == Ocu_GetStatusRunning( ChannelConfigPtr ) )
    {
      Ocu_ReportError( OCU_E_WAITING_TRIGGER, OCU_API_SERVICE_SET_ABSOLUTE_THRESHOLD );
    }
    else
    {
      if ( FALSE == Ocu_SetAbsoluteThreshold_Internal( ChannelConfigPtr, ReferenceValue, AbsoluteValue ) )
      {
        Result = OCU_CM_OUT_REF_INTERVAL;
      }
      else
      {
        Result = OCU_CM_IN_REF_INTERVAL;
      }
    }
  }

  return Result;
}
#endif /* ( OCU_SET_ABSOLUTE_THRESHOLD_API == STD_ON ) */

#if ( OCU_SET_RELATIVE_THRESHOLD_API == STD_ON )
/** \brief Ocu_SetRelativeThreshold
 **
 ** Service to set the value of the channel threshold relative to the current value of the counter.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 ** \param [in] RelativeValue  Value to use for computing the new threshold.
 **
 ** \return  Return information after setting a new threshold value.
 **          OCU_CM_OUT_REF_INTERVAL: The compare match will not occur inside the current Reference Interval.
 **          OCU_CM_IN_REF_INTERVAL:  The compare match will occur inside the current Reference Interval.
 **
 */
FUNC( Ocu_ReturnType, OCU_CODE ) Ocu_SetRelativeThreshold
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber,
  VAR( Ocu_ValueType, AUTOMATIC ) RelativeValue
)
{
  VAR( Ocu_ReturnType, AUTOMATIC ) Result = OCU_CM_OUT_REF_INTERVAL;
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_RELATIVE_THRESHOLD );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_RELATIVE_THRESHOLD );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_SET_RELATIVE_THRESHOLD );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check relative Value */
    if ( RelativeValue > ChannelConfigPtr->MaxCounterValue )
    {
      Ocu_ReportError( OCU_E_PARAM_RELATIVETHRESHOLD, OCU_API_SERVICE_SET_RELATIVE_THRESHOLD );
    }
    /* Check counter running status */
    else if ( FALSE == Ocu_GetStatusRunning( ChannelConfigPtr ) )
    {
      Ocu_ReportError( OCU_E_WAITING_TRIGGER, OCU_API_SERVICE_SET_RELATIVE_THRESHOLD );
    }
    else
    {
      if ( FALSE == Ocu_SetRelativeThreshold_Internal( ChannelConfigPtr, RelativeValue ) )
      {
        Result = OCU_CM_OUT_REF_INTERVAL;
      }
      else
      {
        Result = OCU_CM_IN_REF_INTERVAL;
      }
    }
  }

  return Result;
}
#endif /* ( OCU_SET_RELATIVE_THRESHOLD_API == STD_ON ) */

#if ( OCU_NOTIFICATION_SUPPORTED == STD_ON )
/** \brief Ocu_DisableNotification
 **
 ** Service to disable notifications from an OCU channel.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 **
 */
FUNC( void, OCU_CODE ) Ocu_DisableNotification
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_DISABLE_NOTIFICATION );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_DISABLE_NOTIFICATION );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_DISABLE_NOTIFICATION );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check notification function */
    if ( NULL_PTR == ChannelConfigPtr->Notification )
    {
      Ocu_ReportError( OCU_E_NO_VALID_NOTIF, OCU_API_SERVICE_DISABLE_NOTIFICATION );
    }
    else
    {
      Ocu_DisableNotification_Internal( ChannelConfigPtr );
    }
  }
}

/** \brief Ocu_EnableNotification
 **
 ** Service to enable notifications from an OCU channel.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the OCU channel.
 **
 */
FUNC( void, OCU_CODE ) Ocu_EnableNotification
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_ENABLE_NOTIFICATION );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_ENABLE_NOTIFICATION );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_ENABLE_NOTIFICATION );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check notification function */
    if ( NULL_PTR == ChannelConfigPtr->Notification )
    {
      Ocu_ReportError( OCU_E_NO_VALID_NOTIF, OCU_API_SERVICE_ENABLE_NOTIFICATION );
    }
    else
    {
      Ocu_EnableNotification_Internal( ChannelConfigPtr );
    }
  }
}
#endif /* ( OCU_NOTIFICATION_SUPPORTED == STD_ON ) */

#if ( OCU_VERSION_INFO_API == STD_ON )
/** \brief Ocu_GetVersionInfo
 **
 ** Service to return the version information of this module.
 **
 ** \param [out] versioninfo  Pointer to where to store the version information of this module.
 **
 */
FUNC( void, OCU_CODE ) Ocu_GetVersionInfo
(
  P2VAR( Std_VersionInfoType, AUTOMATIC, OCU_APPL_DATA ) versioninfo
)
{
  /* NULL pointer check */
  if ( NULL_PTR == versioninfo )
  {
    Ocu_ReportError( OCU_E_PARAM_POINTER, OCU_API_SERVICE_GET_VERSION_INFO );
  }
  else
  {
    versioninfo->vendorID = OCU_VENDOR_ID;
    versioninfo->moduleID = OCU_MODULE_ID;
    versioninfo->sw_major_version = OCU_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = OCU_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = OCU_SW_PATCH_VERSION;
  }
}
#endif /* ( OCU_VERSION_INFO_API == STD_ON ) */

#if ( OCU_SAFETY_FUNCTION_API == STD_ON )
/** \brief Ocu_CheckChannelStatus
 **
 ** Service to check the current status of the channel.
 **
 ** \param [out] DriverStatusPtr   Pointer to where to store the driver status information.
 ** \param [out] ChannelStatusPtr  Pointer to where to store the channel status information.
 ** \param [in]  ChannelNumber     Numeric identifier of the OCU channel.
 **
 ** \return  E_OK: No error has been detected.
 **          E_NOT_OK: Aborted due to errors.
 **
 */
FUNC( Std_ReturnType, OCU_CODE ) Ocu_CheckChannelStatus
(
  P2VAR( Ocu_DriverStatusType, AUTOMATIC, OCU_APPL_DATA ) DriverStatusPtr,
  P2VAR( Ocu_ChannelStatusType, AUTOMATIC, OCU_APPL_DATA ) ChannelStatusPtr,
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber
)
{
  VAR( Std_ReturnType, AUTOMATIC ) CheckResult = E_NOT_OK;
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* NULL Pointer check */
  if ( ( NULL_PTR == DriverStatusPtr ) || ( NULL_PTR == ChannelStatusPtr ) )
  {
    Ocu_ReportError( OCU_E_PARAM_POINTER, OCU_API_SERVICE_CHECK_CHANNEL_STATUS );
  }
  else
  {
    /* Set driver status */
    *DriverStatusPtr = Ocu_GetDriverStatus();

    /* Check configuration status and driver status */
    if ( ( OCU_S_INITIALIZED != ( *DriverStatusPtr ) ) && ( NULL_PTR == ConfigDataPtr ) )
    {
      /* Nothing is checked when not initialized after reset */
      CheckResult = E_OK;
    }
    /* Check config data pointer */
    else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
    {
      Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_CHECK_CHANNEL_STATUS );
    }
    /* Check channel number */
    else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
    {
      Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_CHECK_CHANNEL_STATUS );
    }
    else
    {
      /* Get config pointer for specified channel */
      ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

      /* Check channel status information */
      if ( TRUE == Ocu_CheckChannelStatus_Internal( ChannelConfigPtr, ChannelStatusPtr ) )
      {
        CheckResult = E_OK;
      }
    }
  }

  return CheckResult;
}
#endif /* ( OCU_SAFETY_FUNCTION_API == STD_ON ) */

#if ( OCU_SET_PRESCALER_API == STD_ON )
/** \brief Ocu_SetPrescaler
 **
 ** The API changes a pre-scaling value of the selected channel by the specified input clock source frequency for
 ** timer HW (TCPWM).
 **
 ** \param [in] ChannelNumber   Numeric identifier of the OCU channel.
 ** \param [in] ClockFrequency  Input clock frequency.
 **
 */
FUNC( void, OCU_CODE ) Ocu_SetPrescaler
(
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber,
  VAR( Ocu_ClkFrequencyType, AUTOMATIC ) ClockFrequency
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;

  /* Check driver status */
  if ( OCU_S_UNINITIALIZED == Ocu_GetDriverStatus() )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_PRESCALER );
  }
  /* Check config data pointer */
  else if ( FALSE == Ocu_CheckConfigPtr( ConfigDataPtr ) )
  {
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_SET_PRESCALER );
  }
  /* Check channel number */
  else if ( ChannelNumber >= ConfigDataPtr->NumberOfChannels )
  {
    Ocu_ReportError( OCU_E_PARAM_INVALID_CHANNEL, OCU_API_SERVICE_SET_PRESCALER );
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

    /* Check channel status */
    if ( OCU_CH_RUNNING == ChannelConfigPtr->ChannelStatusPtr->ChannelState )
    {
      Ocu_ReportError( OCU_E_BUSY, OCU_API_SERVICE_SET_PRESCALER );
    }
    /* Check counter running status */
    else if ( FALSE == Ocu_GetStatusRunning( ChannelConfigPtr ) )
    {
      Ocu_ReportError( OCU_E_WAITING_TRIGGER, OCU_API_SERVICE_SET_PRESCALER );
    }
    else
    {
      if ( FALSE == Ocu_SetPrescaler_Internal( ChannelConfigPtr, ClockFrequency ) )
      {
        Ocu_ReportError( OCU_E_PARAM_INVALID_CLOCK, OCU_API_SERVICE_SET_PRESCALER );
      }
    }
  }
}
#endif /* ( OCU_SET_PRESCALER_API == STD_ON ) */

/** \brief Ocu_EnterCriticalSection
 **
 ** Enter critical section.
 **
 */
FUNC( void, OCU_CODE ) Ocu_EnterCriticalSection( void )
{
  SchM_Enter_Ocu_OCU_EXCLUSIVE_AREA_0();
}

/** \brief Ocu_ExitCriticalSection
 **
 ** Exit critical section.
 **
 */
FUNC( void, OCU_CODE ) Ocu_ExitCriticalSection( void )
{
  SchM_Exit_Ocu_OCU_EXCLUSIVE_AREA_0();
}

/** \brief Ocu_InterruptHandler
 **
 ** Handles channel interrupt. This function is called only within the ISR.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 ** \param [in] ResIndex     Hardware resource index.
 **
 */
FUNC( void, OCU_CODE ) Ocu_InterruptHandler
(
  CONST( uint32, AUTOMATIC ) BaseAddress,
  VAR( Ocu_ChannelType, AUTOMATIC ) ResIndex
)
{
  /* Get global config pointer */
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigDataPtr = Ocu_GetConfigPtr();
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber;
  /* Get configuration data */
  VAR(boolean, AUTOMATIC) ConfigState = Ocu_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration data and driver status */
  if ( ( OCU_S_INITIALIZED != Ocu_GetDriverStatus() ) || ( FALSE == ConfigState ) )
  {
    /* Clear the interrupt flag */
    Ocu_ClearChannelInterruptByBaseAddr( BaseAddress );
    Ocu_ReportError( OCU_E_UNINIT, OCU_API_SERVICE_INTERRUPT_HANDLER );
  }
  else
  {
    /* Get channel identifier */
    ChannelNumber = ConfigDataPtr->HwResourceChannelPtr[ResIndex];

    if ( ChannelNumber < ConfigDataPtr->NumberOfChannels )
    {
      /* Get config pointer for specified channel */
      ChannelConfigPtr = &( ConfigDataPtr->ChannelCfgPtr[ChannelNumber] );

      Ocu_InterruptHandler_Internal( ChannelConfigPtr );
    }
    else
    {
      /* Clear the interrupt flag */
      Ocu_ClearChannelInterruptByBaseAddr( BaseAddress );
    }
  }
}

#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[internal function definitions]==========================*/
#define OCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** \brief Ocu_GetConfigPtr
 **
 ** Returns the pointer of the current configuration set.
 **
 ** \return  Pointer of data stored current configuration set information.
 */
static FUNC_P2CONST( Ocu_ConfigType, OCU_APPL_CONST, OCU_CODE ) Ocu_GetConfigPtr( void )
{
  return ( Ocu_ConfigPtr );
}

#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>
/*==================[end of file]============================================*/
