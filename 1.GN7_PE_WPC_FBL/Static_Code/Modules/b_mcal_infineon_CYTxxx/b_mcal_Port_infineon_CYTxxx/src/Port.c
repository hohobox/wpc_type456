/** \brief AUTOSAR Port Port Driver
 **
 ** This file contains the implementation of the
 ** AUTOSAR module Port.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Port.h>                 /* PORT driver types */
#if (PORT_DEV_ERROR_DETECT == STD_ON)
#include <Det.h>                  /* DET moudle type */
#endif  /* (PORT_DEV_ERROR_DETECT == STD_ON) */
#include <Port_Det.h>             /* PORT driver defines for development error handling */
#include <SchM_Port.h>            /* SchM module types */
#include <Port_SchM.h>            /* interface types for critical section types */
#include <Port_Internal_Arch.h>   /* interface header for Internal_Arch Unit */
#include <Port_CheckParameter.h>  /* interface header for error check function depend on hardware */
#include <Port_Regs.h>            /* interface header for Regs Unit */

/*==================[macros]=================================================*/

/*------------------[AUTOSAR AR version number check]------------------------*/
#if !PORT_AR_VERSION_CHECK(4U, 2U, 2U)
#error AUTOSAR AR version number mismatch
#endif
/*------------------[AUTOSAR SW version number check]------------------------*/
#if !PORT_SW_VERSION_CHECK(1U, 18U, PORT_GEN_SW_PATCH_VERSION)
#error AUTOSAR SW version number mismatch
#endif

/*==================[type definitions]=======================================*/
/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/
#define PORT_START_SEC_CODE_ASIL_B
#include <Port_MemMap.h>

/** \brief Port_InitTriggerComponent() Initialization of Trigger Component
 **
 ** This function initialize Trigger Component with configuration set.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** */
static FUNC(void,PORT_CODE) Port_InitTriggerComponent
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr
);

#define PORT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
#define PORT_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/** This data is pointer to actually used configuration set */
static P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST) Port_ConfigDataPtr = NULL_PTR;

#define PORT_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

#define PORT_START_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/* This data is enviroments data of Port driver. */
static CONST(Port_DriverEnvType,PORT_CONST) Port_Driver_Env =
{
  &Port_Config[0],                                                             /* table pointer of port config set */
  {
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access.*/
    /* PRQA S 303 1 */
    (volatile Port_HsiomPrtRegisterType *) PORT_HSIOM_PRT0_ADDR,                /* HSIOM_PRT0 base address */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access.*/
    /* PRQA S 303 1 */
    (volatile Port_HsiomAmuxSplitCtlRegisterType *) PORT_AMUX_SPLIT_CTL0_ADDR,  /* AMUX_SPLIT_CTL0 base address */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access.*/
    /* PRQA S 303 1 */
    (volatile Port_GpioPrtRegisterType *) PORT_GPIO_PRT0_ADDR,                  /* GPIO_PRT0 base address */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access.*/
    /* PRQA S 303 1 */
    (volatile Port_SmartioPrtRegisterType *) PORT_SMARTIO_PRT0_ADDR,            /* SMARTIO_PRT base address */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access.*/
    /* PRQA S 303 1 */
    (volatile uint32 *) PORT_PERI_TR_CMD_ADDR,                                  /* TR_CMD base address */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access.*/
    /* PRQA S 303 1 */
    (volatile Port_PeriTrGroupRegisterType *) PORT_PERI_TR_GROUP0_ADDR,         /* TR_GROUP base address */
  },
  (uint8)PORT_PIN_NUMBER_OF_AMUX_SPLIT_CELLS,                                   /* Number of AMUX splitter cell */
  (uint8)PORT_PIN_NUMBER_OF_CONFIGSETS,                                         /* Number of port pin config sets */
  (uint8)PORT_PIN_NUMBER_OF_PORTS                                               /* Port Number (check configuration) */
};

/* This data store Trigger Component Information. */
/* Deviation from MISRA-C:2012 Rule-8.9
   Justification: In AUTOSAR specification, it is a necessary process to 
   apply AUTOSAR MemMap mechanism. */
/* PRQA S 3218 1 */
static CONST(Port_TriggerComponentType, PORT_CONST) Port_TriggerComponent = PORT_TRIGGER_COMPONENT;

#define PORT_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*==================[external function definitions]==========================*/
#define PORT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*------------------[Port_Init]----------------------------------------------*/
/** \brief Port_Init() Initialization of all Ports
 **
 ** This function initialize all ports with configuration set in paramter \p ConfigPtr.
 **
 ** \pre \p ConfigPtr shall be a valid pointer
 ** \pre \p ConfigPtr shall point to a configuration set
 ** \pre function is not re-entrant
 **
 ** \param[in]  ConfigPtr Pointer to start address of configuration set */
FUNC(void,PORT_CODE) Port_Init
(
  P2CONST(Port_ConfigType, AUTOMATIC, PORT_APPL_CONST) ConfigPtr
)
{
  /* (DET) Check ConfigPtr parameter */
  if ( Port_Arch_CheckConfigPtr(ConfigPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_INIT,PORT_E_INIT_FAILED);
  }
  /* (DET) Check number of port in configuration */
  else if ( ConfigPtr->numberOfPorts > Port_Driver_Env.numberOfPorts )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_INIT,PORT_E_INIT_FAILED);
  }
  /* Not Error */
  else
  {
    /* Init I/O Port Register */
    Port_Arch_Init(ConfigPtr, &Port_Driver_Env);
    
    /* Init Trigger Component */
    Port_InitTriggerComponent(ConfigPtr, &Port_Driver_Env);
    
    /* Making configuration accessible to other port functions */
    Port_ConfigDataPtr = ConfigPtr;
  }
}

/*------------------[Port_GetVersionInfo]------------------------------------*/
/** \brief Port_GetVersionInfo() Get Version Information
 **
 ** Return the version of the Port driver in a Std_VersionInfoType structure.
 ** \param[out] versioninfo Port driver module's version
 **
 ** \return the version of the Port driver in a Std_VersionInfoType structure.
 ** */
#if (PORT_VERSION_INFO_API == STD_ON)
FUNC(void, PORT_CODE) Port_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, PORT_APPL_DATA) versioninfo
)
{
  /* (DET) Check versioninfo parameter */
  if ( versioninfo == NULL_PTR )
  {
    /* Report Development Error */
    Port_ReportDetError( PORT_API_GET_VERSION_INFO, PORT_E_PARAM_POINTER);
  }
  /* Not Error */
  else
  {
    /* Store version information to versioninfo pointer */
    versioninfo->vendorID         = PORT_VENDOR_ID;
    versioninfo->moduleID         = PORT_MODULE_ID;
    versioninfo->sw_major_version = PORT_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = PORT_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = PORT_SW_PATCH_VERSION;
  }
}
#endif /* PORT_VERSION_INFO_API == STD_ON */

/*------------------[Port_RefreshPortDirection]------------------------------*/
/** \brief Port_RefreshPortDirection() Refreshs the Port direction
 **
 ** This function refresh the direction of all ports that are configured as
 ** direction not changeable during runtime.
 **
 ** \pre ports must be initialized before
 ** \pre function is not re-entrant */
FUNC(void,PORT_CODE) Port_RefreshPortDirection
(
  void
)
{
  /* (DET) Check already initialization */
  if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_REFRESH_PORT_DIRECTION,PORT_E_UNINIT);
  }
  /* Not Error */
  else
  {
    /* refresh direction of all port */
    Port_Arch_RefreshPortDirection(Port_ConfigDataPtr, &Port_Driver_Env);
  }
}


/*------------------[Port_SetPinDirection]-----------------------------------*/
/** \brief Port_SetPinDirection() Set port pin direction
 **
 ** This function sets the direction of port pin \p Pin to the new
 ** direction of parameter \p Direction.
 **
 ** \pre ports must be initialized before
 ** \pre \p Pin shall be a valid port pin
 ** \pre \p Direction must be changeable for \p Pin
 ** \pre function is re-entrant
 **
 ** \param[in]  Pin         The ID of port pin
 ** \param[in]  Direction   The direction to be set for port pin */
#if (PORT_SET_PIN_DIRECTION_API == STD_ON)
FUNC(void,PORT_CODE) Port_SetPinDirection
(
  Port_PinType          Pin,
  Port_PinDirectionType Direction
)
{
  uint8 PortID = (uint8)(Pin >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 PinID  = (uint8)(Pin & PORT_PIN_MASK);       /* Gets pin ID. */
  
  /* (DET) Check already initialization */
  if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_DIRECTION,PORT_E_UNINIT);
  }
  /* (DET) Check Pin parameter (range of Port number) */
  else if ( (uint8)PortID >= Port_ConfigDataPtr->numberOfPorts )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_DIRECTION, PORT_E_PARAM_PIN);
  }
  /* (DET) Check Pin parameter (available of PortPin) */
  else if ( (Port_ConfigDataPtr->configChannelPtr[PortID].availablePins
             & ((uint32)1U << PinID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_DIRECTION, PORT_E_PARAM_PIN);
  }
  /* (DET) Check Direction parameter */
  else if ( (Direction != PORT_PIN_IN) && (Direction != PORT_PIN_OUT) && (Direction != PORT_PIN_IN_OUT_DISABLED) )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_DIRECTION, PORT_E_PARAM_INVALID_DIRECTION);
  }
  /* (DET) Check direction changeable for paramter:Pin */
  else if ( (Port_ConfigDataPtr->configChannelPtr[PortID].directionChangeable
              & ((uint32)0xFU << (PinID * 4U))) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_DIRECTION, PORT_E_DIRECTION_UNCHANGEABLE);
  }
  /* Not Error */
  else
  {
    /* set the pin direction */
    Port_Arch_SetPinDirection(Port_ConfigDataPtr, &Port_Driver_Env, Pin, Direction);
  }
}
#endif /* PORT_SET_PIN_DIRECTION_API == STD_ON */

/*------------------[Port_SetPinMode]----------------------------------------*/
/** \brief Port_SetPinMode() Set port pin mode
 **
 ** This function sets the new mode of parameter \p Mode to the mode of port
 ** pin \p Pin. The modes available in the configuration are grouped because 
 ** a runtime check whether the pin supports the special mode can not be 
 ** performed. Therefore the user is responsible to call this function as 
 ** described in the users guide and with the mode group value provided 
 ** in Port_Cfg_Der.h. E.g. PORT_PIN_MODE_POOO_GPIO_0, PORT_PIN_MODE_P001_ALT1,
 ** ... or anything else conform to the HW manual.
 **
 ** \pre ports must be initialized before
 ** \pre \p Pin   shall be a valid port pin
 ** \pre \p Mode  shall be a valid mode
 ** \pre function is re-entrant
 **
 ** \param[in]  Pin         The ID of port pin
 ** \param[in]  Mode        The new mode of the pin */
#if (PORT_SET_PIN_MODE_API == STD_ON)
FUNC(void,PORT_CODE) Port_SetPinMode
(
  Port_PinType     Pin,
  Port_PinModeType Mode
)
{
  uint8 PortID = (uint8)(Pin >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 PinID  = (uint8)(Pin & PORT_PIN_MASK);       /* Gets pin ID. */
  
  /* (DET) Check already initialization */
  if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_MODE, PORT_E_UNINIT);
  }
  /* (DET) Check Pin parameter (range of port number) */
  else if ( PortID >= Port_ConfigDataPtr->numberOfPorts )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_MODE, PORT_E_PARAM_PIN);
  }
  /* (DET) Check Pin parameter (abailable of PortPin) */
  else if ( (Port_ConfigDataPtr->configChannelPtr[PortID].availablePins
           & ((uint32)1U << PinID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_MODE, PORT_E_PARAM_PIN);
  }
  /* (DET) Check mode changeable for paramter:Pin */
  else if ( (Port_ConfigDataPtr->configChannelPtr[PortID].modeChangeable
           & ((uint32)1U << PinID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_MODE, PORT_E_MODE_UNCHANGEABLE);
  }
  /* (DET) Check Mode parameter (range of Mode) */
  else if ( Port_Der_IsPortModeValid(Pin, Mode) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_PIN_MODE, PORT_E_PARAM_INVALID_MODE);
  }
  /* Not Error */
  else
  {
    /* set the pin mode */
    Port_Arch_SetPinMode(Port_ConfigDataPtr, &Port_Driver_Env, Pin, Mode);
  }
}
#endif /* PORT_SET_PIN_MODE_API == STD_ON */

/*------------------[Port_GetStatus]-----------------------------------*/
/** \brief Port_GetStatus() Get port pin status
 **
 ** This function gets the status of port pin.
 **
 ** \pre \p PortStatusInfoPtr is not equal to zero
 ** \pre ports must be initialized before
 ** \pre \p Pin shall be a valid port pin
 ** \pre function is re-entrant
 **
 ** \param[in]   Pin               The ID of port pin
 ** \param[out]  PortStatusInfoPtr The pointer of data stored the status of the port pin
 ** \return the status of the port pin in a Port_StatusType structure. */
#if (PORT_SAFETY_FUNCTION_API == STD_ON)
FUNC(void,PORT_CODE) Port_GetStatus
(
  Port_PinType     Pin,
  P2VAR(Port_StatusType, AUTOMATIC,PORT_APPL_DATA) PortStatusInfoPtr
)
{
  boolean result;
  uint8 PortID = (uint8)(Pin >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 PinID  = (uint8)(Pin & PORT_PIN_MASK);       /* Gets pin ID. */

  /* (DET) Check PortStatusInfoPtr parameter */
  if ( PortStatusInfoPtr == NULL_PTR )
  {
    /* Report Development Error */
    Port_ReportDetError( PORT_API_GET_STATUS, PORT_E_PARAM_POINTER);
  }
  /* (DET) Check already initialization */
  else if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS, PORT_E_UNINIT);
  }
  /* (DET) Check Pin parameter (range of Port number) */
  else if ( (uint8)PortID >= Port_ConfigDataPtr->numberOfPorts )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS, PORT_E_PARAM_PIN);
  }
  /* (DET) Check Pin parameter (abailable of PortPin) */
  else if ( (Port_ConfigDataPtr->configChannelPtr[PortID].availablePins
           & ((uint32)1U << PinID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS, PORT_E_PARAM_PIN);
  }
  /* Not Error */
  else
  {
    /* Calls the internal processing of GetStatus */
    result = Port_Arch_GetPinStatus(Port_ConfigDataPtr, &Port_Driver_Env, Pin, PortStatusInfoPtr);
    /* Check Pim mode */
    if (Port_Der_IsPortModeValid(Pin, (Port_PinModeType)PortStatusInfoPtr->mode) == (boolean)PORT_FALSE)
    {
      /* Set the error state for the mode */
      result = (boolean)PORT_FALSE;
      PortStatusInfoPtr->mode = (uint8)PORT_PIN_STATUS_FAILURE;
    }
    if( result == (boolean)PORT_FALSE )
    {
      /* Report Development Error */
      Port_ReportDetError(PORT_API_GET_STATUS, PORT_E_REGISTER);
    }
  }
}

/*------------------[Port_GetAmuxSplitCtlStatus]------------------------------*/
/** \brief Port_GetAmuxSplitCtlStatus() Get AMUX cell status
 **
 ** This function gets the status of AMUX cell.
 **
 ** \pre \p AmuxSplitCtlStatusInfoPtr is not equal to zero
 ** \pre ports must be initialized before
 ** \pre \p Cell shall be a valid cell
 ** \pre function is re-entrant
 **
 ** \param[in]   Cell                       The id of AMUX splitter cell
 ** \param[out]  AmuxSplitCtlStatusInfoPtr  Pointer to where to store the AMUX splitter cell control status information
 ** \return the status of the port pin in a Port_AmuxSplitCtlStatusType structure. */
FUNC(void,PORT_CODE) Port_GetAmuxSplitCtlStatus
(
  Port_AmuxCellType     Cell,
  P2VAR(Port_AmuxSplitCtlStatusType, AUTOMATIC,PORT_APPL_DATA) AmuxSplitCtlStatusInfoPtr
)
{
  /* (DET) Check AmuxSplitCtlStatusInfoPtr parameter */
  if ( AmuxSplitCtlStatusInfoPtr == NULL_PTR )
  {
    /* Report Development Error */
    Port_ReportDetError( PORT_API_GET_AMUX_CTL_STATUS, PORT_E_PARAM_POINTER);
  }
  /* (DET) Check already initialization */
  else if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_AMUX_CTL_STATUS, PORT_E_UNINIT);
  }
  /* (DET) Check Cell parameter (range of cell number) */
  else if ( (uint8)Cell >= Port_ConfigDataPtr->numberOfAmuxSplitCtl )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_AMUX_CTL_STATUS, PORT_E_PARAM_CELL);
  }
  /* Not Error */
  else
  {
    /* Calls the internal processing of GetAmuxSplitCtlStatus */
    (void) Port_Arch_GetAmuxSplitCtlStatus(Port_ConfigDataPtr, &Port_Driver_Env, Cell, AmuxSplitCtlStatusInfoPtr);
  }
}
#endif /* PORT_SAFETY_FUNCTION_API == STD_ON */

/*------------------[Port_SetToDioMode]-----------------------------------*/
/** \brief Port_SetToDioMode() Set DIO mode
 **
 ** This function sets mode from the configured mode to DIO mode
 **
 ** \pre ports must be initialized before
 ** \pre \p PortId   shall be a valid port pin
 ** \pre function is re-entrant
 **
 ** \param[in]   PortId         The id of port pin */
#if (PORT_SET_DIO_ALTERNATE_MODE_API == STD_ON)
FUNC(void,PORT_CODE) Port_SetToDioMode
(
  Port_PinType      PortId
)
{
  uint8 Port_ID = (uint8)(PortId >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 Pin_ID  = (uint8)(PortId & PORT_PIN_MASK);       /* Gets pin ID. */
  
  /* (DET) Check already initialization */
  if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_DIO_MODE, PORT_E_UNINIT);
  }
  /* (DET) Check PortId parameter (range of port number) */
  else if ( Port_ID >= Port_ConfigDataPtr->numberOfPorts )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_DIO_MODE, PORT_E_PARAM_PIN);
  }
  /* (DET) Check PortId parameter (abailable of PortPin) */
  else if ( (Port_ConfigDataPtr->configChannelPtr[Port_ID].availablePins
           & ((uint32)1U << Pin_ID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_DIO_MODE, PORT_E_PARAM_PIN);
  }
  /* (DET) Check mode changeable for paramter:PortId */
  else if ( (Port_ConfigDataPtr->configChannelPtr[Port_ID].modeChangeable
           & ((uint32)1U << Pin_ID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_DIO_MODE, PORT_E_MODE_UNCHANGEABLE);
  }
  /* Not Error */
  else
  {
    /* Calls the internal processing of SetToDioMode */
    (void) Port_Arch_SetToDioMode(Port_ConfigDataPtr, &Port_Driver_Env, PortId);
  }
}

/*------------------[Port_SetToAlternateMode]---------------------------------*/
/** \brief Port_SetToAlternateMode() Set configured mode
 **
 ** This function sets mode from DIO mode to the configured mode
 **
 ** \pre ports must be initialized before
 ** \pre \p PortId   shall be a valid port pin
 ** \pre function is re-entrant
 **
 ** \param[in]   PortId         The id of port pin */
FUNC(void,PORT_CODE) Port_SetToAlternateMode
(
  Port_PinType      PortId
)
{
  uint8 Port_ID = (uint8)(PortId >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 Pin_ID  = (uint8)(PortId & PORT_PIN_MASK);       /* Gets pin ID. */
  
  /* (DET) Check already initialization */
  if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_ALTERNATE_MODE, PORT_E_UNINIT);
  }
  /* (DET) Check PortId parameter (range of port number) */
  else if ( Port_ID >= Port_ConfigDataPtr->numberOfPorts )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_ALTERNATE_MODE, PORT_E_PARAM_PIN);
  }
  /* (DET) Check PortId parameter (abailable of PortPin) */
  else if ( (Port_ConfigDataPtr->configChannelPtr[Port_ID].availablePins
           & ((uint32)1U << Pin_ID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_ALTERNATE_MODE, PORT_E_PARAM_PIN);
  }
  /* (DET) Check mode changeable for paramter:PortId */
  else if ( (Port_ConfigDataPtr->configChannelPtr[Port_ID].modeChangeable
           & ((uint32)1U << Pin_ID)) == (uint32)0U )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TO_ALTERNATE_MODE, PORT_E_MODE_UNCHANGEABLE);
  }
  /* Not Error */
  else
  {
    /* Calls the internal processing of SetToAlternateoMode */
    (void) Port_Arch_SetToAlternateMode(Port_ConfigDataPtr, &Port_Driver_Env, PortId);
  }
}
#endif /* PORT_SET_DIO_ALTERNATE_MODE_API == STD_ON */

/*------------------[Port_SetTrigger]----------------------------------------*/
/** \brief Port_SetTrigger() Set trigger
 **
 ** Sets the configuration for specified trigger.
 **
 ** \pre \p group_id shall be a valid trigger group ID
 ** \pre \p out_trg shall be a valid output trigger ID
 ** \pre \p in_trg shall be a valid input trigger ID
 ** \pre triggers must be initialized before
 ** \pre function is re-entrant
 **
 ** \param[in]  group_id        Trigger Group ID number
 ** \param[in]  out_trg         Output Trigger ID number
 ** \param[in]  in_trg          Input Trigger ID number
 ** \param[in]  inv_flg         Trigger Invert Flag
 ** \param[in]  sensitive_type  Trigger Sensitive Type
 ** \param[in]  dbg_freeze_flg  Debug Freeze Flag */
#if (PORT_SET_TRIGGER_API == STD_ON)
FUNC(void,PORT_CODE) Port_SetTrigger
(
  Port_TriggerGroupIdType     group_id,
  Port_TriggerIdType          out_trg,
  Port_TriggerIdType          in_trg,
  boolean                     inv_flg,
  Port_TriggerSensitiveType   sensitive_type,
  boolean                     dbg_freeze_flg
)
{
  /* (DET) Check already initialization */
  if ( Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE )
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_UNINIT);
  }
  /* Check Trigger group ID number */
  else if (Port_Der_IsTriggerGroupValid(group_id) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_PARAM_TR_GROUP);
  }
  /* Check Output trigger ID number */
  else if (Port_Der_IsOutputTriggerValid(group_id, out_trg) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_PARAM_TR_OUTPUT);
  }
  /* Check Input trigger ID number */
  else if (Port_Der_IsInputTriggerValid(group_id, in_trg) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_PARAM_TR_INPUT);
  }
  /* Check Trigger sensitive type */
  else if (sensitive_type > PORT_TR_SENSITIVE_EDGE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_PARAM_TR_SENSITIVE);
  }
  /* Check Trigger group have the trigger manipulation logic */
  else if (Port_Der_IsTriggerManipulationLogic(group_id, inv_flg, sensitive_type) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_TR_MANIPULATION_NOT_PRESENT);
  }
  else
  {
    /* Enter critical section to provide atomic access to the trigger registers */
    Port_EnterCriticalSection();

    /* Check trigger command status */
    if (Port_Arch_CheckTrCmdSet(&Port_Driver_Env, group_id) == (boolean)PORT_FALSE)
    {
      /* Report Development Error */
      Port_ReportDetError(PORT_API_SET_TRIGGER, PORT_E_TR_CMD_STATUS);
    }
    /* Not Error */
    else
    {
      /* Calls the internal processing of SetTrigger */
      (void) Port_Arch_SetTrigger(&Port_Driver_Env, group_id, out_trg, in_trg,
                                  inv_flg, sensitive_type, dbg_freeze_flg);
    }

    /* Exit critical section */
    Port_ExitCriticalSection();
  }
}
#endif /* PORT_SET_TRIGGER_API == STD_ON */

/*------------------[Port_ActTrigger]----------------------------------------*/
/** \brief Port_ActTrigger() Set trigger command to activate status
 **
 ** Activate the specified trigger.
 **
 ** \pre \p group_id shall be a valid trigger group ID
 ** \pre \p trg_id shall be a valid trigger ID
 ** \pre triggers must be initialized before
 ** \pre function is not re-entrant
 **
 ** \param[in]  group_id        Trigger Group ID number
 ** \param[in]  trg_id          Trigger ID number
 ** \param[in]  act_type        Trigger activation type
 ** \param[in]  sensitive_type  Trigger Sensitive Type
 ** \return the result of activation trigger. */
#if (PORT_TRIGGER_COMMAND_API == STD_ON)
FUNC(boolean,PORT_CODE) Port_ActTrigger
(
  Port_TriggerGroupIdType     group_id,
  Port_TriggerIdType          trg_id,
  Port_TriggerActivationType  act_type,
  Port_TriggerSensitiveType   sensitive_type
)
{
  boolean result = (boolean)PORT_FALSE;  /* set false to result */

  /* (DET) Check already initialization */
  if (Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_UNINIT);
  }
  /* Check Trigger group ID number */
  else if (Port_Der_IsTriggerGroupValid(group_id) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_PARAM_TR_GROUP);
  }
  /* Check Trigger activation type */
  else if ((group_id < PORT_MAX_TR_MUX_GROUP) && (act_type > PORT_TR_ACTIVATION_OUTPUT))
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_PARAM_TR_ACTIVATION);
  }
  /* Check Input trigger ID number */
  else if ((Port_Der_IsInputTriggerValid(group_id, trg_id) == (boolean)PORT_FALSE)
       && ((group_id < PORT_MAX_TR_MUX_GROUP) && (act_type == PORT_TR_ACTIVATION_INPUT)))
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_PARAM_TR_INPUT);
  }
  /* Check Output trigger ID number */
  else if ((Port_Der_IsOutputTriggerValid(group_id, trg_id) == (boolean)PORT_FALSE)
       && ((group_id >= PORT_MAX_TR_MUX_GROUP) || (act_type == PORT_TR_ACTIVATION_OUTPUT)))
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_PARAM_TR_OUTPUT);
  }
  /* Check Trigger sensitive type */
  else if (sensitive_type > PORT_TR_SENSITIVE_EDGE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_PARAM_TR_SENSITIVE);
  }
  else
  {
    /* Enter critical section to provide atomic access to the trigger registers */
    Port_EnterCriticalSection();

    /* Check trigger command status */
    if (Port_Arch_CheckTrCmdAct(&Port_Driver_Env) == (boolean)PORT_FALSE)
    {
      /* Report Development Error */
      Port_ReportDetError(PORT_API_ACT_TRIGGER, PORT_E_TR_CMD_STATUS);
    }
    /* Not Error */
    else
    {
      /* Calls the internal processing of ActTrigger */
      result = Port_Arch_ActTrigger(&Port_Driver_Env, group_id, trg_id, act_type, sensitive_type);
    }

    /* Exit critical section */
    Port_ExitCriticalSection();
  }

  return result;
}
#endif /* PORT_TRIGGER_COMMAND_API == STD_ON */

/*------------------[Port_DeactTrigger]--------------------------------------*/
/** \brief Port_DeactTrigger() Set trigger command to deactivate status
 **
 ** Deactivates the trigger activated by Port_ActTrigger.
 ** Modules that use the trigger command shall call the Port_DeactTrigger 
 ** function only if the trigger command is successfully activated with 
 ** the level sensitive.
 **
 ** \pre triggers must be initialized before
 ** \pre function is not re-entrant */
#if (PORT_TRIGGER_COMMAND_API == STD_ON)
FUNC(void,PORT_CODE) Port_DeactTrigger( void )
{
  /* (DET) Check already initialization */
  if (Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_DEACT_TRIGGER, PORT_E_UNINIT);
  }
  else
  {
    /* Enter critical section to provide atomic access to the trigger registers */
    Port_EnterCriticalSection();

    /* Check trigger command status */
    if (Port_Arch_CheckTrCmdDeact(&Port_Driver_Env) == (boolean)PORT_FALSE)
    {
      /* Report Development Error */
      Port_ReportDetError(PORT_API_DEACT_TRIGGER, PORT_E_TR_CMD_STATUS);
    }
    /* Not Error */
    else
    {
      /* Calls the internal processing of DeactTrigger */
      Port_Arch_DeactTrigger(&Port_Driver_Env);
    }

    /* Exit critical section */
    Port_ExitCriticalSection();
  }
}
#endif /* PORT_TRIGGER_COMMAND_API == STD_ON */

/*------------------[Port_GetTriggerIdStatus]--------------------------------*/
/** \brief Port_GetTriggerIdStatus() Get trigger group status
 **
 ** Gets the status of specified trigger.
 **
 ** \pre \p group_id shall be a valid trigger group ID
 ** \pre \p out_trg shall be a valid output trigger ID
 ** \pre \p TrigIdStatusInfoPtr is not equal to zero
 ** \pre triggers must be initialized before
 ** \pre function is re-entrant
 **
 ** \param[in]  group_id            Trigger Group ID number
 ** \param[in]  out_trg             Output Trigger ID number
 ** \param[out] TrigIdStatusInfoPtr Pointer to where to store the trigger status information */
#if (PORT_SAFETY_FUNCTION_API == STD_ON)
FUNC(void,PORT_CODE) Port_GetTriggerIdStatus
(
  Port_TriggerGroupIdType     group_id,
  Port_TriggerIdType          out_trg,
  P2VAR(Port_TriggerIdStatusType, AUTOMATIC,PORT_APPL_DATA) TrigIdStatusInfoPtr
)
{
  /* (DET) Check already initialization */
  if (Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS_TR_ID, PORT_E_UNINIT);
  }
  /* Check Trigger group ID number */
  else if (Port_Der_IsTriggerGroupValid(group_id) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS_TR_ID, PORT_E_PARAM_TR_GROUP);
  }
  /* Check Output trigger ID number */
  else if (Port_Der_IsOutputTriggerValid(group_id, out_trg) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS_TR_ID, PORT_E_PARAM_TR_OUTPUT);
  }
  /* Check NULL pointer */
  else if (TrigIdStatusInfoPtr == NULL_PTR)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS_TR_ID, PORT_E_PARAM_POINTER);
  }
  /* Not Error */
  else
  {
    /* Calls the internal processing of GetTriggerIdStatus */
    Port_Arch_GetTriggerIdStatus(&Port_Driver_Env, group_id, out_trg, TrigIdStatusInfoPtr);
  }
}
#endif /* PORT_SAFETY_FUNCTION_API == STD_ON */

/*------------------[Port_GetTriggerCmdStatus]-------------------------------*/
/** \brief Port_GetTriggerCmdStatus() Get trigger command status
 **
 ** Gets the status of trigger command.
 **
 ** \pre \p TrigCmdStatusInfoPtr is not equal to zero
 ** \pre triggers must be initialized before
 ** \pre function is re-entrant
 **
 ** \param[out] TrigCmdStatusInfoPtr    Pointer to where to store the trigger command status information */
#if (PORT_TRIGGER_COMMAND_API == STD_ON)
FUNC(void,PORT_CODE) Port_GetTriggerCmdStatus
(
  P2VAR(Port_TriggerCmdStatusType, AUTOMATIC,PORT_APPL_DATA) TrigCmdStatusInfoPtr
)
{
  /* (DET) Check already initialization */
  if (Port_Arch_CheckConfigPtr(Port_ConfigDataPtr, &Port_Driver_Env) == (boolean)PORT_FALSE)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS_TR_CMD, PORT_E_UNINIT);
  }
  /* Check NULL pointer */
  else if (TrigCmdStatusInfoPtr == NULL_PTR)
  {
    /* Report Development Error */
    Port_ReportDetError(PORT_API_GET_STATUS_TR_CMD, PORT_E_PARAM_POINTER);
  }
  /* Not Error */
  else
  {
    /* Calls the internal processing of GetTriggerCmdStatus */
    Port_Arch_GetTriggerCmdStatus(&Port_Driver_Env, TrigCmdStatusInfoPtr);
  }
}
#endif /* PORT_TRIGGER_COMMAND_API == STD_ON */

/*------------------[Port_EnterCritSec]--------------------------------------*/
/** \brief Port_EnterCriticalSection() enter critical section
 **
 ** This function enter critical section by calling SchM_Enter.
 **
 ** \pre exit critical section
 **
 ** \post enter critical section
 ** */
FUNC(void,PORT_CODE) Port_EnterCriticalSection
(
  void
)
{
  SchM_Enter_Port_PORT_EXCLUSIVE_AREA_0();
}

/*------------------[Port_ExitCritSec]---------------------------------------*/
/** \brief Port_ExitCriticalSection() exit critical section
 **
 ** This function exit critical section by calling SchM_Exit.
 **
 ** \pre enter critical section
 **
 ** \post exit critical section
 ** */
FUNC(void,PORT_CODE) Port_ExitCriticalSection
(
  void
)
{
  SchM_Exit_Port_PORT_EXCLUSIVE_AREA_0();
}

#define PORT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*==================[internal function definitions]==========================*/
#define PORT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*------------------[Port_InitTriggerComponent]------------------------------*/
/** \brief Port_InitTriggerComponent() Initialization of Trigger Component
 **
 ** This function initializes Trigger Component with configuration set.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** */
static FUNC(void,PORT_CODE) Port_InitTriggerComponent
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr
)
{
  uint32 index;                  /* index counter */
  uint8  count;                  /* counter for loop */
  uint8  group;                  /* counter for group */
  P2CONST(Port_TriggerConfigType, AUTOMATIC, PORT_CONST) triggerCfgPtr;
                                 /* trigger configuration pointer */
  /* Enter critical section to provide atomic access to the port registers */
  Port_EnterCriticalSection();
  
  /* First, Sets value to TR_CMD Register */
  Port_WriteTR_CMD(EnvDataPtr, PORT_TR_CMD_INIT_VALUE);
  
  /* Exit critical section */
  Port_ExitCriticalSection();
  
  /* loop for all trigger groups */
  index = 0U;
  triggerCfgPtr = (P2CONST(Port_TriggerConfigType, AUTOMATIC, PORT_CONST))ConfigDataPtr->configTriggerPtr;
  for ( group = 0U; group < PORT_TR_NUMBER_OF_ALL_GROUPS; group++ )
  {
    /* Enter critical section to provide atomic access to the port registers */
    Port_EnterCriticalSection();
    
    /* loop for all output triggers */
    for ( count = 0U; count < Port_TriggerComponent.trGroup[group].trOutNr; count++ )
    {
      /* Sets value to TR_CTL Register */
      Port_WriteTR_CTL(EnvDataPtr,
                       Port_TriggerComponent.trGroup[group].groupId,
                       Port_TriggerComponent.trCtlOutId[index],
                       (triggerCfgPtr)->TR_CTL_Data[index]);
      index++;
    }
    
    /* Exit critical section */
    Port_ExitCriticalSection();
  }
  /* Read-back to ensure that the register value has been changed before exit this function */
  /* Note that registers accessed by this function belong to a same IO group. */
  /* So read-back from one of the register can satify the synchronization. */
  (void)Port_ReadTR_CTL(EnvDataPtr, Port_TriggerComponent.trGroup[0].groupId, Port_TriggerComponent.trCtlOutId[0]);
}

#define PORT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*==================[end of file]============================================*/
