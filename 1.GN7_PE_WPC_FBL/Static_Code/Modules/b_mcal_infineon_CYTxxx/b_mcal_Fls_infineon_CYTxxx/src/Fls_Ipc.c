/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains the implementation of the AUTOSAR module Fls
 ** function Fls_Ipc.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Fls.h>                /* Fls Flash Driver header file */
#include <Fls_LibInterface.h>   /* Library interface header file */
#include <Fls_InternalLib.h>    /* Module internal API */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/** \brief Fls_IpcIntrMask
 **
 ** Sets mask of IPC interrupt structure used for eCT Flash safety mechanism.
 **
 ** \return    none
 **
 */
FUNC(void, FLS_CODE) Fls_IpcIntrMask(void)
{
#if ( FLS_USE_SAFETY_MECHANISM == STD_ON )
    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
       Justification: This cast is needed for doing pointer arithmetic. */
    /* PRQA S 488 4 */
    FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_IPC_INTERRUPT_STRUCTURE) = ( FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_IPC_INTERRUPT_STRUCTURE) &
                                                                       FLS_IPC_INTR_STRUCT_INTR_MASK_W_MASK(FLS_IPC_STRUCTURE) ) |
                                                                       FLS_IPC_INTR_STRUCT_INTR_MASK_ENABLE(FLS_IPC_STRUCTURE);
    FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_IPC_INTERRUPT_STRUCTURE);
#if ( FLS_SW_MAJOR_VERSION != 1U )
    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
       Justification: This cast is needed for doing pointer arithmetic. */
    /* PRQA S 488 4 */
    FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_IPC_INTERRUPT_STRUCTURE) = ( FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_IPC_INTERRUPT_STRUCTURE) &
                                                                       FLS_IPC_INTR_STRUCT_INTN_MASK_W_MASK(FLS_IPC_STRUCTURE) ) |
                                                                       FLS_IPC_INTR_STRUCT_INTN_MASK_ENABLE(FLS_IPC_STRUCTURE);
    FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_IPC_INTERRUPT_STRUCTURE);
#endif /* if( FLS_SW_MAJOR_VERSION != 1U ) */
#endif /* if( FLS_USE_SAFETY_MECHANISM == STD_ON ) */
    return;
}

/** \brief Fls_IpcLock
 **
 ** Acquires and locks IPC structure used for eCT Flash safety mechanism.
 **
 ** \return    result of locking
 ** \retval    FLS_TRUE     succeeded
 ** \retval    FLS_FALSE    failed
 **
 */
FUNC(uint8, FLS_CODE) Fls_IpcLock(void)
{
    uint8       Ret;    /* return value of main routine of flash driver engine */

    Ret = FLS_FALSE;
#if ( FLS_USE_SAFETY_MECHANISM == STD_ON )
    if( Fls_IpcLocked == FLS_FALSE )
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 1 */
        if( ( FLS_REG_IPC_STRUCT_ACQUIRE(FLS_IPC_STRUCTURE) & FLS_IPC_STRUCT_ACQUIRE_R_MASK ) == FLS_IPC_STRUCT_ACQUIRE_SUCCESS )
        {
            Fls_IpcLocked = FLS_TRUE;
            Ret = FLS_TRUE;
        }
    }
    else
    {
        Ret = FLS_TRUE;
    }
#endif /* if( FLS_USE_SAFETY_MECHANISM == STD_ON ) */
    return Ret;
}

/** \brief Fls_IpcRelease
 **
 ** Releases IPC structure used for eCT Flash safety mechanism.
 **
 ** \param[in]  NotifyKind  Notification for embedded flash
 ** \param[in]  BroadNotify Notification to all IPC (FLS_TRUE) or not (FLS_FALSE)
 **
 ** \return    none
 **
 */
FUNC(void, FLS_CODE) Fls_IpcRelease
(
    uint32 NotifyKind,
    uint8  BroadNotify
)
{
#if ( FLS_USE_SAFETY_MECHANISM == STD_ON )
    if( Fls_IpcLocked == FLS_TRUE )
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 2 */
        FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE) = NotifyKind;
        FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE);
        if( BroadNotify == FLS_FALSE )
        {
            /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
               Justification: This cast is needed for doing pointer arithmetic. */
            /* PRQA S 488,489 8 */
            FLS_REG_IPC_STRUCT_RELEASE(FLS_IPC_STRUCTURE) = ( FLS_REG_IPC_STRUCT_RELEASE(FLS_IPC_STRUCTURE) & FLS_IPC_STRUCT_RELEASE_W_MASK(FLS_IPC_INTERRUPT_STRUCTURE) ) |
                                                              FLS_IPC_STRUCT_RELEASE_VALUE(FLS_IPC_INTERRUPT_STRUCTURE);
        }
        else
        {
            FLS_REG_IPC_STRUCT_RELEASE(FLS_IPC_STRUCTURE) = FLS_IPC_ALL;
        }
        FLS_REG_IPC_STRUCT_RELEASE(FLS_IPC_STRUCTURE);
    }
    Fls_IpcLocked = FLS_FALSE;
#else
    (void)NotifyKind;
    (void)BroadNotify;
#endif /* if( FLS_USE_SAFETY_MECHANISM == STD_ON ) */
    return;
}

/** \brief Fls_IpcNotify
 **
 ** Notifies IPC structure used for eCT Flash safety mechanism.
 **
 ** \param[in]  Kind    Kind for notification
 **
 ** \return    none
 **
 */
FUNC(void, FLS_CODE) Fls_IpcNotify
(
    uint32 Kind
)
{
#if ( ( FLS_HSM_PRESENT == STD_ON ) || ( FLS_USE_SAFETY_MECHANISM == STD_ON ) )
    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
       Justification: This cast is needed for doing pointer arithmetic. */
    /* PRQA S 488 5 */
    FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE) = Kind;
    FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE);
    FLS_REG_IPC_STRUCT_NOTIFY(FLS_IPC_STRUCTURE) = ( FLS_REG_IPC_STRUCT_NOTIFY(FLS_IPC_STRUCTURE) & FLS_IPC_STRUCT_NOTIFY_W_MASK(FLS_IPC_INTERRUPT_STRUCTURE) ) |
                                                     FLS_IPC_STRUCT_NOTIFY_VALUE(FLS_IPC_INTERRUPT_STRUCTURE);
    FLS_REG_IPC_STRUCT_NOTIFY(FLS_IPC_STRUCTURE);
#else
    (void)Kind;
#endif /* if( FLS_HSM_PRESENT == STD_ON ) || ( FLS_USE_SAFETY_MECHANISM == STD_ON ) */
    return;
}

#if ( FLS_USE_SAFETY_MECHANISM == STD_ON )

/** \brief Fls_IpcListen
 **
 ** Listens IPC interrupt structure used for eCT Flash safety mechanism.
 **
 ** \return    none
 **
 */
FUNC(void, FLS_CODE) Fls_IpcListen(void)
{
    volatile FLS_ULONG counter;         /* counter of delay loop for locking */
    FLS_ULONG mask;                     /* mask for reading DATA0 register */

    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
       Justification: This cast is needed for doing pointer arithmetic. */
    /* PRQA S 488 1 */
    if( ( FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE) & FLS_IPC_INTR_STRUCT_INTR_R_MASK(FLS_IPC_STRUCTURE) ) == FLS_IPC_INTR_STRUCT_INTR_RELEASE(FLS_IPC_STRUCTURE) )
    {
        /* set mask for each core */
        mask = Fls_EmbeddedListenMask;
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 1 */
        if( ( FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE) & mask ) != 0UL )
        {
            counter = FLS_COUNT_MAX;
            /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
               Justification: This implementation is adopted for avoiding more nesting.
               It is no problem because side effects cannot be caused. */
            /* PRQA S 3415 1 */
            while( ( Fls_IpcLock() == FLS_FALSE ) && ( counter > 0UL ) )
            {
                counter--;
                Fls_WdgClear(); /* clear the watchdog timer */
            }
            if( Fls_IpcLocked == FLS_TRUE )
            {
                /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
                   Justification: This cast is needed for doing pointer arithmetic. */
                /* PRQA S 488 4 */
                Fls_IpcRelease( FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE) & ~mask, FLS_TRUE );
                FLS_WORK_EMBEDDED_NOTIFICATION();
                FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE) = FLS_IPC_INTR_STRUCT_INTR_CLEAR(FLS_IPC_STRUCTURE);
                FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE);
            }
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
               Justification: This cast is needed for doing pointer arithmetic. */
            /* PRQA S 488 4 */
            if( FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE) == FLS_EMBEDDED_NONE )
            {
                FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE) = FLS_IPC_INTR_STRUCT_INTR_CLEAR(FLS_IPC_STRUCTURE);
                FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE);
            }
        }
    }
#if ( FLS_SW_MAJOR_VERSION != 1U )
    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
       Justification: This cast is needed for doing pointer arithmetic. */
    /* PRQA S 488 8 */
    if( ( FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE) & FLS_IPC_INTR_STRUCT_INTN_R_MASK(FLS_IPC_STRUCTURE) ) == FLS_IPC_INTR_STRUCT_INTN_NOTIFY(FLS_IPC_STRUCTURE) )
    {
        if( FLS_REG_IPC_STRUCT_DATA0(FLS_IPC_STRUCTURE) == FLS_INVOKE_HSM_INVALIDATE_CACHE )
        {
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE ); /* invalidate cache and buffer */
        }
        FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE) = FLS_IPC_INTR_STRUCT_INTN_CLEAR(FLS_IPC_STRUCTURE);
        FLS_REG_IPC_INTR_STRUCT_INTR(FLS_IPC_INTERRUPT_STRUCTURE);
    }
#endif /* if( FLS_SW_MAJOR_VERSION != 1U ) */
    return;
}

#endif /* if( FLS_USE_SAFETY_MECHANISM == STD_ON ) */

#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
