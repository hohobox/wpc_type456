#if !defined( FLS_TYPESDERLIB_H )
#define FLS_TYPESDERLIB_H

/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains the type definitions of
 ** the AUTOSAR module Fls.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]==============================================*/

/*==================[macros]==================================================*/

/** \brief macro indicating maximum size as primitive type (compiler/page-dependent)
 ** It means maximum number of bytes to be read at once.
 */
#define FLS_MULTI_READ_SIZE     4

/** \brief flag for Fls_JobRequest.CurrentJob while wait for flash hardware stop */
#define FLS_WAIT_SECTOR_ERASE       (16)

  /* --- List of AUTOSAR API Ids ----------------------------------------- */

/** \brief Fls_Init() api service id */
#define FLS_ID_INIT                                         0x00U
/** \brief Fls_Erase() api service id */
#define FLS_ID_ERASE                                        0x01U
/** \brief Fls_Write() api service id */
#define FLS_ID_WRITE                                        0x02U
/** \brief Fls_Cancel() api service id */
#define FLS_ID_CANCEL                                       0x03U
/** \brief Fls_GetStatus() api service id */
#define FLS_ID_GETSTATUS                                    0x04U
/** \brief Fls_GetJobResult() api service id */
#define FLS_ID_GETJOBRESULT                                 0x05U
/** \brief Fls_MainFunction() api service id */
#define FLS_ID_MAINFUNCTION                                 0x06U
/** \brief Fls_Read() api service id */
#define FLS_ID_READ                                         0x07U
/** \brief Fls_Compare() api service id */
#define FLS_ID_COMPARE                                      0x08U
/** \brief Fls_SetMode() api service id */
#define FLS_ID_SETMODE                                      0x09U
/** \brief Fls_BlankCheck() api service id */
#define FLS_ID_BLANKCHECK                                   0x0AU
/** \brief Fls_GetVersionInfo() api service id */
#define FLS_ID_GETVERSIONINFO                               0x10U
/** \brief Fls_SetCycleMode() api service id */
#define FLS_ID_SETCYCLEMODE                                 0xFAU
/** \brief Fls_ReadImmediate() api service id */
#define FLS_ID_READIMMEDIATE                                0xFBU
/** \brief Fls_Suspend() api service id */
#define FLS_ID_SUSPEND                                      0xFCU
/** \brief Fls_Resume() api service id */
#define FLS_ID_RESUME                                       0xFDU

  /* --- List of development error codes --------------------------------- */

/** \brief FLS_E_PARAM_CONFIG error code */
#define FLS_E_PARAM_CONFIG                                  0x01U
/** \brief FLS_E_PARAM_ADDRESS error code */
#define FLS_E_PARAM_ADDRESS                                 0x02U
/** \brief FLS_E_PARAM_LENGTH error code */
#define FLS_E_PARAM_LENGTH                                  0x03U
/** \brief FLS_E_PARAM_DATA error code */
#define FLS_E_PARAM_DATA                                    0x04U
/** \brief FLS_E_UNINIT error code */
#define FLS_E_UNINIT                                        0x05U
/** \brief FLS_E_BUSY error code */
#define FLS_E_BUSY                                          0x06U
/** \brief FLS_E_VERIFY_ERASE_FAILED error code */
#define FLS_E_VERIFY_ERASE_FAILED                           0x07U
/** \brief FLS_E_VERIFY_WRITE_FAILED error code */
#define FLS_E_VERIFY_WRITE_FAILED                           0x08U
/** \brief FLS_E_TIMEOUT error code */
#define FLS_E_TIMEOUT                                       0x09U
/** \brief FLS_E_PARAM_POINTER error code */
#define FLS_E_PARAM_POINTER                                 0x0aU

  /* --- List of production error codes --------------------------------- */

/** \brief FLS_E_ERASE_FAILED_FOR_CALLOUT error code */
#define FLS_E_ERASE_FAILED_FOR_CALLOUT                      0x81U
/** \brief FLS_E_WRITE_FAILED_FOR_CALLOUT error code */
#define FLS_E_WRITE_FAILED_FOR_CALLOUT                      0x82U
/** \brief FLS_E_READ_FAILED_FOR_CALLOUT error code */
#define FLS_E_READ_FAILED_FOR_CALLOUT                       0x83U
/** \brief FLS_E_COMPARE_FAILED_FOR_CALLOUT error code */
#define FLS_E_COMPARE_FAILED_FOR_CALLOUT                    0x84U
/** \brief FLS_E_DED_FAILURE error code */
#define FLS_E_DED_FAILURE                                   0x85U
/** \brief FLS_E_SED_FAILURE error code */
#define FLS_E_SED_FAILURE                                   0x86U

  /* --- List of runtime error codes --------------------------------- */

/** \brief FLS_E_ERASE_FAILED error code */
#define FLS_E_ERASE_FAILED                                  0x01U
/** \brief FLS_E_WRITE_FAILED error code */
#define FLS_E_WRITE_FAILED                                  0x02U
/** \brief FLS_E_READ_FAILED error code */
#define FLS_E_READ_FAILED                                   0x03U
/** \brief FLS_E_COMPARE_FAILED error code */
#define FLS_E_COMPARE_FAILED                                0x04U

  /* --- List of event status codes --------------------------------- */

/** \brief type for Fls internal status */
#define FLS_EVENT_STATUS_PASSED (0x00U)  /* Fls internal status passed */
#define FLS_EVENT_STATUS_FAILED (0x01U)  /* Fls internal status failed */

  /* --- For VCAST --- */
#if defined( FLS_USE_VCAST )
#if defined( CONST )
#undef CONST
#define CONST(consttype, memclass) memclass consttype
#endif
#if defined( P2CONST )
#undef P2CONST
#define P2CONST(ptrtype, memclass, ptrclass) ptrtype ptrclass * memclass
#endif
#if defined( CONSTP2CONST )
#undef CONSTP2CONST
#define CONSTP2CONST(ptrtype, memclass, ptrclass) ptrclass ptrtype * memclass
#endif
#endif /* if defined( FLS_USE_VCAST ) */

/*==================[type definitions]========================================*/

/** \brief Fls_JobType
 ** Type of job performed on next mainfunction call
 */
typedef enum fls_jobtype
{
    FLS_COMPARE           = 1,   /* compare job pending */
    FLS_ERASE             = 2,   /* erase job pending */
    FLS_ERASE_VERIFY      = 3,   /* verify in erase job */
    FLS_READ              = 4,   /* read job pending */
    FLS_WRITE             = 5,   /* write job pending */
    FLS_WRITE_VERIFY      = 6,   /* post verify in write job */
    FLS_WRITE_PREVER      = 7,   /* previous verify in write job */
    FLS_IDLE              = 8,   /* no job pending */
    FLS_BLANKCHECK        = 9,   /* blank check job pending */
    /* from here, status waiting for flash hardware stop */
    FLS_COMPARE_WAIT      = (FLS_COMPARE      + FLS_WAIT_SECTOR_ERASE),
    FLS_ERASE_WAIT        = (FLS_ERASE        + FLS_WAIT_SECTOR_ERASE),
    FLS_READ_WAIT         = (FLS_READ         + FLS_WAIT_SECTOR_ERASE),
    FLS_WRITE_WAIT        = (FLS_WRITE        + FLS_WAIT_SECTOR_ERASE),
    FLS_WRITE_PREVER_WAIT = (FLS_WRITE_PREVER + FLS_WAIT_SECTOR_ERASE),
    FLS_BLANKCHECK_WAIT   = (FLS_BLANKCHECK   + FLS_WAIT_SECTOR_ERASE),
    FLS_SUSPEND_RESUME    = 0x40 /* suspend or resume processing bit */
} Fls_JobType;

/** \brief Type definition of Fls_PhysicalAddressType
 **
 ** This type is used to address the physical flash area
 ** as implemented in the device
 **
 ** Platform dependent */
typedef uint32 Fls_PhysicalAddressType;

/** \brief Type definition of Fls_PhysicalLengthType
 **
 ** This type denotes the number of bytes in the physical flash
 ** memory area.
 **
 ** Platform dependent */
typedef Fls_PhysicalAddressType Fls_PhysicalLengthType;

/** \brief Type definition of Fls_WriteDataType
 **
 ** type used within the flash algorithms */
typedef uint32 Fls_WriteDataType;

/** \brief Type definition of Fls_MultiReadType
 **
 ** type used within the flash algorithms */
#if FLS_MULTI_READ_SIZE == 2
typedef uint16 Fls_MultiReadType;
#elif FLS_MULTI_READ_SIZE == 8
typedef uint64 Fls_MultiReadType;
#else
typedef uint32 Fls_MultiReadType;
#endif

/** \brief Fls_JobRequestType
 ** structure to hold data for the current job
 */
typedef struct fls_jobrequesttype
{
    Fls_AddressType LogFlashAddress;        /* logical address in flash */
    Fls_AddressType RamAddress;             /* address in RAM */
    Fls_LengthType  Length;                 /* length parameter of current job */
    Fls_LengthType  CurrentLength;          /* current length of current job */
    Fls_LengthType  ResetLength;            /* reset length for verify */
    sint32          Fls_MainFunctionTime;   /* time for calling Mainfunction job */
    uint16          Fls_RetryTime;          /* time for retrying for write enable acquisition */
    Fls_JobType     CurrentJob;             /* type of current job */
    uint8           ReadWithoutBlankCheck;  /* flag for specifying whether blank check before read is skipped */
} Fls_JobRequestType;

/** \brief Fls_WriteJobType
 ** structure to hold data for the write job
 */
typedef struct fls_writejobtype
{
  Fls_AddressType FlashAddress;     /* address in flash */
  Fls_AddressType LogicalAddress;   /* logical address */
  Fls_LengthType  Length;           /* length parameter of complete job */
  Fls_LengthType  CheckAreaSize;    /* remaining size for verifing job */
} Fls_WriteJobType;

/** \brief flash memory map structure
 **
 ** Configuration structure to map the flash memory.
 */
typedef struct fls_memorymaptype
{
    uint32 logical;     /* logical start address          */
    uint32 size;        /* length of sector               */
    uint32 physical;    /* sector address for operations  */
    uint16 number;      /* number of sectors              */
} Fls_MemoryMapType;

/** \brief Fls_FaultType
 ** Type of fault information
 */
typedef enum fls_faulttype
{
    FLS_FAULT_NONE       = 0,   /* no fault */
    FLS_FAULT_SED        = 1,   /* single bit error */
    FLS_FAULT_DED        = 2,   /* double bit error */
    FLS_FAULT_BUSERROR   = 3,   /* bus error */
    FLS_FAULT_MACROERROR = 4,   /* Flash macro error */
    FLS_FAULT_OTHERERROR = 5    /* any other error */
} Fls_FaultType;

/*==================[external function declarations]==========================*/

/*==================[internal function declarations]==========================*/

/*==================[external constants]======================================*/

/*==================[internal constants]======================================*/

/*==================[external data]===========================================*/

/*==================[internal data]===========================================*/

/*==================[external function definitions]===========================*/

/*==================[internal function definitions]===========================*/

#endif /* if !defined( FLS_TYPESDERLIB_H ) */
/*==================[end of file]=============================================*/
