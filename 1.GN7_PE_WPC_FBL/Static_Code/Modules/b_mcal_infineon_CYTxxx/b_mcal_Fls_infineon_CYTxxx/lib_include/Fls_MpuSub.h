/** \brief AUTOSAR Fls Flash Driver
 **
 ** MPU configuration header for Fls sub module
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef FLS_MPUSUB_H
#define FLS_MPUSUB_H

/*========*/
/* Header */
/*========*/
#include "Fls_CfgSub.h"    /* include user configuration */

/*=============*/
/* ARCH Define */
/*=============*/
#define FLS_MXS40                       (1)

/*============*/
/* MPU Define */
/*============*/
#define FLS_MXS40                       (1)

/*==============*/
/* Set ARCH/MPU */
/*==============*/
#define FLS_ARCH                        FLS_MXS40
#define FLS_MPU                         FLS_MXS40

/*===============*/
/* MPU dependent */
/*===============*/
#if (FLS_MPU == FLS_MXS40)

    /* Deviation from MISRA-C:2012 Rule-2.5.
       Justification: The unused macros can be declared because of future extension. */

    /*=======================*/
    /* FLASHC register macro */
    /*=======================*/
    /* Register access macro */
#if !defined( FLS_USE_VCAST )
    #define FLS_REG_FLASHC_FLASH_CTL                (*Fls_WfregBaseAddr)                    /* FLASHC.FLASH_CTL access macro */
    #define FLS_REG_FLASHC_FLASH_CMD                (*(Fls_WfregBaseAddr + 0x0002UL))       /* FLASHC.FLASH_CMD access macro */
    #define FLS_REG_FLASHC_CM0_STATUS_ADDR          (Fls_WfregBaseAddr + 0x0118UL)          /* FLASHC.CM0_STATUS access macro */
    #define FLS_REG_FLASHC_CM4_CM7_0_STATUS_ADDR    (Fls_WfregBaseAddr + 0x0138UL)          /* FLASHC.CM4_STATUS/CM7_0_STATUS access macro */
    #define FLS_REG_FLASHC_CM7_1_STATUS_ADDR        (Fls_WfregBaseAddr + 0x0158UL)          /* FLASHC.CM7_1_STATUS access macro */
    #define FLS_REG_FM_CTL_ECT_FM_CTL               (*(Fls_WfregBaseAddr + 0x3C00UL))       /* FM_CTL_ECT.FM_CTL access macro */
    #define FLS_REG_FM_CTL_ECT_INTR                 (*(Fls_WfregBaseAddr + 0x3C08UL))       /* FM_CTL_ECT.INTR access macro */
    #define FLS_REG_FM_CTL_ECT_STATUS               (*(Fls_WfregBaseAddr + 0x3D01UL))       /* FM_CTL_ECT.STATUS access macro */
    #define FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY    (*(Fls_WfregBaseAddr + 0x3D40UL))       /* FM_CTL_ECT.WORK_FLASH_SAFETY access macro */
#else
    #define FLS_REG_FLASHC_FLASH_CTL                FLS_VCAST_FLASHC_FLASH_CTL              /* FLASHC.FLASH_CTL access macro */
    #define FLS_REG_FLASHC_FLASH_CMD                FLS_VCAST_FLASHC_FLASH_CMD              /* FLASHC.FLASH_CMD access macro */
    #define FLS_REG_FLASHC_CM0_STATUS_ADDR          FLS_VCAST_FLASHC_CM0_STATUS_ADDR        /* FLASHC.CM0_STATUS access macro */
    #define FLS_REG_FLASHC_CM4_CM7_0_STATUS_ADDR    FLS_VCAST_FLASHC_CM4_CM7_0_STATUS_ADDR  /* FLASHC.CM4_STATUS/CM7_0_STATUS access macro */
    #define FLS_REG_FLASHC_CM7_1_STATUS_ADDR        FLS_VCAST_FLASHC_CM7_1_STATUS_ADDR      /* FLASHC.CM7_1_STATUS access macro */
    #define FLS_REG_FM_CTL_ECT_FM_CTL               FLS_VCAST_FM_CTL_ECT_FM_CTL             /* FM_CTL_ECT.FM_CTL access macro */
    #define FLS_REG_FM_CTL_ECT_INTR                 FLS_VCAST_FM_CTL_ECT_INTR               /* FM_CTL_ECT.INTR access macro */
    #define FLS_REG_FM_CTL_ECT_STATUS               FLS_VCAST_FM_CTL_ECT_STATUS             /* FM_CTL_ECT.STATUS access macro */
    #define FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY    FLS_VCAST_FM_CTL_ECT_WORK_FLASH_SAFETY  /* FM_CTL_ECT.WORK_FLASH_SAFETY access macro */
#endif /* if !defined( FLS_USE_VCAST ) */

    /* mask of FLASHC.FLASH_CMD: mask for setting cache/buffer control */
    #define FLS_FLASHC_FLASH_CMD_W_MASK             (0xFFFFFFFCUL)

    /* mask of FLASHC.CMn_STATUS: mask for reading work flash read error */
    #define FLS_FLASHC_CM_STATUS_R_MASK             (0x00000002UL)

    /* mask of FLASHC.CMn_STATUS: mask for clearing work flash read error */
    #define FLS_FLASHC_CM_STATUS_W_MASK             (0xFFFFFFFDUL)

    /* mask of FM_CTL_ECT.FM_CTL: mask for clearing flash macro control status */
    #define FLS_FM_CTL_ECT_FM_CTL_W_MASK            (0x7FFFFFE0UL)

    /* mask of FM_CTL_ECT.INTR: mask for detecting event after embedded operation */
    #define FLS_FM_CTL_ECT_INTR_R_MASK              (0x00000001UL)

    /* mask of FM_CTL_ECT.STATUS: mask for getting result after embedded operation */
    #define FLS_FM_CTL_ECT_STATUS_HANG_MASK         (0x40000000UL)

    /* mask of FM_CTL_ECT.STATUS: mask for checking if active operation to Work flash or not */
    #define FLS_FM_CTL_ECT_STATUS_BUSY_MASK         (0x80000000UL)

    /* mask of FM_CTL_ECT.WORK_FLASH_SAFETY: mask for verifying if embedded operations are enabled */
    #define FLS_FM_CTL_ECT_WORK_FLASH_SAFETY_R_MASK (0x00000001UL)

    /* value of FLASHC.FLASH_CMD: INV=0; BUFF_INV=0 */
    #define FLS_FLASHC_FLASH_CMD_NOINVALID          (0x00000000UL)

    /* value of FLASHC.FLASH_CMD: INV=0; BUFF_INV=1 */
    #define FLS_FLASHC_FLASH_CMD_INVALID            (0x00000002UL)

    /* value of FLASHC.CMn_STATUS: WORK_INTERNAL_ERR=1 */
    #define FLS_FLASHC_CM_STATUS_ERROR              (0x00000002UL)

    /* value of FLASHC.CMn_STATUS: WORK_INTERNAL_ERR=1 */
    #define FLS_FLASHC_CM_STATUS_CLEAR              (0x00000002UL)

    /* value of FM_CTL_ECT.FM_CTL: EMB_START=0; FM_MODE=00000 */
    #define FLS_FM_CTL_ECT_FM_CTL_CLEAR             (0x00000000UL)

    /* value of FM_CTL_ECT.INTR: INTR=0 */
    #define FLS_FM_CTL_ECT_INTR_NODETECT            (0x00000000UL)

    /* value of FM_CTL_ECT.INTR: INTR=1 */
    #define FLS_FM_CTL_ECT_INTR_DETECT              (0x00000001UL)

    /* value of FM_CTL_ECT.STATUS: HANG=0 */
    #define FLS_FM_CTL_ECT_STATUS_NOHANG            (0x00000000UL)

    /* value of FM_CTL_ECT.STATUS: BLANK_CHECK_WORK/ERASE_WORK/PGM_WORK=0 */
    #define FLS_FM_CTL_ECT_STATUS_NOTBUSY           (0x00000000UL)

    /* value of FM_CTL_ECT.WORK_FLASH_SAFETY: WorkFlashWriteEnable=0 */
    #define FLS_FM_CTL_ECT_WORK_FLASH_SAFETY_WE_OFF (0x00000000UL)

    /* value of FM_CTL_ECT.WORK_FLASH_SAFETY: WorkFlashWriteEnable=1 */
    #define FLS_FM_CTL_ECT_WORK_FLASH_SAFETY_WE_ON  (0x00000001UL)

    /*=======================*/
    /* FAULT structure macro */
    /*=======================*/
    /* Register access macro */
#if !defined( FLS_USE_VCAST )
    #define FLS_REG_FAULT_STRUCT_STATUS             (*(Fls_FaultBaseAddr + 0x0003UL)) /* STATUS access macro */
    #define FLS_REG_FAULT_STRUCT_DATA               (*(Fls_FaultBaseAddr + 0x0004UL)) /* DATA access macro */
    #define FLS_REG_FAULT_STRUCT_MASK0              (*(Fls_FaultBaseAddr + 0x0014UL)) /* MASK0 access macro */
    #define FLS_REG_FAULT_STRUCT_MASK1              (*(Fls_FaultBaseAddr + 0x0015UL)) /* MASK1 access macro */
    #define FLS_REG_FAULT_STRUCT_MASK2              (*(Fls_FaultBaseAddr + 0x0016UL)) /* MASK2 access macro */
    #define FLS_REG_FAULT_STRUCT_INTR               (*(Fls_FaultBaseAddr + 0x0030UL)) /* INTR access macro */
#else
    #define FLS_REG_FAULT_STRUCT_STATUS             FLS_VCAST_FAULT_STRUCT_STATUS     /* STATUS access macro */
    #define FLS_REG_FAULT_STRUCT_DATA               FLS_VCAST_FAULT_STRUCT_DATA       /* DATA access macro */
    #define FLS_REG_FAULT_STRUCT_MASK0              FLS_VCAST_FAULT_STRUCT_MASK0      /* MASK0 access macro */
    #define FLS_REG_FAULT_STRUCT_MASK1              FLS_VCAST_FAULT_STRUCT_MASK1      /* MASK1 access macro */
    #define FLS_REG_FAULT_STRUCT_MASK2              FLS_VCAST_FAULT_STRUCT_MASK2      /* MASK2 access macro */
    #define FLS_REG_FAULT_STRUCT_INTR               FLS_VCAST_FAULT_STRUCT_INTR       /* INTR access macro */
#endif /* if !defined( FLS_USE_VCAST ) */

    /* Register mask macro */
    /* mask of STATUS: mask for setting work interface */
    #define FLS_FAULT_STRUCT_STATUS_R_MASK1         (0x80000000UL)
    #define FLS_FAULT_STRUCT_STATUS_R_MASK2         (0x8000007FUL)

    /* mask of INTR: mask for clearing the interrupt */
    #define FLS_FAULT_STRUCT_INTR_W_MASK            (0xFFFFFFFEUL)

    /* Register value macro */
    /* value of STATUS: VALID=0 (clear) */
    #define FLS_FAULT_STRUCT_STATUS_CLEAR           (0x00000000UL)

    /* value of STATUS: VALID=1; IDX=FLASHC_WORK_BUS_ERROR */
    #define FLS_FAULT_STRUCT_STATUS_WORK_BUS_ERROR  (0x80000033UL)

    /* value of STATUS: VALID=1; IDX=FLASHC_WORK_C_ECC */
    #define FLS_FAULT_STRUCT_STATUS_WORK_C_ECC      (0x80000034UL)

    /* value of STATUS: VALID=1; IDX=FLASHC_WORK_NC_ECC */
    #define FLS_FAULT_STRUCT_STATUS_WORK_NC_ECC     (0x80000035UL)

    /* value of INTR: FAULT=1 */
    #define FLS_FAULT_STRUCT_INTR_CLEAR             (0x00000001UL)

    /*========================*/
    /* IPC structure #x macro */
    /*========================*/
    /* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9.
       Justification: In case of using in small processing, function-like macro is
       used. It improves readability. */
    /* PRQA S 3453 37 */
    /* Register access macro */
#if !defined( FLS_USE_VCAST )
    #define FLS_REG_IPC_STRUCT_ACQUIRE(x)           (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(x)) << 3U) + 0UL)) /* ACQUIRE access macro */
    #define FLS_REG_IPC_STRUCT_RELEASE(x)           (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(x)) << 3U) + 1UL)) /* RELEASE access macro */
    #define FLS_REG_IPC_STRUCT_NOTIFY(x)            (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(x)) << 3U) + 2UL)) /* NOTIFY access macro */
    #define FLS_REG_IPC_STRUCT_DATA0(x)             (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(x)) << 3U) + 3UL)) /* DATA0 access macro */
    #define FLS_REG_IPC_STRUCT_DATA1(x)             (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(x)) << 3U) + 4UL)) /* DATA1 access macro */
#else
    #define FLS_REG_IPC_STRUCT_ACQUIRE(x)           FLS_VCAST_IPC_STRUCT_ACQUIRE(x) /* ACQUIRE access macro */
    #define FLS_REG_IPC_STRUCT_RELEASE(x)           FLS_VCAST_IPC_STRUCT_RELEASE(x) /* RELEASE access macro */
    #define FLS_REG_IPC_STRUCT_NOTIFY(x)            FLS_VCAST_IPC_STRUCT_NOTIFY(x)  /* NOTIFY access macro */
    #define FLS_REG_IPC_STRUCT_DATA0(x)             FLS_VCAST_IPC_STRUCT_DATA0(x)   /* DATA0 access macro */
    #define FLS_REG_IPC_STRUCT_DATA1(x)             FLS_VCAST_IPC_STRUCT_DATA1(x)   /* DATA1 access macro */
#endif /* if !defined( FLS_USE_VCAST ) */

    /* Register mask macro */
    /* mask of ACQUIRE: mask for getting successfully acquired or not */
    #define FLS_IPC_STRUCT_ACQUIRE_R_MASK           (0x80000000UL)

    /* mask of RELEASE: mask for IPC release event  */
    #define FLS_IPC_STRUCT_RELEASE_W_MASK(m)        (~(1UL << (m)))

    /* mask of NOTIFY: mask for IPC notification event  */
    #define FLS_IPC_STRUCT_NOTIFY_W_MASK(m)         (~(1UL << (m)))

    /* Register value macro */
    /* value of ACQUIRE: SUCCESS=0 (Not successfully) */
    #define FLS_IPC_STRUCT_ACQUIRE_NOTSUCCESS       (0x00000000UL)

    /* value of ACQUIRE: SUCCESS=1 (Successfully) */
    #define FLS_IPC_STRUCT_ACQUIRE_SUCCESS          (0x80000000UL)

    /* value of RELEASE: INTR_RELEASE[m]=1 (IPC interrupt structure #m) */
    #define FLS_IPC_STRUCT_RELEASE_VALUE(m)         (1UL << (m))

    /* value of NOTIFY: INTR_NOTIFY[m]=1 (IPC interrupt structure #m) */
    #define FLS_IPC_STRUCT_NOTIFY_VALUE(m)          (1UL << (m))

    /*==================================*/
    /* IPC interrupt structure #y macro */
    /*==================================*/
    /* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9.
       Justification: In case of using in small processing, function-like macro is
       used. It improves readability. */
    /* PRQA S 3453 48 */
    /* Register access macro */
#if !defined( FLS_USE_VCAST )
    #define FLS_REG_IPC_INTR_STRUCT_INTR(y)         (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(y)) << 3U) + 0x400UL)) /* INTR access macro */
    #define FLS_REG_IPC_INTR_STRUCT_INTR_MASK(y)    (*(Fls_IpcStructBaseAddr + (((FLS_ULONG)(y)) << 3U) + 0x402UL)) /* INTR_MASK access macro */
#else
    #define FLS_REG_IPC_INTR_STRUCT_INTR(y)         FLS_VCAST_IPC_INTR_STRUCT_INTR(y)       /* INTR access macro */
    #define FLS_REG_IPC_INTR_STRUCT_INTR_MASK(y)    FLS_VCAST_IPC_INTR_STRUCT_INTR_MASK(y)  /* INTR_MASK access macro */
#endif /* if !defined( FLS_USE_VCAST ) */

    /* Register mask macro */
    /* mask of INTR: mask for polling release / clearing IPC interrupt cause */
    #define FLS_IPC_INTR_STRUCT_INTR_R_MASK(x)      (1UL << (x))
    #define FLS_IPC_INTR_STRUCT_INTR_W_MASK(x)      (~(1UL << (x)))

    /* mask of INTR: mask for polling notify / clearing IPC interrupt cause */
    #define FLS_IPC_INTR_STRUCT_INTN_R_MASK(x)      (1UL << ((x) + 16))
    #define FLS_IPC_INTR_STRUCT_INTN_W_MASK(x)      (~(1UL << ((x) + 16)))

    /* mask of INTR_MASK: mask for setting IPC RELEASE interrupt */
    #define FLS_IPC_INTR_STRUCT_INTR_MASK_W_MASK(x) (~(1UL << (x)))

    /* mask of INTR_MASK: mask for setting IPC NOTIFY interrupt */
    #define FLS_IPC_INTR_STRUCT_INTN_MASK_W_MASK(x) (~(1UL << ((x) + 16)))

    /* Register value macro */
    /* value of INTR: RELEASE[x]=0, NOTIFY[x]=0 (IPC structure #x release/notify not detected) */
    #define FLS_IPC_INTR_STRUCT_INTR_NOTRELEASE     (0x00000000UL)

    /* value of INTR: RELEASE[x]=1 (IPC structure #x release detected) */
    #define FLS_IPC_INTR_STRUCT_INTR_RELEASE(x)     (1UL << (x))

    /* value of INTR: NOTIFY[x]=1 (IPC structure #x notify detected) */
    #define FLS_IPC_INTR_STRUCT_INTN_NOTIFY(x)      (1UL << ((x) + 16))

    /* value of INTR: RELEASE[x]=1 (IPC structure #x release clear) */
    #define FLS_IPC_INTR_STRUCT_INTR_CLEAR(x)       (1UL << (x))

    /* value of INTR: NOTIFY[x]=1 (IPC structure #x release clear) */
    #define FLS_IPC_INTR_STRUCT_INTN_CLEAR(x)       (1UL << ((x) + 16))

    /* value of INTR_MASK: RELEASE[x]=0 (IPC structure #x release interupt disable) */
    #define FLS_IPC_INTR_STRUCT_INTR_MASK_DISABLE   (0x00000000UL)

    /* value of INTR_MASK: RELEASE[x]=1 (IPC structure #x release interupt enable) */
    #define FLS_IPC_INTR_STRUCT_INTR_MASK_ENABLE(x) (1UL << (x))

    /* value of INTR_MASK: RELEASE[x]=1 (IPC structure #x release interupt enable) */
    #define FLS_IPC_INTR_STRUCT_INTN_MASK_ENABLE(x) (1UL << ((x) + 16))

    /*=====================*/
    /* DMAC register macro */
    /*=====================*/
    /* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9.
       Justification: In case of using in small processing, function-like macro is
       used. It improves readability. */
    /* PRQA S 3453 37 */
    /* Register access macro */
#if !defined( FLS_USE_VCAST )
    #define FLS_REG_DMAC_CTL                        (*Fls_DmacBaseAddr)                                        /* DMAC.CTL access macro */
    #define FLS_REG_DMAC_CH_CTL(x)                  (*(Fls_DmacBaseAddr + (((FLS_ULONG)(x)) << 6U) + 0x400UL)) /* DMAC_CH.CTL access macro */
    #define FLS_REG_DMAC_CH_IDX(x)                  (*(Fls_DmacBaseAddr + (((FLS_ULONG)(x)) << 6U) + 0x404UL)) /* DMAC_CH.IDX access macro */
    #define FLS_REG_DMAC_CH_CURR(x)                 (*(Fls_DmacBaseAddr + (((FLS_ULONG)(x)) << 6U) + 0x408UL)) /* DMAC_CH.CURR access macro */
    #define FLS_REG_DMAC_CH_TR_CMD(x)               (*(Fls_DmacBaseAddr + (((FLS_ULONG)(x)) << 6U) + 0x40AUL)) /* DMAC_CH.TR_CMD access macro */
    #define FLS_REG_DMAC_CH_INTR(x)                 (*(Fls_DmacBaseAddr + (((FLS_ULONG)(x)) << 6U) + 0x420UL)) /* DMAC_CH.INTR access macro */
    #define FLS_REG_DMAC_CH_INTR_MASK(x)            (*(Fls_DmacBaseAddr + (((FLS_ULONG)(x)) << 6U) + 0x422UL)) /* DMAC_CH.INTR_MASK access macro */
#else
    #define FLS_REG_DMAC_CTL                        FLS_VCAST_DMAC_CTL              /* DMAC.CTL access macro */
    #define FLS_REG_DMAC_CH_CTL(x)                  FLS_VCAST_DMAC_CH_CTL(x)        /* DMAC_CH.CTL access macro */
    #define FLS_REG_DMAC_CH_IDX(x)                  FLS_VCAST_DMAC_CH_IDX(x)        /* DMAC_CH.IDX access macro */
    #define FLS_REG_DMAC_CH_CURR(x)                 FLS_VCAST_DMAC_CH_CURR(x)       /* DMAC_CH.CURR access macro */
    #define FLS_REG_DMAC_CH_TR_CMD(x)               FLS_VCAST_DMAC_CH_TR_CMD(x)     /* DMAC_CH.TR_CMD access macro */
    #define FLS_REG_DMAC_CH_INTR(x)                 FLS_VCAST_DMAC_CH_INTR(x)       /* DMAC_CH.INTR access macro */
    #define FLS_REG_DMAC_CH_INTR_MASK(x)            FLS_VCAST_DMAC_CH_INTR_MASK(x)  /* DMAC_CH.INTR_MASK access macro */
#endif /* if !defined( FLS_USE_VCAST ) */

    /* Register mask macro */
    /* mask of DMAC.CTL: mask for enabling / disabling DMA controller */
    #define FLS_DMAC_CTL_R_MASK                     (0x80000000UL)

    /* mask of DMAC.CTL: mask for enabling / disabling DMA controller */
    #define FLS_DMAC_CTL_W_MASK                     (0x7FFFFFFFUL)

    /* mask of DMAC_CH.CTL: mask for enabling / disabling DMA channel */
    #define FLS_DMAC_CH_CTL_W_MASK                  (0x7FFFFFFFUL)

    /* mask of DMAC_CH.INTR: mask for acquiring of completion or failure */
    #define FLS_DMAC_CH_INTR_R_MASK                 (0x000000FFUL)

    /* mask of DMAC_CH.INTR_SET: mask for clearing DMAC interrupt cause */
    #define FLS_DMAC_CH_INTR_SET_W_MASK             (0xFFFFFF00UL)

    /* mask of DMAC_CH.INTR: mask for unsetting DMAC interrupt */
    #define FLS_DMAC_CH_INTR_MASK_W_MASK            (0xFFFFFF00UL)

    /* Register value macro */
    /* value of DMAC.CTL: ENABLED=1 */
    #define FLS_DMAC_CTL_ENABLED                    (0x80000000UL)

    /* value of DMAC.CTL: ENABLED=0 */
    #define FLS_DMAC_CTL_DISABLED                   (0x00000000UL)

    /* value of DMAC_CH.CTL: ENABLED=1 */
    #define FLS_DMAC_CH_CTL_ENABLED                 (0x80000000UL)

    /* value of DMAC_CH.CTL: ENABLED=0 */
    #define FLS_DMAC_CH_CTL_DISABLED                (0x00000000UL)

    /* value of DMAC_CH.TR_CMD: ACTIVATE=1 */
    #define FLS_DMAC_CH_TR_CMD_ACTIVATE             (0x00000001UL)

    /* value of DMAC_CH.INTR: COMPLETION=1 */
    #define FLS_DMAC_CH_INTR_COMPLETION             (0x00000001UL)

    /* value of DMAC_CH.INTR: SRC_BUS_ERROR=1 */
    #define FLS_DMAC_CH_INTR_SRC_BUS_ERROR          (0x00000002UL)

    /* value of DMAC_CH.INTR: Bits[0:7]=1 */
#if !defined( FLS_USE_VCAST )
    #define FLS_DMAC_CH_INTR_CLEAR                  (0x000000FFUL)
#else
    #define FLS_DMAC_CH_INTR_CLEAR                  FLS_VCAST_DMAC_CH_INTR_VALUE
#endif /* if !defined( FLS_USE_VCAST ) */

    /* value of DMAC_CH.INTR_MASK: Bits[0:7]=1 */
    #define FLS_DMAC_CH_INTR_MASK_CLEAR             (0x00000000UL)

    /*=======================*/
    /* DMAC descriptor macro */
    /*=======================*/
    /* Register value macro */
    /* value of DMAC_DESCR_CTL: WAIT_FOR_DEACT=00; INTR_TYPE=01; TR_OUT_TYPE=01; TR_IN_TYPE=01; DATA_PREFETCH=0;     */
    /*                          DATA_SIZE=00; CH_DISABLE=1; SRC_TRANSFER_SIZE=0; DST_TRANSFER_SIZE=0; DESCR_TYPE=011 */
    #define FLS_DMAC_DESCR_CTL_VALUE                (0x31000054UL)

    /* value of DMAC_DESCR_NEXT: PTR=0 */
    #define FLS_DMAC_DESCR_NEXT_VALUE               (0x00000000UL)

    /*==================================*/
    /* FLS_IPC structure relevant macro */
    /*==================================*/
    /* Embedded information macro */
    #define FLS_EMBEDDED_CM0_CODE                   ((FLS_ULONG)0x00000001UL)   /* Code flash embedded information for CM0+ */
    #define FLS_EMBEDDED_CM0_WORK                   ((FLS_ULONG)0x00000002UL)   /* Work flash embedded information for CM0+ */
    #define FLS_EMBEDDED_CM4_CM7_0_CODE             ((FLS_ULONG)0x00000004UL)   /* Code flash embedded information for CM4/CM7_0 */
    #define FLS_EMBEDDED_CM4_CM7_0_WORK             ((FLS_ULONG)0x00000008UL)   /* Work flash embedded information for CM4/CM7_0 */
    #define FLS_EMBEDDED_CM7_1_CODE                 ((FLS_ULONG)0x00000010UL)   /* Code flash embedded information for CM7_1 */
    #define FLS_EMBEDDED_CM7_1_WORK                 ((FLS_ULONG)0x00000020UL)   /* Work flash embedded information for CM7_1 */

    /* Information to All CPUs macro */
    /* Code flash embedded information */
    #define FLS_EMBEDDED_CODE                       (FLS_EMBEDDED_CM0_CODE | FLS_EMBEDDED_CM4_CM7_0_CODE | FLS_EMBEDDED_CM7_1_CODE)
    /* Work flash embedded information */
    #define FLS_EMBEDDED_WORK                       (FLS_EMBEDDED_CM0_WORK | FLS_EMBEDDED_CM4_CM7_0_WORK | FLS_EMBEDDED_CM7_1_WORK)

    /* No Information */
    #define FLS_EMBEDDED_NONE                       ((FLS_ULONG)0x00000000UL)   /* No embedded information */

    /* Flash control request to HSM macro */
    #define FLS_INVOKE_HSM_INVALIDATE_CACHE         ((FLS_ULONG)0x00000001UL)   /* Invalidate cache request */

    /* Event to All IPCs macro */
    #define FLS_IPC_ALL                             ((FLS_ULONG)0x0000FFFFUL)

    /*============================*/
    /* FLASH management API macro */
    /*============================*/
    /* Fls_InvokeFMAPI() opcode */
    #define FLS_FMAPI_SILICON_ID                    ((FLS_UCHAR)0x00) /* Silicon ID */
    #define FLS_FMAPI_PROGRAM_ROW                   ((FLS_UCHAR)0x06) /* ProgramRow */
    #define FLS_FMAPI_CHECK_FM_STATUS               ((FLS_UCHAR)0x07) /* CheckFmStatus */
    #define FLS_FMAPI_CONFIGURE_FM_INTERRUPT        ((FLS_UCHAR)0x08) /* ConfigureFmInterrupt */
    #define FLS_FMAPI_ERASE_SECTOR                  ((FLS_UCHAR)0x14) /* EraseSector */
    #define FLS_FMAPI_ERASE_SUSPEND                 ((FLS_UCHAR)0x22) /* EraseSuspend */
    #define FLS_FMAPI_ERASE_RESUME                  ((FLS_UCHAR)0x23) /* EraseResume */
    #define FLS_FMAPI_BLANK_CHECK                   ((FLS_UCHAR)0x2A) /* BlankCheck */

    /* Fls_InvokeFMAPI() inner opcode */
    #define FLS_FMAPI_SILICON_ID_SROMFW_VERSION     ((FLS_UCHAR)0xF5) /* Silicon ID (returns SROM firmware version) */
    #define FLS_FMAPI_PROGRAM_ROW_BLOCKING          ((FLS_UCHAR)0xF6) /* ProgramRow (blocking mode) */
    #define FLS_FMAPI_PROGRAM_ROW_NONBLOCKING       ((FLS_UCHAR)0xF7) /* ProgramRow (non-blocking mode) */
    #define FLS_FMAPI_BLANK_CHECK_SYNC              ((FLS_UCHAR)0xF8) /* BlankCheck (sync) */
    #define FLS_FMAPI_BLANK_CHECK_ASYNC             ((FLS_UCHAR)0xF9) /* BlankCheck (async) */
    #define FLS_FMAPI_CONFIGURE_FM_INTERRUPT_MCLEAR ((FLS_UCHAR)0xFA) /* ConfigureFmInterrupt (clear interrupt mask) */
    #define FLS_FMAPI_CONFIGURE_FM_INTERRUPT_MSET   ((FLS_UCHAR)0xFB) /* ConfigureFmInterrupt (set interrupt mask) */
    #define FLS_FMAPI_CONFIGURE_FM_INTERRUPT_CLEAR  ((FLS_UCHAR)0xFC) /* ConfigureFmInterrupt (clear interrupt) */
    #define FLS_FMAPI_ERASE_SECTOR_NOINTR           ((FLS_UCHAR)0xFD) /* EraseSector (disable FM interrupt) */
    #define FLS_FMAPI_ERASE_SECTOR_INTR             ((FLS_UCHAR)0xFE) /* EraseSector (enable FM interrupt) */

    /* Fls_InvokeFMAPI() argument */
    #define FLS_FMAPI_SROMFW_VERSION                ((FLS_UCHAR)0x02) /* SROM firmware version */
    #define FLS_FMAPI_NONBLOCKING                   ((FLS_UCHAR)0x00) /* non-blocking API */
    #define FLS_FMAPI_BLOCKING                      ((FLS_UCHAR)0x01) /* blocking API */
    #define FLS_FMAPI_DATALOCATION_SRAM             ((FLS_UCHAR)0x01) /* Data location (SRAM) */
    #define FLS_FMAPI_PROGRAM_32BITS                ((FLS_UCHAR)0x02) /* Program data size (32bits) */
    #define FLS_FMAPI_ALLINDATA                     ((FLS_UCHAR)0x01) /* all arguments are passed in DATA */
    #define FLS_FMAPI_SKIP_BLANKCHECK               ((FLS_UCHAR)0x01) /* skips the blank check step */
    #define FLS_FMAPI_NO_INTR_MASK                  ((FLS_UCHAR)0x00) /* don't set FM interrupt mask */
    #define FLS_FMAPI_INTR_MASK                     ((FLS_UCHAR)0x01) /* set FM interrupt mask */
    #define FLS_FMAPI_CLEAR_INTERRUPT_MASK          ((FLS_UCHAR)0x00) /* clear interrupt mask */
    #define FLS_FMAPI_SET_INTERRUPT_MASK            ((FLS_UCHAR)0x01) /* set interrupt mask */
    #define FLS_FMAPI_CLEAR_INTERRUPT               ((FLS_UCHAR)0x02) /* clear interrupt */

    /* Fls_InvokeFMAPI() and Fls_GetResultFMAPI() return values */
    #define FLS_FMAPI_STATUS_SUCCESS                ((FLS_ULONG)0xA0000000UL) /* complete successfully */
    #define FLS_FMAPI_STATUS_IPC_BUSY               ((FLS_ULONG)0x00000080UL) /* IPC cannot be acquired */
    #define FLS_FMAPI_STATUS_FLASH_NOT_ERASED       ((FLS_ULONG)0xF00000A4UL) /* blank check fails */
    #define FLS_FMAPI_STATUS_NO_ERASE_ONGOING       ((FLS_ULONG)0xF00000A5UL) /* no ongoing erase operation */
    #define FLS_FMAPI_STATUS_ACTIVE_ERASE           ((FLS_ULONG)0xF00000A6UL) /* ongoing erase operation */
    #define FLS_FMAPI_STATUS_EMB_ACTIVE             ((FLS_ULONG)0xF00000A9UL) /* ongoing write operation */

    /* CheckFmStatus mask */
    #define FLS_FMSTATUS_HANG_MASK                  ((FLS_ULONG)0xA0000080UL)   /* result after embedded operation mask */
    #define FLS_FMSTATUS_BUSY_MASK                  ((FLS_ULONG)0xA000002AUL)   /* active operation to Work flash */
    #define FLS_FMSTATUS_ERROR_MASK                 ((FLS_ULONG)0xF0000000UL)   /* API error mask */

    /* CheckFmStatus return values */
    #define FLS_FMSTATUS_NOHANG                     ((FLS_ULONG)0xA0000000UL)   /* result is pass */
    #define FLS_FMSTATUS_NOTBUSY                    ((FLS_ULONG)0xA0000000UL)   /* embedded mode ready */
    #define FLS_FMSTATUS_NOERROR                    ((FLS_ULONG)0xA0000000UL)   /* API no error */
    #define FLS_FMSTATUS_ERROR                      ((FLS_ULONG)0xF0000000UL)   /* API error */

    /* BlankCheck mask */
    #define FLS_BLANKCHECK_ERROR_MASK               ((FLS_ULONG)0xF00000FFUL)   /* blank check error mask */

    /* IPC structure for FLASH management API */
    #define FLS_FMAPI_IPC                           (Fls_FMAPIIpcStruct)        /* IPC structure (for CM0/CM4/CM7_0/CM7_1) */

    /* IPC interrupt structure for FLASH management API */
    #define FLS_FMAPI_MASTER_IPC_INTR               (0UL)                       /* IPC interrupt structure 0 (for CM0 master) */
    #define FLS_FMAPI_SLAVE_IPC_INTR                (1UL + Fls_FMAPIIpcStruct)  /* IPC interrupt structure (for CM0/CM4/CM7_0/CM7_1 slave) */

    /*==================*/
    /* Multi-core macro */
    /*==================*/
    /* Register access macro */
#if !defined( FLS_USE_VCAST )
    #define FLS_REG_CPUSS_IDENTITY                  (*Fls_CpussBaseAddr)        /* CPUSS.IDENTITY access macro */
#else
    #define FLS_REG_CPUSS_IDENTITY                  FLS_VCAST_CPUSS_IDENTITY    /* CPUSS.IDENTITY access macro */
#endif /* if !defined( FLS_USE_VCAST ) */

    /* Register mask macro */
    /* mask of CPUSS.IDENTITY: mask for identifying which core runs this module */
    #define FLS_CPUSS_IDENTITY_MS_R_MASK            (0x00000F00UL)

    /* Register value macro */
    /* value of CM0: MS=0000 */
    #define FLS_IDENTITY_MS_CM0                     (0x00U)

    /* Register value macro */
    /* value of CM4 and CM7_0: MS=1110 */
    #define FLS_IDENTITY_MS_CM4_CM7_0               (0x0EU)

    /* Register value macro */
    /* value of CM7_1: MS=1101 */
    #define FLS_IDENTITY_MS_CM7_1                   (0x0DU)

#endif

/*=================*/
/* Const variables */
/*=================*/

#endif /* !FLS_MPUSUB_H */

/*==================[end of file]===========================================*/
