#if !defined( FLS_LIBINTERFACE_H )
#define FLS_LIBINTERFACE_H

/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains or includes all library interfaces of
 ** the AUTOSAR module Fls.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Std_Types.h>          /* AUTOSAR standard types */
#include <MemIf_Types.h>        /* AUTOSAR standard types */
#include <Fls_Version.h>        /* this module's version declaration */
#include <Fls_TypesLib.h>       /* module specific types */
#include <Fls_TypesDerLib.h>    /* derivative specific types */
#include <Fls_Cfg.h>            /* Generated module specific config */
#include <Fls_PBcfg.h>          /* Generated post-build time config */
#include <Fls_CfgDer.h>         /* Generated derivative specific config */
#include <Os.h>

/*==================[macros]================================================*/

/*------------------[AUTOSAR configuration AR version number check]----------*/
#if !FLS_AR_VERSION_CHECK(FLS_GEN_AR_RELEASE_MAJOR_VERSION, FLS_GEN_AR_RELEASE_MINOR_VERSION, FLS_GEN_AR_RELEASE_REVISION_VERSION)
#error AUTOSAR configuration AR version number mismatch
#endif
/*------------------[AUTOSAR configuration SW version number check]----------*/
#if !FLS_SW_VERSION_CHECK(FLS_GEN_SW_MAJOR_VERSION, FLS_GEN_SW_MINOR_VERSION, FLS_GEN_SW_PATCH_VERSION)
#error AUTOSAR configuration SW version number mismatch
#endif

/*------------------[AUTOSAR configuration additional check]-----------------*/
#if !FLS_EXTRA_CHECK(FLS_GEN_MODULE_ID, FLS_GEN_VENDOR_ID)
#error AUTOSAR configuation additional check mismatch
#endif

/** \brief FLS_FALSE for boolean operations */
#define FLS_FALSE                                           ((uint8)0x00U)
/** \brief FLS_TRUE for boolean operations */
#define FLS_TRUE                                            ((uint8)0x01U)

#if (defined FLS_INSTANCE_ID) /* to prevent double declaration */
#error FLS_INSTANCE_ID already defined
#endif /* if (defined FLS_INSTANCE_ID) */

/** \brief AUTOSAR module instance identification */
#define FLS_INSTANCE_ID 0U

/** \brief flag mask for specifying verification to do */
#define FLS_ERASE_VERIFICATION          (0x01U)   /* verify in erase job */
#define FLS_BEFORE_WRITE_VERIFICATION   (0x02U)   /* previous verify in write job */
#define FLS_WRITE_VERIFICATION          (0x04U)   /* post verify in write job */

/** \brief return value of Fls_GetLogicalSector */
#define FLS_SECTOR_NOT_FOUND            (0xFFFFU) /* sector not found */

/** \brief macro for counting up to max */
#if !defined( FLS_USE_VCAST )
#define FLS_COUNT_MAX                   (0xFFFFFFFFUL)
#else
#define FLS_COUNT_MAX                   (0x0000000FUL)
#endif /* if !defined( FLS_USE_VCAST ) */

/*==================[macro functions]========================================*/

/*==================[type definitions]======================================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/
#define FLS_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include <Fls_MemMap.h>

/** \brief IPC structure for FLASH management API */
extern VAR( uint32, FLS_VAR_NO_INIT ) Fls_FMAPIIpcStruct;

/** \brief flash interface status register address */
extern volatile P2VAR( uint32, AUTOMATIC, FLS_APPL_DATA ) Fls_FlashStatusAddr;

/** \brief mask for reading safety mechanism IPC DATA0 register */
extern volatile VAR( uint32, FLS_VAR_NO_INIT ) Fls_EmbeddedListenMask;

/* IPC structure context (on scratch) referred by FLASH Management API */
extern VAR(uint32, FLS_VAR_NO_INIT) Fls_IpcContext[4];

/* data to be written that is passed to FLASH Management API */
extern volatile VAR(uint32, FLS_VAR_NO_INIT) Fls_WriteData;

#define FLS_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include <Fls_MemMap.h>

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define FLS_START_SEC_CODE
#include <Fls_MemMap.h>

/** \brief Fls_InitLib
 **
 ** Initializes the FLS module (software) and all flash memory relevant registers (hardware).
 **
 ** \param[in]  ConfigPtr       Configuration address
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_InitLib
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
);

/** \brief Fls_EraseLib
 **
 ** Setup of a flash erase job to be processed when calling the MainFunction().
 ** The function Fls_Erase shall copy the given parameters to FLS module internal
 ** variables, initiate an erase job, set the FLS module status to MEMIF_BUSY,
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] Length           Number of bytes to erase
 **
 ** \return    erase command has been accepted/not been accepted
 ** \retval    E_NOT_OK         erase command has not been accepted
 **            E_OK             erase command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_EraseLib
(
    Fls_AddressType TargetAddress,
    Fls_LengthType Length
);

/** \brief Fls_WriteLib
 **
 ** Setup of a flash write job to be processed when calling the MainFunction().
 ** The function Fls_Write shall copy the given parameters to Fls module internal
 ** variables, initiate a write job, set the FLS module status to MEMIF_BUSY,
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK.
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] SourceAddressPtr Pointer to source data buffer
 ** \param[in] Length           Number of bytes to write
 **
 ** \return    write command has been accepted/not been accepted
 ** \retval    E_NOT_OK         write command has not been accepted
 **            E_OK             write command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_WriteLib
(
    Fls_AddressType TargetAddress,
    P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr,
    Fls_LengthType Length
);

/** \brief Fls_CancelLib
 **
 ** Cancels an ongoing flash job immediately(read/write/erase/compare/blank check).
 ** Reset internal job processing variables and set driver state to IDLE.
 ** If configured, this function call the error notification function.
 **
 ** \return     none
 */ 
extern FUNC(void, FLS_CODE) Fls_CancelLib(void);

/** \brief Fls_GetStatusLib
 **
 ** Returns the FLS module state synchronously.
 **
 ** \return  The driver state
 ** \retval  MEMIF_IDLE      driver is currently idle
 **          MEMIF_UNINIT    driver is not yet initialized
 **          MEMIF_BUSY      driver is busy
 **
 */
extern FUNC(MemIf_StatusType, FLS_CODE)  Fls_GetStatusLib(void);

/** \brief Fls_GetJobResultLib
 **
 ** Returns the result of the last job synchronously.
 **
 ** \return  The result of the last job
 ** \retval  MEMIF_BLOCK_INCONSISTENT  last compare job indicated differences
 **          MEMIF_JOB_CANCELED        last job canceled
 **          MEMIF_JOB_FAILED          last job failed due to hardware error
 **          MEMIF_JOB_OK              last job successfully completed
 **          MEMIF_JOB_PENDING         a new job is pending
 **
 */
extern FUNC(MemIf_JobResultType, FLS_CODE) Fls_GetJobResultLib(void);

/** \brief Fls_MainFunctionLib
 **
 ** This function shall perform the processing of the flash read, write, 
 ** erase and compare jobs. When a job has been initiated, the FLS module's 
 ** environment shall call the function Fls_MainFunction cyclically until the job
 ** is finished. 
 ** This function calls each internal functions by FLS module's state.
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_MainFunctionLib(void);

/** \brief Fls_ReadLib
 **
 ** Setup of a flash read job to be processed when calling the MainFunction().
 ** The function Fls_Read shall copy the given parameters to FLS module internal
 ** variables, initiate a read job, set the FLS module status to MEMIF_BUSY,
 ** set the FLS module job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in]  SourceAddress         Source address in flash memory
 ** \param[out] TargetAddressPtr      Pointer to target data buffer
 ** \param[in]  Length                Number of bytes to read
 ** \param[in]  ReadWithoutBlankCheck Flag for reading without blank check
 **
 ** \return    read command has been accepted/not been accepted
 ** \retval    E_NOT_OK         read command has not been accepted
 **            E_OK             read command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_ReadLib
(
    Fls_AddressType SourceAddress,
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    Fls_LengthType Length,
    uint8 ReadWithoutBlankCheck
);

/** \brief Fls_CompareLib
 **
 ** Setup of a flash compare job to be processed when calling the MainFunction().
 ** The function Fls_Compare shall copy the given parameters to Fls module internal
 ** variables, initiate a compare job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] SourceAddress    Source address in flash memory
 ** \param[in] TargetAddressPtr Pointer to target data buffer
 ** \param[in] Length           Number of bytes to compare
 **
 ** \return    compare command has been accepted/not been accepted
 ** \retval    E_NOT_OK         compare command has not been accepted
 **            E_OK             compare command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_CompareLib
(
    Fls_AddressType SourceAddress,
    P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) TargetAddressPtr,
    Fls_LengthType Length
);

/** \brief Fls_SetModeLib
 **
 ** Sets the mode for the flash access to SLOW or FAST as given by the parameter.
 **
 ** \param[in]  Mode    mode to be switched to (SLOW, FAST)
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_SetModeLib
(
    MemIf_ModeType Mode
);

/** \brief Fls_GetVersionInfoLib
 **
 ** This service returns the version information of this module.
 **
 ** \param[out]  VersioninfoPtr  Pointer to where to store the version
 **                              information of this module (Module Id,
 **                              Vendor Id, Vendor specific version numbers).
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_GetVersionInfoLib
(
    P2VAR(Std_VersionInfoType, AUTOMATIC, FLS_APPL_DATA) VersioninfoPtr
);

/** \brief Fls_BlankCheckLib
 **
 ** Setup of a flash blank check job to be processed when calling the MainFunction().
 ** The function Fls_BlankCheck shall copy the given parameters to FLS module internal
 ** variables, initiate a blank check job, set the FLS module status to MEMIF_BUSY,
 ** set the FLS module job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] Length           Number of bytes to be checked blank
 **
 ** \return    blank check command has been accepted/not been accepted
 ** \retval    E_NOT_OK         blank check command has not been accepted
 **            E_OK             blank check command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_BlankCheckLib
(
    Fls_AddressType TargetAddress,
    Fls_LengthType Length
);

/** \brief Fls_SuspendLib
 **
 ** This function implements suspending in progress Fls operation.
 **
 ** \return    suspend has been accepted/not been accepted
 ** \retval    E_NOT_OK         a Write or an Erase was in progress and could not be
 **                             suspended because another operation was already suspended
 **                             or no Write or Erase operation was in progress
 **            E_OK             a Write or an Erase was in progress and coud be suspended
 **
 */ 
extern FUNC(Std_ReturnType, FLS_CODE) Fls_SuspendLib(void);

/** \brief Fls_ResumeLib
 **
 ** This function implements resuming a suspended Fls operation.
 **
 ** \return    resume has been accepted/not been accepted
 ** \retval    E_NOT_OK         no operation was suspended or the suspended operation
 **                             cannot be resumed because there is a Fls operation
 **                             in progress already
 **            E_OK             an operation was suspended and could be resumed
 **
 */ 
extern FUNC(Std_ReturnType, FLS_CODE) Fls_ResumeLib(void);

/** \brief Fls_SetCycleModeLib
 **
 ** Sets the mode for the timeout checking to SLOW or FAST as given by the
 ** parameter.
 **
 ** \param[in]  Mode    mode to be switched to (SLOW, FAST)
 **
 ** \return     setting mode has been accepted/not been accepted
 ** \retval     E_NOT_OK         setting mode has not been accepted
 **             E_OK             setting mode has been accepted
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_SetCycleModeLib
(
    MemIf_ModeType Mode
);

/** \brief Fls_ReportErrorStatusEraseFailed
 **
 ** This is a wrapper function that calls the DET to report the runtime error
 ** FLS_E_ERASE_FAILED.
 **
 ** \param[in]  EventStatus    Status of the event FLS_E_ERASE_FAILED
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_ReportErrorStatusEraseFailed
(
    const uint8 EventStatus
);

/** \brief Fls_ReportErrorStatusWriteFailed
 **
 ** This is a wrapper function that calls the DET to report the runtime error
 ** FLS_E_WRITE_FAILED.
 **
 ** \param[in]  EventStatus    Status of the event FLS_E_WRITE_FAILED
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_ReportErrorStatusWriteFailed
(
    const uint8 EventStatus
);

/** \brief Fls_ReportErrorStatusReadFailed
 **
 ** This is a wrapper function that calls the DET to report the runtime error
 ** FLS_E_READ_FAILED.
 **
 ** \param[in]  EventStatus    Status of the event FLS_E_READ_FAILED
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_ReportErrorStatusReadFailed
(
    const uint8 EventStatus
);

/** \brief Fls_ReportErrorStatusCompareFailed
 **
 ** This is a wrapper function that calls the DET to report the runtime error
 ** FLS_E_COMPARE_FAILED.
 **
 ** \param[in]  EventStatus    Status of the event FLS_E_COMPARE_FAILED
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_ReportErrorStatusCompareFailed
(
    const uint8 EventStatus
);

/** \brief Fls_EnterCritiSec
 **
 ** Enters critical section. (call SchM module)
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_EnterCritiSec(void);

/** \brief Fls_ExitCritiSec
 **
 ** Exits critical section. (call SchM module)
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_ExitCritiSec(void);

/** \brief Fls_ReportError
 **
 ** Reports error to the DET. (call Det module)
 **
 ** \param[in] ModuleId         The Module ID
 ** \param[in] InstanceId       The Instance ID
 ** \param[in] ApiId            The API ID
 ** \param[in] ErrorId          The Error ID
 **
 ** \return    Result
 ** \retval    E_OK             always E_OK (is required for services)
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_ReportError
(
    VAR(uint16, AUTOMATIC) ModuleId,
    VAR(uint8, AUTOMATIC) InstanceId,
    VAR(uint8, AUTOMATIC) ApiId,
    VAR(uint8, AUTOMATIC) ErrorId
);

/** \brief Fls_ReportFault
 **
 ** Reports fault to the DET and the user callback if configured.
 **
 ** \param[in] CurrentJob       Type of current job
 ** \param[in] ModuleId         The Module ID
 ** \param[in] InstanceId       The Instance ID
 ** \param[in] ApiId            The API ID
 ** \param[in] Fault            The fault information
 **
 ** \return    none
 **
 */
extern FUNC(void, FLS_CODE) Fls_ReportFault
(
    VAR(Fls_JobType, AUTOMATIC) CurrentJob,
    VAR(uint16, AUTOMATIC) ModuleId,
    VAR(uint8, AUTOMATIC) InstanceId,
    VAR(uint8, AUTOMATIC) ApiId,
    VAR(Fls_FaultType, AUTOMATIC) Fault
);

/** \brief Fls_IpcIntrMask
 **
 ** Sets mask of IPC interrupt structure used for eCT Flash safety mechanism.
 **
 ** \return    none
 **
 */
extern FUNC(void, FLS_CODE) Fls_IpcIntrMask(void);

/** \brief Fls_IpcLock
 **
 ** Acquires and locks IPC structure used for eCT Flash safety mechanism.
 **
 ** \return    result of locking
 ** \retval    FLS_TRUE     succeeded
 ** \retval    FLS_FALSE    failed
 **
 */
extern FUNC(uint8, FLS_CODE) Fls_IpcLock(void);

/** \brief Fls_IpcRelease
 **
 ** Releases IPC structure used for eCT Flash safety mechanism.
 **
 ** \param[in]  NotifyKind  Notification for embedded flash
 ** \param[in]  BroadNotify Notification to all IPC (FLS_TRUE) or not (FLS_FALSE)
 **
 ** \return    none
 **
 */
extern FUNC(void, FLS_CODE) Fls_IpcRelease
(
    uint32 NotifyKind,
    uint8  BroadNotify
);

/** \brief Fls_IpcNotify
 **
 ** Notifies IPC structure used for eCT Flash safety mechanism.
 **
 ** \param[in]  Kind    Kind for notification
 **
 ** \return    none
 **
 */
extern FUNC(void, FLS_CODE) Fls_IpcNotify
(
    uint32 Kind
);

/** \brief Fls_IpcListen
 **
 ** Listens IPC structure used for eCT Flash safety mechanism.
 **
 ** \return    none
 **
 */
extern FUNC(void, FLS_CODE) Fls_IpcListen(void);

/** \brief Fls_SetCoreSpecificData
**
** Sets the specific data for each core.
**
 ** \return    result of setting
 ** \retval    FLS_TRUE     succeeded
 ** \retval    FLS_FALSE    failed
**
*/
extern FUNC(uint8, FLS_CODE) Fls_SetCoreSpecificData(void);

#define FLS_STOP_SEC_CODE
#include <Fls_MemMap.h>

/*==================[internal function definitions]=========================*/

#endif /* if !defined( FLS_LIBINTERFACE_H ) */
/*==================[end of file]===========================================*/
