/** \brief Can_ControllerManager.h
 **
 ** This unit manages one CAN controller (given by parameter).
 **
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef CAN_CONTROLLERMANAGER_H_INCLUDED
#define CAN_CONTROLLERMANAGER_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Std_Types.h>

/*==================[macros]================================================*/

/** Bit mask to set or read the Error Passive status in return value of operation
 Can_ControllerGetErrorStatus. */
#define CAN_CONTROLLER_ERRORSTATUS_ERROR_PASSIVE 0x01u
/** Bit mask to set or read the RX Overflow status in return value of operation
 Can_ControllerGetErrorStatus. */
#define CAN_CONTROLLER_ERRORSTATUS_RX_OVERFLOW 0x10u
/** The maximum value for TX event FIFO index. */
#define CAN_CONTROLLER_EVENT_FIFO_MAX 31u
/** Mask for 11Bit Can ID. */
#define CAN_CONTROLLER_MASK_11BIT 0x000007FFuL
/** Mask for 29 bit Can ID. */
#define CAN_CONTROLLER_MASK_29BIT 0x1FFFFFFFuL
/** The maximum value for RX buffer index. */
#define CAN_CONTROLLER_RX_BUFFER_MAX 63u
/** This value indicates RX/TX FIFO (since TX buffers are in range 0..31 and RX
 buffers are in range 0..63). */
#define CAN_CONTROLLER_RX_FIFO_0 64u
/** This value indicates RX/TX FIFO (since TX buffers are in range 0..31 and RX
 buffers are in range 0..63). */
#define CAN_CONTROLLER_RX_FIFO_1 65u
/** The maximum value for TX buffer index. */
#define CAN_CONTROLLER_TX_BUFFER_MAX 31u
/** This value indicates TX FIFO (since TX buffers are in range 0..31). */
#define CAN_CONTROLLER_TX_FIFO 32u
/** Flag/Mask for the bit that encodes if an ID is extended (bit set) or standard
 (bit not set). */
#define CAN_CONTROLLER_XTD_ID_FLAG 0x80000000uL
/** Flag/Mask for the bit that encodes if an ID should send in FD mode (bit set)
 or classic mode (bit not set). */
#define CAN_CONTROLLER_FD_ID_FLAG 0x40000000uL
/** Mask/Flag for the bit that encodes if the filter is for an extended message
 (bit set) or standard message (bit not set). */
#define CAN_CONTROLLER_MASK_XTD_FIDX 0x80u

/*==================[type definitions]======================================*/

/** \brief typedef  Can_ControllerIdType
 **
 ** This parameter provides the controller ID which is unique in a given CAN Driver.
 ** The value for this parameter starts with 0 and continue without any gaps.
 */
typedef uint8 Can_ControllerIdType;

/** \brief typedef  Can_ControllerObjectHandleType
 **
 ** This type is a virtual base type for RX and TX handles.
 */
typedef uint8 Can_ControllerObjectHandleType;

/** \brief typedef  Can_ControllerRxHandleType
 **
 ** This type is used to identify a RX Buffer index.
 ** If the index is in range of any RX buffer (0..63): A dedicated RX buffer is
 ** identified.
 ** If the index equals CAN_CONTROLLER_RX_FIFO_0 or CAN_CONTROLLER_RX_FIFO_1: the
 ** respective RX Fifo is identified.
 ** other values identify no buffer.
 */
typedef Can_ControllerObjectHandleType Can_ControllerRxHandleType;

/** \brief typedef  Can_ControllerPduIdBufferIndexType
 **
 ** This type is used to identify the PduId Buffer index.
 ** The range depends on the configured number of TxHandles.
 ** Values out of range are identified as no buffer. 
 */
typedef uint8 Can_ControllerPduIdBufferIndexType;

/** \brief typedef  Can_ControllerIcomConfigIdType
 **
 ** This parameter provides the Icom ID which is unique in
 ** a given CAN Driver. The value for this parameter starts
 ** with 1 and continue without any gaps. 
 */
typedef uint8 Can_ControllerIcomConfigIdType;

/** \brief typedef  Can_ClkFrequencyType
 **
 ** Represents the changed clock frequency. The unit has a range of 0...255 in MHz.
 */
typedef uint8 Can_ClkFrequencyType;

/** \brief enum Can_ControllerBufferSizeType
 **
 ** This type defines the size of a buffer or FIFO.
 ** The enumeration values correspond to HW settings.
 */
typedef enum can_controllerbuffersizetype_enum
{
  CAN_CONTROLLER_BUFFER_SIZE_8 = 0u,
  CAN_CONTROLLER_BUFFER_SIZE_12 = 1u,
  CAN_CONTROLLER_BUFFER_SIZE_16 = 2u,
  CAN_CONTROLLER_BUFFER_SIZE_20 = 3u,
  CAN_CONTROLLER_BUFFER_SIZE_24 = 4u,
  CAN_CONTROLLER_BUFFER_SIZE_32 = 5u,
  CAN_CONTROLLER_BUFFER_SIZE_48 = 6u,
  CAN_CONTROLLER_BUFFER_SIZE_64 = 7u
} Can_ControllerBufferSizeType;

/** \brief enum Can_ControllerStatusType
 **
 ** This type represents the states of a Can controller as used in the controller
 ** state machine.
 */
typedef enum can_controllerstatustype_enum
{
  CAN_CONTROLLER_UNINIT = 0,
  CAN_CONTROLLER_STOPPED,
  CAN_CONTROLLER_STARTED,
  CAN_CONTROLLER_SLEEP
} Can_ControllerStatusType;

/** \brief enum Can_ControllerIcomSignalOperationType
 **
 ** This parameter defines the operation, which shall be used to verify 
 ** the signal value creates a wakeup condition.
 */
typedef enum can_controllericomsignaloperationtype_enum
{
  CAN_CONTROLLER_ICOM_AND = 0,
  CAN_CONTROLLER_ICOM_XOR,
  CAN_CONTROLLER_ICOM_GREATER,
  CAN_CONTROLLER_ICOM_SMALLER,
  CAN_CONTROLLER_ICOM_EQUAL
} Can_ControllerIcomSignalOperationType;
 
/** \brief struct Can_ControllerBaudrateConfigType
 **
 ** This is the type of the external data structure containing the bit timing
 ** related initialization data for one CAN controller. The contents of the
 ** initialization data structure are CAN hardware specific.
 */
typedef struct can_controllerbaudrateconfigtype_struct
{
  /** The value by which the CAN prescaler output frequency for Heading part or if no
   bit rate switching is set for all parts is divided for generating the bit time
   quanta. (I.e. there is a global CAN prescaler maintained by Can_ModuleManager,
   and an additional individual prescaler per CAN controller.) The bit time is
   built up from a multiple of this quanta.
   Valid values for the Baud Rate Prescaler are 1 to 1024. */
  CONST(uint16, TYPEDEF) NominalBaudratePrescaler;
  /** The value of the baudrate in kbps. */
  CONST(uint16, TYPEDEF) BaudrateValue;
  /** (Re) Synchronization Jump Width: Valid values are 1 to 16. */
  CONST(uint8, TYPEDEF) SyncJumpWidth;
  /** Time segment before sample point: Valid values are 2 to 64. */
  CONST(uint8, TYPEDEF) TSeg1;
  /** Time segment after sample point: Valid values are 1 to 16. */
  CONST(uint8, TYPEDEF) TSeg2;
  /** Switches support of CAN-FD features for this CAN object on or off.
   TRUE := Valid CAN-FD baudrate settings available and should be used for this
   CAN object.
   FALSE := No valid CAN-FD baudrate settings available. Standard CAN should be
   used for this CAN object. */
  CONST(boolean, TYPEDEF) FdEnabled;
  /** (Re) Synchronization Jump Width for CAN FD: Valid values are 1 to 16. */
  CONST(uint8, TYPEDEF) FdSyncJumpWidth;
  /** Time segment for CAN FD before sample point: Valid values are 2 to 64. */
  CONST(uint8, TYPEDEF) FdTSeg1;
  /** Time segment for CAN FD after sample point: Valid values are 1 to 16. */
  CONST(uint8, TYPEDEF) FdTSeg2;
  /** Specifies if the bit rate switching shall be used for transmissions.
   FALSE := CAN FD frames shall be sent without bit rate switching
   TRUE := CAN FD frames shall be sent with bit rate switching */
  CONST(boolean, TYPEDEF) FdTxBitRateSwitch;
  /** Transceiver delay compensation offset for CAN FD in time quanta of the CAN FD
   clock: Valid values are 0 to 127 (normal range) and 0xFF (compensation is
   disabled). */
  CONST(uint8, TYPEDEF) FdTrcvDelayCompensationOffset;
  /** The value of the FD baudrate in kbps. */
  CONST(uint16, TYPEDEF) FdBaudrateValue;
  /** The value by which the CAN prescaler output frequency for Data section if bit
   rate switching is set is divided for generating the bit time quanta. (I.e.
   there is a global CAN prescaler maintained by Can_ModuleManager, and an
   additional individual prescaler per CAN controller.) The bit time is built up
   from a multiple of this quanta.
   Valid values for the Baud Rate Prescaler are 1 to 1024. */
  CONST(uint16, TYPEDEF) DataBaudratePrescaler;
  /** Unique identifier to identify one baud rate configuration.
   Valid range is 0..65535. */
  CONST(uint16, TYPEDEF) BaudrateConfigId;
} Can_ControllerBaudrateConfigType;

/** \brief struct Can_ControllerBufferCfgType
 **
 ** This type stores configuration data about a dedicated buffer or FIFO hardware.
 */
typedef struct can_controllerbuffercfgtype_struct
{
  /** The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO
   size in elements. */
  CONST(uint8, TYPEDEF) ElementCount;
  /** The size of each field in the buffer or FIFO. */
  CONST(Can_ControllerBufferSizeType, TYPEDEF) ElementSize;
  /** Start address of the buffer or FIFO in bytes relative (offset) to the CAN
   message RAM base address. */
  CONST(uint16, TYPEDEF) StartAddress;
} Can_ControllerBufferCfgType;

/** \brief struct Can_ControllerFilterType
 **
 ** This type stores the one Can controller filter setting.
 */
typedef struct can_controllerfiltertype_struct
{
  /** Configured CanIdValue of the Can filter. */
  VAR(uint32, TYPEDEF) FilterIdValue;
  /** Configured CanHwFilterMask of the Can filter. */
  VAR(uint32, TYPEDEF) FilterMaskValue;
} Can_ControllerFilterType;

/** \brief struct Can_ControllerIcomRxMessageSignalConfigType
 **
 ** This structure contains the configuration parameters for the 
 ** wakeup causes for matching signals.
 */
typedef struct can_controllericomrxmessagesignalconfigtype_struct
{
  /** This parameter shall be used to mask a signal in the payload 
   of a CAN message. */
  CONST(uint64, TYPEDEF) SignalMask;
  /** This parameter shall be used to define a signal value which 
   shall be compared (CanIcomSignalOperation) with the masked 
   CanIcomSignalMask value of the received signal. */
  CONST(uint64, TYPEDEF) SignalValue;
  /** This parameter defines the operation, which shall be used to 
   verify the signal value creates a wakeup condition. */
  CONST(Can_ControllerIcomSignalOperationType, TYPEDEF) SignalOperation;
} Can_ControllerIcomRxMessageSignalConfigType;

/** \brief struct Can_ControllerIcomRxMessageConfigType
 **
 ** This structute contains the configuration parameters for the 
 ** wakeup causes for matching received messages. 
 */
 typedef struct can_controllericomrxmessageconfigtype_struct
{
  /** Pointer to an array of Icom Rx message signal Configurations. */
  CONSTP2CONST(Can_ControllerIcomRxMessageSignalConfigType, TYPEDEF, TYPEDEF) RxMessageSignalCfgPtr;
  /** Number of Icom configuration in the array pointed to by RxMessageSignalCfgPtr. */
  CONST(uint32, TYPEDEF) NumberOfRxMessageSignalCfgPtr;
  /** The message ID the wakeup causes of this CanIcomRxMessage 
   are configured for. */
  CONST(uint32, TYPEDEF) MessageId;
  /** Describes a mask for filtering of CAN identifiers. 
   If RxMessageSignalCfgPtr of CanControllerIcomConfigType 
   is not NULL, ignore the value defined for this member. */
  CONST(uint32, TYPEDEF) MessageMask;
  /** The setting for the MCU to occur if a message with 
   an ID has not been received on a communication channel 
   for a specific time. */
  CONST(uint32, TYPEDEF) MissingMessageTimerValue;
  /** If the message with ID is received n times on the 
   communication channel, the setting for the MCU to wakeup. */
  CONST(uint16, TYPEDEF) CounterValue;
  /** This parameter defines that the MCU shall wake if a 
   payload error occurs. */
  CONST(boolean, TYPEDEF) PayloadLengthError;
} Can_ControllerIcomRxMessageConfigType;

/** \brief struct Can_ControllerIcomConfigType
 **
 ** This structute contains the configuration parameters for the 
 ** wakeup causes for matching received messages. 
 */
 typedef struct can_controllericomconfigtype_struct
{
  /** Pointer to an array of Icom Rx message configurations */
  CONSTP2CONST(Can_ControllerIcomRxMessageConfigType, TYPEDEF, TYPEDEF) RxMessageCfgPtr;
  /** Number of Icom configuration in the array pointed to by RxMessageCfgPtr. */
  CONST(uint32, TYPEDEF) NumberOfRxMessageCfgPtr;
  /** Id of the Icom configuration. */
  CONST(Can_ControllerIcomConfigIdType, TYPEDEF) ConfigId;
} Can_ControllerIcomConfigType;

/** \brief struct Can_ControllerConfigType
 **
 ** This type stores the configuration data for one CAN controller.
 */
typedef struct can_controllerconfigtype_struct
{
  /** Pointer to an array of baudrates. */
  CONSTP2CONST(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) BaudratesCfgPtr;
  /** Id of the controller. */
  CONST(Can_ControllerIdType, TYPEDEF) ControllerId;
  /** Pointer to the default baudrate setting. */
  CONSTP2CONST(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) DefaultBaudratePtr;
  /** Configuration of the TX Event FIFO. The FIFO element size is ignored, because
   it is fixed to 8 bytes. */
  CONST(Can_ControllerBufferCfgType, TYPEDEF) EventFifo;
  /** Address offset to the message RAM base address where the filters for extended
   messages shall be located. */
  CONST(uint16, TYPEDEF) FiltersExtendedAddressOffset;
  /** Address offset to the message RAM base address where the filters for standard
   messages shall be located. */
  CONST(uint16, TYPEDEF) FiltersStandardAddressOffset;
  /** Specifies if bus-off handling shall be done in interrupt mode (true) or polling
   mode (false). */
  CONST(boolean, TYPEDEF) InterruptEnableBusOff;
  /** Specifies if RX handling shall be done in interrupt mode (true) or polling mode
   (false). */
  CONST(boolean, TYPEDEF) InterruptEnableRx;
  /** Specifies if TX handling shall be done in interrupt mode (true) or polling mode
   (false). */
  CONST(boolean, TYPEDEF) InterruptEnableTx;
  /** Specifies if wakeup handling shall be done in interrupt mode (true) or polling
   mode (false). */
  CONST(boolean, TYPEDEF) InterruptEnableWakeup;
  /** Pointer to the base address of the Message RAM. It must point to the hardware
   base address, even if the beginning of the message RAM is not used by this
   controller. */
  CONSTP2VAR(uint8, TYPEDEF, TYPEDEF) MessageRamBasePtr;
  /** Message RAM size in 1 Can Instance. It is not Message RAM size occupied
   by 1 channel. */
  CONST(uint32, TYPEDEF) MessageRamSize;
  /** Number of baudrates in the array of baudrates pointed to by BaudratesCfgPtr. */
  CONST(uint8, TYPEDEF) NumberOfBaudrates;
  /** Base address of the CAN FD controller's registers. */
  CONST(uint32, TYPEDEF) RegisterBaseAddress;
  /** Configuration of the dedicated RX buffers. The ElementCount equals the number
   of filter settings in the filter settings list. */
  CONST(Can_ControllerBufferCfgType, TYPEDEF) RxBuffers;
  /** Pointer to an array of CAN IDs. There is one ID per dedicated RX buffer; the
   order is the same as the buffers (same index).  */
  CONSTP2CONST(uint32, TYPEDEF, TYPEDEF) RxBuffersFiltersPtr;
  /** Configuration of the RX FIFO 0. */
  CONST(Can_ControllerBufferCfgType, TYPEDEF) RxFifo0;
  /** Array of different Can filter settings for the RX FIFO 0. */
  CONSTP2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) RxFifo0FiltersPtr;
  /** Number of RxFifo0 filters stored in array RxFifo0FiltersPtr. */
  CONST(uint8, TYPEDEF) RxFifo0FilterElementCount;
  /** Configuration of the RX FIFO 1. */
  CONST(Can_ControllerBufferCfgType, TYPEDEF) RxFifo1;
  /** Array of different Can filter settings for the RX FIFO 1. */
  CONSTP2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) RxFifo1FiltersPtr;
  /** Number of RX FIFO 1 filters stored in array RxFifo1FiltersPtr. */
  CONST(uint8, TYPEDEF) RxFifo1FilterElementCount;
  /** Configuration of the dedicated TX buffers. */
  CONST(Can_ControllerBufferCfgType, TYPEDEF) TxBuffers;
  /** Configuration of the TX FIFO element count. The FIFO element size and start
   offset are shared with the dedicated TX Buffers. */
  CONST(uint8, TYPEDEF) TxFifoElementCount;
  /** The wakeup source id that is passed to EcuM_CheckWakeup. */
  CONST(uint32, TYPEDEF) WakeupSource;
  /** Channel number excluding CanInstance number. */
  CONST(uint8, TYPEDEF) ChannelNumber;
  /** Indicates whether ECC error detection can be enabled. */
  CONST(boolean, TYPEDEF) EccPresentEnable;
} Can_ControllerConfigType;

/** \brief struct Can_ControllerIcomStateDataType
 **
 ** This type stores the runtime Icom state data for one CAN controller.
 */
typedef struct can_controllericomstatedatatype_struct
{ 
  /** Pointer to the Icom config structure that is currently active for the 
   controller. */
  P2CONST(Can_ControllerIcomConfigType, TYPEDEF, TYPEDEF) IcomConfigPtr;
  /** Pointer to the RxMessage Counters structure */
  P2VAR(uint16, TYPEDEF, TYPEDEF) CanRxMessageCountersPtr;
  /** Current status of the CAN controller. */
  VAR(boolean, TYPEDEF) IsPretended;
  /** Wakeup flag in pretended networking mode(TRUE=Wokeup, FALSE=Not wakeup). */
  VAR(boolean, TYPEDEF) IsWakeup;
  /** Pretended networking mode start time. */
  VAR(uint32, TYPEDEF) StartTime;
} Can_ControllerIcomStateDataType;

/** \brief struct Can_ControllerBaudrateDataType
 **
 ** Pointer to the baudrate config structure that is currently active for the controller. 
 ** And, normal prescaler and data prescaler calculated based on the changed clock value are stored.
 */
typedef struct can_controllerbaudratedatatype_struct
{
  /** Pointer to the baudrate config structure that is currently active for the
   controller. */
  P2CONST(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) BaudratePtr;
  /** The value by which the CAN prescaler output frequency for Heading part or if no
   bit rate switching is set for all parts is divided for generating the bit time
   quanta. (I.e. there is a global CAN prescaler maintained by Can_ModuleManager,
   and an additional individual prescaler per CAN controller.) The bit time is
   built up from a multiple of this quanta.
   Valid values for the Baud Rate Prescaler are 1 to 1024. */
  VAR(uint16, TYPEDEF) NominalPrescaler;
  /** The value by which the CAN prescaler output frequency for Data section if bit
   rate switching is set is divided for generating the bit time quanta. (I.e.
   there is a global CAN prescaler maintained by Can_ModuleManager, and an
   additional individual prescaler per CAN controller.) The bit time is built up
   from a multiple of this quanta.
   Valid values for the Baud Rate Prescaler are 1 to 2. */
  VAR(uint16, TYPEDEF) DataPrescaler;
} Can_ControllerBaudrateDataType;

/** \brief struct Can_ControllerStateDataType
 **
 ** This type stores the runtime state data for one CAN controller.
 */
typedef struct can_controllerstatedatatype_struct
{
  /** Pointer to the baudrate config structure that is currently active for the
   controller. And, normal prescaler and data prescaler calculated based on the 
   changed clock value are stored */
  VAR(Can_ControllerBaudrateDataType, TYPEDEF) BaudrateData;
  /** Stores the nesting level of Can_Disable/EnableControllerInterrupts. */
  VAR(uint8, TYPEDEF) InterruptDisableLevel;
  /** Current status of the CAN controller. */
  VAR(Can_ControllerStatusType, TYPEDEF) Status;
  /** This flag is set, when a wakeup was detected and it is reset on a STOPPED-
   >SLEEP transition. */
  VAR(boolean, TYPEDEF) WakeupDetected;
  /** Stores the data lost event (RX overflow) occurrence. */
  VAR(boolean, TYPEDEF) IsRxOverflow;
  /** This flag is set, when Message RAM was initialized. */
  VAR(boolean, TYPEDEF) IsMRamInit;
  /** Icom config structure that is currently active for the controller. */
  VAR(Can_ControllerIcomStateDataType, TYPEDEF) IcomState;
} Can_ControllerStateDataType;

/** \brief struct Can_ControllerPduInfoType
 **
 ** This type stores the PduInfo structure values to send via CAN and to be
 ** independent of an external type inside the library.
 */
typedef struct can_controllerpduinfotype_struct
{
  /** CanId of the CAN message.
   Bits 28..0: The left aligned Can ID of the message.
   Bit 30: indicates if the CAN message is a CAN FD frame (1) or standard CAN
   message (0).
   Bit 31: indicates if the id is extended (1) or standard (0). */
  VAR(uint32, TYPEDEF) CanId;
  /** Number of bytes to send via CAN from DataPtr. */
  VAR(uint8, TYPEDEF) Length;
  /** Data pointer to SDU data to send via CAN. */
  P2VAR(uint8, TYPEDEF, TYPEDEF) DataPtr;
} Can_ControllerPduInfoType;

/*==================[external function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

/** \brief Can_ControllerDisableInterrupts
 **
 ** Disables all interrupts for the given controller.
 ** Nesting is supported.
 **
 ** \return   E_NOT_OK: The maximum nesting level was exceeded, the nesting level
 **                     has not been updated.
 **           E_OK: normal operation.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to state data, which contains
 **                                         the nesting level.
 **
 */
extern FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerDisableInterrupts
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

/** \brief Can_ControllerEnableInterrupts
 **
 ** Enables all interrupts for the given controller, if nesting has ended.
 ** Nesting is supported.
 **
 ** \return   E_NOT_OK: Minimum nesting level exceeded, the nesting level has not
 **                     been updated.
 **           E_OK: normal operation.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to state data, which contains
 **                                         the nesting level.
 **
 */
extern FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerEnableInterrupts
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

/** \brief Can_ControllerEnterInterrupt
 **
 ** Prepares the CAN controller for ISR execution.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerEnterInterrupt
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerGetStatus
 **
 ** Returns the current controller status.
 ** The status is calculated from the SW and HW status:
 ** - STARTED: HW and SW are started (i.e. HW is ready and mode indication was
 **            sent)
 ** - SLEEP: HW and SW are in sleep (i.e. HW is ready and mode indication was
 **          sent)
 ** - UNINIT: SW is uninitialized.
 ** - STOPPED: else (i.e. HW and SW in stopped; HW stopped and SW started but bus-
 **            off indication missing; HW started and SW stopped but mode indication
 **            missing)
 **
 ** \return The current controller state.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 **
 */
extern FUNC(Can_ControllerStatusType, AUTOMATIC) Can_ControllerGetStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

/** \brief Can_ControllerGetWakeup
 **
 ** Checks if a wake-up event has been logged since last sleep transition.
 **
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \return   TRUE: Wakeup has appeared since last sleep transition.
 **           FALSE: Wakeup has not appeared since last wakeup transition.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ControllerGetWakeup
(
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

/** \brief Can_ControllerHandleBusOff
 **
 ** Checks if a bus-off event has appeared. In this case the HW has already stopped
 ** itself, but the SW status is still STARTED.
 ** NOTE: The order of the BusOffIndication and the error report is important.
 **       First the error must be reported and than the BusOffIndcation must
 **       be done due to in the BusOffIndication function call the controller
 **       could be started again and the error is reported in the wrong
 **       controller state.
 **
 ** \return   Returns a bus-off event.
 **           TRUE:  bus-off event detected.
 **           FALSE: bus-off event no detected.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STOPPED
 **                                     if a bus-off event was detected.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ControllerHandleBusOff
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerHandleUncorrectableBitError
 **
 ** Checks if an uncorrectable bit error has appeared. In this case the HW has 
 ** already stopped itself, but the SW status is still STARTED.
 **
 ** \return   Returns an error indication that an uncorrectable bit error in
 **           Message RAM is detected.
 **           TRUE: uncorrectable bit error is detected
 **           FALSE: no error is detected
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STOPPED
 **                                     if an uncorrectable bit error was detected.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ControllerHandleUncorrectableBitError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerHandleMode
 **
 ** Forwards the mode check to mode handler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to
 **                                     STARTED or SLEEP if the respective event
 **                                     was detected.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerHandleMode
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerHandleRx
 **
 ** Forward received event to RX handler.
 **
 ** \return   E_OK: No error was detected,
 **           E_NOT_OK: Message lost error was detected. (Reception was still
 **           conducted.)
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
extern FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerHandleRx
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(uint8, AUTOMATIC) ApiId
);

/** \brief Can_ControllerHandleTx
 **
 ** Forward transmitted event and canceled event to TX handler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerHandleTx
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerHandleWakeup
 **
 ** Checks for wakeup events.
 ** The function is intended to be called on ISR, MainFunction_Wakeup and Init.
 ** If a wakeup event is detected, EcuM_SetWakeupEvent is notified and the wakeup
 ** event is stored to the controller state data for later reference by
 ** Can_CheckWakeup.
 ** If no wakeup was detected, the event is cleared from the controller's state
 ** data.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STOPPED
 **                                     if a wakeup was detected.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerHandleWakeup
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerSetBaudrate
 **
 ** Stores the baudrate setting so that it is applied at future controller starts.
 **
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] BaudratePtr   Pointer to the baudrate structure that shall be
 **                           stored.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerSetBaudrate
(
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) BaudratePtr
);

/** \brief Can_ControllerSetBaudrateInChangedClock
 **
 ** Stores the baudrate and normal/data prescaler settings so that it is 
 ** applied at future controller starts.
 **
 ** \return   E_OK: No error was detected,
 **           E_NOT_OK: As a result of calculating the prescaler, it was a 
 **                     value that can not be set in the register.
 **
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] BaudratePtr   Pointer to the baudrate structure that shall be
 **                           stored.
 ** \param [in] ClockFrequency   Changed clock[MHz]
 **
 */
extern FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerSetBaudrateInChangedClock
(
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) BaudratePtr,
  VAR(Can_ClkFrequencyType, AUTOMATIC) ClockFrequency
);

/** \brief Can_ControllerSleep
 **
 ** Initiates the asynchronous transition from STOPPED to SLEEP.
 ** Resets the wake-up flag.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerSleep
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerStart
 **
 ** Initiates the asynchronous transition from STOPPED to STARTED.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerStart
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerGetErrorStatus
 **
 ** Gets the status if an RxOverflow event and/or status ErrorPassive is occurred.
 ** 
 ** The detected RxOverflow is returned only once. After reporting the RxOverflow
 ** is cleared till next RxOverflow event is detected.
 **
 ** \return   BitField containing following independent flags:
 **           0x00: status is undefined (e.g. the conditions above have not occurred,
 **                 or CAN controller is not in state STARTED)
 **           CAN_STATUS_ERROR_PASSIVE: This flag is returned as long as the error
 **                                     counters of the CAN macro indicate that
 **                                     the controller is in the error passive
 **                                     state. The status is updated on every
 **                                     Can_GetStatus() call.
 **           CAN_STATUS_RX_OVERFLOW: The update of the internal state for
 **                                   Can_GetStatus() happens every time new data
 **                                   has been received by this controller and has
 **                                   been processed by the corresponding function
 **                                   (Can_MainFunction_Read() call in case of
 **                                   polling mode configuration, or on every CAN
 **                                   RX interrupt in case of IRQ mode configuration).
 **                                   This flag is only returned once, if during
 **                                   subsequent calls to Can_GetStatus() no new
 **                                   RX overflow condition occurred.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
extern FUNC(uint8, AUTOMATIC) Can_ControllerGetErrorStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerStop
 **
 ** Performs the synchronous transition to STOPPED from any status.
 **
 **\param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerStop
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ControllerTranslateDlcToLength
 **
 ** Translates the DLC value set in RX/TX message in message RAM to an integer
 ** number in bytes.
 **
 ** \param [in] DlcCode   The DLC code that shall be translated to a length.
 ** \return   Message length in bytes.
 **
 */
extern FUNC(uint8, AUTOMATIC) Can_ControllerTranslateDlcToLength
(
  VAR(uint8, AUTOMATIC) DlcCode
);

/** \brief Can_ControllerTranslateFieldSize
 **
 ** Translates the field size from enumeration to integer number in bytes.
 **
 ** \param [in] FieldSize   The size that shall be translated.
 ** \return   The size in bytes.
 **
 */
extern FUNC(uint8, AUTOMATIC) Can_ControllerTranslateFieldSize
(
  VAR(Can_ControllerBufferSizeType, AUTOMATIC) FieldSize
);

/** \brief Can_ControllerTranslateLengthToDlc
 **
 ** Translates the message length in bytes to the DLC code to set in RX/TX messages
 ** in message RAM.
 **
 ** \param [in] MessageLength   The message length in bytes that shall be translated
 **                             to the DLC code.
 ** \return   DLC code used in message RAM.
 **
 */
extern FUNC(uint8, AUTOMATIC) Can_ControllerTranslateLengthToDlc
(
  VAR(uint8, AUTOMATIC) MessageLength
);

/** \brief Can_ControllerWrite
 **
 ** Forward write request to TX handler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller configuration
 **                                structure.
 ** \param [in] ControllerStatePtr   Pointer to the controller state data 
 **                                  structure.
 ** \param [in] PduIdBufferIndex   The PduIdBufferIndex to know the right index
 **                                where the PduId of the TX object is stored in
 **                                buffer. Required to write to the MM field in
 **                                FIFO.
 ** \param [in] PduInfoPtr   Pointer to PduInfo structure for CanId, data length
 **                          and SDU data pointer.
 ** \param [in] TxHandle   Gives the dedicated TX Buffer number used for
 **                        transmission or that the FIFO is used for transmission.
 **                        0..31 stays for a dedicated TX buffer, values higher
 **                        than 31 stays for FIFO in use.
 ** \param [in] PaddingValue   Value to add for padding bytes in CAN message.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerWrite
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  P2CONST(Can_ControllerPduInfoType, AUTOMATIC, AUTOMATIC) PduInfoPtr,
  VAR(uint8, AUTOMATIC) TxHandle,
  VAR(uint8, AUTOMATIC) PaddingValue
);

/** \brief Can_ControllerSetTxCancelRequest
 **
 ** Operation to forward cancel request to ModeHandler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 ** \param [in] BufferIndex   Index of the TX buffer to cancel.
 ** \param [in] NormalizedNewCanId   CanID of the new message to send. This CanId
 **                                  is normalized, that means that the standard
 **                                  CanIds are left shifted to align with the
 **                                  extended CanIds.
 ** \param [in] IsCancelSameId   Select cancel strategy.
 **                              TRUE := cancellation allowed for same CanId
 **                              FALSE := cancellation allowed if new CanId is
 **                                       smaller than CanId of pending TX message.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerSetTxCancelRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferIndex,
  VAR(uint32, AUTOMATIC) NormalizedNewCanId,
  VAR(boolean, AUTOMATIC) IsCancelSameId
);

/** \brief Can_ControllerReset
 **
 ** Operation to forward cancel request to ModeHandler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerReset
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerSetTxRxConfiguration
 **
 ** Set Tx and Rx configurations.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerSetTxRxConfiguration
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerClearTxData
 **
 ** Clear Tx Data.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerClearTxData
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerEnableEccControl
 **
 ** Enable ECC control.
 ** It must be an MRAM that can enable ECC error detection.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerEnableEccControl
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerSetRxFifoTopPointer
 **
 ** Set Rx FIFO 0/1 Top Pointer.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerSetRxFifoTopPointer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerEnableInterruptProtocolError
 **
 ** Enable interrupt by error frame detection only when enabling pretended networking 
 ** mode under the condition that CanIcomPayloadLengthError is valid.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerEnableInterruptProtocolError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ControllerDisableInterruptProtocolError
 **
 ** Disable interrupt protocol error.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ControllerDisableInterruptProtocolError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

#define CAN_STOP_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

#endif /**defined(CAN_CONTROLLERMANAGER_H_INCLUDED)*/

/*==================[end of file]===========================================*/
