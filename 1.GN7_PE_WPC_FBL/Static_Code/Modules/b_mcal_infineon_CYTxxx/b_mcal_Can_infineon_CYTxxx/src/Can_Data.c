/** \brief Can_Data.c
 **
 ** Implementation of data that is depending on the configuration or any type or
 ** data imported from another module.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can_Data.h>
#include <Can_Cfg.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"
/** \brief Can_DataGetTranslateTxHandle
 **
 ** Get translates TX HW handle (HTH) to the controller ID and TX object handle index.
 **
 ** \return   CAN_OK: Translation was successful, the output parameters are set.
 **           CAN_BUSY: No free slot in message queue, the output parameters cannot
 **                     be used.
 **
 ** \param [in] TxHwHandle   The TX HW handle that shall be translated.
 ** \param [out] ControllerIndexPtr   Pointer to the variable that will be set to
 **                                   the ControllerId that corresponds to the HW
 **                                   handle.
 ** \param [out] PduIdBufferIndexPtr   Pointer to the variable that will be set to
 **                                    the PduId buffer index.
 ** \param [out] TriggerTransmitEnablePtr   Pointer to the variable that will be
 **                                         set to the TriggerTransmitEnable value
 **                                         configured for this HW object.
 ** \param [out] PaddingValuePtr   Pointer to the variable that will be set to the
 **                                PaddingValue value configured for this HW object.
 ** \param [out] TxHandlePtr   Returns in this parameter the buffer handle for the
 **                            TX message. Possible values are only 0..31 and
 **                            CAN_CONTROLLER_TX_FIFO.
 */
 static FUNC(Can_ReturnType, AUTOMATIC) Can_DataGetTranslateTxHandle
 (
  VAR(Can_HwHandleType, AUTOMATIC) TxHwHandle,
  P2VAR(Can_ControllerIdType, AUTOMATIC, AUTOMATIC) ControllerIndexPtr,
  P2VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC, AUTOMATIC) PduIdBufferIndexPtr,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) TriggerTransmitEnablePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PaddingValuePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) TxHandlePtr
);

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal constants]====================================*/

#define CAN_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"



/** Pointer to Can_ConfigType structure. */
static P2CONST(Can_ConfigType, AUTOMATIC, AUTOMATIC) Can_ConfigSetPtr = NULL_PTR;

#define CAN_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_DataSetControllerConfig
 **
 ** Set a pointer to the controller config.
 **
 ** \param [in] Config   Pointer to the controller config structure pointer.
 **
 */
FUNC(void, AUTOMATIC) Can_DataSetControllerConfig
(
  P2CONST(Can_ConfigType, AUTOMATIC, AUTOMATIC) Config
)
{
  Can_ConfigSetPtr = Config;
}

/** \brief Can_DataGetNumberOfControllerConfig
 **
 ** Returns a number of the controller config.
 **
 ** \return   Number of the controller config.
 **
 */
FUNC(uint8, AUTOMATIC) Can_DataGetNumberOfControllerConfig(void)
{
  return Can_ConfigSetPtr->NumberOfControllers;
}

 
/** \brief Can_DataGetControllerConfig
 **
 ** Returns a pointer to the controller config.
 **
 ** \return   Pointer to the controller config structure.
 **           NULL_PTR if the id is not in range.
 ** \param [in] ControllerIndex   Index of the controller whose config shall be
 **                               retrieved.
 **
 */
FUNC_P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) Can_DataGetControllerConfig
(
  VAR(Can_ControllerIdType, AUTOMATIC) ControllerIndex
)
{
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) resultPtr;
  
  if (Can_ConfigSetPtr->NumberOfControllers > ControllerIndex)
  {
    /* ControllerIndex is in range. */
    resultPtr = &(Can_ConfigSetPtr->Can_ControllerConfigsPtr[ControllerIndex]);
  }
  else
  {
    /* ControllerIndex is out of range. */
    resultPtr = (P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)) NULL_PTR;
  }
  
  return resultPtr;
}

/** \brief Can_DataGetControllerIcomConfig
 **
 ** Returns a pointer to the controller config.
 **
 ** \return   Pointer to the controller config structure.
 **           NULL_PTR if the id is not in range.
 ** \param [in] IcomConfigId   Index of the controller whose config shall be
 **                               retrieved.
 **
 */
FUNC_P2CONST(Can_ControllerIcomConfigType, AUTOMATIC, AUTOMATIC) Can_DataGetControllerIcomConfig
(
  VAR(IcomConfigIdType, AUTOMATIC) IcomConfigId
)
{
  P2CONST(Can_ControllerIcomConfigType, AUTOMATIC, AUTOMATIC) resultPtr;
  
  resultPtr = (P2CONST(Can_ControllerIcomConfigType, AUTOMATIC, AUTOMATIC)) NULL_PTR;
  
  if    ((IcomConfigId > 0u)
     && ((IcomConfigIdType)Can_ConfigSetPtr->NumberOfIcomConfigs > (IcomConfigId-1u)))
  {
    /* IcomConfigIndex is in range. */
    resultPtr = &(Can_ConfigSetPtr->Can_ControllerIcomConfigsPtr[IcomConfigId-1u]);
  }
  
  return resultPtr;
}

/** \brief Can_DataGetIcomRxMessageCountersPtr
 **
 ** Returns a pointer to the Can_IcomRxMessageCounters array data.
 **
 ** \return   pointer to the Can_IcomRxMessageCounters array data.
 **           NULL_PTR if the CAN_CFG_NUMBER_OF_ICOM_RX_MESSAGES is not defined.
 ** \param [in] IcomConfigId   Index of the controller whose state data shall be
 **                            retrieved.
 **
 */
FUNC_P2VAR(uint16, AUTOMATIC, AUTOMATIC) Can_DataGetIcomRxMessageCountersPtr
(
  VAR(IcomConfigIdType, AUTOMATIC) IcomConfigId
)
{
  uint8 index;
  uint32 NumberOfRxMessage = 0u;
  
  for (index=0u; Can_ConfigSetPtr->NumberOfIcomConfigs>index; index++)
  {
    if (index < (uint8)(IcomConfigId-1u))
    {
      NumberOfRxMessage += Can_ConfigSetPtr->Can_ControllerIcomConfigsPtr[index].NumberOfRxMessageCfgPtr;
    }
  }
  
  return &(Can_ConfigSetPtr->Can_IcomRxMessageCountersPtr[NumberOfRxMessage]);

}

/** \brief Can_DataGetControllerStateData
 **
 ** Returns a pointer to the controller state data.
 **
 ** \return   Pointer to the controller state data structure.
 **           NULL_PTR if the id is not in range.
 ** \param [in] ControllerIndex   Index of the controller whose state data shall be
 **                               retrieved.
 **
 */
FUNC_P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) Can_DataGetControllerStateData
(
  VAR(Can_ControllerIdType, AUTOMATIC) ControllerIndex
)
{
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) resultPtr;
  
  if (Can_ConfigSetPtr->NumberOfControllers > ControllerIndex)
  {
    /* ControllerIndex is in range. */
    resultPtr = &(Can_ConfigSetPtr->Can_ControllerStatesPtr[ControllerIndex]);
  }
  else
  {
    /* ControllerIndex is out of range. */
    resultPtr = (P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC)) NULL_PTR;
  }
  
  return resultPtr;
}

/** \brief Can_DataGetTxPduId
 **
 ** Reads the swPduId (whose type is imported from ComStackTypes) that was
 ** previously stored by Can_StorePduId for reference in the Tx confirmation. The
 ** item is identified by PduIdBufferIndex.
 **
 ** \return   The PduId that was stored.
 ** \param [in] PduIdBufferIndex   Index of the PduId buffer where the message was
 **                                stored. The valid range depends on amount of
 **                                configured CAN controllers.
 **
 */
FUNC(PduIdType, AUTOMATIC) Can_DataGetTxPduId
(
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex
)
{
  PduIdType PdiId;
  
  /* Can_PduIdBuffer is a buffer and is the message queue. Here each controller
   * has its own slot to queue its 32 messages. For Controller 0 the buffer
   * entries 0..31 is reserved, for Controller 1 the buffer entries 32..63 is
   * reserved etc.. The size is an uint8 within maximum 8 Controllers can be
   * queued there messages. */
   if (Can_ConfigSetPtr->NumberOfTxBuffers > 0u)
   {
      PdiId = Can_ConfigSetPtr->Can_PduIdBufferPtr[PduIdBufferIndex];
   }
   else
   {
      PdiId = 0u;
   }
   
   return PdiId;
}

/** \brief Can_DataReset
 **
 ** Resets all variables to initial values (0).
 **
 */
FUNC(void, AUTOMATIC) Can_DataReset(void)
{
  uint8 index;
  
  for (index = 0u; Can_ConfigSetPtr->NumberOfControllers > index; index++)
  {
    /* Reset all Can_ControllerStates. */
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].BaudrateData.NominalPrescaler = 0u;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].BaudrateData.DataPrescaler    = 0u;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].BaudrateData.BaudratePtr      = 
                                                 (P2CONST(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF)) NULL_PTR;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].InterruptDisableLevel    = 0u;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].Status                   = CAN_CONTROLLER_UNINIT;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].WakeupDetected           = FALSE;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IsRxOverflow             = FALSE;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IsMRamInit               = FALSE;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IcomState.IcomConfigPtr            = 
                                                     (P2CONST(Can_ControllerIcomConfigType, TYPEDEF, TYPEDEF)) NULL_PTR;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IcomState.CanRxMessageCountersPtr  = 
                                                                             (P2VAR(uint16, TYPEDEF, TYPEDEF)) NULL_PTR;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IcomState.IsPretended              = FALSE;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IcomState.IsWakeup                 = FALSE;
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IcomState.StartTime                = 0u;
  }

  /* Reset all entries in PduIdBuffer. */
  for (index = 0u; Can_ConfigSetPtr->NumberOfTxBuffers > index; index++)
  {
    /* Can_PduIdBuffer is a buffer and is the message queue. Here each controller
     * has its own slot to queue its 32 messages. For Controller 0 the buffer
     * entries 0..31 is reserved, for Controller 1 the buffer entries 32..63 is
     * reserved etc.. The size is an uint8 within maximum 8 Controllers can be
     * queued there messages. */
    Can_ConfigSetPtr->Can_PduIdBufferPtr[index] = CAN_DATA_FREE_PDUID_BUFFER_SLOT;
  }

}

/** \brief Can_DataStoreTxPduId
 **
 ** Stores the swPduId (whose type is imported from ComStackTypes) of a TX
 ** message for later reference in the TX confirmation. The item is identified by
 ** PduIdBufferIndex.
 **
 ** \param [in] PduIdBufferIndex   Index of the PduIdTX buffer where the message
 **                                was stored. Valid range depends on configured
 **                                CAN Controller.
 ** \param [in] PduId   The PduId that shall be stored.
 **
 */
FUNC(void, AUTOMATIC) Can_DataStoreTxPduId
(
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  VAR(PduIdType, AUTOMATIC) PduId
)
{
  /* The calling function (Can_Write) assures that and PduIdBufferIndex is in 
     range. Therefore the error check does not need to be repeated here. */
  Can_ConfigSetPtr->Can_PduIdBufferPtr[PduIdBufferIndex] = PduId;
}

/** \brief Can_DataTranslateRxHandle
 **
 ** Translates the controller ID and RX object handle index to HW handle (HRH).
 **
 ** \return   E_OK: Translation was successful, the output parameters are set.
 **           E_NOT_OK: The provided HW handle does not correspond to a hardware
 **                     entity, the output parameters cannot be used.
 ** \param [in] ControllerIndex   ControllerId that corresponds to the HW handle.
 ** \param [in] RxHandle   RX object handle.
 ** \param [in] IsPretended   Flag indicating whether pretended networking mode 
 **                           is enable.
 ** \param [out] RxHwHandlePtr   Pointer to the RX HW handle that was received.
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_DataTranslateRxHandle
(
  VAR(Can_ControllerIdType, AUTOMATIC) ControllerIndex,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) RxHandle,
  VAR(boolean, AUTOMATIC) IsPretended,
  P2VAR(Can_HwHandleType, AUTOMATIC, AUTOMATIC) RxHwHandlePtr
)
{
  Std_ReturnType result = E_NOT_OK;

  /* If there are no RX handles, searching is not possible. */
  if (Can_ConfigSetPtr->NumberOfRxHandleMappings > 0u)
  {
    /* Binary search in Can_RxHandleMappings */
    uint16 leftIndex = 0u;
    uint16 rightIndex = Can_ConfigSetPtr->NumberOfRxHandleMappings; /* This index is never accessed. */
    
    while (leftIndex < rightIndex)
    {
      /* middleIndex can equal leftIndex, if leftIndex==rightIndex-1. 
         But middleIndex is always smaller than rightIndex. 
         Hence the loop must terminate after a finite number of iterations. */
      uint16 middleIndex = (leftIndex + rightIndex) >> 1u;
      
      if (Can_ConfigSetPtr->Can_RxHandleMappingsPtr[middleIndex].ControllerIndex == ControllerIndex)
      {
        /* ControllerIndex is same. --> Check RxHandle. */
        if (Can_ConfigSetPtr->Can_RxHandleMappingsPtr[middleIndex].RxHandle == RxHandle)
        {
          /* Item found --> end search. */
          leftIndex = middleIndex;
          rightIndex = middleIndex;
        }
        else
        {
          /* RxHandle is different. --> Narrow search and continue. */
          if (Can_ConfigSetPtr->Can_RxHandleMappingsPtr[middleIndex].RxHandle < RxHandle)
          {
            /* The item must be after middleIndex. */
            leftIndex = middleIndex + 1u;
          }
          else /* i.e. (Can_RxHandleMappings[middleIndex].RxHandle > RxHandle) */
          {
            /* The item must be before middleIndex, however, avoid negative numbers. */
            rightIndex = middleIndex;
          }
        }
      }
      else
      {
        /* ControllerIndex is different. --> Narrow search and continue. */
        if (Can_ConfigSetPtr->Can_RxHandleMappingsPtr[middleIndex].ControllerIndex < ControllerIndex)
        {
          /* The item must be after middleIndex. */
          leftIndex = middleIndex + 1u;
        }
        else /* i.e. (Can_RxHandleMappings[middleIndex].ControllerIndex > ControllerIndex) */
        {
          /* The item must be before middleIndex, however, avoid negative numbers. */
          rightIndex = middleIndex;
        }
      }
    }
    
    /* Check if the item was found, else it is not a configured id. */
    if 
    (
      (Can_ConfigSetPtr->Can_RxHandleMappingsPtr[leftIndex].ControllerIndex == ControllerIndex)
      &&
      (Can_ConfigSetPtr->Can_RxHandleMappingsPtr[leftIndex].RxHandle == RxHandle)
    )
    {
      if
      (
        (FALSE == IsPretended)
         &&
        (TRUE == Can_ConfigSetPtr->Can_RxHandleMappingsPtr[leftIndex].IcomDedicatedEnable)
      )
      {
        /* When a message dedicated to the pretended networking mode is received in the
           normal mode, it is determined that the item could not be found. */
        ;
      }
      else
      {
        /* Item found. */
        *RxHwHandlePtr = Can_ConfigSetPtr->Can_RxHandleMappingsPtr[leftIndex].RxHwHandle;
        result = E_OK;
      }
    }
  }
  
  return result;
}

/** \brief Can_DataTranslateTxHandle
 **
 ** Translates TX HW handle (HTH) to the controller ID and TX object handle index.
 **
 ** \return   CAN_OK: Translation was successful, the output parameters are set.
 **           CAN_NOT_OK: The provided HW handle does not correspond to a hardware
 **                       entity, the output parameters cannot be used.
 **           CAN_BUSY: No free slot in message queue, the output parameters cannot
 **                     be used.
 ** \param [in] TxHwHandle   The TX HW handle that shall be translated.
 ** \param [out] ControllerIndexPtr   Pointer to the variable that will be set to
 **                                   the ControllerId that corresponds to the HW
 **                                   handle.
 ** \param [out] PduIdBufferIndexPtr   Pointer to the variable that will be set to
 **                                    the PduId buffer index.
 ** \param [out] TriggerTransmitEnablePtr   Pointer to the variable that will be
 **                                         set to the TriggerTransmitEnable value
 **                                         configured for this HW object.
 ** \param [out] PaddingValuePtr   Pointer to the variable that will be set to the
 **                                PaddingValue value configured for this HW object.
 ** \param [out] TxHandlePtr   Returns in this parameter the buffer handle for the
 **                            TX message. Possible values are only 0..31 and
 **                            CAN_CONTROLLER_TX_FIFO.
 **
 */
FUNC(Can_ReturnType, AUTOMATIC) Can_DataTranslateTxHandle
(
  VAR(Can_HwHandleType, AUTOMATIC) TxHwHandle,
  P2VAR(Can_ControllerIdType, AUTOMATIC, AUTOMATIC) ControllerIndexPtr,
  P2VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC, AUTOMATIC) PduIdBufferIndexPtr,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) TriggerTransmitEnablePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PaddingValuePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) TxHandlePtr
)
{
  Can_ReturnType result = CAN_NOT_OK;
  
  /* If there are no TX handles, lookup is not possible. */
  if (Can_ConfigSetPtr->NumberOfTxBuffers > 0u)
  {
    if (Can_ConfigSetPtr->NumberOfRxHandles > 0u)
    {
       if (  (Can_ConfigSetPtr->NumberOfRxHandles <= TxHwHandle) 
        && (TxHwHandle < (Can_ConfigSetPtr->NumberOfRxHandles + Can_ConfigSetPtr->NumberOfTxHandleMappings)))
      {
         /* TxHWHandle (HOH) contains HRHs and HTHs. The order is always first HRHs than
          * HTHs. Subtract number of HRHs results that the object handle (HOH) has now
          * the first HTH is represented with the number 0. All HTHs are now in range
          * to access the right object by using the TX handle mappings array. */
        TxHwHandle -= Can_ConfigSetPtr->NumberOfRxHandles;
        result = Can_DataGetTranslateTxHandle(TxHwHandle,
                                              ControllerIndexPtr,
                                              PduIdBufferIndexPtr,
                                              TriggerTransmitEnablePtr,
                                              PaddingValuePtr,
                                              TxHandlePtr);
      }
    }
    else
    {
      /* Avoid compiler warnings in case Can_ConfigSetPtr->NumberOfRxHandles==0 */
      if (TxHwHandle < Can_ConfigSetPtr->NumberOfTxHandleMappings)
      {
        /* TxHwHandle is in range */
        result = Can_DataGetTranslateTxHandle(TxHwHandle,
                                              ControllerIndexPtr,
                                              PduIdBufferIndexPtr,
                                              TriggerTransmitEnablePtr,
                                              PaddingValuePtr,
                                              TxHandlePtr);
      }
    }
  }
  
  return result;
}

/** \brief Can_DataCheckIcomRxMessageID
 **
 ** Check if it is a wakeup message ID. 
 ** During normal operation, the wakeup message ID of Pretended 
 ** Networking mode is set to Hardware Filter. Therefore, there 
 ** is a possibility to receive a message ID for Wakeup. 
 ** Check the unknown message ID for Wakeup message ID.
 **
 ** \return   TRUE: Receive wakeup message ID.
 **           FALSE: Receiving except wakeup messages ID.
 ** \param [in] MessageId   Can Id of the message.
 **
 */
FUNC(boolean, AUTOMATIC) Can_DataCheckIcomRxMessageID
(
  VAR(uint32, AUTOMATIC) MessageId
)
{
  uint8 CfgIndex;
  uint32 RxIndex;
  boolean result = FALSE;
  P2CONST(Can_ControllerIcomConfigType, AUTOMATIC, AUTOMATIC) IcomConfig = 
                                                                         Can_ConfigSetPtr->Can_ControllerIcomConfigsPtr;
  
  if (NULL_PTR != IcomConfig)
  {
    for (CfgIndex=0u; Can_ConfigSetPtr->NumberOfIcomConfigs > CfgIndex; CfgIndex++)
    {
      P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgCfgPtr = 
                                                                                   IcomConfig[CfgIndex].RxMessageCfgPtr;
      for (RxIndex=0u; IcomConfig[CfgIndex].NumberOfRxMessageCfgPtr > RxIndex; RxIndex++)
      {
        /* Comparing MessageId only when CanIcomRxMessageSignalConfig is defined. */
        if (NULL_PTR != IcomRxMsgCfgPtr[RxIndex].RxMessageSignalCfgPtr)
        {
          if ((MessageId & ~(CAN_CONTROLLER_FD_ID_FLAG | CAN_CONTROLLER_XTD_ID_FLAG)) == 
               IcomRxMsgCfgPtr[RxIndex].MessageId)
          {
            result = TRUE;
          }
        }
        else
        {
          /* Compare with masked MessageId if CanIcomRxMessageSignalConfig is not defined */
          if (    (IcomRxMsgCfgPtr[RxIndex].MessageId == (IcomRxMsgCfgPtr[RxIndex].MessageMask & MessageId))
               || (0u == IcomRxMsgCfgPtr[RxIndex].MessageMask) )
          {
            result = TRUE;
          }
        }
      }
    }
  }
  
  return result;
}

/** \brief Can_DataInitMessageRam
 **
 ** Clear Message RAM in Can Instance unit.
 ** Message RAM has one message RAM in one instance. On the other hand,
 ** argument ControllerCfgPtr is channel unit. Therefore, the caller must
 ** call this function on a per-instance basis.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_DataInitMessageRam
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32 index;
  uint32 RamSize = ControllerCfgPtr->MessageRamSize >> 2u;
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) MessagePtr;

  /* Clear all Message RAM area */
  /* Deviation from MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics:, 
     MISRA-C:2012 Rule-11.3
     Casting to different object pointer type.
     Justification: The elements in message RAM have to be 32-bit aligned as a hardware restriction
     of the CAN FD anyway. Hence byte-wise access to an address that is not
     32-bit aligned would not avoid a fault. Therefore the type can be converted without additional risk. */
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 310,3305 1 */
  MessagePtr = (P2VAR(uint32, AUTOMATIC, AUTOMATIC))(&(ControllerCfgPtr->MessageRamBasePtr[0]));
  for (index = 0u; RamSize > index ; index++ )
  {
    MessagePtr[index] = 0u;
  }

  /* Channel in the same instance is updated to initialization completed. */
  for (index = 0u; Can_ConfigSetPtr->NumberOfControllers > index; index++ )
  {
    if ( Can_ConfigSetPtr->Can_ControllerConfigsPtr[index].MessageRamBasePtr == ControllerCfgPtr->MessageRamBasePtr )
    {
      Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IsMRamInit = TRUE;
    }
  }
}

/** \brief Can_DataClearIsMRamInit
 **
 ** Initialize all Message RAM clear completion flags.
 **
 */
FUNC(void, AUTOMATIC) Can_DataClearIsMRamInit(void)
{
  uint32 index;
  
  for (index = 0u; Can_ConfigSetPtr->NumberOfControllers > index; index++ )
  {
    Can_ConfigSetPtr->Can_ControllerStatesPtr[index].IsMRamInit = FALSE;
  }
}

/** \brief Can_DataGetInterruptNumToControllerId
 **
 ** Get ControllerId corresponding to InterruptNum.
 **
 ** \return   Index of the controller whose state data shall be retrieved.
 **
 ** \param [in] InterruptNum   Element number  of the controller that caused the interrupt.
 **
 */
FUNC(Can_ControllerIdType, AUTOMATIC) Can_DataGetInterruptNumToControllerId
(
  VAR(uint8, AUTOMATIC) InterruptNum
)
{
  Can_ControllerIdType CtrlId;
  if (Can_ConfigSetPtr->NumberOfInterruptToControllerLists > InterruptNum)
  {
    /* Interrupt Index is in range. */
    CtrlId = Can_ConfigSetPtr->Can_InterruptToControllerListPtr[InterruptNum];
  }
  else
  {
    /* Interrupt Index is out of range. */
    CtrlId = Can_ConfigSetPtr->NumberOfInterruptToControllerLists;
  }
  
  return CtrlId;
}

/** \brief Can_DataAllFreeTxPduId
 **
 ** Free all swPduId of the specified CanController.
 **
 ** \param [in] CtrlId   Controller Index
 **
 */
FUNC(void, AUTOMATIC) Can_DataAllFreeTxPduId
(
  VAR(Can_ControllerIdType, AUTOMATIC) CtrlId
)
{
  VAR(Can_HwHandleType, AUTOMATIC) TxHwHandle;
  
  for (TxHwHandle=0u; Can_ConfigSetPtr->NumberOfTxHandleMappings > TxHwHandle; TxHwHandle++)
  {
    if (CtrlId == Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].ControllerIndex)
    {
      uint32 index;
      uint32 StartIndex = Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].QueueStartIndex;
      uint32 EndIndex   = StartIndex + Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].QueueLength;
      
      /* Free all Can_PduIdBufferPtr of the specified CanController */
      for (index=StartIndex; EndIndex > index; index++)
      {
        Can_ConfigSetPtr->Can_PduIdBufferPtr[index] = CAN_DATA_FREE_PDUID_BUFFER_SLOT;
      }
    }
  }
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_DataGetTranslateTxHandle
 **
 ** Get translates TX HW handle (HTH) to the controller ID and TX object handle index.
 **
 ** \return   CAN_OK: Translation was successful, the output parameters are set.
 **           CAN_BUSY: No free slot in message queue, the output parameters cannot
 **                     be used.
 **
 ** \param [in] TxHwHandle   The TX HW handle that shall be translated.
 ** \param [out] ControllerIndexPtr   Pointer to the variable that will be set to
 **                                   the ControllerId that corresponds to the HW
 **                                   handle.
 ** \param [out] PduIdBufferIndexPtr   Pointer to the variable that will be set to
 **                                    the PduId buffer index.
 ** \param [out] TriggerTransmitEnablePtr   Pointer to the variable that will be
 **                                         set to the TriggerTransmitEnable value
 **                                         configured for this HW object.
 ** \param [out] PaddingValuePtr   Pointer to the variable that will be set to the
 **                                PaddingValue value configured for this HW object.
 ** \param [out] TxHandlePtr   Returns in this parameter the buffer handle for the
 **                            TX message. Possible values are only 0..31 and
 **                            CAN_CONTROLLER_TX_FIFO.
 */
 static FUNC(Can_ReturnType, AUTOMATIC) Can_DataGetTranslateTxHandle
 (
  VAR(Can_HwHandleType, AUTOMATIC) TxHwHandle,
  P2VAR(Can_ControllerIdType, AUTOMATIC, AUTOMATIC) ControllerIndexPtr,
  P2VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC, AUTOMATIC) PduIdBufferIndexPtr,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) TriggerTransmitEnablePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PaddingValuePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) TxHandlePtr
)
{
  uint32 idx;
  uint32 startIdx;
  uint32 endIdx;
  Can_ReturnType result;
  
  /* Copy values from table. */
  *ControllerIndexPtr = Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].ControllerIndex;
  *TxHandlePtr = Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].TxHandle;
  *PaddingValuePtr = Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].PaddingValue;
  *TriggerTransmitEnablePtr = Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].TriggerTransmitEnable;
  
  startIdx = Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].QueueStartIndex;
  endIdx   = startIdx + Can_ConfigSetPtr->Can_TxHandleMappingsPtr[TxHwHandle].QueueLength;
  /* Preset return value to CAN_BUSY. If the loop does not find a free
   * message queue slot, the return value stays in CAN_BUSY. */
  result = CAN_BUSY;
  
  /* Search for next free slot in message queue. */
  for (idx = startIdx; (idx < endIdx) && (CAN_BUSY == result); idx++)
  {
    if (CAN_DATA_FREE_PDUID_BUFFER_SLOT == Can_ConfigSetPtr->Can_PduIdBufferPtr[idx])
    {
      /* Set PduIdBufferIndex to found free slot in message queue.
       * Only 8 bit could be used for the index due to the MM field has only
       * 8 bit. The buffer has maximum 256 entries. This is ensured by the
       * configurator. QueueStartIndex + QueueLength is less or equal 256. */
      *PduIdBufferIndexPtr = (uint8)idx;
      /* Set result that free slot is found. */
      result = CAN_OK;
    }
  }
  
  return result;
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[end of file]===========================================*/
