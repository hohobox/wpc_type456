/** \brief Can_ControllerManager.c
 **
 ** This unit manages one CAN controller (given by parameter).
 **
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can_ControllerManager.h>
#include <Can_Callout.h>
#include <Can_ModeHandler.h>
#include <Can_RxHandler.h>
#include <Can_TxHandler.h>
#include <Can_RegisterAbstraction.h>

/*==================[macros]================================================*/

#define CAN_CONTROLLER_IRQ_DISABLE_MAX_NESTING      255u
#define CAN_CONTROLLER_IRQ_DISABLE_MIN_NESTING        0u
#define CAN_CONTROLLER_NOMINAL_PRESCALER_MAX        512u
#define CAN_CONTROLLER_DATA_PRESCALER_MAX            32u
#define CAN_CONTROLLER_DATA_PRESCALER_MAX_TDC_ENABLE  2u

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

/*==================[internal constants]====================================*/

#define CAN_START_SEC_CONST_ASIL_B_UNSPECIFIED

#include "Can_MemMap.h"

/** \brief Can_ControllerFieldSizeLut
 **
 ** Can_ControllerFieldSizeLut maps a value of type Can_ControllerBufferSizeType
 ** (array index) to an integer value representing the same size (array value).
 **/
/* Deviation from MISRA-C:2004 Rule 8.7:, MISRA-C:2012 Rule-8.9
   File scope static constant/variable is only accessed in one function.
   Justification: Allow memory mapping (MemMap). */
/* PRQA S 3218 1 */
static CONST(uint8, AUTOMATIC) Can_ControllerFieldSizeLut[8u] = {8u, 12u, 16u, 20u, 24u, 32u, 48u, 64u};

/** \brief Can_ControllerDlcToLengthLut
 **
 ** Can_ControllerDlcToLengthLut maps the length code out of the message in Message
 ** RAM (array index) to an integer value representing the decimal length (array
 ** value).
 **/
/* Deviation from MISRA-C:2004 Rule 8.7:, MISRA-C:2012 Rule-8.9
   File scope static constant/variable is only accessed in one function.
   Justification: Allow memory mapping (MemMap). */
/* PRQA S 3218 1 */
static CONST(uint8, CAN_CONST) Can_ControllerDlcToLengthLut[16u] = 
                                               {0u,1u,2u,3u,4u,5u,6u,7u,8u,12u,16u,20u,24u,32u,48u,64u};

/** \brief Can_ControllerLengthToDlcLut
 **
 ** Can_ControllerLengthToDlcLut maps the decimal message length out of a message
 ** (array index) to the corresponding data length code of the TX buffer in Message
 ** RAM (array value).
 **/
/* Deviation from MISRA-C:2004 Rule 8.7:, MISRA-C:2012 Rule-8.9
   File scope static constant/variable is only accessed in one function.
   Justification: Allow memory mapping (MemMap). */
/* PRQA S 3218 1 */
static CONST(uint8, CAN_CONST) Can_ControllerLengthToDlcLut[65u] = {
     0u,1u,2u,3u,4u,5u,6u,7u,8u,       /* classic values 1:1 mapping */
     9u,9u,9u,9u,                      /* index  9..12 mapped to 9   */
     10u,10u,10u,10u,                  /* index 13..16 mapped to 10  */
     11u,11u,11u,11u,                  /* index 17..20 mapped to 11  */
     12u,12u,12u,12u,                  /* index 21..24 mapped to 12  */
     13u,13u,13u,13u,13u,13u,13u,13u,  /* index 25..32 mapped to 13  */
     14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,14u,  /* index 33..48 mapped to 14 */
     15u,15u,15u,15u,15u,15u,15u,15u,15u,15u,15u,15u,15u,15u,15u,15u}; /* index 49..64 mapped to 15 */

#define CAN_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_ControllerDisableInterrupts
 **
 ** Disables all interrupts for the given controller.
 ** Nesting is supported.
 **
 ** \return   E_NOT_OK: The maximum nesting level was exceeded, the nesting level
 **                     has not been updated.
 **           E_OK: normal operation.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to state data, which contains
 **                                         the nesting level.
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerDisableInterrupts
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  Std_ReturnType result = E_OK;
  
  /* Protect ReadModifyWrite to nesting level variable. */
  Can_EnterCriticalSection();
  
  if (CAN_CONTROLLER_IRQ_DISABLE_MAX_NESTING == ControllerStateDataPtr->InterruptDisableLevel)
  {
    /* Error: Maximum nesting level exceeded. */
    result = E_NOT_OK;
  }
  else
  {
    /* Normal operation */
    ControllerStateDataPtr->InterruptDisableLevel++;
  }
  /* Actively disable interrupts in any case (safety). */
  Can_ModeSetInterrupts(ControllerCfgPtr, FALSE);
  
  Can_ExitCriticalSection();
  
  return result;
}

/** \brief Can_ControllerEnableInterrupts
 **
 ** Enables all interrupts for the given controller, if nesting has ended.
 ** Nesting is supported.
 **
 ** \return   E_NOT_OK: Minimum nesting level exceeded, the nesting level has not
 **                     been updated.
 **           E_OK: normal operation.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to state data, which contains
 **                                         the nesting level.
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerEnableInterrupts
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  Std_ReturnType result = E_OK;
  uint8 NestingLevel;
  
  /* Protect ReadModifyWrite to nesting level variable. */
  Can_EnterCriticalSection();
  
  /* Disabling of interrupts could be called multiple times. The nesting level
   * (disable level) counts the amount of nested Can_ControllerDisableInterrupt
   * function calls. Enabling of interrupts is only allowed if the amount of
   * Can_ControllerEnableInterrupt function calls is the same as the disable
   * function. No nesting anywhere available. Therefore the disable level is
   * decremented here. If the disable level is zero, the interrupts must be
   * enabled, otherwise the interrupts have to stay disabled. To be ensure that
   * the interrupts are in state disable, may in error cases the interrupt state
   * is enabled, the interrupts shall be actively set to disable. */

  NestingLevel = ControllerStateDataPtr->InterruptDisableLevel;
  if (CAN_CONTROLLER_IRQ_DISABLE_MIN_NESTING == NestingLevel)
  {
    /* Error: Minimum nesting level exceeded. */
    result = E_NOT_OK;
  }
  else
  {
    /* Normal operation */
    NestingLevel--;
  }
  ControllerStateDataPtr->InterruptDisableLevel = NestingLevel;
  
  /* Actively disable or enable interrupts in any case (safety). */
  if (CAN_CONTROLLER_IRQ_DISABLE_MIN_NESTING == NestingLevel)
  {
    Can_ModeSetInterrupts(ControllerCfgPtr, TRUE);
  }
  else
  {
    Can_ModeSetInterrupts(ControllerCfgPtr, FALSE);
  }
  
  Can_ExitCriticalSection();

  return result;
}

/** \brief Can_ControllerEnterInterrupt
 **
 ** Prepares the CAN controller for ISR execution.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerEnterInterrupt
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* The "bus-off change" (BO) flag appears after a bus-off happened and also
   * after a bus-off was "healed". If a bus-off happened, the controller
   * automatically switched to INIT state, which will be detected by the state
   * check later on. The BO flag can safely be cleared. If the controller returned
   * from bus-off, the controller is in STARTED state and there is nothing to do
   * on bus-off check. The BO flag must be cleared in order to prevent ISR
   * deadlock. */
  Can_ModeClearBusOffInterrupt(ControllerCfgPtr);
}

/** \brief Can_ControllerGetStatus
 **
 ** Returns the current controller status.
 ** The status is calculated from the SW and HW status:
 ** - STARTED: HW and SW are started (i.e. HW is ready and mode indication was
 **            sent)
 ** - SLEEP: HW and SW are in sleep (i.e. HW is ready and mode indication was
 **          sent)
 ** - UNINIT: SW is uninitialized.
 ** - STOPPED: else (i.e. HW and SW in stopped; HW stopped and SW started but bus-
 **            off indication missing; HW started and SW stopped but mode indication
 **            missing)
 **
 ** \return   The current controller state.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 **
 */
FUNC(Can_ControllerStatusType, AUTOMATIC) Can_ControllerGetStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  Can_ControllerStatusType result = CAN_CONTROLLER_STOPPED;
  
  switch (ControllerStateDataPtr->Status)
  {
    case CAN_CONTROLLER_STARTED:
      /* STARTED only if SW+HW status is STARTED. */
      if (CAN_CONTROLLER_STARTED == Can_ModeGetHwStatus(ControllerCfgPtr))
      {
        result = CAN_CONTROLLER_STARTED;
      }
      /* else: result = CAN_CONTROLLER_STOPPED already set. */
      break;
      
    case CAN_CONTROLLER_SLEEP:
      /* SLEEP only if SW+HW status is SLEEP. */
      if (CAN_CONTROLLER_SLEEP == Can_ModeGetHwStatus(ControllerCfgPtr))
      {
        result = CAN_CONTROLLER_SLEEP;
      }
      /* else: result = CAN_CONTROLLER_STOPPED already set. */
      break;
      
    case CAN_CONTROLLER_STOPPED:
      /* result = CAN_CONTROLLER_STOPPED already set. */
      break;
      
    /* case CAN_CONTROLLER_UNINIT: */
    default:
      result = CAN_CONTROLLER_UNINIT;
      break;
  }
  
  return result;
}

/** \brief Can_ControllerGetWakeup
 **
 ** Checks if a wake-up event has been logged since last sleep transition.
 **
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \return   TRUE: Wakeup has appeared since last sleep transition.
 **           FALSE: Wakeup has not appeared since last wakeup transition.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ControllerGetWakeup
(
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  return ControllerStateDataPtr->WakeupDetected;
}

/** \brief Can_ControllerHandleBusOff
 **
 ** Checks if a bus-off event has appeared. In this case the HW has already stopped
 ** itself, but the SW status is still STARTED.
 ** NOTE: The order of the BusOffIndication and the error report is important.
 **       First the error must be reported and than the BusOffIndcation must
 **       be done due to in the BusOffIndication function call the controller
 **       could be started again and the error is reported in the wrong
 **       controller state.
 **
 ** \return   Returns a bus-off event.
 **           TRUE:  bus-off event detected.
 **           FALSE: bus-off event no detected.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STOPPED
 **                                     if a bus-off event was detected.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ControllerHandleBusOff
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  boolean retVal = FALSE; /* default: No bus off indication required. */

  /* Avoid intermediate calls to Can_SetControllerMode.
    (Interference of ISR and MainFunctionBusOff is not possible.) */
  Can_EnterCriticalSection();
  
  /* Check for bus-off event. */
  if ((CAN_CONTROLLER_STOPPED == Can_ModeGetHwStatus(ControllerCfgPtr)) )
  {
    retVal = Can_ModeCheckBusOff(ControllerCfgPtr);
    
    if (CAN_CONTROLLER_STARTED == ControllerStatePtr->Status)
    {
      
      /* Clear SW status; this prevents to detect the same event again. */
      ControllerStatePtr->Status = CAN_CONTROLLER_STOPPED;
      /* Properly stop hardware. */
      Can_ModeStop(ControllerCfgPtr);
    }
  }
  Can_ExitCriticalSection();

  return retVal;
}

/** \brief Can_ControllerHandleUncorrectableBitError
 **
 ** Checks if an uncorrectable bit error has appeared. In this case the HW has 
 ** already stopped itself, but the SW status is still STARTED.
 **
 ** \return   Returns an error indication that an uncorrectable bit error in
 **           Message RAM is detected.
 **           TRUE: uncorrectable bit error is detected
 **           FALSE: no error is detected
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STOPPED
 **                                     if an uncorrectable bit error was detected.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ControllerHandleUncorrectableBitError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  boolean retVal = FALSE; /* default: No uncorrectable bit error detected. */
  
  /* Avoid intermediate calls to Can_SetControllerMode.
    (Interference of ISR and MainFunctionBusOff is not possible.) */
  Can_EnterCriticalSection();
  
  /* Check occurrence of an uncorrectable bit error. */
  if ((CAN_CONTROLLER_STOPPED == Can_ModeGetHwStatus(ControllerCfgPtr)) )
  {
    retVal = Can_ModeCheckUncorrectableBitError(ControllerCfgPtr);
    
    if (   (CAN_CONTROLLER_STARTED == ControllerStatePtr->Status)
        || (CAN_CONTROLLER_SLEEP   == ControllerStatePtr->Status))
    {
      /* Clear SW status; this prevents to detect the same event again. */
      ControllerStatePtr->Status = CAN_CONTROLLER_STOPPED;
      /* Properly stop hardware. */
      Can_ModeStop(ControllerCfgPtr);
    }
  }
  Can_ExitCriticalSection();
  
  return retVal;
}

/** \brief Can_ControllerHandleMode
 **
 ** Forwards the mode check to mode handler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to
 **                                     STARTED or SLEEP if the respective event
 **                                     was detected.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerHandleMode
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  /* Return value is not needed to analyze. Due to call is via MainFunction
   * (polling, asynchronous) to react on different HW status. Return value is only
   * necessary to check while waiting synchronously (while-loop) for completion
   * of initialization (Starting the controller). */
  (void)Can_ModeHandleStartSleep(ControllerCfgPtr, ControllerStatePtr);
}

/** \brief Can_ControllerHandleRx
 **
 ** Forward received event to RX handler.
 **
 ** \return   E_OK: No error was detected,
 **           E_NOT_OK: Message lost error was detected. (Reception was still
 **           conducted.)
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerHandleRx
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  Std_ReturnType result = E_OK;
  
  /* A critical section is not needed, because neither the IRQ nor the
     main function can interrupt themselves. Use of main function and
     IRQ in parallel is prohibited. */
  if (FALSE != Can_RxGetNewMessageStatus(ControllerCfgPtr, ControllerStatePtr))
  {
    result = Can_RxHandleReceived(ControllerCfgPtr, ControllerStatePtr, ApiId);
  }
  
  return result;
}

/** \brief Can_ControllerHandleTx
 **
 ** Forward transmitted event and canceled event to TX handler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerHandleTx
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Forward detected transmit or cancel event to TX handler. */
  Can_TxHandleTx(ControllerCfgPtr);
}

/** \brief Can_ControllerHandleWakeup
 **
 ** Checks for wakeup events.
 ** The function is intended to be called on ISR, MainFunction_Wakeup and Init.
 ** If a wakeup event is detected, EcuM_SetWakeupEvent is notified and the wakeup
 ** event is stored to the controller state data for later reference by
 ** Can_CheckWakeup.
 ** If no wakeup was detected, the event is cleared from the controller's state
 ** data.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STOPPED
 **                                     if a wakeup was detected.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerHandleWakeup
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  /* Avoid intermediate wakeup by Can_SetControllerMode(STOP). */
  Can_EnterCriticalSection();

  if (FALSE != Can_RxGetNewMessageStatus(ControllerCfgPtr, ControllerStatePtr))
  {
    /* A wakeup message was received. */
    
    /* Update status to STOPPED. */
    ControllerStatePtr->Status = CAN_CONTROLLER_STOPPED;
    Can_ModeStop(ControllerCfgPtr);

    /* Remember that a wakeup was detected. */
    ControllerStatePtr->WakeupDetected = TRUE;
    
    /* Notify upper layer. */
    Can_ExitCriticalSection();
    Can_EcuMCheckWakeup(ControllerCfgPtr);
  }
  else
  {
    Can_ExitCriticalSection();
  }
}

/** \brief Can_ControllerSetBaudrate
 **
 ** Stores the baudrate setting so that it is applied at future controller starts.
 **
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] BaudratePtr   Pointer to the baudrate structure that shall be
 **                           stored.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerSetBaudrate
(
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) BaudratePtr
)
{
  ControllerStatePtr->BaudrateData.BaudratePtr      = BaudratePtr;
  ControllerStatePtr->BaudrateData.NominalPrescaler = 0u;
  ControllerStatePtr->BaudrateData.DataPrescaler    = 0u;
}

/** \brief Can_ControllerSetBaudrateInChangedClock
 **
 ** Stores the baudrate and normal/data prescaler settings so that it is 
 ** applied at future controller starts.
 **
 ** \return   E_OK: No error was detected,
 **           E_NOT_OK: As a result of calculating the prescaler, it was a 
 **                     value that can not be set in the register.
 **
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] BaudratePtr   Pointer to the baudrate structure that shall be
 **                           stored.
 ** \param [in] ClockFrequency   Changed clock[MHz]
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_ControllerSetBaudrateInChangedClock
(
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) BaudratePtr,
  VAR(Can_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  Std_ReturnType result = E_OK;
  uint16 NominalValue;
  uint16 DataValue      = 0u;
  uint16 MaxDataValue   = 0u;
  
  /* Calculate the prescaler based on the value of ClockFrequency
   * Because the unit of ClockFrequency is MHz and the unit of Baudrate is kbps,
   * it is multiplied by 1000 to set ClockFrequency to kHz. */  
  NominalValue = ((uint16)ClockFrequency * 1000u) /
                 ((1u + (uint16)BaudratePtr->TSeg1 + (uint16)BaudratePtr->TSeg2) * BaudratePtr->BaudrateValue);
  if (0u < BaudratePtr->FdBaudrateValue)
  {
    DataValue = ((uint16)ClockFrequency * 1000u) /
                ((1u + (uint16)BaudratePtr->FdTSeg1 + (uint16)BaudratePtr->FdTSeg2) * BaudratePtr->FdBaudrateValue);
    if (0xFFu != BaudratePtr->FdTrcvDelayCompensationOffset)
    {
      MaxDataValue = CAN_CONTROLLER_DATA_PRESCALER_MAX_TDC_ENABLE;
    }
    else
    {
      MaxDataValue = CAN_CONTROLLER_DATA_PRESCALER_MAX;
    }
  }
  
  /* Check prescaler value */
  if (    (CAN_CONTROLLER_NOMINAL_PRESCALER_MAX < NominalValue) 
       || ((MaxDataValue < DataValue) && (TRUE == BaudratePtr->FdEnabled)))
  {
    result = E_NOT_OK;
  }
  else
  {
    ControllerStatePtr->BaudrateData.BaudratePtr      = BaudratePtr;
    ControllerStatePtr->BaudrateData.NominalPrescaler = NominalValue;
    ControllerStatePtr->BaudrateData.DataPrescaler    = DataValue;
  }
  
  return result;
}

/** \brief Can_ControllerSleep
 **
 ** Initiates the asynchronous transition from STOPPED to SLEEP.
 ** Resets the wake-up flag.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerSleep
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  /* Reset wakeup flag. */
  ControllerStatePtr->WakeupDetected = FALSE;
  
  /* Check interrupt nesting level to enable/disable interrupts. */
  if (0u == ControllerStatePtr->InterruptDisableLevel)
  {
    /* No nesting interrupt level available. Enable interrupts. */
    Can_ModeSetInterrupts(ControllerCfgPtr, TRUE);
  }
  else
  {
    /* Nesting interrupt levels available.
     * Stay interrupts disabled by setting the disable state active for
     * safety reason. */
    Can_ModeSetInterrupts(ControllerCfgPtr, FALSE);
  }
  /* Start the controller in sleep mode. */
  Can_ModeStart(ControllerCfgPtr, ControllerStatePtr->BaudrateData.BaudratePtr, ControllerStatePtr, TRUE);
}

/** \brief Can_ControllerStart
 **
 ** Initiates the asynchronous transition from STOPPED to STARTED.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerStart
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  /* Setup Tx and Rx buffer */
  Can_TxSetup(ControllerCfgPtr);
  Can_RxSetup(ControllerCfgPtr);
  
  /* Pretended networking mode disable */
  ControllerStatePtr->IcomState.IsPretended = FALSE;
  /* Reset RX Overflow error flag. */
  ControllerStatePtr->IsRxOverflow = FALSE;

  /* Check interrupt nesting level to enable/disable interrupts. */
  if (0u == ControllerStatePtr->InterruptDisableLevel)
  {
    /* No nesting interrupt level available. Enable interrupts. */
    Can_ModeSetInterrupts(ControllerCfgPtr, TRUE);
  }
  else
  {
    /* Nesting interrupt levels available.
     * Stay interrupts disabled by setting the disable state active for
     * safety reason. */
    Can_ModeSetInterrupts(ControllerCfgPtr, FALSE);
  }
  /* Start the controller in normal mode. */
  Can_ModeStart(ControllerCfgPtr, ControllerStatePtr->BaudrateData.BaudratePtr, ControllerStatePtr, FALSE);
}

/** \brief Can_ControllerGetErrorStatus
 **
 ** Gets the status if an RxOverflow event and/or status ErrorPassive is occurred.
 ** 
 ** The detected RxOverflow is returned only once. After reporting the RxOverflow
 ** is cleared till next RxOverflow event is detected.
 **
 ** \return   BitField containing following independent flags:
 **           0x00: status is undefined (e.g. the conditions above have not occurred,
 **                 or CAN controller is not in state STARTED)
 **           CAN_STATUS_ERROR_PASSIVE: This flag is returned as long as the error
 **                                     counters of the CAN macro indicate that
 **                                     the controller is in the error passive
 **                                     state. The status is updated on every
 **                                     Can_GetStatus() call.
 **           CAN_STATUS_RX_OVERFLOW: The update of the internal state for
 **                                   Can_GetStatus() happens every time new data
 **                                   has been received by this controller and has
 **                                   been processed by the corresponding function
 **                                   (Can_MainFunction_Read() call in case of
 **                                   polling mode configuration, or on every CAN
 **                                   RX interrupt in case of IRQ mode configuration).
 **                                   This flag is only returned once, if during
 **                                   subsequent calls to Can_GetStatus() no new
 **                                   RX overflow condition occurred.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
FUNC(uint8, AUTOMATIC) Can_ControllerGetErrorStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  uint8 retVal = 0x00u; /* Set default value to undefined. */

  /* Check for passive error status reached. */
  if (TRUE == Can_ModeGetErrorPassiveStatus(ControllerCfgPtr))
  {
    /* Passive error status reached. */
    retVal = CAN_CONTROLLER_ERRORSTATUS_ERROR_PASSIVE;
  }

  /* Check for received message buffer overflow. */
  if (TRUE == ControllerStatePtr->IsRxOverflow)
  {
    /* RX buffer overflow detected. Set RX overflow bit in return value. */
    retVal |= CAN_CONTROLLER_ERRORSTATUS_RX_OVERFLOW;
    /* Reset RX buffer overflow detection flag. */
    ControllerStatePtr->IsRxOverflow = FALSE;
  }

  return retVal;
}

/** \brief Can_ControllerStop
 **
 ** Performs the synchronous transition to STOPPED from any status.
 **
 **\param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerStop
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  /* Pretended networking mode disable */
  ControllerStatePtr->IcomState.IsPretended = FALSE;
  /* Stop HW */
  Can_ModeStop(ControllerCfgPtr);
  /* Stop SW */
  ControllerStatePtr->Status = CAN_CONTROLLER_STOPPED;
}

/** \brief Can_ControllerTranslateDlcToLength
 **
 ** Translates the DLC value set in RX/TX message in message RAM to an integer
 ** number in bytes.
 **
 ** \param [in] DlcCode   The DLC code that shall be translated to a length.
 ** \return   Message length in bytes.
 **
 */
FUNC(uint8, AUTOMATIC) Can_ControllerTranslateDlcToLength
(
  VAR(uint8, AUTOMATIC) DlcCode
)
{
  return Can_ControllerDlcToLengthLut[DlcCode];
}

/** \brief Can_ControllerTranslateFieldSize
 **
 ** Translates the field size from enumeration to integer number in bytes.
 **
 ** \param [in] FieldSize   The size that shall be translated.
 ** \return   The size in bytes.
 **
 */
FUNC(uint8, AUTOMATIC) Can_ControllerTranslateFieldSize
(
  VAR(Can_ControllerBufferSizeType, AUTOMATIC) FieldSize
)
{
  return Can_ControllerFieldSizeLut[(uint8)FieldSize];
}

/** \brief Can_ControllerTranslateLengthToDlc
 **
 ** Translates the message length in bytes to the DLC code to set in RX/TX messages
 ** in message RAM.
 **
 ** \param [in] MessageLength   The message length in bytes that shall be translated
 **                             to the DLC code.
 ** \return   DLC code used in message RAM.
 **
 */
FUNC(uint8, AUTOMATIC) Can_ControllerTranslateLengthToDlc
(
  VAR(uint8, AUTOMATIC) MessageLength
)
{
  return Can_ControllerLengthToDlcLut[MessageLength];
}

/** \brief Can_ControllerWrite
 **
 ** Forward write request to TX handler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller configuration
 **                                structure.
 ** \param [in] ControllerStatePtr   Pointer to the controller state data 
 **                                  structure.
 ** \param [in] PduIdBufferIndex   The PduIdBufferIndex to know the right index
 **                                where the PduId of the TX object is stored in
 **                                buffer. Required to write to the MM field in
 **                                FIFO.
 ** \param [in] PduInfoPtr   Pointer to PduInfo structure for CanId, data length
 **                          and SDU data pointer.
 ** \param [in] TxHandle   Gives the dedicated TX Buffer number used for
 **                        transmission or that the FIFO is used for transmission.
 **                        0..31 stays for a dedicated TX buffer, values higher
 **                        than 31 stays for FIFO in use.
 ** \param [in] PaddingValue   Value to add for padding bytes in CAN message.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerWrite
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  P2CONST(Can_ControllerPduInfoType, AUTOMATIC, AUTOMATIC) PduInfoPtr,
  VAR(uint8, AUTOMATIC) TxHandle,
  VAR(uint8, AUTOMATIC) PaddingValue
)
{
  Can_TxWrite(ControllerCfgPtr, ControllerStatePtr, PduIdBufferIndex, PduInfoPtr, TxHandle, PaddingValue);
}

/** \brief Can_ControllerSetTxCancelRequest
 **
 ** Operation to forward cancel request to ModeHandler.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 ** \param [in] BufferIndex   Index of the TX buffer to cancel.
 ** \param [in] NormalizedNewCanId   CanID of the new message to send. This CanId
 **                                  is normalized, that means that the standard
 **                                  CanIds are left shifted to align with the
 **                                  extended CanIds.
 ** \param [in] IsCancelSameId   Select cancel strategy.
 **                              TRUE := cancellation allowed for same CanId
 **                              FALSE := cancellation allowed if new CanId is
 **                                       smaller than CanId of pending TX message.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerSetTxCancelRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferIndex,
  VAR(uint32, AUTOMATIC) NormalizedNewCanId,
  VAR(boolean, AUTOMATIC) IsCancelSameId
)
{
  /* Forward cancel request to TX handler. */
  Can_TxSetTxCancelRequest(ControllerCfgPtr, BufferIndex, NormalizedNewCanId, IsCancelSameId);
}

/** \brief Can_ControllerReset
 **
 ** Forces the controller to stop mode. All ongoing operations are stopped.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerReset
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Stop hardware. */
  Can_ModeStop(ControllerCfgPtr);
  /* Reset hardware. */
  Can_ModeReset(ControllerCfgPtr);
}

/** \brief Can_ControllerSetTxRxConfiguration
 **
 ** Set Tx and Rx configurations.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerSetTxRxConfiguration
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Set Tx Configuration */
  Can_TxInit(ControllerCfgPtr);
  /* Set Rx Configuration */
  Can_RxInit(ControllerCfgPtr);
}

/** \brief Can_ControllerClearTxData
 **
 ** Clear Tx Data.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerClearTxData
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  Can_TxClearTxData(ControllerCfgPtr);
}

/** \brief Can_ControllerEnableEccControl
 **
 ** Enable ECC control.
 ** It must be an MRAM that can enable ECC error detection.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerEnableEccControl
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Select only MRAM that can enable ECC error detection. */
  if (TRUE == ControllerCfgPtr->EccPresentEnable)
  {
    Can_ModeEnableEccControl(ControllerCfgPtr);
  }
}

/** \brief Can_ControllerSetRxFifoTopPointer
 **
 ** Set Rx FIFO 0/1 Top Pointer.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerSetRxFifoTopPointer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Enable Rx FIFO top pointer */
  Can_ModeSetRxFifoTopPointer(ControllerCfgPtr, CAN_RA_RX_KIND_FIFO0, TRUE);
  Can_ModeSetRxFifoTopPointer(ControllerCfgPtr, CAN_RA_RX_KIND_FIFO1, TRUE);
}

/** \brief Can_ControllerEnableInterruptProtocolError
 **
 ** Enable interrupt by error frame detection only when enabling pretended networking 
 ** mode under the condition that CanIcomPayloadLengthError is valid.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerEnableInterruptProtocolError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  Can_ModeSetInterruptProtocolError(ControllerCfgPtr, TRUE);
}

/** \brief Can_ControllerDisableInterruptProtocolError
 **
 ** Disable interrupt protocol error.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_ControllerDisableInterruptProtocolError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  Can_ModeSetInterruptProtocolError(ControllerCfgPtr, FALSE);
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
