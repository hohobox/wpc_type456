/** \brief Can_ModeHandler.h
 **
 ** The mode handler is responsible for setting and maintaining controller
 ** modes and interrupts.
 **
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef CAN_MODEHANDLER_H_INCLUDED
#define CAN_MODEHANDLER_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Can_ControllerManager.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

/** \brief Can_ModeGetErrorPassiveStatus
 **
 ** Reads the error passive status flag and returns TRUE if passive error is active.
 ** Otherwise FALSE is returned.
 **
 ** \return   Passive error occurrence. Value is TRUE for passive error state is
 **           reached. FALSE is returned otherwise.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ModeGetErrorPassiveStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeGetHwStatus
 **
 ** Reads the current status of the hardware.
 **
 ** \return   Current status of the hardware.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
extern FUNC(Can_ControllerStatusType, AUTOMATIC) Can_ModeGetHwStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeHandleStartSleep
 **
 ** Checks for the event that the hw's status has changed to STARTED or SLEEP. If
 ** so, CanIf is notified.
 ** 
 ** The function is intended to be called from the ISR or MainFunction_Mode.
 **
 ** \return   TRUE: HW is in start or sleep mode and notification has been sent.
 **           FALSE: HW is in init mode and notification has not been sent.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STARTED
 **                                     or SLEEP if the respective event was detected.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ModeHandleStartSleep
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
);

/** \brief Can_ModeSetInterrupts
 **
 ** Enables or disables all interrupts of the controller via the interrupt line
 ** enable (ILE). The function is intended for the use with
 ** Can_Disable/EnableControllerInterrupts.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] Enable   true: enables all interrupts
 **                      false: disables all interrupts
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeSetInterrupts
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(boolean, AUTOMATIC) Enable
);

/** \brief Can_ModeStart
 **
 ** Changes the controller to start or sleep mode.
 ** 
 ** Precondition: The controller is stopped. (Else there will be a data exception.)
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] BaudratePtr        Pointer to the baudrate that shall be applied.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data. The
 **                                data is updated if the state changes before timeout.
 ** \param [in] SleepMode          TRUE: start in SLEEP mode,
 **                                FALSE: start in STARTED mode
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeStart
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) BaudratePtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(boolean, AUTOMATIC) SleepMode
);

/** \brief Can_ModeStop

 **
 ** Forces the controller to stop mode. All ongoing operations are stopped.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeStop
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeReset
 
 **
 ** Forces the controller to reset mode. 
 ** Return the register used by the specified controller to default.
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeReset
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeCheckBusOff
 **
 ** Check the controller for the occurrence of a bus off event.
 **
 ** \return   Returns a bus off event.
 **           TRUE:  bus-off event detected.
 **           FALSE: bus-off event no detected.
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ModeCheckBusOff
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeCheckUncorrectableBitError
 **
 ** Check the controller for the occurrence of an uncorrectable bit error.
 **
 ** \return   Returns an error indication that an uncorrectable bit error in Message
 **           RAM is detected.
 **           TRUE: uncorrectable bit error is detected
 **           FALSE: no error is detected
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_ModeCheckUncorrectableBitError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeClearBusOffInterrupt
 **
 ** Clears the controller BusOff interrupt flag.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeClearBusOffInterrupt
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeEnableEccControl
 **
 ** Enable ECC control.
 ** In order to activate ECC on a per instance basis, if ECC control is already enabled, nothing is done. 
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeEnableEccControl
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_ModeSetRxFifoTopPointer
 **
 ** Set Rx FIFO Top Pointer.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1
 ** \param [in] Value   Set Enable/Disable in Rx FIFO Top Pointer
 **                     TRUE: Enable
 **                     FALSE: Disable
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeSetRxFifoTopPointer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) FifoIndex,
  VAR(boolean, AUTOMATIC) Value
);

/** \brief Can_ModeSetInterruptProtocolError
 **
 ** Sets the error frame detection interrupt of the IE and ILE registers of 
 ** the specified CAN Controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] InterruptEnable    Specify enable/disable of error frame detection interrup
 **                                TRUE : Enable interrupt protocol error
 **                                FALSE: Disable interrupt protocol error
 **
 */
extern FUNC(void, AUTOMATIC) Can_ModeSetInterruptProtocolError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(boolean, AUTOMATIC)InterruptEnable
);

#define CAN_STOP_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

#endif /**defined(CAN_MODEHANDLER_H_INCLUDED)*/

/*==================[end of file]===========================================*/
