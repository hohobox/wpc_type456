/** \brief Can_TxHandler.c
 **
 ** The Tx handler is responsible for sending messages, including
 ** confirmation and cancellation.
 **
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can_TxHandler.h>
#include <Can_Callout.h>
#include <Can_RegisterAbstraction.h>

/*==================[macros]================================================*/

#define CAN_TX_MM_SHIFT                24u
#define CAN_TX_DLC_SHIFT               16u
#define CAN_TX_DLC_MASK              0x0Fu
#define CAN_TX_EFC_ON            0x800000uL
#define CAN_TX_EVENT_ELEMENT_SIZE       8u
#define CAN_TX_BUFFER_HEADER_SIZE       8u
#define CAN_TX_ID_WORD_POS              0u
#define CAN_TX_DLC_MM_WORD_POS          1u
#define CAN_TX_MM_BYTE_POS              7u
#define CAN_TX_DLC_BYTE_POS             6u
#define CAN_TX_DATA_WORD_POS            2u
#define CAN_TX_DATA_BYTE_POS            8u

#define CAN_TX_MASK_ALL_BUFFERS   0xFFFFFFFFuL
#define CAN_TX_MASK_XTD           0x40000000uL
#define CAN_TX_MASK_BR_SWITCHING  0x00100000uL
#define CAN_TX_MASK_FD_FLAG       0x00200000uL
#define CAN_TX_MASK_BYTE_FD_FLAG        0x20uL

#define CAN_TX_MAX_MESSAGE_LENGTH      16u

/** Maximum data length for a CAN message. */
#define CAN_TX_MAX_DLC_CLASSIC     8u

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

/** \brief Can_TxHandleCancelled
 **
 ** Checks all TX buffer entries for canceled messages. The function is intended to
 ** be called on TX cancel IRQ or Can_MainFunction_Write.
 ** 
 ** The function can handle the situation if there is no message pending for cancel.
 ** 
 ** Each TX buffer that is canceled (hw flag set) is freed (ready for next message)
 ** and the TX cancellation notification is sent.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
static FUNC(void, AUTOMATIC) Can_TxHandleCancelled
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_TxHandleTransmitted
 **
 ** Works through all items in the TX event FIFO. The function is intended to be
 ** called on TX event IRQ or Can_MainFunction_Write.
 ** 
 ** The function can handle the situation if there is no message pending.
 ** Each TX event is processed so that the TX buffer is freed (ready for next
 ** message) and the TX confirmation notification is sent.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
static FUNC(void, AUTOMATIC) Can_TxHandleTransmitted
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_TxGetBufferPointer
 **
 ** Returns a pointer to the message RAM where the TX buffer with index
 ** BufferIndex is located.
 **
 ** Each buffer has the following layout:
 ** word 0, bits  0..28: message ID (left aligned)
 ** word 0, bit      29: RTR="0" (transmit data frame)
 ** word 0, bit      30: XTD ("0" -> 11-bit ID, "1" -> 29-bit ID)
 ** word 0, bit      31: reserved
 ** word 1, bits  0..15: reserved
 ** word 1, bits 16..19: DLC
 ** word 1, bits 20..22: reserved
 ** word 1, bit      23: EFC="1" (Store Tx events)
 ** word 1, bits 24..31: MM (message marker, i.e. for general purpose; will be copied to event FIFO.)
 ** (ElementSize)      : message data 
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] BufferIndex   Index of Tx buffer that shall be freed.
 ** \return  Pointer to message RAM TX buffer.
 **
 */
static FUNC_P2VAR(uint8, AUTOMATIC, AUTOMATIC) Can_TxGetBufferPointer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferIndex
);

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal constants]====================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

  /* Deviation from MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics:, 
     MISRA-C:2012 Rule-11.3
     Casting to different object pointer type.
     Justification: The elements in message RAM have to be 32-bit aligned as a hardware restriction
     of the CAN FD anyway. Hence byte-wise access to an address that is not 
     32-bit aligned would not avoid a fault. Therefore the type can be converted without additional risk. */
  /* PRQA S 310 EOF */

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_TxHandleTx
 **
 ** Analyze transmitted and canceled events.
 ** 
 ** Checks all TX buffer entries for canceled messages on cancel event and works
 ** through all items in the TX event FIFO on TX events. The function is intended
 ** to be called on TX cancel IRQ, TX event IRQ or Can_MainFunction_Write.
 ** 
 ** The function can handle the situation if there is no message pending for cancel.
 ** 
 ** Each TX buffer that is canceled (hw flag set) is freed (ready for next message)
 ** and the TX cancellation notification is sent.
 ** 
 ** The function can handle the situation if there is no TX message pending.
 ** Each TX event is processed so that the TX buffer is freed (ready for next
 ** message) and the TX confirmation notification is sent.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_TxHandleTx
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Get interrupt flags */
  uint32 interrupts = Can_RaGetInterruptFlags(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);

  /* Check interrupt flags for TX event */
  if ( 0u != (interrupts & CAN_RA_INTERRUPT_MASK_TX_EVENT) )
  {
    /* TX event detected, handle this TX event. */
    Can_TxHandleTransmitted(ControllerCfgPtr);
  }
  /* Check interrupt flags for cancel event */
  if ( 0u != (interrupts & CAN_RA_INTERRUPT_MASK_TX_CANCEL) )
  {
    /* Cancel event detected, handle this cancel event. */
    Can_TxHandleCancelled(ControllerCfgPtr);
  }
}

/** \brief Can_TxInit
 **
 ** Initializes the TX path of one CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_TxInit
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32 baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  uint32 dedicatedBuffersMask;

  /* Configure FIFOs and buffers. */
  Can_RaSetEventFifoCfg(baseAddress,
                        channelNumber,
                        ControllerCfgPtr->EventFifo.ElementCount,
                        ControllerCfgPtr->EventFifo.StartAddress);
  Can_RaSetTxBufferCfg(baseAddress,
                       channelNumber,
                       ControllerCfgPtr->TxFifoElementCount,
                       ControllerCfgPtr->TxBuffers.ElementCount,
                       ControllerCfgPtr->TxBuffers.StartAddress);
  Can_RaSetTxElementSize(baseAddress, channelNumber, (uint8)(ControllerCfgPtr->TxBuffers.ElementSize));
  
  /* Configure interrupts. */
  Can_RaClearInterruptFlag(baseAddress,
                           channelNumber,
                           CAN_RA_INTERRUPT_MASK_TX_EVENT | CAN_RA_INTERRUPT_MASK_TX_CANCEL);
  /* The dedicated TX buffers start from index 0, FIFO is appended afterwards. */
  dedicatedBuffersMask = CAN_TX_MASK_ALL_BUFFERS >>
                      ((CAN_CONTROLLER_TX_BUFFER_MAX + 1u) - ControllerCfgPtr->TxBuffers.ElementCount);
  Can_RaSetTxCancellationInterruptEnable(baseAddress, channelNumber, dedicatedBuffersMask);
  Can_RaSetTxTransmissionInterruptEnable(baseAddress, channelNumber, dedicatedBuffersMask);

}

/** \brief Can_TxSetup
 **
 ** Setup the TX function of one CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_TxSetup
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32 baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  uint32 dedicatedBuffersMask;
  
  dedicatedBuffersMask = CAN_TX_MASK_ALL_BUFFERS >>
                      ((CAN_CONTROLLER_TX_BUFFER_MAX + 1u) - ControllerCfgPtr->TxBuffers.ElementCount);
  Can_RaSetTxCancellationInterruptEnable(baseAddress, channelNumber, dedicatedBuffersMask);
}

/** \brief Can_TxWrite
 **
 ** Try to write the message to TX buffer of FIFO. The function also checks for
 ** busy and performs cancellation of necessary.
 ** 
 ** Precondition: critical section.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller configuration 
 **                                structure.
 ** \param [in] ControllerStatePtr   Pointer to the controller state data
 **                                  structure.
 ** \param [in] PduIdBufferIndex   The PduIdBufferIndex that shall be used for
 **                                transmission.
 ** \param [in] PduInfoPtr   Pointer to PduInfo structure for CanId, data length
 **                          and SDU data pointer.
 ** \param [in] TxHandle   Gives the dedicated Tx Buffer number used for
 **                        transmission or that the FIFO is used for transmission.
 **                        0..31 stays for a dedicated Tx buffer, values higher
 **                        than 31 stays for FIFO in use.
 ** \param [in] PaddingValue   Value to add for padding bytes in CAN message.
 **
 */
FUNC(void, AUTOMATIC) Can_TxWrite
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  P2CONST(Can_ControllerPduInfoType, AUTOMATIC, AUTOMATIC) PduInfoPtr,
  VAR(uint8, AUTOMATIC) TxHandle,
  VAR(uint8, AUTOMATIC) PaddingValue
)
{
  uint32  baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8 channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8 bufferIndex;
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) txBufferPtr;
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) txDataPtr = PduInfoPtr->DataPtr;
  uint32 dataWord;
  uint8 mappedLength;
  uint8 index;

  
  /* --- Prepare the buffer to with new message data. --- */

  /* --- First word of buffer --- */

  /* Normalize message ID. */
  if (0u == (CAN_CONTROLLER_XTD_ID_FLAG & PduInfoPtr->CanId))
  {
    /* Set standard message ID. */
    dataWord = (PduInfoPtr->CanId << 18u) & CAN_CONTROLLER_MASK_29BIT;
  }
  else
  {
    /* Set extended message ID. */
    dataWord = (PduInfoPtr->CanId & CAN_CONTROLLER_MASK_29BIT) | CAN_TX_MASK_XTD;
  }
  
  /* Get target buffer. */
  if (ControllerCfgPtr->TxBuffers.ElementCount > TxHandle)
  {
    /* TxHandle is a dedicated TX buffer. */
    bufferIndex = TxHandle;
  }
  else
  {
    /* TxHandle is FIFO. */
    bufferIndex = Can_RaGetTxFifoPutIndex(baseAddress, channelNumber);
  }
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 1 */
  txBufferPtr = (P2VAR(uint32, AUTOMATIC, AUTOMATIC))Can_TxGetBufferPointer(ControllerCfgPtr, bufferIndex);

  /* Initialize first word in TX message buffer. */
  txBufferPtr[CAN_TX_ID_WORD_POS] = dataWord;

  /* --- Second word of buffer --- */

  /* Set DLC (Length) and MM (mark as in use and identify message during confirmation. */
  dataWord = ((uint32)PduIdBufferIndex) << CAN_TX_MM_SHIFT;
  dataWord |= CAN_TX_EFC_ON;
  /* Convert length to DLC code. */
  mappedLength = Can_ControllerTranslateLengthToDlc(PduInfoPtr->Length);
  /* Use mapped length, in classic mode higher value than 8 are interpreted as DLC 8. */
  dataWord |= (((uint32)mappedLength) & CAN_TX_DLC_MASK) << CAN_TX_DLC_SHIFT;

  /* Check for CAN FD message*/
  if (   (TRUE == ControllerStatePtr->BaudrateData.BaudratePtr->FdEnabled)
      && (0u != (PduInfoPtr->CanId & CAN_CONTROLLER_FD_ID_FLAG)) )
  {
    /* CAN FD message, set FD Flag. */
    dataWord |= CAN_TX_MASK_FD_FLAG;
    /* Set switch bit rate flag according configuration. */
    if (TRUE == ControllerStatePtr->BaudrateData.BaudratePtr->FdTxBitRateSwitch)
    {
      dataWord |= CAN_TX_MASK_BR_SWITCHING;
    }
  }
  /* Initialize second word in TX message buffer.  */
  txBufferPtr[CAN_TX_DLC_MM_WORD_POS] = dataWord;

  /* --- Data words --- */

  /* Set pointer to start address of the payload. */
  txBufferPtr = &txBufferPtr[CAN_TX_DATA_WORD_POS];

  /* Convert DLC code back to message length and use the new mappedLength to set
   * all data bytes with given values and may fill remaining bytes with PaddingValue.
   * Convert the DLC here again may results in adding number of bytes which have
   * to be filled with padding bytes e.g.
   * PduInfoPtr->Length = 10,
   * first conversion results in mappedLenght = 9 (DLC code),
   * second conversion results in mappedLength = 12 (message length)
   * ==> two bytes are added and must be filled with the PaddingValue. */
  mappedLength = Can_ControllerTranslateDlcToLength(mappedLength);
  for(index = 0u; index < mappedLength; index += 4u)
  {
    uint8 index2;
    /* The input data has to be read byte-wise, because the
       alignment is not known.
       On message RAM byte access does not work, so word access is necessary. */
    dataWord = 0u;
    for (index2 = 0u; index2 < 4u; index2++)
    {
      uint8 byte;
      if (PduInfoPtr->Length > (index + index2))
      {
        byte = txDataPtr[index + index2];
      }
      else
      {
        byte = PaddingValue;
      }
      /* Prepare data word. */
      dataWord |= (((uint32)byte) << ((uint32)index2 * 8u));
    }

    /* Write the prepared data word to TX message buffer */
    *txBufferPtr = dataWord;
    
    /* Update buffer pointer to write next word in next iteration. */
    txBufferPtr = &txBufferPtr[1u];
  }

  /* --- Send message --- */
    
  /* Request sending of the message. */
  Can_RaSetTxAddRequest(baseAddress, channelNumber, bufferIndex);
}

/** \brief Can_TxSetTxCancelRequest
 **
 ** Operation to set the cancel request in HW registers.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 ** \param [in] BufferIndex        Index of the TX buffer to cancel.
 ** \param [in] NormalizedNewCanId
 ** \param [in] IsCancelSameId
 **
 */
FUNC(void, AUTOMATIC) Can_TxSetTxCancelRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferIndex,
  VAR(uint32, AUTOMATIC) NormalizedNewCanId,
  VAR(boolean, AUTOMATIC) IsCancelSameId
)
{
  /* Get current TX buffer to read the pending CAN ID. */
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) txBufferPtr = Can_TxGetBufferPointer(ControllerCfgPtr, BufferIndex);
  /* Get normalized CAN ID of pending TX message. */
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 1 */
  uint32 pendingId = *((P2VAR(uint32, AUTOMATIC, AUTOMATIC))txBufferPtr) & CAN_CONTROLLER_MASK_29BIT;

  /* Check if the priority of the CAN message is higher or the same.
   * Cancellation is allowed if the pending message has a lower priority or
   * in case of the same priority cancellation of same priority must be allowed
   * by configuration. The CAN ID stays for the priority. Lower CAN IDs have
   * higher priority than higher CAN IDs. */
  if (   (pendingId > NormalizedNewCanId)
      || ((TRUE == IsCancelSameId) && (pendingId == NormalizedNewCanId)) )
  {
    Can_RaSetTxCancelRequest(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber, BufferIndex);
  }
}

/** \brief Can_TxClearTxData
 **
 ** Clear Tx Data.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration structure.
 **
 */
FUNC(void, AUTOMATIC) Can_TxClearTxData
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32 baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8  bufferIndex;

  /* Cancel all pending messages, if any. */
  Can_RaSetTxCancellationInterruptEnable(baseAddress, channelNumber, 0u);
  for (bufferIndex = 0u; CAN_CONTROLLER_TX_BUFFER_MAX >= bufferIndex; bufferIndex++)
  {
    /* If the message has been sent or canceled, the cancel request is ignored by the HW. */
    Can_RaSetTxCancelRequest(baseAddress, channelNumber, bufferIndex);
  }

  /* Clean up event FIFO, if not clean already. */
  for (bufferIndex = 0u; (0u < Can_RaGetEventFifoFillLevel(baseAddress, channelNumber))
      && (CAN_CONTROLLER_EVENT_FIFO_MAX >= bufferIndex); bufferIndex++)
  {
    Can_RaSetEventFifoAck(baseAddress, channelNumber, Can_RaGetEventFifoGetIndex(baseAddress, channelNumber));
  }
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_TxHandleCancelled
 **
 ** Checks all TX buffer entries for canceled messages. The function is intended to
 ** be called on TX cancel IRQ or Can_MainFunction_Write.
 ** 
 ** The function can handle the situation if there is no message pending for cancel.
 ** 
 ** Each TX buffer that is canceled (hw flag set) is freed (ready for next message)
 ** and the TX cancellation notification is sent.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
static FUNC(void, AUTOMATIC) Can_TxHandleCancelled
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32  messageCopy[CAN_TX_MAX_MESSAGE_LENGTH];
  uint32  baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8   channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   numberOfDedicatedMessages =  ControllerCfgPtr->TxBuffers.ElementCount;
  uint8   bufferIndex;
  uint8   messageLength;
  uint8   i;
  uint8   maxLoopNum;
  Can_ControllerPduIdBufferIndexType PduIdBufferIndex;
  
  /* Clearing of IRQ flag is done before working through the buffers, because 
   * the flag is set on event-edges. Therefore events that appear before
   * clearing the IRQ-flag but after read-out will not get lost. */
  Can_RaClearInterruptFlag(baseAddress, channelNumber, CAN_RA_INTERRUPT_MASK_TX_CANCEL);
  
  /* Loop each dedicated message Buffer. */
  for (bufferIndex = 0u; numberOfDedicatedMessages > bufferIndex; bufferIndex++)
  {
    if (FALSE != Can_RaGetTxBufferCancelled(baseAddress, channelNumber, bufferIndex))
    {
      /* BufferIndex has been canceled, get MessageRam pointer to pick up some
       * properties of the message to confirm the cancellation. */
      P2VAR(uint8, AUTOMATIC, AUTOMATIC) MessageRamPtr = Can_TxGetBufferPointer(ControllerCfgPtr, bufferIndex);
      
      /* Get PduId Buffer Index */
      PduIdBufferIndex = Can_RaReadByteMRAM(MessageRamPtr, CAN_TX_MM_BYTE_POS);
      if (CAN_DATA_FREE_PDUID_BUFFER_SLOT != Can_DataGetTxPduId(PduIdBufferIndex))
      {
        /* Convert DLC to sduLength values. */
        messageLength = Can_RaReadByteMRAM(MessageRamPtr, CAN_TX_DLC_BYTE_POS) & CAN_TX_DLC_MASK;
        if (0u != (Can_RaReadByteMRAM(MessageRamPtr, CAN_TX_DLC_BYTE_POS) & CAN_TX_MASK_BYTE_FD_FLAG))
        {
          /* CAN FD mode */
          /* Convert length with look up table. */
          messageLength = Can_ControllerTranslateDlcToLength(messageLength);
        }
        else
        {
          /* Classic mode */
          /* Cut length. */
          if (messageLength > CAN_TX_MAX_DLC_CLASSIC)
          {
            messageLength = CAN_TX_MAX_DLC_CLASSIC;
          }
        }

        /* Calculate the number of loops for copy.
           If it is not divisible by 4 bytes, increase the loop number by 1.
           Ex. messageLength=3(bytes)
               messageLength/4(bytes) = 0 mod 3
               Therefore, increase maxLoopNum by 1.
        */
        maxLoopNum = messageLength >> 2u;
        if (0u != (messageLength & 0x03u))
        {
          maxLoopNum++;
        }
        
        /* Copy message. */
        for (i = 0u; i < maxLoopNum; i++)
        {
          /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
             Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is 
             placed in 4-byte alignment. */
          /* PRQA S 3305 2 */
          P2VAR(uint32, AUTOMATIC, AUTOMATIC) mRamWordPtr = 
                                            (P2VAR(uint32, AUTOMATIC, AUTOMATIC))&(MessageRamPtr[CAN_TX_DATA_BYTE_POS]);
          messageCopy[i] = mRamWordPtr[i];
        }
        
        /* BufferIndex has been canceled, so call out TX confirmation.
         * It will release the buffer in the message queue. */
        Can_CanIfTxCancellation(PduIdBufferIndex, (P2VAR(uint8, AUTOMATIC, AUTOMATIC))messageCopy, messageLength);
      }
    }
  }
}

/** \brief Can_TxHandleTransmitted
 **
 ** Works through all items in the TX event FIFO. The function is intended to be
 ** called on TX event IRQ or Can_MainFunction_Write.
 ** 
 ** The function can handle the situation if there is no message pending.
 ** Each TX event is processed so that the TX buffer is freed (ready for next
 ** message) and the TX confirmation notification is sent.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
static FUNC(void, AUTOMATIC) Can_TxHandleTransmitted
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32  baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8   channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   timeout;
  
  /* Loop each event in event FIFO; maximum each entry once to prevent deadlock. */
  for (timeout = CAN_CONTROLLER_EVENT_FIFO_MAX + 1u;
      (0u < Can_RaGetEventFifoFillLevel(baseAddress, channelNumber)) && (0u < timeout);
      timeout--)
  {
    /* Pop event and read PduIdBufferIndex from MM field. */
    uint8 eventIndex = Can_RaGetEventFifoGetIndex(baseAddress, channelNumber);
    P2VAR(uint8, AUTOMATIC, AUTOMATIC) messageRamPtr = 
                                       &(ControllerCfgPtr->MessageRamBasePtr[ControllerCfgPtr->EventFifo.StartAddress]);
    /* Each message item has a size of 8 bytes, MM is stored at byte 7. */
    uint8 pduIdBufferIndex = Can_RaReadByteMRAM(messageRamPtr,
                                                (CAN_TX_EVENT_ELEMENT_SIZE * (uint16)eventIndex) + CAN_TX_MM_BYTE_POS);

    /* Clearing of IRQ flag is done before working through the buffers, 
     * because the flag is set on event-edges. Therefore events that appear
     * before clearing the IRQ-flag but after read-out will not get lost. */
    Can_RaClearInterruptFlag(baseAddress, channelNumber, CAN_RA_INTERRUPT_MASK_TX_EVENT);
    Can_RaSetEventFifoAck(baseAddress, channelNumber, eventIndex);
    
    /* Callout TX confirmation. There the reserved slot for the message is
     * released. */
    Can_CanIfTxConfirmation(pduIdBufferIndex);
  }
}

/** \brief Can_TxGetBufferPointer
 **
 ** Returns a pointer to the message RAM where the TX buffer with index
 ** BufferIndex is located.
 **
 ** Each buffer has the following layout:
 ** word 0, bits  0..28: message ID (left aligned)
 ** word 0, bit      29: RTR="0" (transmit data frame)
 ** word 0, bit      30: XTD ("0" -> 11-bit ID, "1" -> 29-bit ID)
 ** word 0, bit      31: reserved
 ** word 1, bits  0..15: reserved
 ** word 1, bits 16..19: DLC
 ** word 1, bits 20..22: reserved
 ** word 1, bit      23: EFC="1" (Store Tx events)
 ** word 1, bits 24..31: MM (message marker)
 ** (ElementSize)      : message data 
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] BufferIndex   Index of Tx buffer that shall be freed.
 ** \return  Pointer to message RAM TX buffer.
 **
 */
static FUNC_P2VAR(uint8, AUTOMATIC, AUTOMATIC) Can_TxGetBufferPointer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferIndex
)
{
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) messageRamPtr = ControllerCfgPtr->MessageRamBasePtr;
  /* Each message item has a header of 8 bytes followed by the message contents of ElementSize. */
  uint16 ramItemSize =   CAN_TX_BUFFER_HEADER_SIZE 
                       + (uint16)Can_ControllerTranslateFieldSize(ControllerCfgPtr->TxBuffers.ElementSize);
  
  return &(messageRamPtr[ControllerCfgPtr->TxBuffers.StartAddress + (ramItemSize * BufferIndex)]);
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[end of file]===========================================*/
