/** \brief AUTOSAR SPI Driver
 **
 ** This file contains implementation of API function.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Spi.h>
#include <Spi_ExternalInclude.h>
#include <Spi_Cfg_Der.h>
#include <Spi_Common.h>
#include <Spi_Internal.h>
#include <Spi_Sequence.h>
#include <Spi_Hw.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define SPI_START_SEC_CODE_ASIL_B

#include <Spi_MemMap.h>

#if defined (SPI_VERSION_INFO_API) && (SPI_VERSION_INFO_API == STD_ON)

/** \brief Spi_GetVersionInfo
 **
 ** This service returns the version information of this module.
 **
 ** \return None.
 ** \param [out] versioninfo   Pointer to where to store the version information
 **                            of this module
 **
 */
FUNC( void, SPI_CODE ) Spi_GetVersionInfo
(
  P2VAR( Std_VersionInfoType, AUTOMATIC, AUTOMATIC ) versioninfo
)
{
  /* check if the passed pointer is valid */
  if ( versioninfo == NULL_PTR )
  {
    /* Pointer is invalid. */
    Spi_Com_DetReportError( SPI_API_GETVERSIONINFO, SPI_E_PARAM_POINTER );
  }
  /* no error is detected */
  else
  {
    /* Pointer is valid. */
    Spi_Internal_GetVersionInfo( versioninfo );
    /* Set Software version */
    versioninfo->sw_major_version = SPI_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = SPI_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = SPI_SW_PATCH_VERSION;
    
  }
}

#endif /* SPI_VERSION_INFO_API */

#if defined(SPI_CHANNEL_BUFFERS_ALLOWED) && ((SPI_CHANNEL_BUFFERS_ALLOWED == 0) || (SPI_CHANNEL_BUFFERS_ALLOWED == 2))

/** \brief Spi_WriteIB
 **
 ** Service for writing one or more data to an IB SPI Handler/Driver Channel
 ** specified by parameter.
 ** Only available if SPI_CHANNEL_BUFFERS_ALLOWED is 0 or 2.
 **
 ** \return E_OK:     write command has been accepted
 **         E_NOT_OK: write command has not been accepted
 ** 
 ** \param [in] Channel         Channel ID
 ** \param [in] DataBufferPtr   Pointer to source data buffer. If this pointer is
 **                             null, it is assumed that the data to be transmitted 
 **                             is not relevant and the default transmit value of 
 **                             this channel will be used instead.
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_WriteIB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DataBufferPtr
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;

  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_WRITEIB, SPI_E_UNINIT );
  }
  /* check if the channel is valid */
  else if ( Channel >= Spi_Current_ConfigPtr->ChannelCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid channel ID. */
    Spi_Com_DetReportError( SPI_API_WRITEIB, SPI_E_PARAM_CHANNEL );
  }
  /* check if the channel type is not valid */
  else if ( Spi_Internal_CheckChannelType( Channel, SPI_CHANNEL_TYPE_IB ) != SPI_OK )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* the channel type is invalid */
    Spi_Com_DetReportError( SPI_API_WRITEIB, SPI_E_PARAM_CHANNEL );
  }
  /* the channel type is valid */
  else
  {
    /* enter a critical section */
    Spi_Com_SchMEnterCriticalSection();

    /* check if driver is not initialized yet */
    if ( Spi_Internal_GetStatus() == SPI_UNINIT )
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* SPI driver must be initialized. */
      Spi_Com_DetReportError( SPI_API_WRITEIB, SPI_E_UNINIT );
    }
    /* driver is already initialized */
    else
    {
      /* set result to ok */
      RetVal = E_OK;
      /* call an internal function to write data to an internal buffer */
      Spi_Internal_WriteIB( Channel, DataBufferPtr );
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
    }
  }
  return RetVal;
}

/** \brief Spi_ReadIB
 **
 ** Service for reading synchronously one or more data from an IB SPI
 ** Handler/Driver Channel specified by parameter.
 ** Only available if SPI_CHANNEL_BUFFERS_ALLOWED is 0 or 2.
 **
 ** \return E_OK:     read command has been accepted
 **         E_NOT_OK: read command has not been accepted
 ** 
 ** \param [in] Channel             Channel ID
 ** \param [out] DataBufferPointer  Pointer to destination data buffer in RAM
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_ReadIB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DataBufferPointer
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_READIB, SPI_E_UNINIT );
  }
  /* check if the channel is valid */
  else if ( Channel >= Spi_Current_ConfigPtr->ChannelCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid channel ID. */
    Spi_Com_DetReportError( SPI_API_READIB, SPI_E_PARAM_CHANNEL );
  }
  /* check if the passed pointer is valid */
  else if ( DataBufferPointer == NULL_PTR )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid buffer pointer */
    Spi_Com_DetReportError( SPI_API_READIB, SPI_E_PARAM_POINTER );
  }
  /* check if the channel type is valid */
  else if ( Spi_Internal_CheckChannelType( Channel, SPI_CHANNEL_TYPE_IB ) != SPI_OK )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* the channel type is invalid */
    Spi_Com_DetReportError( SPI_API_READIB, SPI_E_PARAM_CHANNEL );
  }
  else
  {
    /* enter a critical section */
    Spi_Com_SchMEnterCriticalSection();

    /* check if driver is not initialized yet */
    if ( Spi_Internal_GetStatus() == SPI_UNINIT )
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* SPI driver must be initialized. */
      Spi_Com_DetReportError( SPI_API_READIB, SPI_E_UNINIT );
    }
    /* driver is already initialized */
    else
    {
      /* set result to ok */
      RetVal = E_OK;
      /* call an internal function to write data to an internal buffer */
      Spi_Internal_ReadIB( Channel, DataBufferPointer );
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
    }
  }
  return RetVal;
}

#endif /* SPI_CHANNEL_BUFFERS_ALLOWED is 0 or 2 */

#if defined(SPI_CHANNEL_BUFFERS_ALLOWED) && ((SPI_CHANNEL_BUFFERS_ALLOWED == 1) || (SPI_CHANNEL_BUFFERS_ALLOWED == 2))

/** \brief Spi_SetupEB
 **
 ** Service to setup the buffers and the length of data for the EB SPI
 ** Handler/Driver Channel specified.
 ** Only available if SPI_CHANNEL_BUFFERS_ALLOWED is 1 or 2.
 **
 ** \return E_OK:       Setup command has been accepted
 **         E_NOT_OK:   Setup command has not been accepted
 **
 ** \param [in] Channel           Channel ID
 ** \param [in] SrcDataBufferPtr  Pointer to source data buffer
 ** \param [in] DesDataBufferPtr  Pointer to destination data buffer in RAM
 ** \param [in] Length            Length (number of data elements) of the data to be transmitted 
 **                               from SrcdataBufferPtr and/or received from 
 **                               DesDataBufferPtr.
 **                               Min.:  1
 **                               Max.: Maximum of data specified at configuration
 **                               for this channel
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_SetupEB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  VAR( Spi_ErrorType, AUTOMATIC ) ErrorId;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_SETUPEB, SPI_E_UNINIT );
  }
  /* check if the channel is valid */
  else if ( Channel >= Spi_Current_ConfigPtr->ChannelCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid channel ID. */
    Spi_Com_DetReportError( SPI_API_SETUPEB, SPI_E_PARAM_CHANNEL );
  }
  /* check if the channel type is not valid */
  else if ( Spi_Internal_CheckChannelType( Channel, SPI_CHANNEL_TYPE_EB ) != SPI_OK )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* the channel type is invalid */
    Spi_Com_DetReportError( SPI_API_SETUPEB, SPI_E_PARAM_CHANNEL );
  }
  /* the channel type is valid */
  else
  {
    /* enter a critical section */
    Spi_Com_SchMEnterCriticalSection();

    /* check if driver is not initialized yet */
    if ( Spi_Internal_GetStatus() == SPI_UNINIT )
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* SPI driver must be initialized. */
      Spi_Com_DetReportError( SPI_API_SETUPEB, SPI_E_UNINIT );
    }
    /* check if the buffer parameters are valid */
    else if ( Spi_Internal_CheckSetupEB( Channel,
                                         SrcDataBufferPtr,
                                         DesDataBufferPtr,
                                         Length,
                                         &ErrorId ) != SPI_OK )
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* the buffer parameters are invalid */
      Spi_Com_DetReportError( SPI_API_SETUPEB, ErrorId );
    }
    /* no error is detected */
    else
    {
      /* call an internal function to setup external buffer and then update result */
      Spi_Internal_SetupEB( Channel,
                            SrcDataBufferPtr,
                            DesDataBufferPtr,
                            Length );
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ok */
      RetVal = E_OK;
    }
  }
  return RetVal;
}

#endif /* SPI_CHANNEL_BUFFERS_ALLOWED is 1 or 2 */

#if defined(SPI_LEVEL_DELIVERED) && ((SPI_LEVEL_DELIVERED == 0) || (SPI_LEVEL_DELIVERED == 2))

/** \brief Spi_SyncTransmit
 **
 ** Service to synchronously transmit data on the SPI bus.
 ** Only available if SPI_LEVEL_DELIVERED is 0 or 2.
 **
 ** Global variables accessed: 
 ** - Spi_SyncStatus (read/write)
 **
 ** \return E_OK:     Transmission command has been accepted
 **         E_NOT_OK: Transmission command has not been accepted
 ** 
 ** \param [in] Sequence   Sequence ID
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_SyncTransmit
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
#if SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT != SPI_TRUE
  VAR( Spi_StatusType, AUTOMATIC ) SyncStatus;
#endif /* SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT != SPI_TRUE */
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfigPtr;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_UNINIT );
  }
  /* check if the passed sequence is valid */
  else if ( Sequence >= Spi_Current_ConfigPtr->SequenceCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid sequence ID. */
    Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_PARAM_SEQ );
  }
  else
  {
    SequenceConfigPtr = &( Spi_Current_ConfigPtr->SequencesConfigListPtr[Sequence] );
    /* check if the sequence does not include an asynchronous job */
    if ( Spi_Internal_CheckSyncJob( SPI_HWUNIT_SYNC, SequenceConfigPtr ) != SPI_OK )
    {
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* Sequence contains an asynchronous job */
      Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_INVALID_HW );
    }
    /* the relevant sequence does not have an asynchronous job */
    else
    {
      /* enter a critical section */
      Spi_Com_SchMEnterCriticalSection();

      /* check if driver is not initialized yet */
      if ( Spi_Internal_GetStatus() == SPI_UNINIT )
      {
        /* exit a critical section */
        Spi_Com_SchMExitCriticalSection();
        /* set result to ng */
        RetVal = E_NOT_OK;
        /* SPI driver must be initialized. */
        Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_UNINIT );
      }
      /* check if the sequence is pending */
      else if ( Spi_Seq_GetCurrentJob( Sequence ) != SPI_INVALID_JOB )
      {
        /* exit a critical section */
        Spi_Com_SchMExitCriticalSection();
        /* set result to ng */
        RetVal = E_NOT_OK;
        /* the sequence is pending */
        Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_SEQ_PENDING );
      }
      else
      {
#if SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT != SPI_TRUE
        /* Get sync status */
        SyncStatus = Spi_Internal_GetSyncStatus();
        /* check if SpiSupportConcurrentSyncTransmit is false */
        if ( SyncStatus != SPI_IDLE )
        {
          /* exit a critical section */
          Spi_Com_SchMExitCriticalSection();
          /* set result to ng */
          RetVal = E_NOT_OK;
          /* the request is not accepted because another sequence is on-going */
          Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_SEQ_IN_PROCESS );
        }
        /* current synchronous status is not busy */
        else
        {
#endif /* SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT != SPI_TRUE */
          /* check if the sequence includes a pending job */
          if ( Spi_Internal_CheckRelatedStatus( SequenceConfigPtr, 
               SPI_HWUNIT_SYNC ) != SPI_OK )
          {
            /* exit a critical section */
            Spi_Com_SchMExitCriticalSection();
            /* set result to ng */
            RetVal = E_NOT_OK;
            /* the request is not accepted because another sequence is on-going */
            Spi_Com_DetReportError( SPI_API_SYNCTRANSMIT, SPI_E_SEQ_IN_PROCESS );
          }
          /* all previous checking are finished */
          else
          {
            /* set synchronous status to idle? */
            Spi_Internal_SetSyncStatus( SPI_BUSY );
            /* update related status */
            /* Pending is checked by a previous function in case of synchronous transmission.
             * If code is reached here, a next function always returns SPI_OK.
             * Therefore a return value of next function is ignored. */
            (void) Spi_Internal_SetRelatedStatus( SequenceConfigPtr, SPI_HWUNIT_SYNC );

            /* exit a critical section */
            Spi_Com_SchMExitCriticalSection();

            /* call an internal function to do synchronous transmission */
            Spi_Internal_SyncTransmit( Sequence );

            /* set result to ok */
            RetVal = E_OK;
          }
#if SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT != SPI_TRUE          
        }
#endif /* SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT != SPI_TRUE */
      }
    }
  }
  return RetVal;
}

#endif /* SPI_LEVEL_DELIVERED is 0 or 2 */

#if defined(SPI_LEVEL_DELIVERED) && ((SPI_LEVEL_DELIVERED == 1) || (SPI_LEVEL_DELIVERED == 2))

/** \brief Spi_AsyncTransmit
 **
 ** Service to asynchronously transmit data on the SPI bus.
 ** Only available if SPI_LEVEL_DELIVERED is 1 or 2.
 **
 ** \return E_OK:     Transmission command has been accepted
 **         E_NOT_OK: Transmission command has not been accepted
 **
 ** \param [in] Sequence   Sequence ID.
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_AsyncTransmit
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  VAR( Spi_ReturnType, AUTOMATIC ) CheckResult;
  VAR( uint8, AUTOMATIC ) LevelDelivered; /* level delivered */
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfigPtr;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_UNINIT );
  }
  /* check if the passed sequence ID is valid */
  else if ( Sequence >= Spi_Current_ConfigPtr->SequenceCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid sequence ID. */
    Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_PARAM_SEQ );
  }
  else 
  {
    SequenceConfigPtr = &( Spi_Current_ConfigPtr->SequencesConfigListPtr[Sequence] );
    /* check if the sequence includes a synchronous job */
    if ( Spi_Internal_CheckSyncJob( SPI_HWUNIT_ASYNC, SequenceConfigPtr ) != SPI_OK )
    {
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* Sequence contains a synchronous job */
      Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_INVALID_HW );
    }
    /* the relevant sequence does not have a synchronous job */
    else
    {
      /* enter a critical section */
      Spi_Com_SchMEnterCriticalSection();

      /* check if driver is not initialized yet */
      if ( Spi_Internal_GetStatus() == SPI_UNINIT )
      {
        /* exit a critical section */
        Spi_Com_SchMExitCriticalSection();
        /* set result to ng */
        RetVal = E_NOT_OK;
        /* SPI driver must be initialized. */
        Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_UNINIT );
      }
      /* check if the sequence is pending */
      else if ( Spi_Seq_GetCurrentJob( Sequence ) != SPI_INVALID_JOB )
      {
        /* exit a critical section */
        Spi_Com_SchMExitCriticalSection();
        /* set result to ng */
        RetVal = E_NOT_OK;
        /* the sequence is pending */
        Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_SEQ_PENDING );
      }
      /* the relevant sequence is not pending */
      else
      {
        LevelDelivered = Spi_Com_GetLevelDelivered();
        CheckResult = Spi_Internal_CheckRelatedStatus( SequenceConfigPtr, SPI_HWUNIT_ASYNC );
        /* check if the sequence includes a pending job */
        if ( ( LevelDelivered == SPI_LEVEL_DELIVERED_2 ) &&
             ( CheckResult != SPI_OK ) )
        {
            /* exit a critical section */
            Spi_Com_SchMExitCriticalSection();
            /* set result to ng */
            RetVal = E_NOT_OK;
            /* a pending job is included in the sequence */
            Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_SEQ_PENDING );
        }
        /* all previous checking are finished */
        else
        {
          /* check if it is possible to set the sequence into queue */
          CheckResult = Spi_Internal_SetRelatedStatus( SequenceConfigPtr, SPI_HWUNIT_ASYNC );
          /* check if queuing is failed */
          if ( CheckResult == SPI_FAILED )
          {
            /* exit a critical section */
            Spi_Com_SchMExitCriticalSection();
            /* set result to ng */
            RetVal = E_NOT_OK;
            /* the sequence is not possible to be queued */
            Spi_Com_DetReportError( SPI_API_ASYNCTRANSMIT, SPI_E_SEQ_PENDING );
          }
          /* check if queuing is successful */
          else if ( CheckResult == SPI_OK )
          {
            /* exit a critical section */
            Spi_Com_SchMExitCriticalSection();
            /* call an internal function to do asynchronous transmission */
            Spi_Internal_AsyncTransmit( Sequence );
            /* set result to ok */
            RetVal = E_OK;
          }
          /* queuing is successful but hwunit is not started yet
           * because the relevant hwuint is already running */
          else
          {
            /* exit a critical section */
            Spi_Com_SchMExitCriticalSection();
            /* set result to ok */
            RetVal = E_OK;
          }
        }
      }
    }
  }
  return RetVal;
}

#endif /* SPI_LEVEL_DELIVERED is 1 or 2 */

#if defined(SPI_CANCEL_API) && (SPI_CANCEL_API == STD_ON)

/** \brief Spi_Cancel
 **
 ** Service to cancel the specified ongoing sequence transmission.
 ** Only available if SPI_CANCEL_API is STD_ON.
 **
 ** \return None.
 ** \param [in] Sequence   Sequence ID
 **
 */
FUNC( void, SPI_CODE ) Spi_Cancel
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{

  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_CANCEL, SPI_E_UNINIT );
  }
  /* check if the sequence is valid */
  else if ( Sequence >= Spi_Current_ConfigPtr->SequenceCount )
  {
    /* Invalid sequence ID. */
    Spi_Com_DetReportError( SPI_API_CANCEL, SPI_E_PARAM_SEQ );
  }
  /* no error is detected */
  else
  {
    /* enter a critical section */
    Spi_Com_SchMEnterCriticalSection();

    /* check if driver is not initialized yet */
    if ( Spi_Internal_GetStatus() == SPI_UNINIT )
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* SPI driver must be initialized. */
      Spi_Com_DetReportError( SPI_API_CANCEL, SPI_E_UNINIT );
    }
    /* driver is already initialized */
    else
    {
      /* call an internal function to cancel the required sequence */
      Spi_Internal_Cancel( Sequence );
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
    }
  }
}
#endif /* SPI_CANCEL_API */

#if defined(SPI_LEVEL_DELIVERED) && (SPI_LEVEL_DELIVERED == 2)

/** \brief Spi_SetAsyncMode
 **
 ** Service to set the transmission mechanism mode for SPI buses
 ** handled asynchronously.
 ** Only available if SPI_LEVEL_DELIVERED is 2.
 **
 ** \return E_OK:     Operation was successful
 **         E_NOT_OK: Command has not been accepted
 **
 ** \param [in] Mode  Requested mode: SPI_POLLING_MODE or SPI_INTERRUPT_MODE
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_SetAsyncMode
(
  VAR( Spi_AsyncModeType, AUTOMATIC ) Mode
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  
  /* Perform error checks. */

  /* enter a critical section */
  Spi_Com_SchMEnterCriticalSection();

  /* check if driver is not initialized yet */
  if ( Spi_Internal_GetStatus() == SPI_UNINIT )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI was not initialized before. */
    Spi_Com_DetReportError( SPI_API_SETASYNCMODE, SPI_E_UNINIT );
  }
  /* check if the passed mode is valid */
  else if ( ( Mode != SPI_POLLING_MODE ) && ( Mode != SPI_INTERRUPT_MODE ) )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* the mode is out of range */
    Spi_Com_DetReportError( SPI_API_SETASYNCMODE, SPI_E_PARAM_BAD_MODE );
  }
  /* no error is detected */
  else
  {
    /* call an internal function to set asynchronous mode */
    RetVal = ( Spi_Internal_SetAsyncMode( Mode ) == SPI_OK ) ? ( E_OK ) : ( E_NOT_OK );
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
  }
  return RetVal;
}

#endif /* SPI_LEVEL_DELIVERED is 2 */

/** \brief Spi_Init
 **
 ** Service for SPI initialization.
 **
 ** \param [in] ConfigPtr   Pointer to driver configuration set
 **
 */
FUNC( void, SPI_CODE ) Spi_Init
(
  P2CONST( Spi_ConfigType, AUTOMATIC, AUTOMATIC ) ConfigPtr
)
{
  /* Perform error checks. */

  /* check if the driver is already initialized */
  if ( Spi_Internal_GetStatus() != SPI_UNINIT ) {
    /* The SPI driver must be in state SPI_UNINIT prior to initialization. */
    Spi_Com_DetReportError( SPI_API_INIT, SPI_E_ALREADY_INITIALIZED );
  }
  /* call an internal function if no error is detected */
  else
  {
    /* request default config */
    if (NULL_PTR == ConfigPtr )
    {
      ConfigPtr = Spi_Cfg_GetDefaultConfig();
    }
    /* check if valid config */
    if ( SPI_FALSE == Spi_Cfg_CheckConfig(ConfigPtr) )
    {
      /* Specified Configptr is incorrect pointer. */
      Spi_Com_DetReportError( SPI_API_INIT, SPI_E_PARAM_CONFIG );
    }
    else
    {
      /* initialize the driver here */
      Spi_Internal_Init(ConfigPtr);
    }
  }
}

/** \brief Spi_DeInit
 **
 ** Service for SPI de-initialization.
 **
 ** \return E_OK:     De-initialization completed
 **         E_NOT_OK: De-initialization request has not been accepted
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_DeInit(void)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  VAR( Spi_StatusType, AUTOMATIC ) CurStatus;

  /* enter a critical section */
  Spi_Com_SchMEnterCriticalSection();

  /* get current status */
  CurStatus = Spi_Internal_GetStatus();

  /* Perform error checks. */

  /* check if driver is not initialized yet */
  if ( CurStatus == SPI_UNINIT )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI was not initialized before.
       Report an error and reject the request. */
    Spi_Com_DetReportError( SPI_API_DEINIT, SPI_E_UNINIT );
  }
  /* check if status is busy */
  else if ( CurStatus == SPI_BUSY )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* SPI is currently transmitting. Reject the request. */
    /* set result to ng */
    RetVal = E_NOT_OK;
  }
  /* no error is detected */
  else
  {
    /* set current status to unint */
    Spi_Internal_SetStatus( SPI_UNINIT );

    /* set synchronous status to idle */
    Spi_Internal_SetSyncStatus( SPI_IDLE );
    
    /* Perform de-initialization tasks. */
    Spi_Internal_DeInit();

    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();

    /* set result to ok */
    RetVal = E_OK;
  }
  return RetVal;
}

/** \brief Spi_GetStatus
 **
 ** Service returns the SPI Handler/Driver software module status.
 **
 ** \return Driver status, either SPI_UNINIT, SPI_IDLE or SPI_BUSY
 **
 */
FUNC( Spi_StatusType, SPI_CODE ) Spi_GetStatus(void)
{
  CONST( Spi_StatusType, AUTOMATIC ) CurStatus = Spi_Internal_GetStatus();

  /* Perform state check. */

  /* check if driver is not initialized yet */
  if ( CurStatus == SPI_UNINIT )
  {
    /* SPI was not initialized before. */
    Spi_Com_DetReportError( SPI_API_GETSTATUS, SPI_E_UNINIT );
  }
  return CurStatus;
}

#if defined(SPI_HW_STATUS_API) && (SPI_HW_STATUS_API == STD_ON)
/** \brief Spi_GetHWUnitStatus
 **
 ** This service returns the status of the specified SPI Hardware
 ** peripheral.
 **
 ** \return Status of specified SPI Hardware peripheral: SPI_UNINIT, SPI_IDLE or 
 **         SPI_BUSY
 ** \param [in] HWUnit   SPI Hardware peripheral (unit) ID
 **
 */
FUNC( Spi_StatusType, SPI_CODE ) Spi_GetHWUnitStatus
(
  VAR( Spi_HWUnitType, AUTOMATIC ) HWUnit
)
{
  VAR( Spi_StatusType, AUTOMATIC ) RetStatus;

  /* Perform error checks. */

  /* check if driver is not initialized yet */
  if ( Spi_Internal_GetStatus() == SPI_UNINIT )
  {
    /* set result to uninit */
    RetStatus = SPI_UNINIT;
    /* SPI was not initialized before. */
    Spi_Com_DetReportError( SPI_API_GETHWUNITSTATUS, SPI_E_UNINIT );
    /* This path will return SPI_UNINIT. */
  }
  /* check if hwunit is valid */
  else if ( HWUnit >= SPI_MAX_HW_UNIT )
  {
    /* set result to uninit */
    RetStatus = SPI_UNINIT;
    /* Invalid HW unit ID. */
    Spi_Com_DetReportError( SPI_API_GETHWUNITSTATUS, SPI_E_PARAM_UNIT );
  }
  /* check avairable SCB */
  else if ( (Spi_SCBRegsType *)NULL_PTR == Spi_Current_ConfigPtr->ScbRegsPtr[HWUnit] )
  {
    /* set result to uninit */
    RetStatus = SPI_UNINIT;
    /* Invalid HW unit ID. */
    Spi_Com_DetReportError( SPI_API_GETHWUNITSTATUS, SPI_E_PARAM_UNIT );
  }
  /* no error is detected */
  else
  {
    /* Valid HW unit. */
    RetStatus = Spi_Info.HwInfoListPtr[HWUnit].Status;
  }
  return RetStatus;
}
#endif /* SPI_HW_STATUS_API */

/** \brief Spi_GetJobResult
 **
 ** This service returns the last transmission result of the specified Job.
 **
 ** \return Transmission result of the specified Job: SPI_JOB_OK, SPI_JOB_PENDING,
 **         SPI_JOB_FAILED or SPI_JOB_QUEUED
 ** \param [in] Job   Job ID. In case of invalid Job ID, SPI_JOB_FAILED will be 
 **                   returned.
 **
 */
FUNC( Spi_JobResultType, SPI_CODE ) Spi_GetJobResult
(
  VAR( Spi_JobType, AUTOMATIC ) Job
)
{
  VAR( Spi_JobResultType, AUTOMATIC ) RetVal;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = SPI_JOB_FAILED;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_GETJOBRESULT, SPI_E_UNINIT );
  }
  /* check if driver is not initialized yet */
  else if ( Spi_Internal_GetStatus () == SPI_UNINIT )
  {
    /* set result to failed */
    RetVal = SPI_JOB_FAILED;
    /* SPI was not initialized before. */
    Spi_Com_DetReportError( SPI_API_GETJOBRESULT, SPI_E_UNINIT );
  }
  /* check if job is invalid */
  else if ( Job >= Spi_Current_ConfigPtr->JobCount )
  {
    /* set result to failed */
    RetVal = SPI_JOB_FAILED;
    /* Invalid job ID. */
    Spi_Com_DetReportError( SPI_API_GETJOBRESULT, SPI_E_PARAM_JOB );
  }
  /* no error is detected */
  else
  {
    /* Job is valid. */
    RetVal = Spi_Internal_GetJobResult( Job );
  }
  return RetVal;
}

/** \brief Spi_GetSequenceResult
 **
 ** This service returns the last transmission result of the specified Sequence.
 **
 ** \return Transmission result of the specified Sequence: SPI_SEQ_OK, 
 **         SPI_SEQ_PENDING, SPI_SEQ_FAILED or SPI_SEQ_CANCELED
 ** \param [in] Sequence   Sequence ID. In case of invalid Sequence ID, SPI_SEQ_FAILED 
 **                        will be returned.
 **
 */
FUNC( Spi_SeqResultType, SPI_CODE ) Spi_GetSequenceResult
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  VAR( Spi_SeqResultType, AUTOMATIC ) RetVal;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = SPI_SEQ_FAILED;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_GETSEQUENCERESULT, SPI_E_UNINIT );
  }
  /* check if driver is not initialized yet */
  else if ( Spi_Internal_GetStatus() == SPI_UNINIT )
  {
    /* set result to failed */
    RetVal = SPI_SEQ_FAILED;
    /* SPI was not initialized before. */
    Spi_Com_DetReportError( SPI_API_GETSEQUENCERESULT, SPI_E_UNINIT );
  }
  /* check if sequence is invalid */
  else if ( Sequence >= Spi_Current_ConfigPtr->SequenceCount )
  {
    /* set result to failed */
    RetVal = SPI_SEQ_FAILED;
    /* Invalid sequence ID. */
    Spi_Com_DetReportError( SPI_API_GETSEQUENCERESULT, SPI_E_PARAM_SEQ );
  }
  /* no error is detected */
  else
  {
    /* Sequence is valid. */
    RetVal = Spi_Internal_GetSequenceResult( Sequence );
  }
  return RetVal;
}

/** \brief Spi_GetBufferStatus
 **
 ** This service reads back the buffer status and the remaining length of data
 ** for the SPI Handler/Driver Channel specified.
 **
 ** \return E_OK:     The output parameters have been filled with the buffer status.
 **         E_NOT_OK: The output parameters could not be filled with the buffer status.
 ** \param [in]  Channel                Channel ID of the channel that is polled for the status.
 ** \param [out] SrcDataBufferPtrPtr    Pointer to pointer that will be filled with 
 **                                     pointer to source data buffer.
 ** \param [out] DesDataBufferPtrPtr    Pointer to pointer that will be filled with pointer to 
 **                                     destination data buffer.
 ** \param [out] SrcRemainingLengthPtr  Pointer to variable that will be filled with the remaining
 **                                     length (number of date elements) of the source data yet to be transmitted
 **                                     from the source data buffer.
 ** \param [out] DesRemainingLengthPtr  Pointer to variable that will be filled with the remaining length
 **                                     (number of date elements) of the destination data yet to be received to
 **                                     destination data buffer.
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_GetBufferStatus
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  /* Deviation from MISRA-C:2004 Rule 16.7, MISRA-C:2012 Rule-8.13.
     Justification: The variable pointed to by the pointer is changed
    in sub functions. */
  /* PRQA S 3673 2 */
  P2VAR( P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC ), AUTOMATIC, AUTOMATIC ) SrcDataBufferPtrPtr,
  P2VAR( P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC ), AUTOMATIC, AUTOMATIC ) DesDataBufferPtrPtr,
  P2VAR( Spi_NumberOfDataType, AUTOMATIC, AUTOMATIC ) SrcRemainingLengthPtr,
  P2VAR( Spi_NumberOfDataType, AUTOMATIC, AUTOMATIC ) DesRemainingLengthPtr
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  
  /* Perform error checks. */

  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_GETBUFFERSTATUS, SPI_E_UNINIT );
  }
  /* check if driver is not initialized yet */
  else if ( Spi_Internal_GetStatus() == SPI_UNINIT )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_GETBUFFERSTATUS, SPI_E_UNINIT );
  }
  /* check if the channel is valid */
  else if ( Channel >= Spi_Current_ConfigPtr->ChannelCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid channel ID. */
    Spi_Com_DetReportError( SPI_API_GETBUFFERSTATUS, SPI_E_PARAM_CHANNEL );
  }
  /* check if the pointers are valid */
  else if ( ( NULL_PTR == SrcDataBufferPtrPtr ) || ( NULL_PTR == DesDataBufferPtrPtr ) ||
            ( NULL_PTR == SrcRemainingLengthPtr ) || ( NULL_PTR == DesRemainingLengthPtr ) )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid pointer. */
    Spi_Com_DetReportError( SPI_API_GETBUFFERSTATUS, SPI_E_PARAM_POINTER );
  }
  /* no error is detected */
  else
  {
    /* set result to ok */
    RetVal = E_OK;
    /* call an internal function to get buffer status */
    Spi_Internal_GetBufferStatus( Channel,
                                  SrcDataBufferPtrPtr,
                                  DesDataBufferPtrPtr,
                                  SrcRemainingLengthPtr,
                                  DesRemainingLengthPtr );
  }
  return RetVal;
}

/** \brief Spi_Terminate
 **
 ** Service to terminate transmit on the SPI bus.
 **
 ** \return E_OK:     Terminate command has been accepted
 **         E_NOT_OK: Terminate command has not been accepted
 **
 ** \param [in] Sequence   Sequence ID.
 **
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_Terminate
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  
  /*  Check the driver is configured. */
  if( NULL_PTR == Spi_Current_ConfigPtr )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI driver must be initialized. */
    Spi_Com_DetReportError( SPI_API_TERMINATE, SPI_E_UNINIT );
  }
  /* check if the passed sequence ID is valid */
  else if ( Sequence >= Spi_Current_ConfigPtr->SequenceCount )
  {
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* Invalid sequence ID. */
    Spi_Com_DetReportError( SPI_API_TERMINATE, SPI_E_PARAM_SEQ );
  }
  else
  {
    /* enter a critical section */
    Spi_Com_SchMEnterCriticalSection();
    /* check if driver is not initialized yet */
    if ( Spi_Internal_GetStatus() == SPI_UNINIT )
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ng */
      RetVal = E_NOT_OK;
      /* SPI driver must be initialized. */
      Spi_Com_DetReportError( SPI_API_TERMINATE, SPI_E_UNINIT );
    }
    /* call an internal function to terminate the required sequence */
    else if ( SPI_OK == Spi_Internal_Terminate( Sequence ))
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ok */
      RetVal = E_OK;
    }
    else
    {
      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();
      /* set result to ng */
      RetVal = E_NOT_OK;
    }
  }
  return RetVal;
}

/** \brief Spi_ChangeOvsSetting
 **
 **  Service to change SPI over sampling setting for changing clock.
 **
 ** \return E_OK:     The setting of over sampling has changed.
 **         E_NOT_OK: The setting of over sampling has not changed.
 **
 ** \param [in] ExtDev      HW unit ID ofExternal device to change setting.
 **
 ** \param [in] ScbOvsValue Setting value of OVS bits in SCB CTRL register.
 */
FUNC( Std_ReturnType, SPI_CODE ) Spi_ChangeOvsSetting
(
  CONST( Spi_ExtDeviceType, AUTOMATIC ) ExtDev,
  VAR( Spi_OvsValueType, AUTOMATIC ) ScbOvsValue
)
{
  VAR( Std_ReturnType, AUTOMATIC ) RetVal;
  VAR( Spi_StatusType, AUTOMATIC ) CurStatus;

  /* enter a critical section */
  Spi_Com_SchMEnterCriticalSection();

  /* get current status */
  CurStatus = Spi_Internal_GetStatus();

  /* Perform error checks. */

  /* check if driver is not initialized yet */
  if ( CurStatus == SPI_UNINIT )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* SPI was not initialized before.
       Report an error and reject the request. */
    Spi_Com_DetReportError( SPI_API_CHANGEOVSSETTING, SPI_E_UNINIT );
  }
  /* Check OVS value setting */
  else if ( ((Spi_OvsValueType)SPI_OVS_VALUE_MIN > ScbOvsValue)
    || ((Spi_OvsValueType)SPI_OVS_VALUE_MAX < ScbOvsValue) )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* ScbOvsValue is out of range.
       Report an error and reject the request. */
    Spi_Com_DetReportError( SPI_API_CHANGEOVSSETTING, SPI_E_PARAM_OTHER );
  }
  /* check Hw unit ID */
  else if ( ExtDev >= Spi_Current_ConfigPtr->ExternalDeviceCount )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* set result to ng */
    RetVal = E_NOT_OK;
    /* HwUnit is invalid.
       Report an error and reject the request. */
    Spi_Com_DetReportError( SPI_API_CHANGEOVSSETTING, SPI_E_PARAM_UNIT );
  }
  /* check if status is busy */
  else if ( CurStatus == SPI_BUSY )
  {
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();
    /* SPI is currently transmitting. Reject the request. */
    /* set result to ng */
    RetVal = E_NOT_OK;
  }
  /* no error is detected */
  else
  {
    /* change OVS setting value */
    Spi_Internal_ChangeOvsSetting( ExtDev, ScbOvsValue );

    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();

    /* set result to ok */
    RetVal = E_OK;
  }
  return RetVal;

}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
