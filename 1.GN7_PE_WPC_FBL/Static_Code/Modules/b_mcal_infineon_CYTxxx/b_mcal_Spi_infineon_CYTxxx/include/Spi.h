/** \brief AUTOSAR SPI Driver
 **
 ** This file contains or includes all external identifiers of
 ** the AUTOSAR module Spi.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef SPI_H_INCLUDED
#define SPI_H_INCLUDED

/*==================[inclusions]============================================*/
#include "Spi_Types.h"
#include "Spi_Cfg.h"

/*==================[macros]================================================*/

/*------------------[AUTOSAR specification version identification]----------*/

#if (defined SPI_AR_RELEASE_MAJOR_VERSION) /* to prevent double declaration */
#error SPI_AR_RELEASE_MAJOR_VERSION already defined
#endif /* if (defined SPI_AR_RELEASE_MAJOR_VERSION) */

/** AUTOSAR specification major version */
#define SPI_AR_RELEASE_MAJOR_VERSION 4U

#if (defined SPI_AR_RELEASE_MINOR_VERSION) /* to prevent double declaration */
#error SPI_AR_RELEASE_MINOR_VERSION already defined
#endif /* if (defined SPI_AR_RELEASE_MINOR_VERSION) */

/** AUTOSAR specification minor version */
#define SPI_AR_RELEASE_MINOR_VERSION 2U

#if (defined SPI_AR_RELEASE_REVISION_VERSION) /* to prevent double declaration */
#error SPI_AR_RELEASE_REVISION_VERSION already defined
#endif /* if (defined SPI_AR_RELEASE_REVISION_VERSION) */

/** AUTOSAR specification patch version */
#define SPI_AR_RELEASE_REVISION_VERSION 2U

/*------------------[Cypress module version identification]----------------*/

#if (defined SPI_SW_MAJOR_VERSION) /* to prevent double declaration */
#error SPI_SW_MAJOR_VERSION already defined
#endif /* if (defined SPI_SW_MAJOR_VERSION) */

/** Driver implementation major version */
#define SPI_SW_MAJOR_VERSION 1U

#if (defined SPI_SW_MINOR_VERSION) /* to prevent double declaration */
#error SPI_SW_MINOR_VERSION already defined
#endif /* if (defined SPI_SW_MINOR_VERSION) */

/** Driver implementation minor version */
#define SPI_SW_MINOR_VERSION 19U

#if (defined SPI_SW_PATCH_VERSION) /* to prevent double declaration */
#error SPI_SW_PATCH_VERSION already defined
#endif /* if (defined SPI_SW_PATCH_VERSION) */

/** Driver implementation patch version */
#define SPI_SW_PATCH_VERSION    SPI_CFG_PATCH_VERSION

/** Id of vendor. */
#define SPI_VENDOR_ID ( 66U )

/* Id of module */
#define SPI_MODULE_ID ( 83U )

/* Id of instance */
#define SPI_INSTANCE_ID ( 0U )

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

#define SPI_START_SEC_CODE_ASIL_B
#include <Spi_MemMap.h>

#if defined (SPI_VERSION_INFO_API) && (SPI_VERSION_INFO_API == STD_ON)

/** \brief Spi_GetVersionInfo
 **
 ** This service returns the version information of this module.
 **
 ** \return None.
 ** \param [out] versioninfo   Pointer to where to store the version 
 **                            information of this module
 **
 */
extern FUNC( void, SPI_CODE ) Spi_GetVersionInfo
(
  P2VAR( Std_VersionInfoType, AUTOMATIC, AUTOMATIC ) versioninfo
);

#endif /* SPI_VERSION_INFO_API */

#if defined(SPI_CHANNEL_BUFFERS_ALLOWED) && ((SPI_CHANNEL_BUFFERS_ALLOWED == 0) || (SPI_CHANNEL_BUFFERS_ALLOWED == 2))

/** \brief Spi_WriteIB
 **
 ** Service for writing one or more data to an IB SPI Handler/Driver Channel
 ** specified by parameter.
 ** Only available if SPI_CHANNEL_BUFFERS_ALLOWED is 0 or 2.
 **
 ** \return E_OK:     write command has been accepted
 **         E_NOT_OK: write command has not been accepted
 ** 
 ** \param [in] Channel         Channel ID
 ** \param [in] DataBufferPtr   Pointer to source data buffer. If this 
 **                             pointer is null, it is assumed that the data 
 **                             to be transmitted is not relevant and the 
 **                             default transmit value of this channel 
 **                             will be used instead.
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_WriteIB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DataBufferPtr
);

/** \brief Spi_ReadIB
 **
 ** Service for reading synchronously one or more data from an IB SPI
 ** Handler/Driver Channel specified by parameter.
 ** Only available if SPI_CHANNEL_BUFFERS_ALLOWED is 0 or 2.
 **
 ** \return E_OK:     read command has been accepted
 **         E_NOT_OK: read command has not been accepted
 ** 
 ** \param [in] Channel             Channel ID
 ** \param [out] DataBufferPointer  Pointer to destination data buffer in RAM
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_ReadIB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DataBufferPointer
);

#endif /* SPI_CHANNEL_BUFFERS_ALLOWED is 0 or 2 */

#if defined(SPI_CHANNEL_BUFFERS_ALLOWED) && ((SPI_CHANNEL_BUFFERS_ALLOWED == 1) || (SPI_CHANNEL_BUFFERS_ALLOWED == 2))

/** \brief Spi_SetupEB
 **
 ** Service to setup the buffers and the length of data for the EB SPI
 ** Handler/Driver Channel specified.
 ** Only available if SPI_CHANNEL_BUFFERS_ALLOWED is 1 or 2.
 **
 ** \return E_OK:       Setup command has been accepted
 **         E_NOT_OK:   Setup command has not been accepted
 **
 ** \param [in] Channel           Channel ID
 ** \param [in] SrcDataBufferPtr  Pointer to source data buffer
 ** \param [in] DesDataBufferPtr  Pointer to destination data buffer in RAM
 ** \param [in] Length            Length (number of data elements) of the  
 **                               data to be transmitted from SrcdataBufferPtr
 **                               and/or received from DesDataBufferPtr.
 **                               Min.:  1
 **                               Max.: Maximum of data specified at 
 **                               configuration for this channel
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_SetupEB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length
);

#endif /* SPI_CHANNEL_BUFFERS_ALLOWED is 1 or 2 */

#if defined(SPI_LEVEL_DELIVERED) && ((SPI_LEVEL_DELIVERED == 0) || (SPI_LEVEL_DELIVERED == 2))

/** \brief Spi_SyncTransmit
 **
 ** Service to transmit data on the SPI bus.
 ** Only available if SPI_LEVEL_DELIVERED is 0 or 2.
 **
 ** \return E_OK: Transmission command has been accepted.
 **         E_NOT_OK: Transmission command has not been accepted.
 ** 
 ** \param [in] Sequence   Sequence ID.
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_SyncTransmit
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
);

#endif /* SPI_LEVEL_DELIVERED is 0 or 2 */

#if defined(SPI_LEVEL_DELIVERED) && ((SPI_LEVEL_DELIVERED == 1) || (SPI_LEVEL_DELIVERED == 2))

/** \brief Spi_AsyncTransmit
 **
 ** Service to asynchronously transmit data on the SPI bus.
 ** Only available if SPI_LEVEL_DELIVERED is 1 or 2.
 **
 ** \return E_OK:     Transmission command has been accepted
 **         E_NOT_OK: Transmission command has not been accepted
 **
 ** \param [in] Sequence   Sequence ID.
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_AsyncTransmit
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
);

#endif /* SPI_LEVEL_DELIVERED is 1 or 2 */

#if defined(SPI_CANCEL_API) && (SPI_CANCEL_API == STD_ON)

/** \brief Spi_Cancel
 **
 ** Service to cancel the specified on-going sequence transmission.
 ** Only available if SPI_CANCEL_API is STD_ON.
 **
 ** \return None.
 ** \param [in] Sequence   Sequence ID
 **
 */
extern FUNC( void, SPI_CODE ) Spi_Cancel
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
);

#endif /* SPI_CANCEL_API */

#if defined(SPI_LEVEL_DELIVERED) && (SPI_LEVEL_DELIVERED == 2)

/** \brief Spi_SetAsyncMode
 **
 ** Service to set the asynchronous mechanism mode for SPI buses
 ** handled asynchronously.
 ** Only available if SPI_LEVEL_DELIVERED is 2.
 **
 ** \return E_OK:     Setting command has been done.
 **         E_NOT_OK: setting command has not been accepted.
 **
 ** \param [in] Mode   New mode required.
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_SetAsyncMode
(
  VAR( Spi_AsyncModeType, AUTOMATIC ) Mode
);

#endif /* SPI_LEVEL_DELIVERED is 2 */

/** \brief Spi_Init
 **
 ** Service for SPI initialization.
 **
 ** \param [in] ConfigPtr   Pointer to driver configuration set
 **                         (unused in this implementation)
 **
 */
extern FUNC( void, SPI_CODE ) Spi_Init
(
  P2CONST( Spi_ConfigType, AUTOMATIC, AUTOMATIC ) ConfigPtr
);

/** \brief Spi_DeInit
 **
 ** Service for SPI de-initialization.
 **
 ** \return E_OK:     De-initialization completed
 **         E_NOT_OK: De-initialization request has not been accepted
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_DeInit(void);

/** \brief Spi_GetStatus
 **
 ** Service returns the SPI Handler/Driver software module status.
 **
 ** \return Driver status, either SPI_UNINIT, SPI_IDLE or SPI_BUSY
 **
 */
extern FUNC( Spi_StatusType, SPI_CODE ) Spi_GetStatus(void);

#if defined(SPI_HW_STATUS_API) && (SPI_HW_STATUS_API == STD_ON)
/** \brief Spi_GetHWUnitStatus
 **
 ** This service returns the status of the specified SPI Hardware 
 ** microcontroller peripheral.
 **
 ** \return The status of the specified SPI Hardware microcontroller 
 **         peripheral.
 ** \param [in] HWUnit   SPI Hardware microcontroller peripheral (unit) ID.
 **
 */
extern FUNC( Spi_StatusType, SPI_CODE ) Spi_GetHWUnitStatus
(
  VAR( Spi_HWUnitType, AUTOMATIC ) HWUnit
);
#endif /* SPI_HW_STATUS_API */

/** \brief Spi_GetJobResult
 **
 ** This service returns the last transmission result of the specified Job.
 **
 ** \return The last transmission result of the specified Job.
 ** \param [in] Job   Job ID. An invalid job ID will return an undefined 
 **                   result.
 **
 */
extern FUNC( Spi_JobResultType, SPI_CODE ) Spi_GetJobResult
(
  VAR( Spi_JobType, AUTOMATIC ) Job
);

/** \brief Spi_GetSequenceResult
 **
 ** This service returns the last transmission result of the specified 
 ** Sequence.
 **
 ** \return The last transmission result of the specified Sequence.
 ** \param [in] Sequence   Sequence ID. An invalid sequence ID will return an
 **                        undefined result.
 **
 */
extern FUNC( Spi_SeqResultType, SPI_CODE ) Spi_GetSequenceResult
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
);

/** \brief Spi_GetBufferStatus
 **
 ** This service reads back the buffer status and the remaining length of data
 ** for the SPI Handler/Driver Channel specified.
 **
 ** \return E_OK:     
 **           The output parameters have been filled with the buffer status.
 **         E_NOT_OK: 
 **           The output parameters could not be filled with the buffer status.
 ** \param [in]  Channel
 **                 Channel ID of the channel that is polled for the status.
 ** \param [out] SrcDataBufferPtrPtr
 **                 Pointer to pointer that will be filled with pointer to
 **                 source data buffer.
 ** \param [out] DesDataBufferPtrPtr
 **                 Pointer to pointer that will be filled with pointer to 
 **                 destination data buffer.
 ** \param [out] SrcRemainingLengthPtr
 **                 Pointer to variable that will be filled with the remaining
 **                 length (number of date elements) of the source data yet 
 **                 to be transmitted from the source data buffer.
 ** \param [out] DesRemainingLengthPtr
 **                 Pointer to variable that will be filled with the remaining
 **                 length (number of date elements) of the destination data 
 **                 yet to be received to destination data buffer.
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_GetBufferStatus
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2VAR( P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC ), AUTOMATIC, AUTOMATIC ) SrcDataBufferPtrPtr,
  P2VAR( P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC ), AUTOMATIC, AUTOMATIC ) DesDataBufferPtrPtr,
  P2VAR( Spi_NumberOfDataType, AUTOMATIC, AUTOMATIC ) SrcRemainingLengthPtr,
  P2VAR( Spi_NumberOfDataType, AUTOMATIC, AUTOMATIC ) DesRemainingLengthPtr
);

/** \brief Spi_Terminate
 **
 ** Service to terminate transmit on the SPI bus.
 **
 ** \return E_OK:     Terminate command has been accepted
 **         E_NOT_OK: Terminate command has not been accepted
 **
 ** \param [in] Sequence   Sequence ID.
 **
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_Terminate
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
);

/** \brief Spi_ChangeOvsSetting
 **
 **  Service to change SPI over sampling setting for changing clock.
 **
 ** \return E_OK:     The setting of over sampling has changed.
 **         E_NOT_OK: The setting of over sampling has not changed.
 **
 ** \param [in] ExtDev      HW unit ID of external device to change setting.
 **
 ** \param [in] ScbOvsValue Setting value of OVS bits in SCB CTRL register.
 */
extern FUNC( Std_ReturnType, SPI_CODE ) Spi_ChangeOvsSetting
(
  CONST( Spi_ExtDeviceType, AUTOMATIC ) ExtDev,
  VAR( Spi_OvsValueType, AUTOMATIC ) ScbOvsValue
);

#define SPI_STOP_SEC_CODE_ASIL_B
#include <Spi_MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#endif /*!defined(SPI_H_INCLUDED)*/

/*==================[end of file]===========================================*/
