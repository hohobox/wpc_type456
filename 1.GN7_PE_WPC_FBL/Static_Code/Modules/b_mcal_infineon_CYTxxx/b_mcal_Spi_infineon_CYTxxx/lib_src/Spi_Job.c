/** \brief AUTOSAR SPI Driver
 **
 ** This file contains implementation of the Spi Job functions.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Spi_Job.h>
#include <Spi_Common.h>
#include <Spi_ChipSelect.h>
#include <Spi_Channel.h>
#include <Spi_Hw.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define SPI_START_SEC_CODE_ASIL_B

#include <Spi_MemMap.h>

/** \brief Spi_Job_WaitSyncTransmitChannel
 **
 ** Wait until synchronous channel transmission is finished.
 **
 ** \return SPI_OK: Channel is finished and successful.
 **         SPI_NOT_OK: Channel is failed (hardware error or timeout).
 ** \param [in] ChannelConfigPtr    Pointer to Channel Configuration.
 ** \param [in] JobConfigPtr        Pointer to Job Configuration.
 ** \param [inout] EventStatusPtr   Pointer to Event Status.
 ** \param [in] Timeout             Period until data is transferred.
 **
 */
static FUNC( Spi_ReturnType, SPI_CODE ) Spi_Job_WaitSyncTransmitChannel
(
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr,
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr,
  P2VAR( uint8, AUTOMATIC, AUTOMATIC ) EventStatusPtr,
  VAR( uint32, AUTOMATIC ) Timeout
);

/** \brief Spi_Job_CheckSyncHwFinished
 **
 ** Check Synchronous job finished.
 **
 ** \return SPI_TRUE: Error detect or Job finished
 **         SPI_FALSE: Not error detect and Job not finished
 **
 ** \param [in] JobConfigPtr        Pointer to Job Configuration.
 ** \param [in] CurHwUnit           Current HW unit id.
 ** \param [inout] EventStatusPtr   Pointer to Event Status.
 **
 */
static FUNC( boolean, SPI_CODE ) Spi_Job_CheckSyncHwFinished
(
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr,
  VAR( Spi_HWUnitType, AUTOMATIC ) CurHwUnit, 
  P2VAR( uint8, AUTOMATIC, AUTOMATIC ) EventStatusPtr
);

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Job_HandlerChannelFinished
 **
 ** Check all channels in the job are finished 
 ** and handles the completion of the job transmission.
 **
 ** \return  SPI_OK:     Finished the specified Job transmission.
 **          SPI_NOT_OK: Not finished the specified Job transmission.
 **
 ** \param [in]  Job              Id of Job.
 ** \param [in]  EventStatus      Event status (passed or failed).
 ** \param [out] NextChannelPtr   Pointer to Next transmit Channel.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Job_HandlerChannelFinished
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR( uint8, AUTOMATIC ) EventStatus,
  P2VAR( Spi_ChannelType, AUTOMATIC, AUTOMATIC ) NextChannelPtr
)
{
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal;
  VAR( Spi_JobResultType, AUTOMATIC ) JobResult;
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  VAR( Spi_ChannelIndexType, AUTOMATIC ) TxChannelIndex = 
      Spi_Job_GetChannelIndex( Job , SPI_HW_FACTOR_SCB_TX);
  VAR( Spi_ChannelIndexType, AUTOMATIC ) RxChannelIndex = 
      Spi_Job_GetChannelIndex( Job , SPI_HW_FACTOR_SCB_RX);

  /* increment current channel index */
  if ( (TxChannelIndex + 1U) <= JobConfigPtr->ChannelCount )
  {
    TxChannelIndex++;
    Spi_Job_SetChannelIndex( Job, TxChannelIndex, SPI_HW_FACTOR_SCB_TX );
  }
  if ( (RxChannelIndex + 1U) <= JobConfigPtr->ChannelCount )
  {
    RxChannelIndex++;
    Spi_Job_SetChannelIndex( Job, RxChannelIndex, SPI_HW_FACTOR_SCB_RX );
  }
  /* check if all channels are not completed yet */
  if ( ( TxChannelIndex < JobConfigPtr->ChannelCount )
    && ( EventStatus == SPI_DEM_EVENT_STATUS_PASSED ) )
  {
    /* set a next channel to a pointer which be specified by a parameter */
    *NextChannelPtr = JobConfigPtr->ChannelListPtr[TxChannelIndex];
    /* set result to ng */
    RetVal = SPI_NOT_OK;
  }
  /* all channels are already completed or the relevant job is failed */
  else
  {
    /* Check how CS pins are asserted (SpiCsSelection). */
    if ( ( JobConfigPtr->ExternalDevicePtr->EnableCs == SPI_TRUE )
      && ( JobConfigPtr->ExternalDevicePtr->CsSelection == SPI_CS_VIA_GPIO ) )
    {
      /* Check if chip select is enabled. */
      /* de-assert the cs signal */
      Spi_CS_DeassertChipSelect( JobConfigPtr->ExternalDevicePtr );
    }

    /* clear job index */
    Spi_Job_SetChannelIndex( Job, 0U,  SPI_HW_FACTOR_SCB_TX_AND_RX);

    /* return the Return = SPI_OK. */
    RetVal = SPI_OK;
    /* set the job result to ok if not failed */
    JobResult = ( EventStatus == SPI_DEM_EVENT_STATUS_PASSED ) ? ( SPI_JOB_OK ) : ( SPI_JOB_FAILED );
    Spi_Info.JobInfoListPtr[Job].Result = JobResult;
  }
  return RetVal;
}

/** \brief Spi_Job_HandlerChannelFinishedDma
 **
 ** Handles the completion of the job transmission.
 **
 ** \return  SPI_OK:     Finished the specified Job transmission.
 **
 ** \param [in]  Job              Id of Job.
 ** \param [in]  EventStatus      Event status (passed or failed).
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Job_HandlerChannelFinishedDma
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR( uint8, AUTOMATIC ) EventStatus
)
{
  /* In DMA case, a job has been finished whenever this API is called. */
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal = SPI_OK;
  VAR( Spi_JobResultType, AUTOMATIC ) JobResult;
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );

  /* all channels are already completed or the relevant job is failed */
  /* Check how CS pins are asserted (SpiCsSelection). */
  if ( ( JobConfigPtr->ExternalDevicePtr->EnableCs == SPI_TRUE )
    && ( JobConfigPtr->ExternalDevicePtr->CsSelection == SPI_CS_VIA_GPIO ) )
  {
    /* Check if chip select is enabled. */
    /* de-assert the cs signal */
    Spi_CS_DeassertChipSelect( JobConfigPtr->ExternalDevicePtr );
  }

  /* Clear job index */
  Spi_Job_SetChannelIndex( Job, 0U,  SPI_HW_FACTOR_DMA_TX_AND_RX);

  /* set the job result to ok if not failed */
  JobResult = ( EventStatus == SPI_DEM_EVENT_STATUS_PASSED ) ? ( SPI_JOB_OK ) : ( SPI_JOB_FAILED );
  Spi_Info.JobInfoListPtr[Job].Result = JobResult;

  return RetVal;
}

/** \brief Spi_Job_TransmitFirstChannel
 **
 ** Starts the first Channel that belong to the specified job.
 **
 ** \return None.
 ** \param [in] Job   Id of Job.
 **
 */
FUNC( void, SPI_CODE ) Spi_Job_TransmitFirstChannel
(
  VAR( Spi_JobType, AUTOMATIC ) Job
)
{
  /* helpers to avoid too many lookups */
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) ExtDevConfigPtr = JobConfigPtr->ExternalDevicePtr;
  CONST( Spi_ChannelType, AUTOMATIC ) FirstChannel = JobConfigPtr->ChannelListPtr[0U];
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr;

  /* get a first channel config in the relevant job */
  ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[FirstChannel] );

  /* setup the relevant hardware */
  Spi_Hw_SetupHwUnit( ExtDevConfigPtr );

  /* setup the first channel */
  Spi_Hw_SetupChannel(ExtDevConfigPtr, ChannelConfigPtr);

  /* check if the chip-select in the relevant job is enabled */
  if ( ExtDevConfigPtr->EnableCs == SPI_TRUE )
  {
    if ( ExtDevConfigPtr->CsSelection == SPI_CS_VIA_GPIO )
    {
      /* de-assert the relevant serial chip-select signal */
      Spi_CS_AssertChipSelect( ExtDevConfigPtr );
    }
  }

  /* start hardware */
  Spi_Hw_StartTransmit( Job, FirstChannel, SPI_HWUNIT_ASYNC );
}

/** \brief Spi_Job_TransmitNextChannel
 **
 ** Starts the next Channel that belong to the specified job.
 **
 ** \return None.
 ** \param [in] Job   Id of Job.
 ** \param [in] NextChannelId   Id of next transmit Channel.
 **
 */
FUNC( void, SPI_CODE ) Spi_Job_TransmitNextChannel
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR( Spi_ChannelType, AUTOMATIC ) NextChannelId
)
{
  /* helpers to avoid too many lookups */
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) ExtDevConfigPtr = JobConfigPtr->ExternalDevicePtr;
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[NextChannelId] );

  /* setup the first channel */
  Spi_Hw_SetupChannel(ExtDevConfigPtr, ChannelConfigPtr);

  /* start to transmit */
  Spi_Hw_StartTransmit( Job, NextChannelId, SPI_HWUNIT_ASYNC );
}

/** \brief Spi_Job_TransmitAllChannels
 **
 ** Starts the all Channels that belong to the specified Job.
 **
 ** \return None.
 ** \param [in] Job   Id of Job.
 ** \param [inout] EventStatusPtr   Pointer to event status.
 **
 */
FUNC( void, SPI_CODE ) Spi_Job_TransmitAllChannels
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  P2VAR( uint8, AUTOMATIC, AUTOMATIC ) EventStatusPtr
)
{
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr;
  VAR( Spi_ChannelIndexType, AUTOMATIC ) ChannelIndex;
  VAR( uint32, AUTOMATIC ) Timeout;
  /* helpers to avoid too many lookups */
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) ExtDevPtr = JobConfigPtr->ExternalDevicePtr;
  VAR( Spi_ChannelType, AUTOMATIC ) Channel;
  VAR( Spi_ReturnType, AUTOMATIC ) SubRetVal;

  /* setup hwunit */
  Spi_Hw_SetupHwUnit( ExtDevPtr );

  /* check if SpiEnableCs is true and not using gpio */
  if ( ExtDevPtr->EnableCs == SPI_TRUE )
  {
    if ( ExtDevPtr->CsSelection == SPI_CS_VIA_GPIO )
    {
      /* assert chip select signal */
      Spi_CS_AssertChipSelect( ExtDevPtr );
    }
  }

  /* for each channels in job */
  ChannelIndex = 0U;
  while ( ChannelIndex < JobConfigPtr->ChannelCount )
  {
    Channel = JobConfigPtr->ChannelListPtr[ChannelIndex];
    ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );

    /* setup channel */
    Spi_Hw_SetupChannel(ExtDevPtr, ChannelConfigPtr);

    /* start transmission for the relevant hwunit */
    Spi_Hw_StartTransmit( Job, Channel, SPI_HWUNIT_SYNC );

    /* calculate time-out value */
    /* Timeout for one data transfer */
    Timeout = Spi_Current_ConfigPtr->SynctransmitTimeout;

    /* check if the current channel is first one? */
    if ( ChannelIndex == 0U )
    {
      /* add timeout for setup delay */
      Timeout += Spi_Current_ConfigPtr->CsActiveTimeout;
    }
    /* check if the current channel is last one? */
    else if ( ( ChannelIndex + 1U ) >= JobConfigPtr->ChannelCount )
    {
      /* add timeout for hold delay */
      Timeout += Spi_Current_ConfigPtr->CsInactiveTimeout;
    }
    /* nothing to do if the current channel is other than first or last one */
    else
    {
      /* nothing to do here */
    }

    /* wait until data transmission is completed or failed */
    SubRetVal = Spi_Job_WaitSyncTransmitChannel(
        ChannelConfigPtr, JobConfigPtr, EventStatusPtr, Timeout);
    
    if ( SubRetVal != SPI_OK )
    {
      /* escape from loop if transmission is failed */
      break;
    }
    /* increment channel index */
    ChannelIndex = Spi_Job_GetChannelIndex(Job, SPI_HW_FACTOR_SCB_RX);
    ChannelIndex++;
    Spi_Job_SetChannelIndex( Job, ChannelIndex, SPI_HW_FACTOR_SCB_TX_AND_RX );
  }

  /* check if SpiEnableCs is true */
  /* Check how CS pins are asserted (SpiCsSelection). */
  if ( ( ExtDevPtr->EnableCs == SPI_TRUE )
    && ( ExtDevPtr->CsSelection == SPI_CS_VIA_GPIO ) )
  {
    /* de-assert chip select signal */
    Spi_CS_DeassertChipSelect( ExtDevPtr );
  }
}

/** \brief Spi_Job_GetIsQueued
 **
 ** Returns whether job is queued or not.
 **
 ** \return Determines whether job is queued or not.
 ** \param [in] Job   Id of Job.
 **
 */
FUNC( boolean, SPI_CODE ) Spi_Job_GetIsQueued
(
  VAR( Spi_JobType, AUTOMATIC ) Job
)
{
  /* helpers to avoid too many lookups */
  P2VAR( Spi_JobInfoType, AUTOMATIC, AUTOMATIC ) JobInfoPtr = 
      ( Spi_JobInfoType * ) &( Spi_Info.JobInfoListPtr[Job] );

  /* return status queued or not */
  return JobInfoPtr->CurIsQueued; 
}

/** \brief Spi_Job_SetIsQueued
 **
 ** Sets the job is queued.
 **
 ** \return None.
 ** \param [in] Job   Id of Job.
 ** \param [in] IsQueue   Determines whether job is queued or not.
 **
 */
FUNC( void, SPI_CODE ) Spi_Job_SetIsQueued
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR( boolean, TYPEDEF ) IsQueue
)
{
  /* helpers to avoid too many lookups */
  P2VAR( Spi_JobInfoType, AUTOMATIC, AUTOMATIC ) JobInfoPtr = 
    ( Spi_JobInfoType * ) &( Spi_Info.JobInfoListPtr[Job] );

  /* set status queued or not */
  JobInfoPtr->CurIsQueued = IsQueue;
}

/** \brief Spi_Job_GetJobResult
 **
 ** Returns the Job result.
 **
 ** \return Result of Job.
 ** \param [in] Job   Id of Job.
 **
 */
FUNC( Spi_JobResultType, SPI_CODE ) Spi_Job_GetJobResult
(
  VAR( Spi_JobType, AUTOMATIC ) Job
)
{
  /* helpers to avoid too many lookups */
  P2VAR( Spi_JobInfoType, AUTOMATIC, AUTOMATIC ) JobInfoPtr = 
      ( Spi_JobInfoType * ) &( Spi_Info.JobInfoListPtr[Job] );

  /* return the result for the relevant job */
  return JobInfoPtr->Result;
}

/** \brief Spi_Job_InitAllJobs
 **
 ** Initializes the all Jobs.
 **
 ** \return None.
 **
 */
FUNC( void, SPI_CODE ) Spi_Job_InitAllJobs(void)
{
  P2VAR( Spi_JobInfoType, AUTOMATIC, AUTOMATIC ) JobInforPtr;
  VAR( Spi_JobIndexType, AUTOMATIC ) JobIndex;

  /* iterate to initialize all jobs */
  for ( JobIndex = 0U; JobIndex < Spi_Current_ConfigPtr->JobCount; JobIndex++ )
  {
    /* initialize job information */

    /* helpers to avoid too many lookups */
    JobInforPtr = ( Spi_JobInfoType * ) &( Spi_Info.JobInfoListPtr[JobIndex] );

    /* set members of job information to initial values */
    JobInforPtr->Result          = SPI_JOB_OK;
    JobInforPtr->CurIsQueued     = SPI_FALSE;
    JobInforPtr->CurRxChannelIndex = SPI_INVALID_CHANNEL;
    JobInforPtr->CurTxChannelIndex = SPI_INVALID_CHANNEL;

    if (Spi_Current_ConfigPtr->JobConfigListPtr[JobIndex].ExternalDevicePtr->UseDma != SPI_FALSE)
    {
      Spi_Hw_InitDescriptor(JobIndex);
    }
  }
}

/** \brief Spi_Job_CheckAsyncJobStatus
 **
 ** Checks the status of the asynchronous jobs.
 **
 ** \return SPI_OK: All asynchronous jobs are IDLE.
 **         SPI_NOT_OK: Any of asynchronous job is busy.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Job_CheckAsyncJobStatus(void)
{
  VAR( uint8, AUTOMATIC ) IndexOfHwUnit;
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr;
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal = SPI_OK;
  CONST( uint8, AUTOMATIC ) MaxNrOfHwUnits = Spi_Com_GetMaxNrOfHwUnits();
  VAR( Spi_JobType, AUTOMATIC ) CurJob;
  VAR( Spi_StatusType, AUTOMATIC ) HwUnitStatus;

  /* iterate to confirm that all hwunits is not running */
  for ( IndexOfHwUnit = 0U; IndexOfHwUnit < MaxNrOfHwUnits; IndexOfHwUnit++ )
  {
    /* get a hwunit status */
    HwUnitStatus = Spi_Info.HwInfoListPtr[IndexOfHwUnit].Status;
    /* get a pointer for the current job config setting */
    CurJob = Spi_Info.DriverHwInfoListPtr[IndexOfHwUnit].Job;
    JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJob] );

    /* check if hwunit is running with asynchronous job */
    if ( ( HwUnitStatus == SPI_BUSY ) && ( JobConfigPtr->HwUnitSync == SPI_HWUNIT_ASYNC ) )
    {
      /* set result to ng */
      RetVal = SPI_NOT_OK;
      break;
    }
  }
  return RetVal;
}

/** \brief Spi_Job_GetCurrentChannel
 **
 ** Returns the current channel in job.
 **
 ** \return Id of current channel.
 ** \param [in] Job   Id of Job.
 ** \param [in] Factor  Tx or Rx of transmission.
 **
 */
FUNC( Spi_ChannelType, SPI_CODE ) Spi_Job_GetCurrentChannel
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR (Spi_HwFactorType, AUTOMATIC ) Factor
)
{
  VAR( uint8, AUTOMATIC ) IndexOfChannel;
  /* helpers to avoid too many lookups */
  if ( (SPI_HW_FACTOR_SCB_RX == Factor ) || ( SPI_HW_FACTOR_DMA_RX == Factor ) )
  { /* For Rx */
    IndexOfChannel = Spi_Info.JobInfoListPtr[Job].CurRxChannelIndex;
  }
  else
  { /* For Tx */
    IndexOfChannel = Spi_Info.JobInfoListPtr[Job].CurTxChannelIndex;
  }
  /* return a current job in the relevant sequence */
  return Spi_Current_ConfigPtr->JobConfigListPtr[Job].ChannelListPtr[IndexOfChannel];
}

/** \brief Spi_Job_SetChannelIndex
 **
 ** Sets the channel index number in job.
 **
 ** \return None.
 ** \param [in] Job   Id of Job.
 ** \param [in] ChannelIndex   Index of channel in the relevant job.
 ** \param [in] Factor  Tx or Rx of transmission.
 **
 */
FUNC( void, SPI_CODE ) Spi_Job_SetChannelIndex
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR( Spi_ChannelIndexType, AUTOMATIC ) ChannelIndex,
  VAR (Spi_HwFactorType, AUTOMATIC ) Factor
)
{
  /* helpers to avoid too many lookups */
  P2VAR( Spi_JobInfoType, AUTOMATIC, AUTOMATIC ) JobInfoPtr = 
      ( Spi_JobInfoType * ) &( Spi_Info.JobInfoListPtr[Job] );

  /* update current channel index */
  if ( (SPI_HW_FACTOR_SCB_RX == Factor ) || ( SPI_HW_FACTOR_DMA_RX == Factor ) )
  { /* For Rx */
    JobInfoPtr->CurRxChannelIndex = ChannelIndex;
  }
  else if ( (SPI_HW_FACTOR_SCB_TX == Factor ) || ( SPI_HW_FACTOR_DMA_TX == Factor ) )
  { /* For Tx */
    JobInfoPtr->CurTxChannelIndex = ChannelIndex;
  }
  else
  { /* For both */
    JobInfoPtr->CurRxChannelIndex = ChannelIndex;
    JobInfoPtr->CurTxChannelIndex = ChannelIndex;
  }
}

/** \brief Spi_Job_GetChannelIndex
 **
 ** Returns the channel index number in job.
 **
 ** \return Index of channel in the relevant job.
 ** \param [in] Job   Id of Job.
 ** \param [in] Factor  Tx or Rx of transmission.
 **
 */
FUNC( Spi_ChannelIndexType, SPI_CODE) Spi_Job_GetChannelIndex
(
  VAR( Spi_JobType, AUTOMATIC ) Job,
  VAR (Spi_HwFactorType, AUTOMATIC ) Factor
)
{
  VAR( uint8, AUTOMATIC ) IndexOfChannel;
  /* helpers to avoid too many lookups */
  P2VAR( Spi_JobInfoType, AUTOMATIC, AUTOMATIC ) JobInfoPtr = 
      ( Spi_JobInfoType * ) &( Spi_Info.JobInfoListPtr[Job] );

  if ( (SPI_HW_FACTOR_SCB_RX == Factor ) || ( SPI_HW_FACTOR_DMA_RX == Factor ) )
  { /* For Rx */
    IndexOfChannel = JobInfoPtr->CurRxChannelIndex;
  }
  else
  { /* For Tx */
    IndexOfChannel = JobInfoPtr->CurTxChannelIndex;
  }
  /* update current channel index */
  return IndexOfChannel;
}


/*==================[internal function definitions]=========================*/
/** \brief Spi_Job_WaitSyncTransmitChannel
 **
 ** Wait until synchronous channel transmission is finished.
 **
 ** \return SPI_OK: Channel is finished and successful.
 **         SPI_NOT_OK: Channel is failed (hardware error or timeout).
 ** \param [in] ChannelConfigPtr    Pointer to Channel Configuration.
 ** \param [in] JobConfigPtr        Pointer to Job Configuration.
 ** \param [inout] EventStatusPtr   Pointer to Event Status.
 ** \param [in] Timeout             Period until data is transferred.
 **
 */
static FUNC( Spi_ReturnType, SPI_CODE ) Spi_Job_WaitSyncTransmitChannel
(
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr,
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr,
  P2VAR( uint8, AUTOMATIC, AUTOMATIC ) EventStatusPtr,
  VAR( uint32, AUTOMATIC ) Timeout
)
{
  VAR( uint32, AUTOMATIC ) Counter=0U;
  VAR( uint16, AUTOMATIC ) DataIndex;
  VAR( uint16, AUTOMATIC ) MaxDataCount;
  VAR( boolean, AUTOMATIC ) BreakOut;
  VAR( Spi_ReturnType, AUTOMATIC ) ReturnValue = SPI_OK;
  VAR( Spi_HWUnitType, AUTOMATIC ) CurHwUnit = JobConfigPtr->ExternalDevicePtr->HwUnit;

  if ( (JobConfigPtr->ChannelCount > 1U) && (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
  { /* Same data width and multi channel */
    VAR( Spi_JobType, AUTOMATIC ) CurJob;
    VAR( Spi_ChannelType, AUTOMATIC ) RxChannel;
    VAR( Spi_ChannelIndexType, AUTOMATIC ) RxChannelIndex;
    VAR( Spi_ChannelIndexType, AUTOMATIC ) NewRxChannelIndex;

    CurJob = Spi_Info.DriverHwInfoListPtr[CurHwUnit].Job;
    RxChannelIndex = Spi_Job_GetChannelIndex( CurJob, SPI_HW_FACTOR_SCB_RX);
    
    /* wait until transmission is completed or failed */
    MaxDataCount = ChannelConfigPtr->BufferSize;

    /* waiting for all data in the relevant channel */
    DataIndex = 0U;
    while ( DataIndex < MaxDataCount )
    {
      Counter = 0U;
      do {
        /* Check Job finished */
        BreakOut = Spi_Job_CheckSyncHwFinished(JobConfigPtr, CurHwUnit, EventStatusPtr);
        if ( BreakOut == SPI_TRUE )
        { /* Job finished or Error detect */
          break;
        }
        NewRxChannelIndex = Spi_Job_GetChannelIndex( CurJob, SPI_HW_FACTOR_SCB_RX);
        if ( RxChannelIndex != NewRxChannelIndex )
        { /* Channel Changed */
          if ( (NewRxChannelIndex + 1U) >= JobConfigPtr->ChannelCount )
          { /* Last Channel */
            Timeout = Spi_Current_ConfigPtr->SynctransmitTimeout + Spi_Current_ConfigPtr->CsInactiveTimeout;
          }
          else
          {
            Timeout = Spi_Current_ConfigPtr->SynctransmitTimeout;
          }
          RxChannelIndex = NewRxChannelIndex;
          RxChannel = JobConfigPtr->ChannelListPtr[RxChannelIndex];
          ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[RxChannel] );
          /* reset for loop */
          DataIndex = 0U;
          MaxDataCount = ChannelConfigPtr->BufferSize;
        }
        Counter++;
      } while ( Counter < Timeout);
      if ( BreakOut == SPI_TRUE )
      {
        break;
      }
      DataIndex++;
    }
  }
  else
  {
    /* wait until transmission is completed or failed */
    MaxDataCount = ChannelConfigPtr->BufferSize;

    /* waiting for all data in the relevant channel */
    for ( DataIndex = 0U; DataIndex < MaxDataCount; DataIndex++ )
    {
      Counter = 0U;
      /* waiting for one data in the relevant channel */
      do
      {
        /* Check Job finished */
        BreakOut = Spi_Job_CheckSyncHwFinished(JobConfigPtr, CurHwUnit, EventStatusPtr);
        if ( BreakOut == SPI_TRUE )
        { /* Job finished or Error detect */
          break;
        }
        Counter++;
      } while ( Counter < Timeout );
      /* break-out immediately after transmission is completed or failed */
      if ( BreakOut == SPI_TRUE )
      {
        break;
      }
    }
  }
  /* check if time-out was occurred or an error was detected */
  if ( ( Counter >= Timeout )
    || ( *EventStatusPtr == SPI_DEM_EVENT_STATUS_FAILED ) )
  {
    /* set event status to failed (this is necessary after timeout) */
    *EventStatusPtr = SPI_DEM_EVENT_STATUS_FAILED;
    ReturnValue = SPI_NOT_OK;
  }
  return ReturnValue;
}

/** \brief Spi_Job_CheckSyncHwFinished
 **
 ** Check Synchronous job finished.
 **
 ** \return SPI_TRUE: Error detect or Job finished
 **         SPI_FALSE: Not error detect and Job not finished
 **
 ** \param [in] JobConfigPtr        Pointer to Job Configuration.
 ** \param [in] CurHwUnit           Current HW unit id.
 ** \param [inout] EventStatusPtr   Pointer to Event Status.
 **
 */
static FUNC( boolean, SPI_CODE ) Spi_Job_CheckSyncHwFinished
(
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr,
  VAR( Spi_HWUnitType, AUTOMATIC ) CurHwUnit, 
  P2VAR( uint8, AUTOMATIC, AUTOMATIC ) EventStatusPtr
)
{
  /* Return Value */
  VAR( boolean, AUTOMATIC ) RetVal = SPI_FALSE;

  /* check if hwunit is already finished */
  if ( Spi_Hw_CheckFinished( SPI_HW_FACTOR_SCB_RX, CurHwUnit ) == SPI_OK )
  {
      Spi_Hw_SyncFinished( JobConfigPtr, CurHwUnit, SPI_HW_FACTOR_SCB_RX );
  }
  /* check if hwunit is already finished */
  if ( Spi_Hw_CheckFinished( SPI_HW_FACTOR_SCB_TX, CurHwUnit ) == SPI_OK )
  {
      Spi_Hw_SyncFinished( JobConfigPtr, CurHwUnit, SPI_HW_FACTOR_SCB_TX );
  }
  /* check if all events are already finished */
  if ( Spi_Hw_ValidateEvent( CurHwUnit, EventStatusPtr ) == SPI_OK )
  {
      /* Error detect or Job finished */
      RetVal = SPI_TRUE;
  }
  return RetVal;
}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[end of file]===========================================*/
