/** \brief AUTOSAR SPI Driver
 **
 ** This file contains implementation of internal functions.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Spi_Internal.h>
#include <Spi_Common.h>
#include <Spi_Sequence.h>
#include <Spi_Job.h>
#include <Spi_Hw.h>
#include <Spi_Queue.h>
#include <Spi_Channel.h>
#include <Spi_ChipSelect.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define SPI_START_SEC_CODE_ASIL_B

#include <Spi_MemMap.h>

/** \brief Spi_Internal_UpdateDriverStatus
 **
 ** Updates driver status.
 **
 ** \return None.
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_UpdateDriverStatus(void);

/** \brief Spi_Internal_UpdateDriverAndSyncStatus
 **
 ** Updates both driver status and synchronous status.
 **
 ** \return None.
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_UpdateDriverAndSyncStatus(void);

/** \brief Spi_Internal_TerminateEvent
 **
 ** This function is intended to terminate an event.
 ** This function checks if at least one job still alive yet.
 ** If a job is not found, this function finishes an event for the relevant 
 ** hwunit.
 ** If a job is found, it returns with a job id.
 ** A caller shall start the job in order to proceed event immediately after 
 ** it is received.
 **
 ** \return None.
 ** \param [in] CurHwUnit            Id of HW unit.
 ** \param [out] NextJobIdPtr        Pointer to next Job id. 
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_TerminateEvent
(
  VAR( Spi_HWUnitType, AUTOMATIC ) CurHwUnit,
  P2VAR( Spi_JobType, AUTOMATIC, AUTOMATIC ) NextJobIdPtr
);

/** \brief Spi_Internal_InformJobFinished
 **
 ** This function is used to inform a job end notification.
 ** DEM event is also issued at the same time.
 **
 ** \return None.
 ** \param [in] ApiId         Id of API.
 ** \param [in] CurJob        Id of current job.
 ** \param [in] EventStatus   Event status (passed or failed).
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_InformJobFinished
(
  VAR( uint8, AUTOMATIC ) ApiId,
  VAR( Spi_JobType, AUTOMATIC ) CurJob,
  VAR( uint8, AUTOMATIC ) EventStatus
);

/** \brief Spi_Internal_EventHandler
 **
 ** Handles the transmission completion event.
 **
 ** \return None.
 ** \param [in] HwUnit        Id of HW unit.
 ** \param [in] EventStatus   Event status (passed or failed).
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_EventHandler
(
  VAR( Spi_HWUnitType, AUTOMATIC ) HwUnit,
  VAR( uint8, AUTOMATIC ) EventStatus
);

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

#define SPI_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/* current asynchronous mode (interrupt mode or polling mode ) */
static VAR( Spi_AsyncModeType, AUTOMATIC ) Spi_PrivateVar_AsyncMode = SPI_POLLING_MODE;

/* current status (uninit, idle or busy) */
static VAR( Spi_StatusType, AUTOMATIC ) Spi_PrivateVar_Status = SPI_UNINIT;

/* current synchronous status (idle or busy) */
static VAR( Spi_StatusType, AUTOMATIC ) Spi_PrivateVar_SyncStatus = SPI_IDLE;

#define SPI_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external function definitions]=========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>


/** \brief Spi_Internal_Cancel
 **
 ** Cancels the specified ongoing sequence transmission.
 **
 ** \return None.
 ** \param [in] Sequence   Id of Sequence.
 **
 */
FUNC( void, SPI_CODE) Spi_Internal_Cancel
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  /* check if the sequence is on-going currently */
  if ( Spi_Seq_GetSequenceResult( Sequence ) == SPI_SEQ_PENDING )
  {
    /* the sequence is pending */
    Spi_Seq_SetSequenceResult( Sequence, SPI_SEQ_CANCELED );
  }
}

/** \brief Spi_Internal_GetAsyncMode
 **
 ** Gets the asynchronous mode (Polling or Interrupt).
 **
 ** \return Asynchronous mode (Polling or Interrupt).
 **
 */
FUNC( Spi_AsyncModeType, SPI_CODE ) Spi_Internal_GetAsyncMode(void)
{
  /* set asynchronous mode */
  return Spi_PrivateVar_AsyncMode;
}

/** \brief Spi_Internal_SetAsyncMode
 **
 ** Sets the asynchronous mode (Polling or Interrupt).
 **
 ** \return SPI_OK: Setting command has been done.
 **         SPI_NOT_OK: Setting command has not been accepted.
 ** \param [in] Status   Asynchronous mode (Polling or Interrupt).
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Internal_SetAsyncMode
(
  VAR( Spi_AsyncModeType, AUTOMATIC ) Status
)
{
  VAR( Spi_StatusType, AUTOMATIC ) InternalStatus;
  VAR( Spi_ReturnType, AUTOMATIC ) CheckResult;
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal;

  /* Get driver status and check job status */
  InternalStatus = Spi_Internal_GetStatus();
  CheckResult = Spi_Job_CheckAsyncJobStatus();
  /* check if driver status is busy */
  if ( ( InternalStatus == SPI_BUSY )
    && ( CheckResult == SPI_NOT_OK ) )
  {
    /* set result to ng */
      RetVal = SPI_NOT_OK;
  }
  /* driver status is not busy */
  else
  {
    /* set result to ok */
    RetVal = SPI_OK;
    /* set asynchronous mode */
    Spi_PrivateVar_AsyncMode = Status;
  }
  return RetVal;
}

/** \brief Spi_Internal_GetStatus
 **
 ** Returns the driver status.
 **
 ** \return Driver status.
 **
 */
FUNC( Spi_StatusType, SPI_CODE ) Spi_Internal_GetStatus(void)
{
  /* return current status */
  return Spi_PrivateVar_Status;
}

/** \brief Spi_Internal_SetStatus
 **
 ** Sets the driver status.
 **
 ** \return None.
 ** \param [in] Status   Driver status.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_SetStatus
(
  VAR( Spi_StatusType, AUTOMATIC ) Status
)
{
  /* set status */
  Spi_PrivateVar_Status = Status;
}

/** \brief Spi_Internal_GetJobResult
 **
 ** Returns the last transmission result of the specified Job.
 **
 ** \return Transmission result of Job.
 ** \param [in] Job   Id of Job.
 **
 */
FUNC( Spi_JobResultType, SPI_CODE ) Spi_Internal_GetJobResult
(
  VAR( Spi_JobType, AUTOMATIC ) Job
)
{
  /* return the relevant job result */
  return Spi_Job_GetJobResult( Job );
}

/** \brief Spi_Internal_GetSequenceResult
 **
 ** Returns the last transmission result of the specified Sequence.
 **
 ** \return Transmission result of Sequence.
 ** \param [in] Sequence   Id of Sequence.
 **
 */
FUNC( Spi_SeqResultType, SPI_CODE ) Spi_Internal_GetSequenceResult
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  /* return the relevant sequence result */
  return Spi_Seq_GetSequenceResult( Sequence );
}

/** \brief Spi_Internal_GetVersionInfo
 **
 ** Returns the version information.
 **
 ** \return None.
 ** \param [out] versionInfoPtr   Pointer to where to store the version 
 **                               information.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_GetVersionInfo
(
  P2VAR( Std_VersionInfoType, AUTOMATIC, AUTOMATIC ) versionInfoPtr
)
{
  /* set version information */
  versionInfoPtr->vendorID         = SPI_VENDOR_ID;
  versionInfoPtr->moduleID         = SPI_MODULE_ID;
}

/** \brief Spi_Internal_Init
 **
 ** Initializes the driver.
 **
 ** \return None.
 ** \param [in] ConfigPtr   Pointer to driver configuration set
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_Init
(
  P2CONST( Spi_ConfigType, AUTOMATIC, AUTOMATIC ) ConfigPtr
)
{
  VAR( uint8, AUTOMATIC ) LevelDelivered = Spi_Com_GetLevelDelivered();

  /* Set configuration */
  Spi_Cfg_SetConfig(ConfigPtr);

  /* check if level delivered is 1 or 2 */
  if ( ( LevelDelivered == 1U ) || ( LevelDelivered == 2U ) )
  {
    /* initialized queue */
    Spi_Que_Init();
  }

  /* initialize all sequences */
  Spi_Seq_InitAllSequences();
  /* initialize all jobs */
  Spi_Job_InitAllJobs();
  /* initialize all channels */
  Spi_Chan_InitAllChannels();

  /* initialize hwunit */
  Spi_Hw_Init();
  /* initialize hwunit */
  Spi_CS_InitChipSelect();

  /* check if LevelDelivered is 2 */
  if ( LevelDelivered == 2U )
  {
    Spi_PrivateVar_AsyncMode = SPI_POLLING_MODE; 
  }
  /* check if LevelDelivered is 1 */
  else if ( LevelDelivered == 1U )
  {
    Spi_PrivateVar_AsyncMode = SPI_INTERRUPT_MODE; 
  }
  /* LevelDelivered is 0 */
  else
  {
    /* nothing to do here */
  }
            
  /* set synchronous status to idle */
  Spi_Internal_SetSyncStatus( SPI_IDLE );
  
  /* set status to idle */
  Spi_Internal_SetStatus( SPI_IDLE );
}

/** \brief Spi_Internal_DeInit
 ** De-initializes the driver.
 **
 ** \return None.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_DeInit(void)
{
  /* de-initialize all hwunits */
  Spi_Hw_DeInit();

  /* Set to current config pointer to NULL_PTR */
  Spi_Cfg_SetConfig(NULL_PTR);
  
}

/** \brief Spi_Internal_WriteIB
 **
 ** Writing one or more data to an IB channel.
 **
 ** \return None.
 ** \param [in] Channel   Id of Channel.
 ** \param [in] DataBufferPtr   Pointer to source data buffer.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_WriteIB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DataBufferPtr
)
{
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr;
  P2VAR( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) CurChannelInfoPtr;
  VAR( uint8, AUTOMATIC ) BytesPerDataElement;

  /* get a channel config setting */
  ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
  /* get a channel information setting */
  CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[Channel] );

  /* check if the buffer pointer is valid */
  if ( DataBufferPtr != NULL_PTR )
  {
    /* copy required data to the internal buffer */
    Spi_Com_MemCopy( CurChannelInfoPtr->TxBufferPtr,
                     DataBufferPtr,
                     (CurChannelInfoPtr->BufferSize * ChannelConfigPtr->DataWidth) );
  }
  /* the buffer pointer is invalid */
  else
  {
    /* Set the number of bytes per data element (determined by SpiDataWidth). */
    BytesPerDataElement = ChannelConfigPtr->DataWidth;

    /* copy default data to the internal buffer */
    /* Deviation from MISRA-C:2004 Rule 11.4, MISRA-C:2012 Rule-11.3.
       Justification: This deviation is due to handling with 8-bit type 
       address. */
    /* PRQA S 310 3 */
    Spi_Com_MemSet( CurChannelInfoPtr->TxBufferPtr,
                    ( CurChannelInfoPtr->BufferSize * BytesPerDataElement ) ,
                    ( P2CONST(uint8, AUTOMATIC, AUTOMATIC) ) &( ChannelConfigPtr->DefaultData ),
                    BytesPerDataElement );
  }
  /* reset buffer positions. */
  Spi_Info.ChannelInfoListPtr[Channel].BufferPosStoredForSend = 0U;
  Spi_Info.ChannelInfoListPtr[Channel].BufferPosReceived = 0U;
}

/** \brief Spi_Internal_ReadIB
 **
 ** Reading synchronously one or more data from an IB channel.
 **
 ** \return None.
 ** \param [in]  Channel         Id of Channel.
 ** \param [out] DataBufferPtr   Pointer to destination data buffer in RAM.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_ReadIB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DataBufferPtr
)
{
  P2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr;
  P2VAR( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) CurChannelInfoPtr;

  /* get a channel config setting */
  ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
  /* get a channel information setting */
  CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[Channel] );

  /* copy internal buffer to the specified area (pointed by DataBufferPtr) */
  Spi_Com_MemCopy( DataBufferPtr, CurChannelInfoPtr->RxBufferPtr,
  (CurChannelInfoPtr->BufferSize * ChannelConfigPtr->DataWidth) );
}

/** \brief Spi_Internal_SetupEB
 **
 ** Sets the buffers and the length of data for the EB channel.
 **
 ** \return None.
 **
 ** \param [in] Channel
 **                 Channel ID
 ** \param [in] SrcDataBufferPtr
 **                 Pointer to source data buffer
 ** \param [in] DesDataBufferPtr
 **                 Pointer to destination data buffer in RAM
 ** \param [in] Length
 *                  Length (in number of data elements) of the data to be  
 **                 transmitted from SrcdataBufferPtr and/or received 
 **                 from DesDataBufferPtr.
 **                   Min.: 1
 **                   Max.: Maximum of data specified at configuration
 **                         for this channel
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_SetupEB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length
)
{
  /* setup a channel for an external buffer */
  Spi_Chan_SetupEB(
    Channel,
    SrcDataBufferPtr,
    DesDataBufferPtr,
    Length
  );
}

/** \brief Spi_Internal_CheckSetupEB
 **
 ** Internal implementation of service to setup the buffers and the length of 
 ** data for the EB channel specified.
 **
 ** \return SPI_OK: Accept request.
 **         SPI_NOT_OK: Not accept request.
 **
 ** \param [in] Channel           
 **                 Channel ID
 ** \param [in] SrcDataBufferPtr
 **                 Pointer to source data buffer
 ** \param [in] DesDataBufferPtr
 **                 Pointer to destination data buffer in RAM
 ** \param [in] Length
 **                 Length (in number of data elements) of the data to be 
 **                 transmitted from SrcdataBufferPtr and/or received 
 **                 from DesDataBufferPtr.
 **                   Min.:  1
 **                   Max.: Maximum of data specified at configuration
 **                       for this channel
 ** \param [out] ErrorIdPtr
 **                 Pointer to error code id.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Internal_CheckSetupEB
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length,
  P2VAR( Spi_ErrorType, AUTOMATIC, AUTOMATIC ) ErrorIdPtr
)
{
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal = SPI_OK;
  P2CONST ( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr = 
      &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
  VAR( uint8, AUTOMATIC ) DataWidthInBytes;

  /* check the range of length */
  if ( ( Length > ChannelConfigPtr->BufferSize ) || ( Length == 0U ) )
  {
    *ErrorIdPtr = SPI_E_PARAM_LENGTH;
    RetVal = SPI_NOT_OK;
  }
  /* check whether length is a multiple of data width */
  else
  {
    /* get data width in byte */
    DataWidthInBytes = ChannelConfigPtr->DataWidth;

    /* check the alignment of buffer address if the AlignedBuffer is true */
    if ( SPI_TRUE == ChannelConfigPtr->AlignedBuffer )
    {
      /* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
         Justification: Cast between pointer and integer is necessary for 
         hardware access. */
      /* PRQA S 306 2 */
      if ( ( ( ( (uint32) SrcDataBufferPtr ) % DataWidthInBytes ) != 0U )
        || ( ( ( (uint32) DesDataBufferPtr ) % DataWidthInBytes ) != 0U ) )
      {
        *ErrorIdPtr = SPI_E_PARAM_POINTER;
        RetVal = SPI_NOT_OK;
      }
    }
    else
    {
       ; /* nothing to do here */
    }
  }
  return RetVal;
}

/** \brief Spi_Internal_GetBufferStatus
 **
 ** This function reads back the buffer status and the remaining length of 
 ** data for the SPI Handler/Driver Channel specified.
 ** The calling function shall assure correct parameters.
 **
 ** \param [in]  Channel
 **                 Channel ID of the channel that is polled for the status.
 ** \param [out] SrcDataBufferPtrPtr
 **                 Pointer to pointer that will be filled with pointer to 
 **                 source data buffer.
 ** \param [out] DesDataBufferPtrPtr
 **                 Pointer to pointer that will be filled with pointer to 
 **                 destination data buffer.
 ** \param [out] SrcRemainingLengthPtr
 **                 Pointer to variable that will be filled with the remaining
 **                 length (in number of data elements) of the source data yet 
 **                 to be transmitted from the source data buffer.
 ** \param [out] DesRemainingLengthPtr
 **                 Pointer to variable that will be filled with the remaining 
 **                 length (in number of data elements) of the destination  
 **                 data yet to be received to destination data buffer.
 */
FUNC( void, SPI_CODE ) Spi_Internal_GetBufferStatus
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2VAR( P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC ), AUTOMATIC, AUTOMATIC ) SrcDataBufferPtrPtr,
  P2VAR( P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC ), AUTOMATIC, AUTOMATIC ) DesDataBufferPtrPtr,
  P2VAR( Spi_NumberOfDataType, AUTOMATIC, AUTOMATIC ) SrcRemainingLengthPtr,
  P2VAR( Spi_NumberOfDataType, AUTOMATIC, AUTOMATIC ) DesRemainingLengthPtr
)
{
  P2VAR( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) CurChannelInfoPtr;
  VAR( uint8, AUTOMATIC ) BytesPerDataElement;
  VAR(Spi_NumberOfDataType, AUTOMATIC) CurBufferPosStoredForSend;
  VAR(Spi_NumberOfDataType, AUTOMATIC) CurBufferPosReceived;
  
  /* get a channel information */
  CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[Channel] );

  CurBufferPosStoredForSend = CurChannelInfoPtr->BufferPosStoredForSend;
  CurBufferPosReceived = CurChannelInfoPtr->BufferPosReceived;
  
  BytesPerDataElement = Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel].DataWidth;

  /* Check TxBuffer available */
  if (CurChannelInfoPtr->TxBufferPtr == NULL_PTR)
  {
    /* update pointers to buffers */
    *SrcDataBufferPtrPtr = NULL_PTR;
  }
  else
  {
    /* update pointers to buffers */
    *SrcDataBufferPtrPtr = &CurChannelInfoPtr->TxBufferPtr[CurBufferPosStoredForSend*BytesPerDataElement];
  }

  /* Check RxBuffer available */
  if (CurChannelInfoPtr->RxBufferPtr == NULL_PTR)
  {
    /* update pointers to buffers */
    *DesDataBufferPtrPtr = NULL_PTR;
  }
  else
  {
    /* update pointers to buffers */
    *DesDataBufferPtrPtr = &CurChannelInfoPtr->RxBufferPtr[CurBufferPosReceived*BytesPerDataElement];
  }

  /* update remaining buffer length */
  *SrcRemainingLengthPtr = CurChannelInfoPtr->BufferSize - CurBufferPosStoredForSend;
  *DesRemainingLengthPtr = CurChannelInfoPtr->BufferSize - CurBufferPosReceived;
}

/** \brief Spi_Internal_AsyncTransmit
 **
 ** Starts asynchronous transmission.
 **
 ** \return None.
 ** \param [in]  Sequence   Id of Sequence.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_AsyncTransmit
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  VAR( Spi_JobType, AUTOMATIC ) FirstJob;
  /* helper to avoid too many lookups */
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfigPtr;

  /* get a first channel in the specified job */
  SequenceConfigPtr = &( Spi_Current_ConfigPtr->SequencesConfigListPtr[Sequence] );
  FirstJob = SequenceConfigPtr->JobListPtr[0U];

  /* start a first channel in the specified job */
  Spi_Job_TransmitFirstChannel( FirstJob );
}

/** \brief Spi_Internal_SyncTransmit
 **
 ** Starts synchronous transmission.
 **
 ** \return None.
 ** \param [in]  Sequence     Id of Sequence.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_SyncTransmit
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  VAR( Spi_ReturnType, AUTOMATIC ) JobFinishedFlag;
  VAR( Spi_JobType, AUTOMATIC ) CurJob;
  VAR( Spi_JobType, AUTOMATIC ) NextJob;
  VAR( Spi_HWUnitType, AUTOMATIC ) CurHwUnit;
  VAR( Spi_HWUnitType, AUTOMATIC ) NextHwUnit;
  VAR( Spi_JobIndexType, AUTOMATIC ) JobIndex;
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfigPtr;
  VAR( uint8, AUTOMATIC ) EventStatus;
  VAR( Spi_JobResultType, AUTOMATIC ) JobResult;

  SequenceConfigPtr = &( Spi_Current_ConfigPtr->SequencesConfigListPtr[Sequence] );

  /* iterate to transmit all jobs in the relevant sequence */
  for ( JobIndex = 0U; JobIndex < SequenceConfigPtr->JobCount; JobIndex++ )
  {
    /* get a current job */
    CurJob = SequenceConfigPtr->JobListPtr[JobIndex];

    /* transmit a job */
    Spi_Job_TransmitAllChannels( CurJob, &EventStatus );

    /* enter a critical section */
    Spi_Com_SchMEnterCriticalSection();

    /* get a hwunit */
    CurHwUnit = Spi_Current_ConfigPtr->JobConfigListPtr[CurJob].ExternalDevicePtr->HwUnit;

    /* set hwunit status to idle */
    Spi_Hw_SetHwUnitStatus( CurHwUnit, SPI_IDLE );

    /* set job result to ok or failed */
    JobResult = ( EventStatus == SPI_DEM_EVENT_STATUS_PASSED ) ? ( SPI_JOB_OK ) : ( SPI_JOB_FAILED );
    Spi_Info.JobInfoListPtr[CurJob].Result = JobResult;

    /* set channel index to 0 */
    Spi_Job_SetChannelIndex( CurJob, 0U, SPI_HW_FACTOR_SCB_TX_AND_RX );

    /* release relationship between the hwunit and the job */
    Spi_Info.DriverHwInfoListPtr[CurHwUnit].Job = SPI_INVALID_JOB;

    /* release current sequence from the hwunit */
    Spi_Com_SetCurrentSequence( CurHwUnit, SPI_INVALID_SEQUENCE );

    /* call an internal function to judge all jobs are finished */
    JobFinishedFlag = Spi_Seq_HandlerJobFinished( Sequence, EventStatus, &NextJob );

    /* all jobs in the relevant sequence are already finished */
    if ( JobFinishedFlag == SPI_OK )
    {
      /* update driver status and synchronous status */
      Spi_Internal_UpdateDriverAndSyncStatus();

      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();

      /* inform that job has been just finished */
      Spi_Internal_InformJobFinished( SPI_API_SYNCTRANSMIT, CurJob, EventStatus );

      /* check if sequence end notification is enabled */
      if ( SequenceConfigPtr->SeqEndNotification != NULL_PTR )
      {
        /* call a sequence end notification */
        SequenceConfigPtr->SeqEndNotification();
      }

      /* escape from loop because all jobs were already finished or one job 
        was failed */
      break;
    }
    /* at least one job in the relevant sequence is NOT finished yet */
    else
    {
      /* get a hwunit */
      NextHwUnit = Spi_Current_ConfigPtr->JobConfigListPtr[NextJob].ExternalDevicePtr->HwUnit;

      /* set the relevant hwunit to busy */
      Spi_Hw_SetHwUnitStatus( NextHwUnit, SPI_BUSY );

      /* clear channel index in the relevant job */
      Spi_Job_SetChannelIndex( NextJob, 0U, SPI_HW_FACTOR_SCB_TX_AND_RX );
      /* associate a next job with the relevant hwunit */
      Spi_Info.DriverHwInfoListPtr[NextHwUnit].Job = NextJob;

      /* associate a sequence with the relevant hwunit */
      Spi_Com_SetCurrentSequence( NextHwUnit, Sequence );

      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();

      /* inform that job has been just finished */
      Spi_Internal_InformJobFinished( SPI_API_SYNCTRANSMIT, CurJob, EventStatus );
    }
  }
}

/** \brief Spi_Internal_GetSyncStatus
 **
 ** Returns the synchronous transmission status.
 **
 ** \return Synchronous transmission status.
 **
 */
FUNC(Spi_StatusType, SPI_CODE) Spi_Internal_GetSyncStatus(void)
{
  /* return synchronous status */
  return Spi_PrivateVar_SyncStatus;
}

/** \brief Spi_Internal_CheckSyncJob
 **
 ** Checks whether synchronous mode of jobs in the sequence is correct.
 **
 ** \return SPI_OK: Synchronous mode is correct.
 **         SPI_NOT_OK: Synchronous mode is not correct.
 **
 ** \param [in] HwUnitSync   SPI_HWUNIT_SYNC: Synchronous mode.
 **                          SPI_HWUNIT_ASYNC: Asynchronous mode.
 ** \param [in] SequenceConfPtr   Pointer to Sequence configuration.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE) Spi_Internal_CheckSyncJob
(
  VAR( Spi_HWUnitSyncType, AUTOMATIC ) HwUnitSync,
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfPtr
)
{
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) FirstJobConfigPtr;
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal;
  
  FirstJobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[SequenceConfPtr->JobListPtr[0U]] );
  /* check whether the first job is defined as an asynchronous job */
  if ( FirstJobConfigPtr->HwUnitSync == HwUnitSync )
  {
    /* set result to ok */
    RetVal = SPI_OK;
  }
  /* the job is defined as a synchronous job */
  else
  {
    /* set result to ng */
    RetVal = SPI_NOT_OK;
  }
  return RetVal;
}

/** \brief Spi_Internal_CheckChannelType
 **
 ** Checks whether channel buffer type is correct.
 **
 ** \return SPI_OK: Channel buffer type is correct.
 **         SPI_NOT_OK: Channel buffer type is not correct.
 ** \param [in] Channel         Id of Channel.
 ** \param [in] ChannelBuffer   Buffer type (internal or external) of Channel.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Internal_CheckChannelType
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  VAR( uint8, AUTOMATIC ) ChannelBuffer
)
{
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal;
  CONSTP2CONST( Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC ) ChannelConfigPtr = 
      &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );

  /* check if type of channel buffer is same as the passed parameter */
  if ( ChannelConfigPtr->ChannelType == ChannelBuffer )
  {
    /* set result to ok */
    RetVal = SPI_OK;
  }
  /* type of channel buffer is not same as the passed parameter */
  else
  {
    /* set result to ng */
    RetVal = SPI_NOT_OK;
  }
  return RetVal;
}

/** \brief Spi_Internal_SetSyncStatus
 **
 ** Sets the synchronous transmission status.
 **
 ** \return None.
 ** \param [in] Status   Synchronous transmission status.
 **
 */
FUNC( void, SPI_CODE ) Spi_Internal_SetSyncStatus
(
  VAR( Spi_StatusType, AUTOMATIC ) Status
)
{
  /* set synchronous status */
  Spi_PrivateVar_SyncStatus = Status;
}

/** \brief Spi_Internal_CheckRelatedStatus
 **
 ** Checks the status of related sequences and the Jobs.
 **
 ** \return SPI_OK: The sequence is available.
 **         SPI_NOT_OK: The sequence is not available.
 ** \param [in] SequenceConfPtr   Pointer to Sequence configuration.
 ** \param [in] HwUnitSync        SPI_HWUNIT_SYNC: Synchronous mode.
 ** SPI_HWUNIT_ASYNC: Asynchronous mode.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Internal_CheckRelatedStatus
(
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfPtr,
  VAR( Spi_HWUnitSyncType, AUTOMATIC ) HwUnitSync
)
{
  VAR( Spi_SequenceIndexType, AUTOMATIC ) IndexOfSequence;
  VAR( Spi_JobType, AUTOMATIC ) CurJob;
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr;
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal = SPI_OK;
  VAR( Spi_SequenceType, AUTOMATIC ) SharedSequence;

  /* iterate to check all sequences which share same hwunit in the required 
    sequence */
  for ( IndexOfSequence = 0U; IndexOfSequence < SequenceConfPtr->SharedHwUnitSeqCount; IndexOfSequence++ )
  {
    /* helpers to avoid too many lookups */
    SharedSequence = SequenceConfPtr->SharedHwUnitSeqListPtr[IndexOfSequence];
    CurJob = Spi_Seq_GetCurrentJob( SharedSequence );
    /* check if the shared sequence is pennding */
    if ( CurJob != SPI_INVALID_JOB )
    {
      /* sequence is pending if there are current job. */
      JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJob] );

      /* check if the relevant job is synchronous */
      if ( JobConfigPtr->HwUnitSync == SPI_HWUNIT_SYNC )
      {
        /* check if the relevant job is pending */
        if ( Spi_Job_GetJobResult( CurJob ) == SPI_JOB_PENDING )
        {
          /* set result to failed */
          RetVal = SPI_NOT_OK;
        }
      }
    }
    /* check if the passed HwUnitSync is synchronous */
    if ( (HwUnitSync == SPI_HWUNIT_SYNC) && (RetVal != SPI_NOT_OK) )
    {
      /* check if the shared sequence is queued */
      if ( Spi_Que_CheckQueue( SharedSequence ) == SPI_OK )
      {
        /* set result to failed */
        RetVal = SPI_NOT_OK;
      }
    }
    /* break the iteration if the result is set to failed */
    if(RetVal == SPI_NOT_OK)
    {
      break;
    }
  }
  return RetVal;
}

/** \brief Spi_Internal_SetRelatedStatus
 **
 ** Sets the status of related sequences and the Jobs.
 **
 ** \return SPI_OK: The sequence is available.
 **         SPI_NOT_OK: The sequence is not available.
 ** \param [in] SequenceConfPtr   Pointer to Sequence configuration.
 ** \param [in] HwUnitSync        SPI_HWUNIT_SYNC: Synchronous mode.
 ** SPI_HWUNIT_ASYNC: Asynchronous mode.
 **
 */
FUNC( Spi_ReturnType, SPI_CODE ) Spi_Internal_SetRelatedStatus
(
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfPtr,
  VAR( Spi_HWUnitSyncType, AUTOMATIC ) HwUnitSync
)
{
  VAR( Spi_ReturnType, AUTOMATIC ) RetVal = SPI_NOT_OK;
  VAR( Spi_JobType, AUTOMATIC ) CurJobId;
  VAR( Spi_JobIndexType, AUTOMATIC ) JobIndex;
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr;
  VAR( Spi_HWUnitType, AUTOMATIC ) HwUnitId;
  VAR( Spi_JobResultType, AUTOMATIC ) JobResult;
  VAR( Spi_StatusType, AUTOMATIC ) HwUnitStatus;

  /* check if HwUnitSync is equal to asynchronous */
  if ( HwUnitSync == SPI_HWUNIT_ASYNC )
  {
    /* check if queuing is not ok */
    if ( Spi_Que_Enqueue( SequenceConfPtr ) != SPI_OK )
    {
      /* set result to ng because queuing is failed */
      RetVal = SPI_FAILED;
    }
    /* queuing is success */
    else
    {
      /* set all job queued status in the sequence */
      Spi_Seq_SetAllJobIsQueued( SequenceConfPtr->SequenceId, SPI_TRUE );
    }
  }

  /* check if result is not failed */
  if ( RetVal != SPI_FAILED )
  {
    /* set sequence result to pending */
    Spi_Seq_SetSequenceResult( SequenceConfPtr->SequenceId, SPI_SEQ_PENDING );
    /* set current job */
    Spi_Seq_SetJobIndex( SequenceConfPtr->SequenceId, 0U );

    /* set a job result */
    JobResult = ( HwUnitSync == SPI_HWUNIT_ASYNC ) ? ( SPI_JOB_QUEUED ) : ( SPI_JOB_PENDING );
    /* iterate to set job result for all jobs */
    for ( JobIndex = 0U; JobIndex < SequenceConfPtr->JobCount; JobIndex++ )
    {
      /* set a job result to queued */
	  Spi_Info.JobInfoListPtr[SequenceConfPtr->JobListPtr[JobIndex]].Result = JobResult;
    }

    /* helpers to avoid too many lookups */
    CurJobId = SequenceConfPtr->JobListPtr[0U];
    JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJobId] );
    HwUnitId = JobConfigPtr->ExternalDevicePtr->HwUnit;

    /* Get HW status */
    HwUnitStatus = Spi_Info.HwInfoListPtr[HwUnitId].Status;

    /* check if hwunit status is busy in case of asynchronous transmission */
    if ( ( HwUnitSync == SPI_HWUNIT_SYNC )
      || ( HwUnitStatus != SPI_BUSY ) )
    {
      /* set result to ok */
      RetVal = SPI_OK;

      /* set hwunit status to busy */
      Spi_Hw_SetHwUnitStatus( HwUnitId, SPI_BUSY );
      /* set job result to pending */
      Spi_Info.JobInfoListPtr[CurJobId].Result = SPI_JOB_PENDING;
      /* clear channel index */
      Spi_Job_SetChannelIndex( CurJobId, 0U, SPI_HW_FACTOR_SCB_TX_AND_RX );
      /* associate a current job in the relevant hwunit */
      Spi_Info.DriverHwInfoListPtr[HwUnitId].Job = CurJobId;

      /* set current sequence to the relevant hwunit */
      Spi_Com_SetCurrentSequence( HwUnitId, SequenceConfPtr->SequenceId );

      /* set driver status to busy */
      Spi_Internal_SetStatus( SPI_BUSY );
    }
    /* the relevant hwunit is already pending */
  }
  return RetVal;
}

/** \brief Spi_Internal_InterruptHandler
 **
 ** Common functions for interrupt.
 **
 ** \return SPI_OK: Factor was cleared in interruption.
 **         SPI_NOT_OK: Factor is not cleared in interruption.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HWUnit   Id of hardware unit.
 **
 */
FUNC(Spi_ReturnType, SPI_CODE) Spi_Internal_InterruptHandler
(
  VAR( Spi_HwFactorType, AUTOMATIC ) Factor,
  VAR( Spi_HWUnitType,   AUTOMATIC ) HwUnit
)
{
  uint8 EventStatus;
  VAR( uint8, AUTOMATIC ) LevelDelivered; /* level delivered */
  VAR( Spi_AsyncModeType, AUTOMATIC ) AsyncMode; /* async mode */
  VAR(Spi_ReturnType, AUTOMATIC) RetVal = SPI_NOT_OK; /* return value */

  if (SPI_BUSY == Spi_Info.HwInfoListPtr[HwUnit].Status )
  {
    if ( SPI_OK == Spi_Hw_CheckFinished(Factor, HwUnit) )
    {
      RetVal = SPI_OK;
      Spi_Hw_Finished(Factor, HwUnit);
    }
    if ( SPI_OK == Spi_Hw_ValidateEvent(HwUnit, &EventStatus) )
    {
      Spi_Internal_EventHandler(HwUnit, EventStatus);
    }
  }
  else
  {
    /* Get level delivered and async mode */
    LevelDelivered = Spi_Com_GetLevelDelivered();
    AsyncMode = Spi_Internal_GetAsyncMode();

    if ( ( LevelDelivered == SPI_LEVEL_DELIVERED_1 )
      || ( SPI_POLLING_MODE != AsyncMode ) )
    {
      RetVal = Spi_Hw_CheckFinished(SPI_HW_FACTOR_SCB_ERROR, HwUnit);
    }
  }
  return RetVal;
}

/** \brief Spi_Internal_Terminate
 **
 ** Terminates the specified sequence.
 **
 ** \return SPI_OK:     Terminate command has been accepted
 **         SPI_NOT_OK: Terminate command has not been accepted
 ** \param [in] Sequence Id of sequence.
 **
 */
FUNC(Spi_ReturnType, SPI_CODE) Spi_Internal_Terminate
(
  VAR( Spi_SequenceType, AUTOMATIC ) Sequence
)
{
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) CurJobConfigPtr;
  VAR( Spi_JobType, AUTOMATIC ) CurJob;
  VAR( uint8, AUTOMATIC ) LevelDelivered; /* level delivered */
  VAR( Spi_AsyncModeType, AUTOMATIC ) AsyncMode; /* async mode */
  VAR(Spi_ReturnType, AUTOMATIC) RetVal; /* return value */

  /* get current job */
  CurJob = Spi_Seq_GetCurrentJob( Sequence );
  
  /* check if the sequence is not pending */
  if ( CurJob == SPI_INVALID_JOB )
  {
    RetVal = SPI_NOT_OK;
  }
  else
  {
    /* get job result */
    if ( SPI_JOB_PENDING == Spi_Job_GetJobResult( CurJob ) )
    {
      /* get pointer to job configuration */
      CurJobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJob] );
      /* terminate the HW unit */
      RetVal = Spi_Hw_TerminateHwUnit( CurJobConfigPtr->ExternalDevicePtr,
                                       CurJobConfigPtr->HwUnitSync );
      if ( RetVal == SPI_OK )
      {
        /* Get level delivered and async mode */
        LevelDelivered = Spi_Com_GetLevelDelivered();
        AsyncMode = Spi_Internal_GetAsyncMode();
        if (( CurJobConfigPtr->HwUnitSync == SPI_HWUNIT_ASYNC )
        && ( ( LevelDelivered == SPI_LEVEL_DELIVERED_1 )
          || ( AsyncMode != SPI_POLLING_MODE ) ) )
        {
          /* exit a critical section */
          Spi_Com_SchMExitCriticalSection();
          /* successfully stopped the HW unit. */
          Spi_Internal_EventHandler( CurJobConfigPtr->ExternalDevicePtr->HwUnit,
                                     SPI_DEM_EVENT_STATUS_FAILED );
          /* enter a critical section */
          Spi_Com_SchMEnterCriticalSection();
        }
      }
    }
    else
    {
      RetVal = SPI_NOT_OK;
    }
  }
  return RetVal;
}

/** \brief Spi_Internal_ChangeOvsSetting
 **
 ** Change over sampling setting of external device.
 **
 ** \return None.
 ** \param [in] ExtDev      Id of external device.
 ** \param [in] ScbOvsValue Value of OVS bits in SCB CTRL register.
 **
 */
FUNC(void, SPI_CODE) Spi_Internal_ChangeOvsSetting
(
  CONST( Spi_ExtDeviceType, AUTOMATIC ) ExtDev,
  VAR( Spi_OvsValueType, AUTOMATIC ) ScbOvsValue
)
{
  Spi_Hw_ChangeOvs( ExtDev, ScbOvsValue );
}

/*==================[internal function definitions]=========================*/

/** \brief Spi_Internal_UpdateDriverStatus
 **
 ** Updates driver status.
 **
 ** \return None.
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_UpdateDriverStatus(void)
{
  VAR( boolean, AUTOMATIC ) StatusResult = SPI_FALSE;
  VAR( uint8, AUTOMATIC ) IndexOfHwUnit;
  VAR( uint8, AUTOMATIC ) MaxNrOfHwUnits;

  /* get number of maximum hwunit */
  MaxNrOfHwUnits = Spi_Com_GetMaxNrOfHwUnits();
  /* for maximum HW units */
  for ( IndexOfHwUnit = 0U; IndexOfHwUnit < MaxNrOfHwUnits; IndexOfHwUnit++ )
  {
    /* check if the hwunit status is busy */
    if ( Spi_Info.HwInfoListPtr[IndexOfHwUnit].Status == SPI_BUSY )
    {
      /* set result to true */
      StatusResult = SPI_TRUE;
      break;
    }
  }
  /* check if all hwunits are not running */
  if ( StatusResult != SPI_TRUE )
  {
    /* set driver status to idle */
    Spi_Internal_SetStatus( SPI_IDLE );
  }
}

/** \brief Spi_Internal_UpdateDriverAndSyncStatus
 **
 ** Updates both driver status and synchronous status.
 **
 ** \return None.
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_UpdateDriverAndSyncStatus(void)
{
  VAR( uint8, AUTOMATIC ) MaxNrOfHwUnits;
  VAR( uint8, AUTOMATIC ) IndexOfHwUnit;
  VAR( Spi_JobType, AUTOMATIC ) CurJob;
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr;
  VAR( uint8, AUTOMATIC ) NrOfPendingHwUnit;
  VAR( uint8, AUTOMATIC ) NrOfPendingSyncHwUnit;

  /* get number of maximum hwunit */
  MaxNrOfHwUnits = Spi_Com_GetMaxNrOfHwUnits();
  /* initialize counters */
  NrOfPendingSyncHwUnit = 0U;
  NrOfPendingHwUnit = 0U;
  /* for maximum HW units */
  for ( IndexOfHwUnit = 0U; IndexOfHwUnit < MaxNrOfHwUnits; IndexOfHwUnit++ )
  {
    /* check if the hwunit status is busy */
    if ( Spi_Info.HwInfoListPtr[IndexOfHwUnit].Status == SPI_BUSY )
    {
      /* get a current job in the relevant hwunit */
      CurJob = Spi_Info.DriverHwInfoListPtr[IndexOfHwUnit].Job;
      /* get a current job config setting for the relevant hwunit */
      JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJob] );

      /* increment number of pending hwunit */
      NrOfPendingHwUnit++;

      /* check if the job is synchronous job */
      if ( JobConfigPtr->HwUnitSync == SPI_HWUNIT_SYNC )
      {
        /* increment number of pending hwunit (which is used by synchronous 
          job) */
        NrOfPendingSyncHwUnit = 1U;
        /* escape from loop */
        break;
      }
    }
  }
  /* set sync status to idle if all sync jobs are not pending */
  Spi_PrivateVar_SyncStatus = ( NrOfPendingSyncHwUnit > 0U ) ? ( SPI_BUSY ) : ( SPI_IDLE );
  /* set driver status to busy if all hwunit status are idle */
  Spi_Internal_SetStatus( ( NrOfPendingHwUnit > 0U ) ? ( SPI_BUSY ) : ( SPI_IDLE ) );
}

/** \brief Spi_Internal_TerminateEvent
 **
 ** This function is intended to terminate an event.
 ** This function checks if at least one job still alive yet.
 ** If a job is not found, this function finishes an event for the relevant 
 ** hwunit.
 ** If a job is found, it returns with a job id.
 ** A caller shall start the job in order to proceed event immediately after 
 ** it is received.
 **
 ** \return None.
 ** \param [in] CurHwUnit            Id of HW unit.
 ** \param [out] NextJobIdPtr        Pointer to next Job id. 
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_TerminateEvent
(
  VAR( Spi_HWUnitType, AUTOMATIC ) CurHwUnit,
  P2VAR( Spi_JobType, AUTOMATIC, AUTOMATIC ) NextJobIdPtr
)
{
  VAR( Spi_SequenceType, AUTOMATIC ) NextSequence;

  /* start the next sequence if the next sequence is found in the transmit 
    queue */
  Spi_Que_FindHighestPriorJob( CurHwUnit, &NextSequence, NextJobIdPtr );

  /* check if the highest job in the sequence */
  if ( *NextJobIdPtr != SPI_INVALID_JOB )
  {
    /* set a current sequence for the relevant hwunit */
    Spi_Com_SetCurrentSequence( CurHwUnit, NextSequence );
    /* set a current job for the relevant hwunit */
    Spi_Info.DriverHwInfoListPtr[CurHwUnit].Job = *NextJobIdPtr;

    /* set a job result to pending */
    Spi_Info.JobInfoListPtr[*NextJobIdPtr].Result = SPI_JOB_PENDING;
    /* set a channel index to zero */
    Spi_Job_SetChannelIndex( *NextJobIdPtr, 0U, SPI_HW_FACTOR_SCB_TX_AND_RX );
  }
  /* the highest job is not found */
  else
  {
    /* clear a current sequence for the relevant hwunit */
    Spi_Com_SetCurrentSequence( CurHwUnit, SPI_INVALID_SEQUENCE );
    /* clear a current job for the relevant hwunit */
    Spi_Info.DriverHwInfoListPtr[CurHwUnit].Job = SPI_INVALID_JOB;

    /* set the relevant hwunit to idle */
    Spi_Hw_SetHwUnitStatus( CurHwUnit, SPI_IDLE );

    /* Changes the DriverStatus if all HW units state are SPI_IDLE. */
    Spi_Internal_UpdateDriverStatus();
  }
}

/** \brief Spi_Internal_InformJobFinished
 **
 ** This function is used to inform a job end notification.
 ** DEM event is also issued at the same time.
 **
 ** \return None.
 ** \param [in] ApiId         Id of API.
 ** \param [in] CurJob        Id of current job.
 ** \param [in] EventStatus   Event status (passed or failed).
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_InformJobFinished
(
  VAR( uint8, AUTOMATIC ) ApiId,
  VAR( Spi_JobType, AUTOMATIC ) CurJob,
  VAR( uint8, AUTOMATIC ) EventStatus
)
{
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr;

  /* report a DEM event */
  Spi_Com_DemReportEvent( ApiId, SPI_E_HW_ERROR, EventStatus );

  /* get a job config setting */
  JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJob] );
  /* check if job end notification is enabled */
  if ( JobConfigPtr->JobEndNotification != NULL_PTR )
  {
    /* call a notification for the relevant job */
    JobConfigPtr->JobEndNotification();
  }
}

/** \brief Spi_Internal_EventHandler
 **
 ** Handles the transmission completion event.
 **
 ** \return None.
 ** \param [in] HwUnit        Id of HW unit.
 ** \param [in] EventStatus   Event status (passed or failed).
 **
 */
static FUNC( void, SPI_CODE ) Spi_Internal_EventHandler
(
  VAR( Spi_HWUnitType, AUTOMATIC ) HwUnit,
  VAR( uint8, AUTOMATIC ) EventStatus
)
{
  VAR( Spi_ReturnType, AUTOMATIC ) IsCurJobCompleted;
  VAR( Spi_JobType, AUTOMATIC ) CurJob;
  VAR( Spi_SequenceType, AUTOMATIC ) CurSequence;
  VAR( Spi_ChannelType, AUTOMATIC ) NextChannel = SPI_INVALID_CHANNEL;
  VAR( Spi_JobType, AUTOMATIC) NextJob;
  VAR( Spi_JobType, AUTOMATIC) CandiJob = SPI_INVALID_JOB;
  VAR( Spi_HWUnitType, AUTOMATIC ) NextHwUnit;
  P2CONST( Spi_SequenceConfigType, AUTOMATIC, AUTOMATIC ) SequenceConfigPtr;
  P2CONST( Spi_JobConfigType, AUTOMATIC, SPI_CONST ) JobConfigPtr;
  VAR( uint8, AUTOMATIC ) JobPrior;

  /* enter a critical section */
  Spi_Com_SchMEnterCriticalSection();

  /* get a current job in the relevant hwunit */
  CurJob = Spi_Info.DriverHwInfoListPtr[HwUnit].Job;
  JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurJob] );

  /* check if all channels are finished in the job */
  if (JobConfigPtr->ExternalDevicePtr->UseDma != SPI_FALSE)
  {
    /* DMA case */
    IsCurJobCompleted = Spi_Job_HandlerChannelFinishedDma(CurJob, EventStatus);
  }
  else
  {
    /* SCB case */
    IsCurJobCompleted = Spi_Job_HandlerChannelFinished( CurJob, EventStatus, &NextChannel );
  }
  
  if (IsCurJobCompleted != SPI_OK)
  { /* Not all channel finished */
    /* exit a critical section */
    Spi_Com_SchMExitCriticalSection();

    /* Start transmit next channel */
    Spi_Job_TransmitNextChannel( CurJob, NextChannel );

  }
  /* all channels are already finished */
  else
  {
    /* get a current sequence in the relevant hwunit */
    CurSequence = Spi_Info.DriverHwInfoListPtr[HwUnit].Sequence;

    /* check if all jobs are finished in the sequence */
    if ( Spi_Seq_HandlerJobFinished( CurSequence, EventStatus, &NextJob ) != SPI_OK )
    {
      /* get the relevant hwunit for next job */
      NextHwUnit = Spi_Current_ConfigPtr->JobConfigListPtr[NextJob].ExternalDevicePtr->HwUnit;

      /* check if current hwunit is different from next hwunit */
      if ( NextHwUnit != HwUnit )
      {
        /* check if next hwunit is not busy */
        if ( Spi_Info.HwInfoListPtr[NextHwUnit].Status == SPI_IDLE )
        {
          /* set hwunit status to busy */
          Spi_Hw_SetHwUnitStatus( NextHwUnit, SPI_BUSY );
          /* set a job result to pending */
          Spi_Info.JobInfoListPtr[NextJob].Result = SPI_JOB_PENDING;
          /* set a channel index to zero */
          Spi_Job_SetChannelIndex( NextJob, 0U, SPI_HW_FACTOR_SCB_TX_AND_RX );

          /* set a current job for the relevant hwunit */
          Spi_Info.DriverHwInfoListPtr[NextHwUnit].Job = NextJob;
          /* set a current sequence for the relevant hwunit */
          Spi_Com_SetCurrentSequence( NextHwUnit, CurSequence );

          /* finish the event for the relevant hwunit */
          Spi_Internal_TerminateEvent( HwUnit, &CandiJob );

          /* exit a critical section */
          Spi_Com_SchMExitCriticalSection();

          /* inform that job has been just finished */
          Spi_Internal_InformJobFinished( SPI_API_HANDLER, CurJob, EventStatus );

          /* start to transmit a first channel in the next job */
          Spi_Job_TransmitFirstChannel( NextJob );
        }
        /* next hwunit status is busy */
        else
        {
          /* finish the event for the relevant hwunit */
          Spi_Internal_TerminateEvent( HwUnit, &CandiJob );

          /* exit a critical section */
          Spi_Com_SchMExitCriticalSection();

          /* inform that job has been just finished */
          Spi_Internal_InformJobFinished( SPI_API_HANDLER, CurJob, EventStatus );
        }
      }
      /* at least one job is not finished yet
       * and a next job has same hwunit with a previous job */
      else
      {
        /* get configuration set for the relevant sequence */
        SequenceConfigPtr = &( Spi_Current_ConfigPtr->SequencesConfigListPtr[CurSequence] );
        /* get a priority of the relevant job */
        JobPrior = Spi_Current_ConfigPtr->JobConfigListPtr[NextJob].JobPriority;

        /* check if the next job is valid to be transmitted */
        if ( ( SequenceConfigPtr->InterruptibleSequence == SPI_FALSE )
          || ( JobPrior == 3U ) )
        {
          /* set a job result to pending */
          Spi_Info.JobInfoListPtr[NextJob].Result = SPI_JOB_PENDING;

          /* set a channel index to zero */
          Spi_Job_SetChannelIndex( NextJob, 0U, SPI_HW_FACTOR_SCB_TX_AND_RX );

          /* set a current job for the relevant hwunit */
          Spi_Info.DriverHwInfoListPtr[HwUnit].Job = NextJob;

          /* exit a critical section */
          Spi_Com_SchMExitCriticalSection();

          /* inform that job has been just finished */
          Spi_Internal_InformJobFinished( SPI_API_HANDLER, CurJob, EventStatus );

          /* start to transmit a first channel in the next job */
          Spi_Job_TransmitFirstChannel( NextJob );
        }
        /* a high prior job might be existed,
         * therefore it is checked here */
        else
        {
          /* at least one job is not transmitted yet if code reaches here,
           * therefore it is necessary to find next job */
          /* the job is checked in an internal function */

          /* finish the event for the relevant hwunit */
          Spi_Internal_TerminateEvent( HwUnit, &CandiJob );

          /* exit a critical section */
          Spi_Com_SchMExitCriticalSection();

          /* inform that job has been just finished */
          Spi_Internal_InformJobFinished( SPI_API_HANDLER, CurJob, EventStatus );
        }
      }
    }
    /* all jobs are already finished */
    else
    {
      /* remove the current sequence from a queue */
      Spi_Que_Dequeue( CurSequence );

      /* set all job queued status in the sequence */
      Spi_Seq_SetAllJobIsQueued( CurSequence, SPI_FALSE );

      /* finish the event for the relevant hwunit */
      Spi_Internal_TerminateEvent( HwUnit, &CandiJob );

      /* exit a critical section */
      Spi_Com_SchMExitCriticalSection();

      /* inform that job has been just finished */
      Spi_Internal_InformJobFinished( SPI_API_HANDLER, CurJob, EventStatus );

      /* get configuration set for the relevant sequence */
      SequenceConfigPtr = &( Spi_Current_ConfigPtr->SequencesConfigListPtr[CurSequence] );

      /* check if sequence end notification is enabled */
      if ( SequenceConfigPtr->SeqEndNotification != NULL_PTR )
      {
        /* call a notification for the relevant sequence */
        SequenceConfigPtr->SeqEndNotification();
      }
    }
  }

  /* check if a found job is valid */
  if ( CandiJob != SPI_INVALID_JOB )
  {
    /* start to transmit a first channel in the next job */
    Spi_Job_TransmitFirstChannel( CandiJob );
  }
}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[end of file]===========================================*/
