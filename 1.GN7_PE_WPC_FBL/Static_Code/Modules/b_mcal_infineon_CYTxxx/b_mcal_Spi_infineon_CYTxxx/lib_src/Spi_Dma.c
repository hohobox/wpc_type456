/** \brief AUTOSAR SPI Driver
 **
 ** This file contains implementation of the DMA functions for Spi module.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Spi_Dma.h>
#include <Spi_Common.h>
#include <Spi_Common_Der.h>
#include <Spi_Internal.h>
#include <Spi_Job.h>
#include <Spi_Channel.h>
#include <Spi_Hw.h>


/*==================[macros]================================================*/
/*****************************/
/* Bit mask value for DMA_DESC CTL register */
/* \brief DATA_SIZE bit */
#define SPI_DMA_DESC_CTL_DATA_SIZE_BYTE         ((uint32)(((uint32)0x0UL) << 28U))
#define SPI_DMA_DESC_CTL_DATA_SIZE_HALFWORD     ((uint32)(((uint32)0x1UL) << 28U))
#define SPI_DMA_DESC_CTL_DATA_SIZE_WORD         ((uint32)(((uint32)0x2UL) << 28U))

/*****************************/
/* Bitvalue for DMA CH_CTL register */
/* \brief ENABLED bit */
#define SPI_DMA_CH_CTL_DISABLED       (0x0U)
#define SPI_DMA_CH_CTL_ENABLED        (0x1U)

/*****************************/
/* Set Value of DMA Channel register */
/* CH_CTL register */
/*   P=0, NS=1, B=0, PC=0, PRIO=0, PREEMPTABLE=0, ENABLED=0 */
#define SPI_DMA_CH_CTL_INIT     ( (uint32)0x00000002U)
#define SPI_DMA_CH_CTL_UNINIT   SPI_DMA_CH_CTL_INIT
/* CH_CURR_PTR register */
#define SPI_DMA_CH_CURR_PTR_INIT    ( (uint32)0x00000000U)
#define SPI_DMA_CH_CURR_PTR_UNINIT  SPI_DMA_CH_CURR_PTR_INIT
/* CH_INTR register */
#define SPI_DMA_INTR_INIT    ( (uint32)0x00000001U)
#define SPI_DMA_INTR_UNINIT  SPI_DMA_INTR_INIT
/* CH_INTR_MASK register */
#define SPI_DMA_INTR_MASK_INIT    ( (uint32)0x00000000U)
#define SPI_DMA_INTR_MASK_UNINIT  SPI_DMA_INTR_MASK_INIT

/*****************************/
/* Set Value of DMA Descriptor register */
/* DESCR_CTL register */
/*   WAIT_FOR_DEACT=0, INTR_TYPE=3, TR_OUT_TYPE=0, 
     TR_IN_TYPE=0, CH_DISABLE=0, SRC_TRANSFER_SIZE=0,
     DST_TRANSFER_SIZE=1, DATA_SIZE=0, DESCR_TYPE=1 
*/
#define SPI_DMA_TX_DESCR_CTL_INIT   ((uint32)0x4800000CU)
#define SPI_DMA_TX_DESCR_CTL_UNINIT (SPI_DMA_TX_DESCR_CTL_INIT)

/* Set Value of DMA Descriptor register */
/* DESCR_CTL register */
/*   WAIT_FOR_DEACT=0, INTR_TYPE=3, TR_OUT_TYPE=0, 
     TR_IN_TYPE=0, CH_DISABLE=0, SRC_TRANSFER_SIZE=1,
     DST_TRANSFER_SIZE=0, DATA_SIZE=0, DESCR_TYPE=1 
*/
#define SPI_DMA_RX_DESCR_CTL_INIT   ((uint32)0x4400000CU)
#define SPI_DMA_RX_DESCR_CTL_UNINIT (SPI_DMA_RX_DESCR_CTL_INIT)

/* DESCR_CTL register */
/*   WAIT_FOR_DEACT=0, INTR_TYPE=3, TR_OUT_TYPE=0, 
     TR_IN_TYPE=0, CH_DISABLE=0, SRC_TRANSFER_SIZE=0,
     DST_TRANSFER_SIZE=1, DATA_SIZE=0, DESCR_TYPE=2
*/
#define SPI_DMA_TX_DESCR_CTL2_INIT    ((uint32)0x8800000CU)
#define SPI_DMA_TX_DESCR_CTL2_UNINIT  (SPI_DMA_TX_DESCR_CTL2_INIT)

/* DESCR_CTL register */
/*   WAIT_FOR_DEACT=0, INTR_TYPE=3, TR_OUT_TYPE=0, 
     TR_IN_TYPE=0, CH_DISABLE=0, SRC_TRANSFER_SIZE=1,
     DST_TRANSFER_SIZE=0, DATA_SIZE=0, DESCR_TYPE=2
*/
#define SPI_DMA_RX_DESCR_CTL2_INIT    ((uint32)0x8400000CU)
#define SPI_DMA_RX_DESCR_CTL2_UNINIT  (SPI_DMA_RX_DESCR_CTL2_INIT)

/* DESCR_SRC register */
#define SPI_DMA_DESCR_SRC_INIT    ( (uint32)0x00000000U)
#define SPI_DMA_DESCR_SRC_UNINIT  SPI_DMA_DESCR_SRC_INIT
/* DESCR_DST register */
#define SPI_DMA_DESCR_DST_INIT    ( (uint32)0x00000000U)
#define SPI_DMA_DESCR_DST_UNINIT  SPI_DMA_DESCR_DST_INIT
/*  DECR_X_CTL Register */
/*    SRC_X_INCR=0, DSTX_X_INCR=0, X_COUNT=0 */
#define SPI_DMA_DESCR_X_CTL_INIT   ( (uint32)0x00000000U)
#define SPI_DMA_DESCR_X_CTL_UNINIT SPI_DMA_DESCR_X_CTL_INIT
/*  DECR_Y_CTL Register */
/*    SRC_Y_INCR=0, DST_Y_INCR=0, Y_COUNT=0 */
#define SPI_DMA_DESCR_Y_CTL_INIT   ( (uint32)0x00000000U)
#define SPI_DMA_DESCR_Y_CTL_UNINIT SPI_DMA_DESCR_Y_CTL_INIT
/*  DESCR_NEXT_PTR Register */
#define SPI_DMA_DESCR_NEXT_PTR_INIT   ( (uint32)0x00000000U)
#define SPI_DMA_DESCR_NEXT_PTR_UNINIT SPI_DMA_DESCR_NEXT_PTR_INIT
/* Maximum transfer count per 1D */
#define SPI_DMA_1D_TRANSFER_COUNT_MAX (256U)

/*****************************/

/*****************************/

/*****************************/

/*****************************/

/*==================[type definitions]======================================*/

/** \brief struct Spi_DmaDescriptorConfigType
 **
 ** Specifies the configuration for an DMA descriptor
 */
typedef struct spi_dma_descriptor_config_struct
{
  /* Tx source buffer top address */
  VAR(uint32, AUTOMATIC) TxSrcAddress;
  /* Tx source buffer address for fraction 1D transfer */
  VAR(uint32, AUTOMATIC) TxSrcAddressFrac;
  /* Rx destination buffer top address */
  VAR(uint32, AUTOMATIC) RxDstAddress;
  /* Rx destination buffer address for fraction 1D transfer */
  VAR(uint32, AUTOMATIC) RxDstAddressFrac;
  /* Tx source X increment width */
  VAR(uint16, AUTOMATIC) TxXIncr;
  /* Tx source Y increment width */
  VAR(uint16, AUTOMATIC) TxYIncr;
  /* Rx destination X increment width */
  VAR(uint16, AUTOMATIC) RxXIncr;
  /* Rx destination Y increment width */
  VAR(uint16, AUTOMATIC) RxYIncr;
  /* Number of transfer count for 2D transfer X loop */
  VAR(uint16, AUTOMATIC) XCount;
  /* Number of transfer count for 2D transfer Y loop */
  VAR(uint16, AUTOMATIC) YCount;
  /* Number of transfer count for fraction 1D transfer */
  VAR(uint16, AUTOMATIC) XCountFrac;
  /* Need to use 1D transfer or not */
  VAR(boolean, AUTOMATIC) Use1DTransfer;
} Spi_DmaDescriptorConfigType;

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Dma_ConstructDescriptorConfig
 **
 ** Construct descriptor configuration.
 **
 ** \return None.
 ** \param [in] Channel
 **                 Channel ID
 ** \param [in] SrcDataBufferPtr
 **                 Pointer to source data buffer
 ** \param [in] DesDataBufferPtr
 **                 Pointer to destination data buffer in RAM
 ** \param [in] Length
 *                  Length (in number of data elements) of the data to be  
 **                 transmitted from SrcdataBufferPtr and/or received 
 **                 from DesDataBufferPtr.
 **                   Min.: 1
 **                   Max.: Maximum of data specified at configuration
 **                         for this channel **
 ** \param [out] DmaDescConfig
 **                 Output data structure pointer.
 */
static FUNC(void, SPI_CODE) Spi_Dma_ConstructDescriptorConfig
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length,
  P2VAR(Spi_DmaDescriptorConfigType, AUTOMATIC, AUTOMATIC) DmaDescConfig
);

/** \brief Spi_Dma_SetDescriptor
 **
 ** Set constructed configuration into descriptors.
 **
 ** \return None.
 ** \param [in] Channel
 **                 Channel ID
 ** \param [in] DmaDescConfig
 **                 Configuration data structure pointer.
 */
static FUNC(void, SPI_CODE) Spi_Dma_SetDescriptor
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST(Spi_DmaDescriptorConfigType, AUTOMATIC, AUTOMATIC) DmaDescConfig
);

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

#define SPI_START_SEC_VAR_NO_INIT_ASIL_B_32
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Dma_RxIgnore
 **
 ** The address of this variable is used as DMA transfer destination when
 ** received values ought to be ignored for a channel. This way, DMA interrupt
 ** handling is independent of channel buffer configuration.
 ** */
/* Deviation from MISRA-C:2004 Rule 8.7, MISRA-C:2012 Rule-8.9.
   Justification: Allow memory mapping (Spi_MemMap). */
/* PRQA S 3218 1 */
static VAR(uint32, AUTOMATIC) Spi_Dma_RxIgnore;

#define SPI_STOP_SEC_VAR_NO_INIT_ASIL_B_32
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external function definitions]=========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Dma_CheckFinishedHwUnit
 **
 ** Checks whether the transmission of DMA is finished or not.
 **
 ** \return SPI_OK:     Transmission has been finished.
 **         SPI_NOT_OK: Transmission has not been finished.
 **         SPI_FAILED: Detected an error.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
FUNC(uint8, SPI_CODE) Spi_Dma_CheckFinishedHwUnit
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  VAR(uint8, AUTOMATIC) RetVal = SPI_NOT_OK; /* return value */
  
  if ( Factor != SPI_HW_FACTOR_DMA_ERROR )
  {
    /* get DMA register address  */
    volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelPtr =
        Spi_Com_GetDmaChannelRegPtr( HwUnit, Factor );
    
    /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
       Justification: This union type is used for accessing to register. */
    /* PRQA S 759 1 */
    VAR(Spi_un_Dw1_Ch_Status_Type, AUTOMATIC) TempDmaChanneCH_STATUS;

    TempDmaChanneCH_STATUS.u32Register = DmaChannelPtr->unCH_STATUS.u32Register;
    
    if ( DmaChannelPtr->unINTR.u32Register != 0x0U)
    {
      /* checks error flag */
      if ( (TempDmaChanneCH_STATUS.stcField.u4INTR_CAUSE >= SPI_DMA_INTR_CAUSE_DESCR_BUS_ERROR)
        || ( (TempDmaChanneCH_STATUS.stcField.u4INTR_CAUSE >= SPI_DMA_INTR_CAUSE_SRC_BUS_ERROR)
          && (TempDmaChanneCH_STATUS.stcField.u4INTR_CAUSE <= SPI_DMA_INTR_CAUSE_DST_MISAL) ) )
      {
        /* detect HW error */
        RetVal = SPI_FAILED;
      }
      /* checks transfer complete flag */
      else if ( TempDmaChanneCH_STATUS.stcField.u4INTR_CAUSE == SPI_DMA_INTR_CAUSE_COMPLETION )
      {
        RetVal = SPI_OK;
      }
      else
      { /* Do nothing. RetVal has been already initialized with SPI_NOT_OK, */
        ;
      }
    }
  }
  else
  {
    /* get DMA register address for Rx  */
    volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelRxPtr =
        Spi_Com_GetDmaChannelRegPtr( HwUnit, SPI_HW_FACTOR_DMA_RX );
    /* get DMA register address for Tx  */
    volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelTxPtr =
        Spi_Com_GetDmaChannelRegPtr( HwUnit, SPI_HW_FACTOR_DMA_TX );
    
    /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
       Justification: This union type is used for accessing to register. */
    /* PRQA S 759 1 */
    Spi_un_Dw1_Ch_Status_Type TempDmaChannelRxCH_STATUS;
    /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
       Justification: This union type is used for accessing to register. */
    /* PRQA S 759 1 */
    Spi_un_Dw1_Ch_Status_Type TempDmaChannelTxCH_STATUS;
    
    if ( DmaChannelRxPtr->unINTR.u32Register != 0x0U)
    {
      TempDmaChannelRxCH_STATUS.u32Register = DmaChannelRxPtr->unCH_STATUS.u32Register;

      /* checks error flag */
      if ( (TempDmaChannelRxCH_STATUS.stcField.u4INTR_CAUSE >= SPI_DMA_INTR_CAUSE_DESCR_BUS_ERROR)
        || ( (TempDmaChannelRxCH_STATUS.stcField.u4INTR_CAUSE >= SPI_DMA_INTR_CAUSE_SRC_BUS_ERROR)
          && (TempDmaChannelRxCH_STATUS.stcField.u4INTR_CAUSE <= SPI_DMA_INTR_CAUSE_DST_MISAL) ) )
      {
        /* detect HW error */
        RetVal = SPI_FAILED;
      }
    }
    if ( DmaChannelTxPtr->unINTR.u32Register != 0x0U)
    {
      TempDmaChannelTxCH_STATUS.u32Register = DmaChannelTxPtr->unCH_STATUS.u32Register;
    
      if ( (TempDmaChannelTxCH_STATUS.stcField.u4INTR_CAUSE >= SPI_DMA_INTR_CAUSE_DESCR_BUS_ERROR)
        || ( (TempDmaChannelTxCH_STATUS.stcField.u4INTR_CAUSE >= SPI_DMA_INTR_CAUSE_SRC_BUS_ERROR)
          && (TempDmaChannelTxCH_STATUS.stcField.u4INTR_CAUSE <= SPI_DMA_INTR_CAUSE_DST_MISAL) ) )
      {
        /* detect HW error */
        RetVal = SPI_FAILED;
      }
    }
  }
  return RetVal;
}

/** \brief Spi_Dma_SetupHwUnit
 **
 ** Sets the DMA unit to start transmission.
 **
 ** \return None.
 ** \param [in] Job      Id of Job.
 **
 */
FUNC(void, SPI_CODE) Spi_Dma_SetupHwUnit
(
  VAR(Spi_JobType, AUTOMATIC) Job
) 
{
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  /* get channel register address */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaRxChannelPtr = 
    Spi_Com_GetDmaChannelRegPtr( JobConfigPtr->ExternalDevicePtr->HwUnit, SPI_HW_FACTOR_DMA_RX  );
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaTxChannelPtr = 
    Spi_Com_GetDmaChannelRegPtr( JobConfigPtr->ExternalDevicePtr->HwUnit, SPI_HW_FACTOR_DMA_TX  );
    
  /* For setup DMA channel */
  /* Initialize DMA A register with hardware defaults and reserved values. */
  /* Disable the DMA channel . */
  DmaRxChannelPtr->unCH_CTL.u32Register = SPI_DMA_CH_CTL_INIT;
  DmaTxChannelPtr->unCH_CTL.u32Register = SPI_DMA_CH_CTL_INIT;

  /* Clear the flag bits indicating a DMA transfer interrupts. */
  DmaRxChannelPtr->unINTR.u32Register = SPI_DMA_INTR_INIT;
  DmaTxChannelPtr->unINTR.u32Register = SPI_DMA_INTR_INIT;
  (void)DmaRxChannelPtr->unINTR.u32Register;
  
  /* Set the interrupt mask of DMA channel. */
  DmaRxChannelPtr->unINTR_MASK.u32Register = SPI_DMA_INTR_MASK_INIT;
  DmaTxChannelPtr->unINTR_MASK.u32Register = SPI_DMA_INTR_MASK_INIT;

  /* Set the CH_CURR_PTR. */
  /* Deviation from MISRA-C:2004 Rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4.
     Justification: This implementation is needed for calculating
     address. */
  /* PRQA S 303,491 4 */
  DmaRxChannelPtr->CH_CURR_PTR
    = (uint32)&(JobConfigPtr->DmaRxDescriptorRegsPtr[0].unDESCR_CTL2);
  DmaTxChannelPtr->CH_CURR_PTR
    = (uint32)&(JobConfigPtr->DmaTxDescriptorRegsPtr[0].unDESCR_CTL2);

  /* Clear CH_IDX */
  DmaRxChannelPtr->unCH_IDX.u32Register = 0U;
  DmaTxChannelPtr->unCH_IDX.u32Register = 0U;
}

/** \brief Spi_Dma_StartHwUnit
 **
 ** Starts the DMA transfer.
 **
 ** \return None.
 ** \param [in] HwUnit               Id of HW unit.
 ** \param [in] InterruptEnable      Flag of interrupt enable
 **
 */
FUNC(void, SPI_CODE) Spi_Dma_StartHwUnit
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(boolean, AUTOMATIC) InterruptEnable
)
{
  /* get channel register address */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelRxPtr =
      Spi_Com_GetDmaChannelRegPtr( HwUnit, SPI_HW_FACTOR_DMA_RX );
  /* get channel register address */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelTxPtr =
      Spi_Com_GetDmaChannelRegPtr( HwUnit, SPI_HW_FACTOR_DMA_TX );
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR( Spi_un_Dw1_Ch_Ctl_Type, AUTOMATIC ) TempRxDmaChannelChCtl;
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR( Spi_un_Dw1_Ch_Ctl_Type, AUTOMATIC ) TempTxDmaChannelChCtl;

  /* Clear Interrupt */
  DmaChannelRxPtr->unINTR.u32Register = STD_HIGH;
  (void)DmaChannelRxPtr->unINTR.u32Register;
  DmaChannelTxPtr->unINTR.u32Register = STD_HIGH;
  (void)DmaChannelTxPtr->unINTR.u32Register;
  /* Enable DMA channels for RX and TX: */
  
  if ( InterruptEnable == SPI_TRUE )
  {
    /* Enable the completion interrupt of the DMA RX channel. */
    /* Enable the error interrupt of the DMA RX channel. */
    DmaChannelRxPtr->unINTR_MASK.u32Register = STD_HIGH;

    /* Enable the completion interrupt of the DMA TX channel. */
    /* Enable the error interrupt of the DMA TX channel. */
    DmaChannelTxPtr->unINTR_MASK.u32Register = STD_HIGH;
  }
  else
  {
    /* Disable all interrupt of the DMA RX channel. */
    DmaChannelRxPtr->unINTR_MASK.u32Register = STD_LOW;
    /* Disable all interrupt of the DMA TX channel. */
    DmaChannelTxPtr->unINTR_MASK.u32Register = STD_LOW;
  }
  /* Enable the DMA RX and TX channel. */
  TempRxDmaChannelChCtl.u32Register = DmaChannelRxPtr->unCH_CTL.u32Register;
  TempTxDmaChannelChCtl.u32Register = DmaChannelTxPtr->unCH_CTL.u32Register;
  TempRxDmaChannelChCtl.stcField.u1ENABLED = STD_HIGH;
  TempTxDmaChannelChCtl.stcField.u1ENABLED = STD_HIGH;
  DmaChannelRxPtr->unCH_CTL.u32Register = TempRxDmaChannelChCtl.u32Register;
  DmaChannelTxPtr->unCH_CTL.u32Register = TempTxDmaChannelChCtl.u32Register;
}

/** \brief Spi_Dma_StopHwUnit
 **
 ** Sets the DMA unit to stop transmission.
 **
 ** \return None.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
FUNC(void, SPI_CODE) Spi_Dma_StopHwUnit
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* get channel register address */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelPtr = 
      Spi_Com_GetDmaChannelRegPtr( HwUnit, Factor );
  
  /* Temporally variable for DMA CH_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR( Spi_un_Dw1_Ch_Ctl_Type, AUTOMATIC ) TempDmaChannelChCtlr;

  /* Disable the DMA channel. */
  TempDmaChannelChCtlr.u32Register = DmaChannelPtr->unCH_CTL.u32Register;
  TempDmaChannelChCtlr.stcField.u1ENABLED = STD_LOW;
  DmaChannelPtr->unCH_CTL.u32Register = TempDmaChannelChCtlr.u32Register;
  
  /* Clear DMA Interrupt factor */
  DmaChannelPtr->unINTR.u32Register = STD_HIGH;
  (void)DmaChannelPtr->unINTR.u32Register;

  /* Disable DMA Channel interrupt */
  DmaChannelPtr->unINTR_MASK.u32Register = STD_LOW;
}

/** \brief Spi_Dma_DeInit
 **
 ** De-initializes the DMA channel.
 **
 ** \return None.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
FUNC(void, SPI_CODE) Spi_Dma_DeInit
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* get channel register address */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelPtr
   = Spi_Com_GetDmaChannelRegPtr( HwUnit, Factor );

  if ( DmaChannelPtr != NULL_PTR )
  {
    /* Un initialize the DMA CH_CTL. */
    DmaChannelPtr->unCH_CTL.u32Register = SPI_DMA_CH_CTL_UNINIT;
    /* Un initialize the DMA CH_CURRENT_PTR. */
    DmaChannelPtr->CH_CURR_PTR = SPI_DMA_CH_CURR_PTR_UNINIT;
    /* Un initialize the DMA INTR.  */
    DmaChannelPtr->unINTR.u32Register = SPI_DMA_INTR_UNINIT;
    (void)DmaChannelPtr->unINTR.u32Register;
    /* Un initialize the DMA INTR_MASK.  */
    DmaChannelPtr->unINTR_MASK.u32Register = SPI_DMA_INTR_MASK_UNINIT;
  }
}

/** \brief Spi_Dma_DeInitDescriptor
 **
 ** De-initializes the DMA Descriptor.
 **
 ** \return None.
 ** \param [in] Job      Id of Job.
 **
 */
FUNC(void, SPI_CODE) Spi_Dma_DeInitDescriptor
(
  VAR(Spi_JobType, AUTOMATIC) Job
)
{
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  VAR(Spi_ChannelIndexType, TYPEDEF) Index;

  P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT) CurDmaRxDescriptorRegsPtr;
  P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT) CurDmaTxDescriptorRegsPtr;

  for( Index = 0U; Index < JobConfigPtr->ChannelCount; Index++)
  {
    CurDmaRxDescriptorRegsPtr =
    (P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT))&(JobConfigPtr->DmaRxDescriptorRegsPtr[Index]);
    CurDmaTxDescriptorRegsPtr =
    (P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT))&(JobConfigPtr->DmaTxDescriptorRegsPtr[Index]);

    /* Rx descriptor */
    CurDmaRxDescriptorRegsPtr->unDESCR_CTL.u32Register = SPI_DMA_RX_DESCR_CTL_UNINIT;
    CurDmaRxDescriptorRegsPtr->DESCR_SRC = SPI_DMA_DESCR_SRC_UNINIT;
    CurDmaRxDescriptorRegsPtr->DESCR_DST = SPI_DMA_DESCR_DST_UNINIT;
    CurDmaRxDescriptorRegsPtr->unDESCR_X_CTL.u32Register = SPI_DMA_DESCR_X_CTL_UNINIT;
    CurDmaRxDescriptorRegsPtr->DESCR_NEXT_PTR = SPI_DMA_DESCR_NEXT_PTR_UNINIT;
    CurDmaRxDescriptorRegsPtr->unDESCR_CTL2.u32Register = SPI_DMA_RX_DESCR_CTL2_UNINIT;
    CurDmaRxDescriptorRegsPtr->DESCR_SRC2 = SPI_DMA_DESCR_SRC_UNINIT;
    CurDmaRxDescriptorRegsPtr->DESCR_DST2 = SPI_DMA_DESCR_DST_UNINIT;
    CurDmaRxDescriptorRegsPtr->unDESCR_X_CTL2.u32Register = SPI_DMA_DESCR_X_CTL_UNINIT;
    CurDmaRxDescriptorRegsPtr->unDESCR_Y_CTL2.u32Register = SPI_DMA_DESCR_Y_CTL_UNINIT;
    CurDmaRxDescriptorRegsPtr->DESCR_NEXT_PTR2 = SPI_DMA_DESCR_NEXT_PTR_UNINIT;
    /* Tx descriptor */
    CurDmaTxDescriptorRegsPtr->unDESCR_CTL.u32Register = SPI_DMA_TX_DESCR_CTL_UNINIT;
    CurDmaTxDescriptorRegsPtr->DESCR_SRC = SPI_DMA_DESCR_SRC_UNINIT;
    CurDmaTxDescriptorRegsPtr->DESCR_DST = SPI_DMA_DESCR_DST_UNINIT;
    CurDmaTxDescriptorRegsPtr->unDESCR_X_CTL.u32Register = SPI_DMA_DESCR_X_CTL_UNINIT;
    CurDmaTxDescriptorRegsPtr->DESCR_NEXT_PTR = SPI_DMA_DESCR_NEXT_PTR_UNINIT;
    CurDmaTxDescriptorRegsPtr->unDESCR_CTL2.u32Register = SPI_DMA_TX_DESCR_CTL2_UNINIT;
    CurDmaTxDescriptorRegsPtr->DESCR_SRC2 = SPI_DMA_DESCR_SRC_UNINIT;
    CurDmaTxDescriptorRegsPtr->DESCR_DST2 = SPI_DMA_DESCR_DST_UNINIT;
    CurDmaTxDescriptorRegsPtr->unDESCR_X_CTL2.u32Register = SPI_DMA_DESCR_X_CTL_UNINIT;
    CurDmaTxDescriptorRegsPtr->unDESCR_Y_CTL2.u32Register = SPI_DMA_DESCR_Y_CTL_UNINIT;
    CurDmaTxDescriptorRegsPtr->DESCR_NEXT_PTR2 = SPI_DMA_DESCR_NEXT_PTR_UNINIT;
  }
}

/** \brief Spi_Dma_Init
 **
 ** Initializes the DMA channel.
 **
 ** \return None.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
FUNC(void, SPI_CODE) Spi_Dma_Init
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* get channel register address */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) DmaChannelPtr
   = Spi_Com_GetDmaChannelRegPtr( HwUnit, Factor );

  if ( DmaChannelPtr != NULL_PTR )
  {
    /* Un initialize the DMA CH_CTL. */
    DmaChannelPtr->unCH_CTL.u32Register = SPI_DMA_CH_CTL_INIT;
    /* Un initialize the DMA CH_CURRENT_PTR. */
    DmaChannelPtr->CH_CURR_PTR = SPI_DMA_CH_CURR_PTR_INIT;
    /* Un initialize the DMA INTR.  */
    DmaChannelPtr->unINTR.u32Register = SPI_DMA_INTR_INIT;
    (void)DmaChannelPtr->unINTR.u32Register;
    /* Un initialize the DMA INTR_MASK.  */
    DmaChannelPtr->unINTR_MASK.u32Register = SPI_DMA_INTR_MASK_INIT;
  }
}

/** \brief Spi_Dma_InitDescriptor
 **
 ** Initialize descriptor for job.
 **
 ** \return None.
 ** \param [in] Job Id of Job.
 ** \note Descriptors that is associated to IB will be updated in Spi_Chan_InitAllChannels().
 */
FUNC(void, SPI_CODE) Spi_Dma_InitDescriptor
(
  VAR(Spi_JobType, AUTOMATIC) Job
)
{
  /* Pointer to JobConfig */
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr = &(Spi_Current_ConfigPtr->JobConfigListPtr[Job]);
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr 
    = Spi_Current_ConfigPtr->ScbRegsPtr[JobConfigPtr->ExternalDevicePtr->HwUnit];
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr;
  VAR(Spi_ChannelType, AUTOMATIC) CurChannel;
  VAR(Spi_ChannelIndexType, AUTOMATIC) Index;
  VAR(uint32, AUTOMATIC) RxBufferAddress;
  VAR(uint32, AUTOMATIC) TxBufferAddress;
  VAR(uint32, AUTOMATIC) TxCtlInitval;
  VAR(uint32, AUTOMATIC) TxCtl2Initval;
  VAR(uint32, AUTOMATIC) RxCtlInitval;
  VAR(uint32, AUTOMATIC) RxCtl2Initval;

  P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT) CurDmaRxDescriptorRegsPtr;
  P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT) CurDmaTxDescriptorRegsPtr;

  /* Deviation from MISRA-C:2004 Rule 3.1, MISRA-C:2012 Rule-11.4, Rule-11.6.
     Justification: Implementation often uses pointer access by 
     array-subscripting. */
  /* PRQA S 306 1 */
  RxBufferAddress = (uint32)&Spi_Dma_RxIgnore;
    
  for( Index = 0U; Index < JobConfigPtr->ChannelCount; Index++)
  {
    CurChannel = JobConfigPtr->ChannelListPtr[Index];
    ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[CurChannel] );
    CurDmaRxDescriptorRegsPtr =
    (P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT))&(JobConfigPtr->DmaRxDescriptorRegsPtr[Index]);
    CurDmaTxDescriptorRegsPtr =
    (P2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT))&(JobConfigPtr->DmaTxDescriptorRegsPtr[Index]);

    /* Update DATA_SIZE field */
    switch (ChannelConfigPtr->DataWidth)
    {
      case SPI_BYTESIZE_8BIT:
        RxCtlInitval  = SPI_DMA_RX_DESCR_CTL_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_BYTE;
        RxCtl2Initval = SPI_DMA_RX_DESCR_CTL2_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_BYTE;
        TxCtlInitval  = SPI_DMA_TX_DESCR_CTL_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_BYTE;
        TxCtl2Initval = SPI_DMA_TX_DESCR_CTL2_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_BYTE;
        break;
      case SPI_BYTESIZE_16BIT:
        RxCtlInitval  = SPI_DMA_RX_DESCR_CTL_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_HALFWORD;
        RxCtl2Initval = SPI_DMA_RX_DESCR_CTL2_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_HALFWORD;
        TxCtlInitval  = SPI_DMA_TX_DESCR_CTL_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_HALFWORD;
        TxCtl2Initval = SPI_DMA_TX_DESCR_CTL2_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_HALFWORD;
        break;
      default:
        RxCtlInitval  = SPI_DMA_RX_DESCR_CTL_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_WORD;
        RxCtl2Initval = SPI_DMA_RX_DESCR_CTL2_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_WORD;
        TxCtlInitval  = SPI_DMA_TX_DESCR_CTL_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_WORD;
        TxCtl2Initval = SPI_DMA_TX_DESCR_CTL2_INIT | SPI_DMA_DESC_CTL_DATA_SIZE_WORD;
        break;
    }

    /* RX Descriptor */
    CurDmaRxDescriptorRegsPtr->unDESCR_CTL.u32Register = RxCtlInitval;
    CurDmaRxDescriptorRegsPtr->unDESCR_CTL2.u32Register = RxCtl2Initval;
    /* Deviation from MISRA-C:2004 Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
       Justification: Cast between volatile pointer and integer is necessary
       for calculating address. */
    /* PRQA S 303 2 */
    CurDmaRxDescriptorRegsPtr->DESCR_SRC = (uint32)&(CurScbPtr->RX_FIFO_RD);
    CurDmaRxDescriptorRegsPtr->DESCR_SRC2 = (uint32)&(CurScbPtr->RX_FIFO_RD);
    CurDmaRxDescriptorRegsPtr->DESCR_DST = RxBufferAddress;
    CurDmaRxDescriptorRegsPtr->DESCR_DST2 = RxBufferAddress;
    CurDmaRxDescriptorRegsPtr->unDESCR_X_CTL.u32Register = SPI_DMA_DESCR_X_CTL_INIT;
    CurDmaRxDescriptorRegsPtr->unDESCR_X_CTL2.u32Register = SPI_DMA_DESCR_X_CTL_INIT;
    CurDmaRxDescriptorRegsPtr->unDESCR_Y_CTL2.u32Register = SPI_DMA_DESCR_Y_CTL_INIT;

    /* TX Descriptor */
    CurDmaTxDescriptorRegsPtr->unDESCR_CTL.u32Register = TxCtlInitval;
    CurDmaTxDescriptorRegsPtr->unDESCR_CTL2.u32Register = TxCtl2Initval;
    /* Deviation from MISRA-C:2004 Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
       Justification: Cast between volatile pointer and integer is necessary
       for calculating address. */
    /* PRQA S 303 2 */
    CurDmaTxDescriptorRegsPtr->DESCR_DST = (uint32)&(CurScbPtr->TX_FIFO_WR);
    CurDmaTxDescriptorRegsPtr->DESCR_DST2 = (uint32)&(CurScbPtr->TX_FIFO_WR);
    /* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: Cast between pointer and integer is necessary for 
       hardware access. */
    /* PRQA S 306 1 */
    TxBufferAddress = (uint32)&(ChannelConfigPtr->DefaultData);
    CurDmaTxDescriptorRegsPtr->DESCR_SRC = TxBufferAddress;
    CurDmaTxDescriptorRegsPtr->DESCR_SRC2 = TxBufferAddress;
    CurDmaTxDescriptorRegsPtr->unDESCR_X_CTL.u32Register = SPI_DMA_DESCR_X_CTL_INIT;
    CurDmaTxDescriptorRegsPtr->unDESCR_X_CTL2.u32Register = SPI_DMA_DESCR_X_CTL_INIT;
    CurDmaTxDescriptorRegsPtr->unDESCR_Y_CTL2.u32Register = SPI_DMA_DESCR_Y_CTL_INIT;

    /* Setup descriptor chain */
    if( Index >= (JobConfigPtr->ChannelCount - 1U))
    {
      /* Last channel */
      /* RX Descriptor */
      CurDmaRxDescriptorRegsPtr->unDESCR_CTL2.stcField.u1CH_DISABLE = 1U;
      CurDmaRxDescriptorRegsPtr->unDESCR_CTL.stcField.u1CH_DISABLE = 1U;
      CurDmaRxDescriptorRegsPtr->DESCR_NEXT_PTR2 = 0U;
      CurDmaRxDescriptorRegsPtr->DESCR_NEXT_PTR = 0U;

      /* TX Descriptor */
      CurDmaTxDescriptorRegsPtr->unDESCR_CTL2.stcField.u1CH_DISABLE = 1U;
      CurDmaTxDescriptorRegsPtr->unDESCR_CTL.stcField.u1CH_DISABLE = 1U;
      CurDmaTxDescriptorRegsPtr->DESCR_NEXT_PTR2 = 0U;
      CurDmaTxDescriptorRegsPtr->DESCR_NEXT_PTR = 0U;
    }
    else
    {
      /* RX Descriptor */
      /* Deviation from MISRA-C:2004 Rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4.
         Justification: This implementation is needed for calculating
         address. */
      /* PRQA S 303,491 4 */
      CurDmaRxDescriptorRegsPtr->DESCR_NEXT_PTR2 
        = (uint32)&(JobConfigPtr->DmaRxDescriptorRegsPtr[Index + 1U].unDESCR_CTL2);
      CurDmaRxDescriptorRegsPtr->DESCR_NEXT_PTR 
        = (uint32)&(JobConfigPtr->DmaRxDescriptorRegsPtr[Index + 1U].unDESCR_CTL2);

      /* TX Descriptor */
      /* Deviation from MISRA-C:2004 Rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4.
         Justification: This implementation is needed for calculating
         address. */
      /* PRQA S 303,491 4 */
      CurDmaTxDescriptorRegsPtr->DESCR_NEXT_PTR2 
        = (uint32)&(JobConfigPtr->DmaTxDescriptorRegsPtr[Index + 1U].unDESCR_CTL2);
      CurDmaTxDescriptorRegsPtr->DESCR_NEXT_PTR 
        = (uint32)&(JobConfigPtr->DmaTxDescriptorRegsPtr[Index + 1U].unDESCR_CTL2);
    }
  }
}

/** \brief Spi_Dma_UpdateDescriptor
 **
 ** Update descriptor for channel.
 **
 ** \return None.
 ** \param [in] Channel
 **                 Channel ID
 ** \param [in] SrcDataBufferPtr
 **                 Pointer to source data buffer
 ** \param [in] DesDataBufferPtr
 **                 Pointer to destination data buffer in RAM
 ** \param [in] Length
 *                  Length (in number of data elements) of the data to be  
 **                 transmitted from SrcdataBufferPtr and/or received 
 **                 from DesDataBufferPtr.
 **                   Min.: 1
 **                   Max.: Maximum of data specified at configuration
 **                         for this channel **
 */
FUNC(void, SPI_CODE) Spi_Dma_UpdateDescriptor
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length
)
{
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr = 
    &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
    
  VAR(Spi_DmaDescriptorConfigType, AUTOMATIC) DmaDescConfig;

  if (ChannelConfigPtr->DmaDescriptorCount == 0U)
  {
    /* Do nothing */
  }
  else
  {
    /* Calculate configuration values */
    Spi_Dma_ConstructDescriptorConfig(
        Channel,
        SrcDataBufferPtr,
        DesDataBufferPtr,
        Length,
        &DmaDescConfig
    );
    /* Setup Descriptors */
    Spi_Dma_SetDescriptor(Channel, &DmaDescConfig);
  }
}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[internal function definitions]=========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Dma_ConstructDescriptorConfig
 **
 ** Construct descriptor configuration.
 **
 ** \return None.
 ** \param [in] Channel
 **                 Channel ID
 ** \param [in] SrcDataBufferPtr
 **                 Pointer to source data buffer
 ** \param [in] DesDataBufferPtr
 **                 Pointer to destination data buffer in RAM
 ** \param [in] Length
 *                  Length (in number of data elements) of the data to be  
 **                 transmitted from SrcdataBufferPtr and/or received 
 **                 from DesDataBufferPtr.
 **                   Min.: 1
 **                   Max.: Maximum of data specified at configuration
 **                         for this channel **
 ** \param [out] DmaDescConfig
 **                 Output data structure pointer.
 */
static FUNC(void, SPI_CODE) Spi_Dma_ConstructDescriptorConfig
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  /* Deviation from MISRA-C:2004 Rule 16.7, MISRA-C:2012 Rule-8.13.
     Justification: The variable pointed to by the pointer is changed
     in sub functions. */
  /* PRQA S 3673 1 */
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length,
  P2VAR(Spi_DmaDescriptorConfigType, AUTOMATIC, AUTOMATIC) DmaDescConfig
)
{
  /* Num of transer count (Fraction) */
  VAR(Spi_NumberOfDataType, AUTOMATIC) FractionTransferCount;
  /* Num of transer count (Y transfer count) */
  VAR(Spi_NumberOfDataType, AUTOMATIC) YTransferCount;
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );

  /* Calculate transfer count */
  if (Length == 0U)
  {
    /* Guard to avoid un-expected behavior. */
    FractionTransferCount = 1U;
    YTransferCount = 0U;
  }
  else
  {
    FractionTransferCount = Length % SPI_DMA_1D_TRANSFER_COUNT_MAX;
    YTransferCount = Length / SPI_DMA_1D_TRANSFER_COUNT_MAX;
  }

  if (YTransferCount > 0U)
  {
    if (FractionTransferCount > 0U)
    {
      /* Use both 2D and 1D transfer */
      DmaDescConfig->Use1DTransfer = SPI_TRUE;
      DmaDescConfig->XCount = SPI_DMA_1D_TRANSFER_COUNT_MAX - 1U;
      DmaDescConfig->YCount = YTransferCount - 1U;
      DmaDescConfig->XCountFrac = FractionTransferCount - 1U;
    }
    else
    {
      /* Use only 2D transfer */
      DmaDescConfig->Use1DTransfer = SPI_FALSE;
      DmaDescConfig->XCount = SPI_DMA_1D_TRANSFER_COUNT_MAX - 1U;
      DmaDescConfig->YCount = YTransferCount - 1U;
      DmaDescConfig->XCountFrac = 0U;
    }
  }
  else
  {
    /* Use only 2D transfer */
    DmaDescConfig->Use1DTransfer = SPI_FALSE;
    DmaDescConfig->XCount = FractionTransferCount - 1U;
    DmaDescConfig->YCount = 0U;
    DmaDescConfig->XCountFrac = 0U;
  }

  /* Setup data for Tx descriptor */
  if (SrcDataBufferPtr == NULL_PTR)
  {
    /* SRC address is fixed */
    /* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: Cast between pointer and integer is necessary for 
       hardware access. */
    /* PRQA S 306 2 */
    DmaDescConfig->TxSrcAddress = (uint32)&(ChannelConfigPtr->DefaultData);
    DmaDescConfig->TxSrcAddressFrac = (uint32)&(ChannelConfigPtr->DefaultData);
    DmaDescConfig->TxXIncr = 0U;
    DmaDescConfig->TxYIncr = 0U;
  }
  else
  {
    /* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: Cast between pointer and integer is necessary for 
       hardware access. */
    /* PRQA S 306 1 */
    DmaDescConfig->TxSrcAddress = (uint32)SrcDataBufferPtr;
    DmaDescConfig->TxSrcAddressFrac = DmaDescConfig->TxSrcAddress + 
        (SPI_DMA_1D_TRANSFER_COUNT_MAX * (uint32)ChannelConfigPtr->DataWidth * (uint32)YTransferCount);
    DmaDescConfig->TxXIncr = 1U;
    DmaDescConfig->TxYIncr = SPI_DMA_1D_TRANSFER_COUNT_MAX;
  }

  /* Setup data for Rx descriptor */
  if (DesDataBufferPtr == NULL_PTR)
  {
    /* DST address is fixed */
    /* Deviation from MISRA-C:2004 Rule 17.4, 3.1, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: Implementation often uses pointer access by 
       array-subscripting. */
    /* PRQA S 491,306 1 */
    DmaDescConfig->RxDstAddress = (uint32)&Spi_Dma_RxIgnore;
    DmaDescConfig->RxDstAddressFrac = DmaDescConfig->RxDstAddress;
    DmaDescConfig->RxXIncr = 0U;
    DmaDescConfig->RxYIncr = 0U;
  }
  else
  {
    /* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: Cast between pointer and integer is necessary for 
       hardware access. */
    /* PRQA S 306 1 */
    DmaDescConfig->RxDstAddress = (uint32)DesDataBufferPtr;
    DmaDescConfig->RxDstAddressFrac = DmaDescConfig->RxDstAddress + 
        (SPI_DMA_1D_TRANSFER_COUNT_MAX * (uint32)ChannelConfigPtr->DataWidth * (uint32)YTransferCount);
    DmaDescConfig->RxXIncr = 1U;
    DmaDescConfig->RxYIncr = SPI_DMA_1D_TRANSFER_COUNT_MAX;
  }
}

/** \brief Spi_Dma_SetDescriptor
 **
 ** Set constructed configuration into descriptors.
 **
 ** \return None.
 ** \param [in] Channel
 **                 Channel ID
 ** \param [in] DmaDescConfig
 **                 Configuration data structure pointer.
 */
static FUNC(void, SPI_CODE) Spi_Dma_SetDescriptor
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST(Spi_DmaDescriptorConfigType, AUTOMATIC, AUTOMATIC) DmaDescConfig
)
{
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr 
    = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
  VAR(Spi_DmaDescAssignIndexType, AUTOMATIC) DmaDescIndex;

  P2VAR(CONSTP2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, TYPEDEF), TYPEDEF, SPI_VAR_NO_INIT)
    CurDmaRxDescriptorRegsPtr = ChannelConfigPtr->DmaRxDescriptorRegsPtr;
  P2VAR(CONSTP2VAR(volatile Spi_DmaDescriptorRegsType, TYPEDEF, TYPEDEF), TYPEDEF, SPI_VAR_NO_INIT)
    CurDmaTxDescriptorRegsPtr = ChannelConfigPtr->DmaTxDescriptorRegsPtr;

  volatile P2VAR(Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT) TxDescPtr;
  volatile P2VAR(Spi_DmaDescriptorRegsType, TYPEDEF, SPI_VAR_NO_INIT) RxDescPtr;

  /* DMA Descriptor unDESCR_Y_CTL2 register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 3 */
  VAR(Spi_un_Dw1_Descr_Y_Ctl_Type, AUTOMATIC) unDescrYCtl2;
  VAR(Spi_un_Dw1_Descr_X_Ctl_Type, AUTOMATIC) unDescrXCtl2;
  VAR(Spi_un_Dw1_Descr_X_Ctl_Type, AUTOMATIC) unDescrXCtl;

  /* Setup descriptors */
  for( DmaDescIndex = 0U; DmaDescIndex < ChannelConfigPtr->DmaDescriptorCount; DmaDescIndex++ )
  {
    TxDescPtr = CurDmaTxDescriptorRegsPtr[DmaDescIndex];
    RxDescPtr = CurDmaRxDescriptorRegsPtr[DmaDescIndex];

    /* Tx Decriptors (No need to update DST, it fixed points to FIFO reg.) */
    unDescrYCtl2.u32Register = 0UL;
    unDescrXCtl2.u32Register = 0UL;
    unDescrXCtl.u32Register  = 0UL;

    unDescrYCtl2.stcField.u12SRC_Y_INCR = DmaDescConfig->TxYIncr;
    unDescrYCtl2.stcField.u8Y_COUNT = DmaDescConfig->YCount;
    TxDescPtr->unDESCR_Y_CTL2.u32Register = unDescrYCtl2.u32Register;

    unDescrXCtl2.stcField.u12SRC_X_INCR = DmaDescConfig->TxXIncr;
    unDescrXCtl2.stcField.u8X_COUNT = DmaDescConfig->XCount;
    TxDescPtr->unDESCR_X_CTL2.u32Register = unDescrXCtl2.u32Register;

    unDescrXCtl.stcField.u12SRC_X_INCR = DmaDescConfig->TxXIncr;
    unDescrXCtl.stcField.u8X_COUNT = DmaDescConfig->XCountFrac;
    TxDescPtr->unDESCR_X_CTL.u32Register = unDescrXCtl.u32Register;

    TxDescPtr->DESCR_SRC2 = DmaDescConfig->TxSrcAddress;
    TxDescPtr->DESCR_SRC  = DmaDescConfig->TxSrcAddressFrac;

    /* Rx Decriptors (No need to update SRC, it fixed points to FIFO reg.) */
    unDescrYCtl2.u32Register = 0UL;
    unDescrXCtl2.u32Register = 0UL;
    unDescrXCtl.u32Register  = 0UL;

    unDescrYCtl2.stcField.u12DST_Y_INCR = DmaDescConfig->RxYIncr;
    unDescrYCtl2.stcField.u8Y_COUNT = DmaDescConfig->YCount;
    RxDescPtr->unDESCR_Y_CTL2.u32Register = unDescrYCtl2.u32Register;

    unDescrXCtl2.stcField.u12DST_X_INCR = DmaDescConfig->RxXIncr;
    unDescrXCtl2.stcField.u8X_COUNT = DmaDescConfig->XCount;
    RxDescPtr->unDESCR_X_CTL2.u32Register = unDescrXCtl2.u32Register;

    unDescrXCtl.stcField.u12DST_X_INCR = DmaDescConfig->RxXIncr;
    unDescrXCtl.stcField.u8X_COUNT = DmaDescConfig->XCountFrac;
    RxDescPtr->unDESCR_X_CTL.u32Register = unDescrXCtl.u32Register;

    RxDescPtr->DESCR_DST2 = DmaDescConfig->RxDstAddress;
    RxDescPtr->DESCR_DST  = DmaDescConfig->RxDstAddressFrac;

    /* Update descriptor chain */
    if (DmaDescConfig->Use1DTransfer != SPI_FALSE)
    {
      /* Enable 1D descriptor */
      if( TxDescPtr->unDESCR_CTL2.stcField.u1CH_DISABLE == 1U )
      {
        TxDescPtr->unDESCR_CTL2.stcField.u1CH_DISABLE = 0U;
      }

      if( RxDescPtr->unDESCR_CTL2.stcField.u1CH_DISABLE == 1U )
      {
        RxDescPtr->unDESCR_CTL2.stcField.u1CH_DISABLE = 0U;
      }
      
      /* Update chain */
      /* Deviation from MISRA-C:2004 Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
         Justification: Cast between volatile pointer and integer is necessary
         for calculating address. */
      /* PRQA S 303 2 */
      TxDescPtr->DESCR_NEXT_PTR2  = (uint32)&(TxDescPtr->unDESCR_CTL);
      RxDescPtr->DESCR_NEXT_PTR2  = (uint32)&(RxDescPtr->unDESCR_CTL);      
    }
    else
    {
      if( TxDescPtr->unDESCR_CTL.stcField.u1CH_DISABLE == 1U )
      {
        TxDescPtr->unDESCR_CTL2.stcField.u1CH_DISABLE = 1U;
      }

      if( RxDescPtr->unDESCR_CTL.stcField.u1CH_DISABLE == 1U )
      {
        RxDescPtr->unDESCR_CTL2.stcField.u1CH_DISABLE = 1U;
      }
      
      /* Update chain */
      /* DESCR_NEXT_PTR always points next channel descriptor after init. */
      TxDescPtr->DESCR_NEXT_PTR2  = TxDescPtr->DESCR_NEXT_PTR;
      RxDescPtr->DESCR_NEXT_PTR2  = RxDescPtr->DESCR_NEXT_PTR;
    }
  }
}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[end of file]===========================================*/
