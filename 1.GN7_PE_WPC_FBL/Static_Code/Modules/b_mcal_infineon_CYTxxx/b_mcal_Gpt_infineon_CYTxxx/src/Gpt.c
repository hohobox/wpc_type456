/** \brief AUTOSAR Gpt GPT Driver
 **
 ** This file contains the implementation of the AUTOSAR module Gpt
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Gpt.h>                  /* GPT driver types */
#include <SchM_Gpt.h>            /* SchM module types */
#include <Gpt_External.h>        /* external module types */
#include <Gpt_Status.h>          /* status types      */
#include <Gpt_Controller.h>      /* Internal architecture types */
#include <Gpt_Timer_Counter.h>   /* Timer counter types */
#include <Gpt_Cfg_Include.h>     /* user's notification function */
/*==================[macros]================================================*/
/*==================[type definitions]======================================*/
/*==================[external function declarations]========================*/
/*==================[internal function declarations]========================*/
/*==================[external constants]====================================*/
/*==================[internal constants]====================================*/
/*==================[external data]=========================================*/
/*==================[internal data]=========================================*/
#define GPT_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
#include <Gpt_MemMap.h>

/* This data holds configured driver data. */
static P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_APPL_DATA) Gpt_ConfigPtr = NULL_PTR;

#define GPT_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[external function definitions]=========================*/
#define GPT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/** \brief Gpt_Init()
 **
 ** This function initializes the GPT driver.
 ** 
 ** \param[in] ConfigPtr  Pointer to a selected configuration structure.
*/
FUNC(void, GPT_CODE) Gpt_Init
(
  P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_CONST) ConfigPtr
)
{
  /* ConfigPtr environment check */
  if (GPT_NOT_OK == Gpt_CheckConfigPtr(ConfigPtr))
  {
    Gpt_ReportError(GPT_INIT, GPT_E_INIT_FAILED);
  }
  /* driver initialization state check */
  else if (Gpt_ReadDriverInitialised() == GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_INIT, GPT_E_ALREADY_INITIALIZED);
  }
  else
  {
    Gpt_SetInit(ConfigPtr);

#if (GPT_PREDEF_TIMER == STD_ON)
    Gpt_SetPredefTimerInit(ConfigPtr->PredefTimerStartTriggerSelect);
#endif /* GPT_PREDEF_TIMER == STD_ON */
  }
}

/** \brief Gpt_DeInit()
 **
 ** This function deinitializes the GPT driver.
*/
#if (GPT_DEINIT_API == STD_ON)
FUNC(void, GPT_CODE) Gpt_DeInit(void)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() == GPT_DRIVER_UNINITIALIZE)
  {
    Gpt_ReportError(GPT_DEINIT, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    /* sets uninitialize to initialization flag */
    Gpt_SetDriverInitialised(GPT_DRIVER_UNINITIALIZE);
    Gpt_ReportError(GPT_DEINIT, GPT_E_UNINIT);
  }
  else
  {
    /* status check and de-initialization process */
#if (GPT_DEV_ERROR_DETECT == STD_ON)
    if (Gpt_SetDeInit() != GPT_OK)
    {
      Gpt_ReportError(GPT_DEINIT, GPT_E_BUSY);
    }
    else
    {
#if (GPT_PREDEF_TIMER == STD_ON)
      Gpt_SetPredefTimerDeInit();
#endif /* GPT_PREDEF_TIMER == STD_ON */    
    }
#else /* GPT_DEV_ERROR_DETECT == STD_ON */
    Gpt_SetDeInitStopTimer();
#if (GPT_PREDEF_TIMER == STD_ON)
    Gpt_SetPredefTimerDeInit();
#endif /* GPT_PREDEF_TIMER == STD_ON */   
#endif /* GPT_DEV_ERROR_DETECT == STD_ON */
  }
}
#endif /* GPT_DEINIT_API == STD_ON */

/** \brief Gpt_GetTimeElapsed()
 **
 ** This function returns the time already elapsed.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \return  Elapsed timer value (in number of ticks).
*/
#if (GPT_TIME_ELAPSED_API == STD_ON)
FUNC(Gpt_ValueType, GPT_CODE) Gpt_GetTimeElapsed(Gpt_ChannelType Channel)
{
  Gpt_ValueType Value = 0U;

  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_GETTIMEELAPSED, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_GETTIMEELAPSED, GPT_E_UNINIT);
  }
  /* paramete check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_GETTIMEELAPSED, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Value = Gpt_GetTimeElapsed_Internal(Channel);
  }

  return Value;
}
#endif /* GPT_TIME_ELAPSED_API == STD_ON */

/** \brief Gpt_GetTimeRemaining()
 **
 ** This function returns the time remaining until the target time is reached.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \return Remaining timer value (in number of ticks).
*/
#if (GPT_TIME_REMAINING_API == STD_ON)
FUNC(Gpt_ValueType, GPT_CODE) Gpt_GetTimeRemaining(Gpt_ChannelType Channel)
{
  Gpt_ValueType Value = 0U;

  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_GETTIMEREMAINING, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_GETTIMEREMAINING, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_GETTIMEREMAINING, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Value = Gpt_GetTimeRemaining_Internal(Channel);
  }

  return Value;
}
#endif /* GPT_TIME_REMAINING_API == STD_ON */


/** \brief Gpt_StartTimer()
 **
 ** This function starts a timer channel.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 ** \param[in] Value    Target time in number of ticks.
*/
FUNC(void, GPT_CODE) Gpt_StartTimer(Gpt_ChannelType Channel, Gpt_ValueType Value)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_STARTTIMER, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_STARTTIMER, GPT_E_UNINIT);
  }
  /* parameter:Channel check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_STARTTIMER, GPT_E_PARAM_CHANNEL);
  }
  /* parameter Value check */
  else if (Gpt_Arch_CheckTimerRange(Channel, Value) != GPT_OK)
  {
    Gpt_ReportError(GPT_STARTTIMER, GPT_E_PARAM_VALUE);
  }
  /* status check */
  else
  {
    Gpt_EnterCriticalSection();
    if (Gpt_ReadChannelStatus(Channel) == GPT_STATE_RUNNING)
    {
      Gpt_ExitCriticalSection();
      Gpt_ReportError(GPT_STARTTIMER, GPT_E_BUSY);
    }
    else
    {
      Gpt_SetStartTimer(Channel, Value);
      Gpt_ExitCriticalSection();
    }
  }
}

/** \brief Gpt_StopTimer()
 **
 ** This function stops a timer channel.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
FUNC(void, GPT_CODE) Gpt_StopTimer(Gpt_ChannelType Channel)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_STOPTIMER, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_STOPTIMER, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_STOPTIMER, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Gpt_SetStopTimer(Channel);
  }
}

/** \brief Gpt_EnableNotification()
 **
 ** This function enables the interrupt notification for a channel (relevant in normal mode).
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
FUNC(void, GPT_CODE) Gpt_EnableNotification(Gpt_ChannelType Channel)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_ENABLENOTIFICATION, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_ENABLENOTIFICATION, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_ENABLENOTIFICATION, GPT_E_PARAM_CHANNEL);
  }
  /* notification enable check */
  else if (Gpt_ConfigPtr->ChannelsCfgPtr[Channel].notifyFunction == NULL_PTR)
  {
    Gpt_ReportError(GPT_ENABLENOTIFICATION, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Gpt_SetNotification(Channel, GPT_TRUE);
  }
}
#endif /* GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */

/** \brief Gpt_DisableNotification() 
 **
 ** This function disables the interrupt notification for a channel (relevant in normal mode).
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
FUNC(void, GPT_CODE) Gpt_DisableNotification(Gpt_ChannelType Channel)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_DISABLENOTIFICATION, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_DISABLENOTIFICATION, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_DISABLENOTIFICATION, GPT_E_PARAM_CHANNEL);
  }
  /* notification enable check */
  else if (Gpt_ConfigPtr->ChannelsCfgPtr[Channel].notifyFunction == NULL_PTR)
  {
    Gpt_ReportError(GPT_DISABLENOTIFICATION, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Gpt_SetNotification(Channel, GPT_FALSE);
  }
}
#endif /* GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */

/** \brief Gpt_SetMode()
 **
 ** This function sets the operation mode of the GPT.
 **
 ** \param[in] Mode  GPT_MODE_NORMAL: Normal operation mode of the GPT driver. 
 **                  GPT_MODE_SLEEP : Sleep mode of the GPT driver (wakeup capable).
*/
#if (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
FUNC(void, GPT_CODE) Gpt_SetMode(Gpt_ModeType Mode)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_SETMODE, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_SETMODE, GPT_E_UNINIT);
  }
  /* parameter check */
  else if ((Mode != GPT_MODE_SLEEP) && (Mode != GPT_MODE_NORMAL))
  {
    Gpt_ReportError(GPT_SETMODE, GPT_E_PARAM_MODE);
  }
  else
  {
    if (GPT_OK == Gpt_SetMode_Internal(Mode))
    {
#if (GPT_PREDEF_TIMER == STD_ON)
      Gpt_SetPredefTimerMode_Internal(Mode, Gpt_ConfigPtr->PredefTimerStartTriggerSelect);
#endif /* GPT_PREDEF_TIMER == STD_ON */   
    }
  }
}
#endif /* GPT_REPORT_WAKEUP_SOURCE == STD_ON */
#endif /* GPT_WAKEUP_FUNCTIONALITY_API == STD_ON */

/** \brief Gpt_DisableWakeup()
 **
 ** This function disables the wakeup interrupt of a channel (relevant in sleep mode).
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
#if (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
FUNC(void, GPT_CODE) Gpt_DisableWakeup(Gpt_ChannelType Channel)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_DISABLEWAKEUP, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_DISABLEWAKEUP, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_DISABLEWAKEUP, GPT_E_PARAM_CHANNEL);
  }
  /* wakeup enable check */
  else if (Gpt_Arch_CheckChannelWakeup(Channel) != GPT_OK)
  {
    Gpt_ReportError(GPT_DISABLEWAKEUP, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Gpt_SetWakeup(Channel, GPT_FALSE);
  }
}
#endif /* GPT_REPORT_WAKEUP_SOURCE == STD_ON */
#endif /* GPT_WAKEUP_FUNCTIONALITY_API == STD_ON */

/** \brief Gpt_EnableWakeup()
 **
 ** This function enables the wakeup interrupt of a channel (relevant in sleep mode).
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
#if (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
FUNC(void, GPT_CODE) Gpt_EnableWakeup(Gpt_ChannelType Channel)
{
  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_ENABLEWAKEUP, GPT_E_UNINIT);
  }
   /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_ENABLEWAKEUP, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_ENABLEWAKEUP, GPT_E_PARAM_CHANNEL);
  }
  /* wakeup enable check */
  else if (Gpt_Arch_CheckChannelWakeup(Channel) != GPT_OK)
  {
    Gpt_ReportError(GPT_ENABLEWAKEUP, GPT_E_PARAM_CHANNEL);
  }
  else
  {
    Gpt_SetWakeup(Channel, GPT_TRUE);
  }
}
#endif /* GPT_REPORT_WAKEUP_SOURCE == STD_ON */
#endif /* GPT_WAKEUP_FUNCTIONALITY_API == STD_ON */

/** \brief Gpt_GetVersionInfo()
 **
 ** This function returns the version information of this module.
 **
 ** \param[out] VersionInfoPtr  Pointer to where to store the version information of this module.
*/
#if (GPT_VERSION_INFO_API == STD_ON)
FUNC(void, GPT_CODE) Gpt_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, GPT_APPL_DATA) VersionInfoPtr
)
{
  /* parameter check */
  if (VersionInfoPtr == NULL_PTR)
  {
    Gpt_ReportError(GPT_GETVERSIONINFO, GPT_E_PARAM_POINTER);
  }
  else
  {
    /* store version */
    VersionInfoPtr->vendorID         = GPT_VENDOR_ID;
    VersionInfoPtr->moduleID         = GPT_MODULE_ID;
    VersionInfoPtr->sw_major_version = GPT_SW_MAJOR_VERSION;
    VersionInfoPtr->sw_minor_version = GPT_SW_MINOR_VERSION;
    VersionInfoPtr->sw_patch_version = GPT_SW_PATCH_VERSION;
  }
}
#endif /* GPT_VERSION_INFO_API == STD_ON */

/** \brief Gpt_CheckWakeup()
 **
 ** This function checks if a wakeup capable GPT channel is the source for a wakeup event 
 ** and calls the ECU state manager service EcuM_SetWakeupEvent in case of a valid GPT. channel wakeup event. 
 **
 ** \param[in] WakeupSource  Information on wakeup source to be checked. The associated GPT channel can be determined from configuration data.
*/
#if (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
FUNC(void, GPT_CODE) Gpt_CheckWakeup(EcuM_WakeupSourceType WakeupSource)
{
    Gpt_ChannelType ChannelCounter;

  /* driver initialization state check */
  if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_CHECKWAKEUP, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_CHECKWAKEUP, GPT_E_UNINIT);
  }
  else
  {
    /* loop for all channel */
    for (ChannelCounter = 0U; ChannelCounter < Gpt_ConfigPtr->nChannels; ChannelCounter++)
    {
      /* wakeup source id is match? */
      if ((EcuM_WakeupSourceType)Gpt_ConfigPtr->WakeupSourcePtr[ChannelCounter] == WakeupSource)
      {
        if (Gpt_CheckNeedWakeup(ChannelCounter) == GPT_OK)
        {
          EcuM_SetWakeupEvent(WakeupSource);
        }
        break;
      }
    }
  }
}
#endif /* GPT_REPORT_WAKEUP_SOURCE == STD_ON */
#endif /* GPT_WAKEUP_FUNCTIONALITY_API == STD_ON */

#if (GPT_SAFETY_FUNCTION_API == STD_ON)
/** \brief Gpt_CheckChannelStatus()
 **
 ** This function checks the register value, and gets the status.
 **
 ** \param[out] DriverStatusPtr  Pointer of driver status data.
 ** \param[out] ChannelStatusPtr Pointer of Channel status data.
 ** \param[in]  Channel          Numeric identifier of the GPT channel.
 ** \retval E_OK      no error has been detected.
 **         E_NOT_OK  aborted due to errors.
*/
FUNC(Std_ReturnType, GPT_CODE) Gpt_CheckChannelStatus
(
  P2VAR(Gpt_DriverStateType, AUTOMATIC, GPT_APPL_DATA)  DriverStatusPtr,
  P2VAR(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_ChannelType Channel
)
{
  Std_ReturnType result = E_NOT_OK;
  
  /* pointer check */
  if ((DriverStatusPtr == NULL_PTR) || (ChannelStatusPtr == NULL_PTR))
  {
    Gpt_ReportError(GPT_CHECKCHANNELSTATUS, GPT_E_PARAM_POINTER);
  }
  /* called before driver initialization */
  else if ((Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE) && (NULL_PTR == Gpt_ConfigPtr))
  {
    DriverStatusPtr->driverInitialised = GPT_DRIVER_UNINITIALIZE;
    result = E_OK;
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_CHECKCHANNELSTATUS, GPT_E_UNINIT);
  }
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_CHECKCHANNELSTATUS, GPT_E_PARAM_CHANNEL);
  }
  else if (Gpt_CheckChannelStatus_Internal(Channel, DriverStatusPtr, ChannelStatusPtr) == GPT_OK)
  {
    result = E_OK;
  }
  else
  {
    /* This function call error. */
  }

  return result;
}

#if (GPT_PREDEF_TIMER == STD_ON)
/** \brief Gpt_CheckPredefTimerStatus()
 **
 ** This function checks the register value, and gets the status.
 **
 ** \param[out] DriverStatusPtr  Pointer of driver status data.
 ** \param[out] ChannelStatusPtr Pointer of Predef Timer status data.
 ** \param[in]  PredefTimer      GPT Predef Timer.
 ** \retval E_OK     no error has been detected.
 **         E_NOT_OK aborted due to errors.
*/
FUNC(Std_ReturnType, GPT_CODE) Gpt_CheckPredefTimerStatus
(
  P2VAR(Gpt_DriverStateType, AUTOMATIC, GPT_APPL_DATA)  DriverStatusPtr,
  P2VAR(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_PredefTimerType PredefTimer
)
{
  Std_ReturnType result = E_NOT_OK;
  /* pointer check */
  if ((DriverStatusPtr == NULL_PTR) || (ChannelStatusPtr == NULL_PTR))
  {
    Gpt_ReportError(GPT_CHECKPREDEFTIMERSTATUS, GPT_E_PARAM_POINTER);
  }
  /* called before driver initialization */
  else if ((Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE) && (NULL_PTR == Gpt_ConfigPtr))
  {
    DriverStatusPtr->driverInitialised = GPT_DRIVER_UNINITIALIZE;
    result = E_OK;
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_CHECKPREDEFTIMERSTATUS, GPT_E_UNINIT);
  }
  else if (Gpt_Arch_CheckPredefTimerParameter(PredefTimer) != GPT_OK)
  {
    Gpt_ReportError(GPT_CHECKPREDEFTIMERSTATUS, GPT_E_PARAM_PREDEF_TIMER);
  }
  else if (Gpt_CheckPredefTimerStatus_Internal(PredefTimer, DriverStatusPtr, ChannelStatusPtr, Gpt_ConfigPtr->PredefTimerStartTriggerSelect) == GPT_OK)
  {
    result = E_OK;
  }
  else
  {
    /* This function call error. */
  }

  return result;
}
#endif /* GPT_PREDEF_TIMER == STD_ON */
#endif /* GPT_SAFETY_FUNCTION_API == STD_ON */

#if (GPT_PREDEF_TIMER == STD_ON)
/** \brief Gpt_GetPredefTimerValue()
 **
 ** This function delivers the current value of the desired GPT Predef Timer.
 **
 ** \param[in] PredefTimer  GPT Predef Timer.
 ** \param[out] TimeValuePtr Pointer to time value destination data in RAM.
 ** \return  E_NOT_OK : aborted due to errors.
             E_OK :     no error has been detected.
*/
FUNC(Std_ReturnType, GPT_CODE) Gpt_GetPredefTimerValue
(
  Gpt_PredefTimerType PredefTimer,
  P2VAR(uint32, AUTOMATIC, GPT_APPL_DATA) TimeValuePtr
)
{
  Std_ReturnType result = E_NOT_OK;

  /* pointer check */
  if (TimeValuePtr == NULL_PTR)
  {
    Gpt_ReportError(GPT_GETPREDEFTIMERVALUE, GPT_E_PARAM_POINTER);
  }
  /* driver initialization state check */
  else if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
  {
    Gpt_ReportError(GPT_GETPREDEFTIMERVALUE, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_GETPREDEFTIMERVALUE, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Gpt_Arch_CheckPredefTimerParameter(PredefTimer) != GPT_OK)
  {
    Gpt_ReportError(GPT_GETPREDEFTIMERVALUE, GPT_E_PARAM_PREDEF_TIMER);
  }
  /* driver mode check */
  else if (Gpt_ReadDriverStatus() == GPT_MODE_SLEEP)
  {
    Gpt_ReportError(GPT_GETPREDEFTIMERVALUE, GPT_E_MODE);
  }
  else
  {
    if (GPT_OK == Gpt_GetPredefTimerValue_Internal(PredefTimer, TimeValuePtr))
    {
      result = E_OK;
    }
  }

  return result;
}
#endif /* GPT_PREDEF_TIMER == STD_ON */

#if (GPT_SET_PRESCALER_API == STD_ON)
/** \brief Gpt_SetPrescaler()
 **
 ** Set a timer prescaler.
 **
 ** \param[in] Channel  ChannelNumber.
 ** \param[in] ClockFrequency  Frequency change.
*/
FUNC(void, GPT_CODE) Gpt_SetPrescaler
(
  Gpt_ChannelType        Channel,
  Gpt_ClkFrequencyType   ClockFrequency
)
{
  Gpt_ReturnType result;

  /* driver initialization state check */
  if (GPT_DRIVER_INITIALIZE != Gpt_ReadDriverInitialised())
  {
    Gpt_ReportError(GPT_SETPRESCALER, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_SETPRESCALER, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Channel >= Gpt_ConfigPtr->nChannels)
  {
    Gpt_ReportError(GPT_SETPRESCALER, GPT_E_PARAM_CHANNEL);
  }
  /* external clock check */
  else if (Gpt_Arch_GetClockSource(Channel) != GPT_CLK_INT)
  {
    Gpt_ReportError(GPT_SETPRESCALER, GPT_E_PARAM_CHANNEL);
  }
  /* channel status check */
  else
  {
    Gpt_EnterCriticalSection();
  
    if (Gpt_ReadChannelStatus(Channel) == GPT_STATE_RUNNING)
    {
      Gpt_ExitCriticalSection();
      Gpt_ReportError(GPT_SETPRESCALER, GPT_E_BUSY);
    }
    else
    {
      result = Gpt_SetPrescaler_Internal(Channel, ClockFrequency);

      Gpt_ExitCriticalSection();

      if (GPT_OK != result)
      {
        Gpt_ReportError(GPT_SETPRESCALER, GPT_E_PARAM_CLOCK);
      }
    }
  }
}
#endif /* GPT_SET_PRESCALER_API == STD_ON */

#if (GPT_PREDEF_TIMER == STD_ON)
#if (GPT_SET_PREDEFTIMER_PRESCALER_API  == STD_ON)
/** \brief Gpt_SetPredefTimerPrescaler()
 **
 ** Set a predef timer prescaler.
 **
 ** \param[in] PredefTimer  GPT Predef Timer.
 ** \param[in] ClockFrequency  Clock Frequency Type.
*/
FUNC(void, GPT_CODE) Gpt_SetPredefTimerPrescaler
(
  Gpt_PredefTimerType PredefTimer,
  Gpt_ClkFrequencyType ClockFrequency
)
{
  /* driver initialization state check */
  if (GPT_DRIVER_INITIALIZE != Gpt_ReadDriverInitialised())
  {
    Gpt_ReportError(GPT_SETPREDEFTIMERPRESCALER, GPT_E_UNINIT);
  }
  /* ConfigPtr environment check */
  else if (GPT_NOT_OK == Gpt_CheckConfigPtr(Gpt_ConfigPtr))
  {
    Gpt_ReportError(GPT_SETPREDEFTIMERPRESCALER, GPT_E_UNINIT);
  }
  /* parameter check */
  else if (Gpt_Arch_CheckPredefTimerParameter(PredefTimer) != GPT_OK)
  {
    Gpt_ReportError(GPT_SETPREDEFTIMERPRESCALER, GPT_E_PARAM_PREDEF_TIMER);
  }
  /* running check (if start trigger is enable) */
  /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
     Justification: It is not effect any other decisions whether calls the function of right hand operand. */
  /* PRQA S 3415 2 */
  else if ((Gpt_ConfigPtr->PredefTimerStartTriggerSelect != GPT_PREDEF_TIMER_START_TRIGGER_INVALID) &&
           (Gpt_Arch_CheckPredefTimerRunning(PredefTimer) != GPT_OK))
  {
      Gpt_ReportError(GPT_SETPREDEFTIMERPRESCALER, GPT_E_INTERNAL);
  }
  else if (GPT_OK != Gpt_SetPredefTimerPrescaler_Internal(PredefTimer, ClockFrequency, Gpt_ConfigPtr->PredefTimerStartTriggerSelect))
  {
    Gpt_ReportError(GPT_SETPREDEFTIMERPRESCALER, GPT_E_PARAM_CLOCK);
  }
  else
  {
    /* This function call no error. */
  }
}
#endif /* GPT_SET_PREDEFTIMER_PRESCALER_API  == STD_ON */
#endif /* GPT_PREDEF_TIMER == STD_ON */

/** \brief Gpt_Isr_Vector_Internal()
 **
 ** Internal service of Gpt interrupt routine.
 **
 ** \param[in] ResourceIndex  Resource index of TCPWM peripheral.
 ** \param[in] BaseAddrPtr    Base address of channel.
 **
 */
FUNC(void, GPT_CODE) Gpt_IsrVector_Internal(uint16 ResourceIndex, volatile P2VAR(uint32, GPT_CONST, REGSPACE) BaseAddrPtr)
{
  Gpt_ChannelType Channel;
  
  if (Gpt_CheckConfigPtr(Gpt_ConfigPtr) == GPT_NOT_OK)
  {
    Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);

    /* Disable the interrupt */
    Gpt_DisableInterruptByBaseAddr(BaseAddrPtr);
  }
  else 
  {
    Channel = Gpt_ConfigPtr->ResAssignedChannelidPtr[ResourceIndex];

    if (GPT_INVALID_CHANNELID != Channel)
    {
      if (Gpt_ReadDriverInitialised() != GPT_DRIVER_INITIALIZE)
      {
        Gpt_ReportError(GPT_TIMEREXPIRE, GPT_E_INTERNAL);

        /* Disable the interrupt */
        Gpt_DisableInterruptByBaseAddr(BaseAddrPtr);
      }
      else
      {
        if (Gpt_Arch_ClearInterruptFlag(Channel) == GPT_OK)
        {  
          if (Gpt_Arch_TimerExpire(Channel) == GPT_OK)
          {
#if (GPT_REPORT_WAKEUP_SOURCE == STD_ON)
            EcuM_CheckWakeup((EcuM_WakeupSourceType)Gpt_ConfigPtr->WakeupSourcePtr[Channel]);
#endif
          }
        }
        else
        {
          /* not action */
        }
      }

    }
    else
    {
      /* Disable the interrupt */
      Gpt_DisableInterruptByBaseAddr(BaseAddrPtr);
    }
  }
}

/** \brief Gpt_EnterCriticalSection()
 **
 ** This function calls the Function of enter critical section.
*/
FUNC(void, GPT_CODE) Gpt_EnterCriticalSection(void)
{
  SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_0();
}

/** \brief Gpt_ExitCriticalSection()
 **
 ** This function calls the Function of exit critical section.
*/
FUNC(void, GPT_CODE) Gpt_ExitCriticalSection(void)
{
  SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_0();
}

/** \brief Gpt_NotifyFunc()
 **
 ** This function calls user's notification function.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
FUNC(void, GPT_CODE) Gpt_NotifyFunc(Gpt_ChannelType Channel)
{
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &Gpt_ConfigPtr->ChannelsCfgPtr[Channel];
  (*ChannelCfgPtr->notifyFunction)();
}

/** \brief Gpt_GetConfigPtr()
 **
 ** This function gets the configuration data pointer.
 **
 ** \return configuration data pointer.
*/
FUNC_P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_CODE) Gpt_GetConfigPtr(void)
{
  return(Gpt_ConfigPtr);
}

/** \brief Gpt_SetConfigPtr()
 **
 ** This function sets the configuration data pointer.
 **
 **  \param[in] configuration data pointer.
*/
FUNC(void, GPT_CODE) Gpt_SetConfigPtr
(
  P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_CONST) ConfigPtr
)
{
  Gpt_ConfigPtr = ConfigPtr;
}


#define GPT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
