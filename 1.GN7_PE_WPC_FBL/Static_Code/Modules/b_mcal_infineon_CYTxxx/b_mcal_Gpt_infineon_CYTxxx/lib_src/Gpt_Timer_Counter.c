/** \brief AUTOSAR Gpt GPT Driver
 **
 ** This file implements the basic functions for Timer Counter of TCPWM.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Gpt_Timer_Counter.h>  /* Timer Counter types */

/*==================[macros]================================================*/
/*==================[type definitions]======================================*/
/*==================[external function declarations]========================*/
/*==================[internal function declarations]========================*/
#define GPT_START_SEC_CODE_ASIL_B
#include <Gpt_MemMap.h>

/** \brief Gpt_TimerCounterInit() initializes the timer.
 **
 ** This function initializes the timer.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterInit
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
);

/** \brief Gpt_TimerCounterStart() starts the timer.
 **
 ** This function starts an appropriate timer.
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  A valid start timer value.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterStart
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
);

/** \brief Gpt_TimerCounterCancel() stops the timer.
 **
 ** This function stops the Timer Counter.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterCancel
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
);

/** \brief Gpt_TimerCounterSetInterrupt() sets interrupt of the timer.
 **
 ** This function is called to enable or disable interrupt.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 ** \param[in] Operation GPT_TRUE : Enable interrupt.
 **                      GPT_FALSE : Disable interrupt.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterSetInterrupt
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  boolean Operation
);

/** \brief Gpt_TimerCounterGetTimeRemainContinuous()
 **
 ** This function reads counter value of remaining time in continuous mode.
 ** The remaining time is "channel's Interval - counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  The interval time for the specified channel.
 **
 ** \return the counter value of remaining time in continuous mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeRemainContinuous
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
);

/** \brief Gpt_TimerCounterGetTimeRemainOneShot()
 **
 ** This function reads counter value of remaining time in one-shot mode.
 ** If interrupt flag is true, the remaining time is "0".
 ** If interrupt flag is false, the remaining time is "channel's interval - counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  The interval time for the specified channel.
 **
 ** \return the counter value of remaining time in one-shot mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeRemainOneShot
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
);

/** \brief Gpt_TimerCounterGetTimeElapsedContinuous()
 **
 ** This function reads counter value of elapsed time in continuous mode.
 ** The elapsed time is "counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 **
 ** \return the counter value of elapsed time in continuous mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeElapsedContinuous
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
);

/** \brief Gpt_TimerCounterGetTimeElapsedOneShot()
 **
 ** This function reads counter value of elapsed time in one-shot mode.
 ** If interrupt flag is true, the elapsed time is "channel's interval".
 ** If interrupt flag is false, the elapsed time is "counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  The interval time for the specified channel.
 **
 ** \return the counter value of elapsed time in one-shot mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeElapsedOneShot
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
);

/** \brief Gpt_TimerCounterDeInit() de-initialises the timer.
 **
 ** This function de-initializes the timer.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterDeInit
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
);

/** \brief Gpt_TimerCounterClearInterruptFlag() reads and clears the interrupt flag.
 **
 ** If interrupt flag is true and cleared, return value is GPT_OK.
 ** If interrupt flag is false,return value is GPT_NOT_OK.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 **
 ** \retval GPT_OK      If interrupt flag is true and cleared.
 **         GPT_NOT_OK  If interrupt flag is false.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterClearInterruptFlag
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
);

/** \brief Gpt_TimerCounterCheckRegister() checks the register.
 **
 ** If the register is normal, return value is GPT_OK.
 ** If the register is failed, return value is GPT_NOT_OK.
 **
 ** \param[in] ChannelCfgPtr           A valid configuration for a single channel.
 ** \param[in] DriverStatusPtr   Pointer to where to store the driver status information.
 ** \param[in] ChannelStatusPtr  Pointer to where to store the channel status information.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      If the register is normal.
 **         GPT_NOT_OK  If the register is failed.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckRegister
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)  ChannelCfgPtr,
  P2CONST(Gpt_DriverStateType, AUTOMATIC, GPT_APPL_DATA)  DriverStatusPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
);

/** \brief Gpt_TimerCounterSetPrescaler() set prescaler of a timer.
 **
 ** This function sets prescaler of appropriate timer.
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Prescaler prescaler value.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterSetPrescaler
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  uint8 Prescaler
);

/** \brief Gpt_TimerCounterSetStartTrigger() set start trigger of a timer.
 **
 ** This function sets start trigger of appropriate timer.
 **
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] PredefTimerStartTrigger  start trigger value.
 ** \param[in] Operation GPT_TRUE :     set start trigger.
 **                      GPT_FALSE :    clear start trigger.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterSetStartTrigger
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger,
  boolean Operation
);

/** \brief Gpt_TimerCounterCheckRunning() checks running status.
 **
 ** If timer is running, return value is GPT_OK.
 ** If timer is not running ,return value is GPT_NOT_OK.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 **
 ** \retval GPT_OK      timer is running.
 **         GPT_NOT_OK  timer is not running.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckRunning
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
);

/** \brief Gpt_TimerCounterCheckSTATUS() checks the STATUS, TR_CMD and INTR register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr       Pointer to base address of register.
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr         Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckSTATUS
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

/** \brief Gpt_TimerCounterCheckTR_IN_SEL1() checks the TR_IN_SEL1 register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr       Pointer to base address of register.
 ** \param[in] ChannelStatusPtr         Pointer to where to store the channel status information.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_IN_SEL1
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType                                    PredefTimerStartTrigger
);

/** \brief Gpt_TimerCounterCheckCTRL() checks the CTRL register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckCTRL
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

/** \brief Gpt_TimerCounterCheckCOUNTER() checks the COUNTER register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckCOUNTER
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr
);

/** \brief Gpt_TimerCounterCheckPERIOD() checks the PERIOD register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckPERIOD
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

/** \brief Gpt_TimerCounterCheckDT() checks the DT register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckDT
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

/** \brief Gpt_TimerCounterCheckTR_IN_SEL0() checks the TR_IN_SEL0 register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_IN_SEL0
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

/** \brief Gpt_TimerCounterCheckTR_IN_EDGE_SEL() checks the TR_IN_EDGE_SEL register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr       Pointer to base address of register.
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr         Pointer to where to store the channel status information.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_IN_EDGE_SEL
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
);

/** \brief Gpt_TimerCounterCheckTR_OUT_SEL() checks the TR_OUT_SEL register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_OUT_SEL
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

/** \brief Gpt_TimerCounterCheckINTR_MASK() checks the INTR_MASK register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckINTR_MASK
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
);

#define GPT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[external constants]====================================*/
/*==================[internal constants]====================================*/
/*==================[external data]=========================================*/
/*==================[internal data]=========================================*/
/* pointer table for the FRT32bit timer module. */
#define GPT_START_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/* This data is function table. */
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9.
   Justification: Since the section to place data is specified, it should be placed in a different location from the reference function. */
/* PRQA S 3218 1 */
static CONST(Gpt_TcpwmDrvFctTable_t, GPT_CONST) Gpt_TcpwmDrvFctTable =
{
  (Gpt_drvVoidFct_t)&Gpt_TimerCounterCancel,
  (Gpt_drvResultFct_t)&Gpt_TimerCounterClearInterruptFlag,
  (Gpt_drvResultFctAndPassInfo_t)&Gpt_TimerCounterCheckRegister,
  (Gpt_drvVoidFct_t)&Gpt_TimerCounterDeInit,
  (Gpt_drvVoidAndPassBoolFct_t)&Gpt_TimerCounterSetInterrupt,
  (Gpt_drvValueFct_t)&Gpt_TimerCounterGetTimeElapsedContinuous,
  (Gpt_drvValueFctAndPassValue_t)&Gpt_TimerCounterGetTimeElapsedOneShot,
  (Gpt_drvValueFctAndPassValue_t)&Gpt_TimerCounterGetTimeRemainContinuous,
  (Gpt_drvValueFctAndPassValue_t)&Gpt_TimerCounterGetTimeRemainOneShot,
  (Gpt_drvVoidAndPassChar2Fct_t)&Gpt_TimerCounterInit,
  (Gpt_drvVoidAndPassValueFct_t)&Gpt_TimerCounterStart,
  (Gpt_drvVoidAndPassCharFct_t)&Gpt_TimerCounterSetPrescaler,
  (Gpt_drvVoidAndPassChar3Fct_t)&Gpt_TimerCounterSetStartTrigger,
  (Gpt_drvResultFct_t)&Gpt_TimerCounterCheckRunning
};

#define GPT_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[external function definitions]=========================*/
#define GPT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/** \brief Gpt_GetTbl_GPT_TimerCounter()
 **
 ** This function returns the table pointer of Gpt_CounterTimerDrvFctTable.
 **
 ** \return Function table pointer of the Counter Timer.
*/
FUNC_P2CONST(Gpt_TcpwmDrvFctTable_t, AUTOMATIC, GPT_CODE) Gpt_GetTbl_GPT_TimerCounter(void)
{
  /* return function table pointer */
  return &Gpt_TcpwmDrvFctTable;
}

#define GPT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[internal function definitions]=========================*/
#define GPT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/** \brief Gpt_TimerCounterInit() initializes the timer.
 **
 ** This function initializes the timer.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterInit
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
)
{
  uint32 registerAccess;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  /* disable counter */
  TimerCounterRegPtr->CTRL &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* read CTRL register (clears all bit except bit 7-4) */
  /* set to timer counter mode */
  /* set to counter up */
  registerAccess = (uint32)(TimerCounterRegPtr->CTRL & GPT_TCPWM_CTRL_INIT_MASK);

  /* channel mode */
  if (GPT_MODE_CONTINUOUS != (ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS))
  {
    registerAccess |= (uint32)(1UL << GPT_TCPWM_CTRL_ONE_SHOT);
  }

  /* channel debug */
  if (GPT_DEBUG_TRUE == (ChannelCfgPtr->ChannelConfigFlags & GPT_DEBUG_TRUE))
  {
    registerAccess |= (uint32)(1UL << GPT_TCPWM_CTRL_DBG_PAUSE);
  } 

  /* write CTRL register */
  TimerCounterRegPtr->CTRL = registerAccess;
  
  /* interval */
  TimerCounterRegPtr->PERIOD = ChannelCfgPtr->timerMax;

  /* write input trigger value to TR_IN_SEL0 register (other bits are filled with '0') */
  TimerCounterRegPtr->TR_IN_SEL0 = (uint32)ChannelCfgPtr->InputTrigger << GPT_TCPWM_TR_IN_SEL0_COUNT_SEL;

  /* Predef Timer start trigger */
  registerAccess = (uint32)GPT_TCPWM_TR_IN_SEL1_INIT_VALUE;

  if (GPT_PREDEF_TIMER_START_TRIGGER_INVALID != PredefTimerStartTrigger)
  {
    registerAccess = (uint32)PredefTimerStartTrigger;
  }

  /* write TR_IN_SEL1 register */
  TimerCounterRegPtr->TR_IN_SEL1 = registerAccess;

  /* trigger edge */
  registerAccess = (uint32)GPT_TCPWM_TR_IN_EDGE_SEL_TC_INIT_VALUE;

  if (ChannelCfgPtr->SourceClock == GPT_CLK_EXT)
  {
    /* Count trigger edge */
    registerAccess = (uint32)GPT_TCPWM_TR_IN_EDGE_SEL_COUNT_RISING;
  }

  if (GPT_PREDEF_TIMER_START_TRIGGER_INVALID != PredefTimerStartTrigger) 
  {
    /* Predef Timer start trigger edge */
    registerAccess &= ~(uint32)(GPT_TCPWM_CTRL_2BITS_MASK << GPT_TCPWM_TR_IN_EDGE_SEL_START_EDGE);
  }

  /* write TR_IN_EDGE_SEL register */
  TimerCounterRegPtr->TR_IN_EDGE_SEL = registerAccess;

  /* pre-scaling of the selected counter clock */
  registerAccess = (uint32)GPT_TCPWM_DT_INIT_VALUE;

  if (ChannelCfgPtr->Prescaler <= GPT_PRESCALER_DIVIDE_BY_128)
  {
    registerAccess = (uint32)ChannelCfgPtr->Prescaler;
  }

  /* write DT register */
  TimerCounterRegPtr->DT = registerAccess;

  /* counter output trigger selection register */
  registerAccess = GPT_TCPWM_TR_OUT_SEL_DISABLE_VALUE;
  if (GPT_TR_OUT0_EN == (ChannelCfgPtr->ChannelConfigFlags & GPT_TR_OUT0_EN))
  {
    registerAccess = (uint32)GPT_TCPWM_TR_OUT_SEL_OUT0_TC_VALUE;
  }
  if (GPT_TR_OUT1_EN == (ChannelCfgPtr->ChannelConfigFlags & GPT_TR_OUT1_EN))
  {
    registerAccess &= ~(uint32)(GPT_TCPWM_CTRL_3BITS_MASK << GPT_TCPWM_TR_OUT_SEL_OUT1);
    registerAccess |= (uint32)(GPT_TCPWM_TR_OUT_SEL_OUT_TC << GPT_TCPWM_TR_OUT_SEL_OUT1);
  }

  /* write TR_OUT_SEL register */
  TimerCounterRegPtr->TR_OUT_SEL = registerAccess;
  
  /* inter mask */
  if (GPT_MODE_CONTINUOUS == (ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS))
  {
    /* if continuous mode, interrupt disable */
    TimerCounterRegPtr->INTR_MASK = GPT_TCPWM_INTR_MASK_DEFAULT_VALUE;
  }
  else
  {
    /* if oneshot mode, interrupt enable */
    TimerCounterRegPtr->INTR_MASK = GPT_TCPWM_INTR_MASK_ONESHOT_VALUE;
  }

  /* counter clear */
  TimerCounterRegPtr->COUNTER = GPT_TCPWM_COUNTER;

  /* enable timer counter */
  TimerCounterRegPtr->CTRL |= (uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

}

/** \brief Gpt_TimerCounterStart() starts the timer.
 **
 ** This function starts an appropriate timer.
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  A valid interal value.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterStart
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
)
{
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  /* disable counter */
  TimerCounterRegPtr->CTRL &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* enable timer counter */
  TimerCounterRegPtr->CTRL |= (uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* set interval timer value */
  if (GPT_MODE_CONTINUOUS == (ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS))
  {
    TimerCounterRegPtr->PERIOD = Interval;
  }
  else
  {
    TimerCounterRegPtr->PERIOD = Interval - 1U;
  }
  
  /* counter clear */
  TimerCounterRegPtr->COUNTER= GPT_TCPWM_COUNTER;
  
  /* SW start trigger of  counter timer */
  TimerCounterRegPtr->TR_CMD |= (uint32)(1UL << GPT_TCPWM_TR_CMD_START);

  /* Read TR_CMD register (This read ensures that the write has been flushed to hardware) */
  (void)TimerCounterRegPtr->TR_CMD;
}

/** \brief Gpt_TimerCounterCancel() stops the timer.
 **
 ** This function stops the Timer Counter.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterCancel
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
)
{
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  /* disable counter */
  TimerCounterRegPtr->CTRL &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* clear start trigger */
  TimerCounterRegPtr->TR_IN_SEL1 &= ~(uint32)GPT_TCPWM_CTRL_8BITS_MASK;

  /* enable timer counter */
  TimerCounterRegPtr->CTRL |= (uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* Read CTRL register (This read ensures that the write has been flushed to hardware) */
  (void)TimerCounterRegPtr->CTRL;
}

/** \brief Gpt_TimerCounterSetInterrupt() sets interrupt of the timer.
 **
 ** This function is called to enable or disable interrupt.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 ** \param[in] Operation GPT_TRUE : Enable interrupt.
 **                      GPT_FALSE : Disable interrupt.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterSetInterrupt
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  boolean Operation
)
{
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* enable/disable inter mask */
  if (GPT_TRUE == Operation)
  {

    /* clear interrupt cause */
    TimerCounterRegPtr->INTR = GPT_TCPWM_INTR_CLEAR_TC;
  
    /* Read INTR register (This read ensures that the write has been flushed to hardware) */
    (void) TimerCounterRegPtr->INTR;

    TimerCounterRegPtr->INTR_MASK = GPT_TCPWM_INTR_MASK_SET_TC;
  }
  else
  {
    TimerCounterRegPtr->INTR_MASK = GPT_TCPWM_INTR_MASK_CLEAR_TC;
  
    /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
    (void) TimerCounterRegPtr->INTR_MASK;
  }
}

/** \brief Gpt_TimerCounterGetTimeElapsedContinuous()
 **
 ** This function reads counter value of elapsed time in continuous mode.
 ** The elapsed time is "counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 **
 ** \return the counter value of elapsed time in continuous mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeElapsedContinuous
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
)
{
  Gpt_ValueType timer_value;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* Elapsed time is register value of elapsed time. */
  timer_value = TimerCounterRegPtr->COUNTER;
  
 return timer_value;
}

/** \brief Gpt_TimerCounterGetTimeElapsedOneShot()
 **
 ** This function reads counter value of elapsed time in one-shot mode.
 ** If interrupt flag is true, the elapsed time is "channel's interval".
 ** If interrupt flag is false, the elapsed time is "counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  The interval time for the specified channel.
 **
 ** \return the counter value of elapsed time in one-shot mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeElapsedOneShot
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
)
{
  Gpt_ValueType timer_value;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* Is interrupt cause set? */
  if (0U != (TimerCounterRegPtr->INTR & (uint32)1UL))
  {
    /* If interrupt cause is set, elapsed time is interval time. */
    timer_value = Interval;
  }
  else
  {
    /* If interrupt cause is not set, elapsed time is register value of elapsed time. */
    timer_value = TimerCounterRegPtr->COUNTER;
  }

  return timer_value;
}

/** \brief Gpt_TimerCounterGetTimeRemainContinuous()
 **
 ** This function reads counter value of remaining time in continuous mode.
 ** The remaining time is "channel's Interval - counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  The interval time for the specified channel.
 **
 ** \return the counter value of remaining time in continuous mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeRemainContinuous
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
)
{
  Gpt_ValueType timer_value;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* Remaining time is (interval - register valeu of elapsed time). */
  timer_value = Interval - TimerCounterRegPtr->COUNTER;
  
  return timer_value;
}

/** \brief Gpt_TimerCounterGetTimeRemainOneShot()
 **
 ** This function reads counter value of remaining time in one-shot mode.
 ** If interrupt flag is true, the remaining time is "0".
 ** If interrupt flag is false, the remaining time is "channel's interval - counter value".
 **
 ** \param[in] ChannelCfgPtr   A valid configuration for a single channel.
 ** \param[in] Interval  The interval time for the specified channel.
 **
 ** \return the counter value of remaining time in one-shot mode.
**/
static FUNC(Gpt_ValueType, GPT_CODE) Gpt_TimerCounterGetTimeRemainOneShot
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_ValueType Interval
)
{
  Gpt_ValueType timer_value;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  /* Is interrupt cause set? */
  if (0U != (TimerCounterRegPtr->INTR & (uint32)1UL))
  {
    /* If interrupt cause is set, remaining time is 0. */
    timer_value = 0U;
  }
  else
  {
    /* If interrupt cause is not set, remaining time is (interval - register value of elapsed time). */
    timer_value = Interval - TimerCounterRegPtr->COUNTER;
  }

  return timer_value;
}

/** \brief Gpt_TimerCounterDeInit() de-initialises the timer.
 **
 ** This function de-initializes the timer.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterDeInit
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
)
{
  uint32 registerAccess;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* disable counter */
  TimerCounterRegPtr->CTRL &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* read CTRL register */
  registerAccess = TimerCounterRegPtr->CTRL;
  
  /* channel updown mode default: COUNT_UP */
  registerAccess &= ~(uint32)(GPT_TCPWM_CTRL_2BITS_MASK << GPT_TCPWM_CTRL_UP_DOWN_MODE);
  
  /* channel mode default: continuous */
  registerAccess &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ONE_SHOT);

  /* debug default: continuous */
  registerAccess &= ~(uint32)(1UL << GPT_TCPWM_CTRL_DBG_PAUSE);

  /* write CTRL register */
  TimerCounterRegPtr->CTRL = registerAccess;

  /* period default: 0xFFFFFFFF */
  TimerCounterRegPtr->PERIOD = GPT_TCPWM_PERIOD;

  /* counter default: 0x00000000 */
  TimerCounterRegPtr->COUNTER = GPT_TCPWM_COUNTER;
  
  /* counter input trigger default: 1 */
  TimerCounterRegPtr->TR_IN_SEL0 &= ~(uint32)(GPT_TCPWM_CTRL_8BITS_MASK << GPT_TCPWM_TR_IN_SEL0_COUNT_SEL);
  TimerCounterRegPtr->TR_IN_SEL0 |= (uint32)(1UL << GPT_TCPWM_TR_IN_SEL0_COUNT_SEL);
  
  /* Predef Timer start trigger default: 0 */
  TimerCounterRegPtr->TR_IN_SEL1 &= ~(uint32)GPT_TCPWM_CTRL_8BITS_MASK;

  /* read TR_IN_EDGE_SEL register */
  registerAccess = TimerCounterRegPtr->TR_IN_EDGE_SEL;

  /* trigger edge */
  registerAccess |= (uint32)(GPT_TCPWM_CTRL_2BITS_MASK << GPT_TCPWM_TR_IN_EDGE_SEL_COUNT_EDGE);

  /* Predef Timer start trigger edge */
  registerAccess |= (uint32)(GPT_TCPWM_CTRL_2BITS_MASK << GPT_TCPWM_TR_IN_EDGE_SEL_START_EDGE);
  
  /* write TR_IN_EDGE_SEL register */
  TimerCounterRegPtr->TR_IN_EDGE_SEL = registerAccess;

  /* DT_LINE_OUT_L/pre-scaling default: 0 */
  TimerCounterRegPtr->DT &= ~(uint32)GPT_TCPWM_CTRL_8BITS_MASK;
  
  /* counter output trigger default: terminal count event */
  TimerCounterRegPtr->TR_OUT_SEL = GPT_TCPWM_TR_OUT_SEL_DEFAULT_VALUE;
  
  /* inter mask default: disable */
  TimerCounterRegPtr->INTR_MASK = GPT_TCPWM_INTR_MASK_DEFAULT_VALUE;
 
  /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
  (void)TimerCounterRegPtr->INTR_MASK;
}

/** \brief Gpt_TimerCounterClearInterruptFlag() reads and clears the interrupt flag.
 **
 ** If interrupt flag is true and cleared, return value is GPT_OK.
 ** If interrupt flag is false,return value is GPT_NOT_OK.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 **
 ** \retval GPT_OK      If interrupt flag is true and cleared.
 **         GPT_NOT_OK  If interrupt flag is false.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterClearInterruptFlag
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
)
{
  Gpt_ReturnType result = GPT_NOT_OK;
  
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* Is interrupt flag ON? */
  if (0U != (TimerCounterRegPtr->INTR_MASKED & (uint32)1UL))
  {
    /* clear interrupt cause */
    TimerCounterRegPtr->INTR = GPT_TCPWM_INTR_CLEAR_TC;
    
    /* Read INTR register (This read ensures that the write has been flushed to hardware) */
    (void) TimerCounterRegPtr->INTR;

    result = GPT_OK;
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckRegister() checks the register.
 **
 ** If the register is normal, return value is GPT_OK.
 ** If the register is failed, return value is GPT_NOT_OK.
 **
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] DriverStatusPtr          Pointer to where to store the driver status information.
 ** \param[inout] ChannelStatusPtr      Pointer to where to store the channel status information.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      If the register is normal.
 **         GPT_NOT_OK  If the register is failed.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckRegister
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)  ChannelCfgPtr,
  P2CONST(Gpt_DriverStateType, AUTOMATIC, GPT_APPL_DATA)  DriverStatusPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
)
{
  Gpt_ReturnType result;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  if (DriverStatusPtr->driverInitialised == GPT_DRIVER_INITIALIZE)
  {
    if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
    {
      result = Gpt_TimerCounterCheckSTATUS(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckTR_IN_SEL1(TimerCounterRegPtr, ChannelStatusPtr, PredefTimerStartTrigger);

      result &= Gpt_TimerCounterCheckCTRL(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckPERIOD(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckDT(TimerCounterRegPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckTR_IN_SEL0(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckTR_IN_EDGE_SEL(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr, PredefTimerStartTrigger);

      result &= Gpt_TimerCounterCheckTR_OUT_SEL(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckINTR_MASK(TimerCounterRegPtr, ChannelStatusPtr);
    }
    else
    {
      /* driver initialised and channel uninitialise is impossable case */
      result = GPT_NOT_OK;
    }
  }
  else if (DriverStatusPtr->driverInitialised == GPT_DRIVER_UNINITIALIZE)
  {
    if (GPT_STATE_UNINITIALIZE == ChannelStatusPtr->state)
    {
      result = Gpt_TimerCounterCheckCTRL(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckCOUNTER(TimerCounterRegPtr);

      result &= Gpt_TimerCounterCheckPERIOD(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckDT(TimerCounterRegPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckTR_IN_SEL0(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckTR_IN_SEL1(TimerCounterRegPtr, ChannelStatusPtr, PredefTimerStartTrigger);

      result &= Gpt_TimerCounterCheckTR_IN_EDGE_SEL(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr, PredefTimerStartTrigger);

      result &= Gpt_TimerCounterCheckTR_OUT_SEL(TimerCounterRegPtr, ChannelCfgPtr, ChannelStatusPtr);

      result &= Gpt_TimerCounterCheckINTR_MASK(TimerCounterRegPtr, ChannelStatusPtr);
    }
    else
    {
      /* driver uninitialised and channel not uninitialise is impossable case */
      result = GPT_NOT_OK;
    }
  }
  else
  {
    result = GPT_NOT_OK;
  }

  return result;
}

/** \brief Gpt_TimerCounterSetPrescaler() set prescaler of a timer.
 **
 ** This function sets prescaler of  appropriate timer.
 **
 ** \param[in] ChannelCfgPtr    A valid configuration for a single channel.
 ** \param[in] Prescaler  prescaler value.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterSetPrescaler
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  uint8 Prescaler
)
{
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  /* disable counter */
  TimerCounterRegPtr->CTRL &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  TimerCounterRegPtr->DT = (uint32)Prescaler;

  /* enable timer counter */
  TimerCounterRegPtr->CTRL |= (uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* Read CTRL register (This read ensures that the write has been flushed to hardware) */
  (void)TimerCounterRegPtr->CTRL;
}

/** \brief Gpt_TimerCounterDisableInterrupt().
 **
 ** This function disables interrupt of specific channel.
 **
 ** \param[in] BaseAddrPtr    Base address of channel to disable interrupt.
**/
FUNC(void, GPT_CODE) Gpt_TimerCounterDisableInterrupt
(
  volatile P2VAR(uint32, GPT_CONST, REGSPACE) BaseAddrPtr
)
{
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(BaseAddrPtr);

  /* clear interrupt cause */
  TimerCounterRegPtr->INTR = GPT_TCPWM_INTR_CLEAR_ALL_CAUSE;

  /* Read INTR register (This read ensures that the write has been flushed to hardware) */
  (void) TimerCounterRegPtr->INTR;
  
  /* inter mask : disable */
  TimerCounterRegPtr->INTR_MASK = GPT_TCPWM_INTR_MASK_DEFAULT_VALUE;
}

/** \brief Gpt_TimerCounterSetStartTrigger() set start trigger of a timer.
 **
 ** This function sets start trigger of appropriate timer.
 **
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] PredefTimerStartTrigger  start trigger value.
 ** \param[in] Operation GPT_TRUE :     set start trigger.
 **                      GPT_FALSE :    clear start trigger.
**/
static FUNC(void, GPT_CODE) Gpt_TimerCounterSetStartTrigger
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger,
  boolean Operation
)
{
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);

  /* disable counter */
  TimerCounterRegPtr->CTRL &= ~(uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);

  /* set start trigger */
  TimerCounterRegPtr->TR_IN_SEL1 &= ~(uint32)GPT_TCPWM_CTRL_8BITS_MASK;
  if (Operation == GPT_TRUE)
  {
    TimerCounterRegPtr->TR_IN_SEL1 |= (uint32)PredefTimerStartTrigger;
  }

  /* counter clear */
  TimerCounterRegPtr->COUNTER= GPT_TCPWM_COUNTER;

  /* enable timer counter */
  TimerCounterRegPtr->CTRL |= (uint32)(1UL << GPT_TCPWM_CTRL_ENABLED);
}

/** \brief Gpt_TimerCounterCheckRunning() checks running status.
 **
 ** If timer is running, return value is GPT_OK.
 ** If timer is not running ,return value is GPT_NOT_OK.
 **
 ** \param[in] ChannelCfgPtr  A valid configuration for a single channel.
 **
 ** \retval GPT_OK      timer is running.
 **         GPT_NOT_OK  timer is not running.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckRunning
(
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr
)
{
  Gpt_ReturnType result = GPT_NOT_OK;
  
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 2 */
  volatile CONSTP2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE) TimerCounterRegPtr
    = (volatile P2VAR(Gpt_CTimerType, GPT_CONST, REGSPACE))(ChannelCfgPtr->BaseAddrPtr);
  
  /* Is timer running? */
  if (1UL == ((TimerCounterRegPtr->STATUS >> GPT_TCPWM_STATUS_RUNNING) & (uint32)1UL))
  {
    result = GPT_OK;
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckSTATUS() checks the STATUS, TR_CMD and INTR register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr       Pointer to base address of register.
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr         Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckSTATUS
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr)
{
  Gpt_ReturnType result = GPT_OK;

  if (ChannelStatusPtr->state == GPT_STATE_RUNNING)
  {
    /* status register is not running? */
    if ((1UL != ((TimerCounterRegPtr->TR_CMD >> GPT_TCPWM_TR_CMD_START) & (uint32)1UL)) &&
        (1UL != ((TimerCounterRegPtr->STATUS >> GPT_TCPWM_STATUS_RUNNING) & (uint32)1UL)))
    {
      /* timer is not one-shot mode with TC event occurred? */
      /* (If the one-shot mode timer expires during this API, register status changes to the stop status.) */ 
      if (((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) != GPT_MODE_ONESHOT) ||
          (1UL != (TimerCounterRegPtr->INTR & (uint32)1UL)))
      {
        /* status inconsistency occurs since SW status is running, but register status is stop. */
        result = GPT_NOT_OK;
      }
    }
  }
  else
  {
    /* status register is running? */
    if (1UL == ((TimerCounterRegPtr->STATUS >> GPT_TCPWM_STATUS_RUNNING) & (uint32)1UL))
    {
      /* timer still running */
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckTR_IN_SEL1() checks the TR_IN_SEL1 register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr       Pointer to base address of register.
 ** \param[in] ChannelStatusPtr         Pointer to where to store the channel status information.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_IN_SEL1
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType                                    PredefTimerStartTrigger
)
{
  Gpt_ReturnType result = GPT_OK;

  if ((ChannelStatusPtr->state == GPT_STATE_RUNNING) || (ChannelStatusPtr->state == GPT_STATE_EXPIRED))
  {
    /* if the timer is Predef Timer and start trigger enabled, check start trigger */
    if (GPT_PREDEF_TIMER_START_TRIGGER_INVALID != PredefTimerStartTrigger)
    {
      /* is Predef Timer start trigger right check */
      if ((uint32)PredefTimerStartTrigger != (TimerCounterRegPtr->TR_IN_SEL1 & (uint32)GPT_TCPWM_CTRL_8BITS_MASK))
      {
        result = GPT_NOT_OK;
      }
    }
  }
  else
  {
    /* is Predef Timer trigger default (0) check */
    if (0UL != (TimerCounterRegPtr->TR_IN_SEL1 & (uint32)GPT_TCPWM_CTRL_8BITS_MASK))
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckCTRL() checks the CTRL register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckCTRL
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  uint32 registerAccess;
  Gpt_ReturnType result = GPT_OK;

  /* read CTRL register */
  registerAccess = TimerCounterRegPtr->CTRL;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* is counter (enable/disable, up/down mode, counter mode) correct check */
    if ((registerAccess & GPT_TCPWM_CTRL_INITIALIZED_MASK) != GPT_TCPWM_CTRL_INITIALIZED_VALUE)
    {
      result = GPT_NOT_OK;
    }

    /* is channel mode correct check */
    if (((uint32)ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) == ((registerAccess >> GPT_TCPWM_CTRL_ONE_SHOT) & (uint32)1UL))
    {
      result = GPT_NOT_OK;
    }

    /* is debug mode correct check */
    if ((((uint32)ChannelCfgPtr->ChannelConfigFlags & GPT_DEBUG_TRUE) >> GPT_DEBUG_BIT_POSITION) != ((registerAccess >> GPT_TCPWM_CTRL_DBG_PAUSE) & (uint32)1UL))
    {
      result = GPT_NOT_OK;
    }
  }
  else
  {
    /* is counter (enable/disable, up/down mode, counter mode, channel mode, debug mode) default check */
    if ((registerAccess & GPT_TCPWM_CTRL_UNINITIALIZE_MASK) != GPT_TCPWM_CTRL_UNINITIALIZE_VALUE)
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckCOUNTER() checks the COUNTER register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckCOUNTER
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr
)
{
  Gpt_ReturnType result = GPT_OK;

  /* is counter default (0) check */
  if (GPT_TCPWM_COUNTER != TimerCounterRegPtr->COUNTER)
  {
    result = GPT_NOT_OK;
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckPERIOD() checks the PERIOD register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckPERIOD
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  Gpt_ReturnType result = GPT_OK;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* when state running, check register value */
    if (GPT_STATE_RUNNING == ChannelStatusPtr->state)
    {
      /* if continuous mode, check whether register value is equal to interval  */
      if (GPT_MODE_CONTINUOUS == (ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS))
      {
        if (ChannelStatusPtr->interval != TimerCounterRegPtr->PERIOD)
        {
          result = GPT_NOT_OK;
        }
      }
      /* if one-shot mode, check whether register value is equal to (interval - 1)  */
      else
      {
        if ((ChannelStatusPtr->interval - 1U) != TimerCounterRegPtr->PERIOD)
        {
          result = GPT_NOT_OK;
        }
      }
    }
  }
  else
  {
    /* is peroid default (0xFFFFFFFF(32bit)/0xFFFF(16bit)) check */
    if (ChannelCfgPtr->TimerWide == GPT_TIMER_WIDTH_32)
    {
      if (GPT_TCPWM_PERIOD != TimerCounterRegPtr->PERIOD)
      {
        result = GPT_NOT_OK;
      }
    }
    else
    {
      if ((GPT_TCPWM_PERIOD & (uint32)GPT_TCPWM_CTRL_16BITS_MASK) != TimerCounterRegPtr->PERIOD)
      {
        result = GPT_NOT_OK;
      }
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckDT() checks the DT register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckDT
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  Gpt_ReturnType result = GPT_OK;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* is pre-scaling correct check */
    if ((uint32)(ChannelStatusPtr->prescaler) != (TimerCounterRegPtr->DT & (uint32)GPT_TCPWM_CTRL_8BITS_MASK))
    {
      result = GPT_NOT_OK;
    }
  }
  else
  {
    /* is pre-scaling default (0) check */
    if (0UL != (TimerCounterRegPtr->DT & (uint32)GPT_TCPWM_CTRL_8BITS_MASK))
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckTR_IN_SEL0() checks the TR_IN_SEL0 register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_IN_SEL0
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  Gpt_ReturnType result = GPT_OK;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* is input trigger right check */
    if ((uint32)ChannelCfgPtr->InputTrigger != ((TimerCounterRegPtr->TR_IN_SEL0 >> GPT_TCPWM_TR_IN_SEL0_COUNT_SEL) & (uint32)GPT_TCPWM_CTRL_8BITS_MASK))
    {
      result = GPT_NOT_OK;
    }
  }
  else
  {
    /* is input trigger default (1) check */
    if (1UL != ((TimerCounterRegPtr->TR_IN_SEL0 >> GPT_TCPWM_TR_IN_SEL0_COUNT_SEL) & (uint32)GPT_TCPWM_CTRL_8BITS_MASK))
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckTR_IN_EDGE_SEL() checks the TR_IN_EDGE_SEL register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr       Pointer to base address of register.
 ** \param[in] ChannelCfgPtr            A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr         Pointer to where to store the channel status information.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_IN_EDGE_SEL
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
)
{
  uint32 registerAccess;
  Gpt_ReturnType result = GPT_OK;

  /* read TR_IN_EDGE_SEL register */
  registerAccess = TimerCounterRegPtr->TR_IN_EDGE_SEL;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* is trigger edge up check */
    if (ChannelCfgPtr->SourceClock == GPT_CLK_EXT)
    {
       if (0UL != ((registerAccess >> GPT_TCPWM_TR_IN_EDGE_SEL_COUNT_EDGE) & (uint32)GPT_TCPWM_CTRL_2BITS_MASK))
       {
         result = GPT_NOT_OK;
       }
    }
    else
    {
       if (GPT_TCPWM_TR_IN_EDGE_SEL_NO_EDGE_DET != ((registerAccess >> GPT_TCPWM_TR_IN_EDGE_SEL_COUNT_EDGE) & (uint32)GPT_TCPWM_CTRL_2BITS_MASK))
       {
         result = GPT_NOT_OK;
       }
    }

    if (GPT_PREDEF_TIMER_START_TRIGGER_INVALID != PredefTimerStartTrigger)
    {
      /* is Predef Timer start trigger edge up check */
      if (0UL != ((registerAccess >> GPT_TCPWM_TR_IN_EDGE_SEL_START_EDGE) & (uint32)GPT_TCPWM_CTRL_2BITS_MASK))
      {
        result = GPT_NOT_OK;
      }
    }
  }
  else
  {
    /* is trigger edge (default) check */
    if ((registerAccess & GPT_TCPWM_TR_IN_EDGE_SEL_UNINIT_MASK) != GPT_TCPWM_TR_IN_EDGE_SEL_UNINIT_VALUE)
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckTR_OUT_SEL() checks the TR_OUT_SEL register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelCfgPtr        A valid configuration for a single channel.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckTR_OUT_SEL
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST)    ChannelCfgPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  uint32 registerAccess;
  Gpt_ReturnType result = GPT_OK;

  /* read TR_OUT_SEL register */
  registerAccess = TimerCounterRegPtr->TR_OUT_SEL;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* counter output trigger selection check */
    if (GPT_TR_OUT0_EN == (ChannelCfgPtr->ChannelConfigFlags & GPT_TR_OUT0_EN))
    {
      if (GPT_TCPWM_TR_OUT_SEL_OUT_TC != (registerAccess & (uint32)GPT_TCPWM_CTRL_3BITS_MASK))
      {
        result = GPT_NOT_OK;
      }
    }
    if (GPT_TR_OUT1_EN == (ChannelCfgPtr->ChannelConfigFlags & GPT_TR_OUT1_EN))
    {
      if (GPT_TCPWM_TR_OUT_SEL_OUT_TC != ((registerAccess >> GPT_TCPWM_TR_OUT_SEL_OUT1) & (uint32)GPT_TCPWM_CTRL_3BITS_MASK))
      {
        result = GPT_NOT_OK;
      }
    }
    if (GPT_NO_TR_OUT == (ChannelCfgPtr->ChannelConfigFlags & (GPT_TR_OUT0_EN | GPT_TR_OUT1_EN)))
    {
      if (registerAccess != GPT_TCPWM_TR_OUT_SEL_DISABLE_VALUE)
      {
      result = GPT_NOT_OK;
      }
    }
  }
  else
  {
    /* is counter output trigger 0/1 default (2) check */
    if (registerAccess != GPT_TCPWM_TR_OUT_SEL_DEFAULT_VALUE)
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

/** \brief Gpt_TimerCounterCheckINTR_MASK() checks the INTR_MASK register.
 **
 ** If the register is correct, return value is GPT_OK.
 ** If the register is incorrect, return value is GPT_NOT_OK.
 **
 ** \param[in] TimerCounterRegPtr   Pointer to base address of register.
 ** \param[in] ChannelStatusPtr     Pointer to where to store the channel status information.
 **
 ** \retval GPT_OK      If the register is correct.
 **         GPT_NOT_OK  If the register is incorrect.
**/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_TimerCounterCheckINTR_MASK
(
  volatile P2CONST(Gpt_CTimerType, AUTOMATIC, REGSPACE)   TimerCounterRegPtr,
  P2CONST(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  Gpt_ReturnType result = GPT_OK;

  if (GPT_STATE_UNINITIALIZE != ChannelStatusPtr->state)
  {
    /* is the timer mode continuous? */
    if (0UL == ((TimerCounterRegPtr->CTRL >> GPT_TCPWM_CTRL_ONE_SHOT) & (uint32)1UL))
    {
      /* is enable inter mask correct check */
      if ((GPT_NOTIFY_EN == (ChannelStatusPtr->channelStateFlags & GPT_NOTIFY_EN)) || 
          (GPT_WAKEUP_EN == (ChannelStatusPtr->channelStateFlags & GPT_WAKEUP_EN)))
      {
        if (1UL != (TimerCounterRegPtr->INTR_MASK & (uint32)1UL))
        {
          result = GPT_NOT_OK;
        }
      }
      else
      {
        if (0UL != (TimerCounterRegPtr->INTR_MASK & (uint32)1UL))
        {
          result = GPT_NOT_OK;
        }
      }
    }
    else
    {
      /* if oneshot mode, always enable interrupt */
      if (1UL != (TimerCounterRegPtr->INTR_MASK & (uint32)1UL))
      {
        result = GPT_NOT_OK;
      }
    }
  }
  else
  {
    /* is enable inter mask default check */
    if (0UL != (TimerCounterRegPtr->INTR_MASK & (uint32)1UL))
    {
      result = GPT_NOT_OK;
    }
  }

  return result;
}

#define GPT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[end of file]===========================================*/
