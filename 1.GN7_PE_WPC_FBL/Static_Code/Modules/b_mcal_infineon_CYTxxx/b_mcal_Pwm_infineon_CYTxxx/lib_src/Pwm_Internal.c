/** \brief AUTOSAR Pwm Driver
 **
 ** This file contains internal architecture function for the
 ** AUTOSAR Pwm driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/

#include <Pwm_Internal.h>
#include <Pwm_RegisterAccess.h>

/*==================[macros]=================================================*/
/** \brief Channel states
 **
 ** Possible channel state flags used to modify Pwm_ChannelStateType.flags */
/* PWM channel notification is enabled. */
#define PWM_CH_STATE_NOTIFY         ((uint8) 0x01u)
/* PWM channel is started. */
#define PWM_CH_STATE_STARTED        ((uint8) 0x02u)
/* PWM channel trigger is enabled. */
#define PWM_CH_STATE_TRIGGER        ((uint8) 0x04u)
/* PWM channel is waiting HW trigger. */
#define PWM_CH_STATE_WAITHWTRIGGER  ((uint8) 0x08u)
/* The shift bits when convert duty cycle to duty tick. */
#define PWM_DUTY_CYCLETOTICK_SHIFT  ((uint8) 15u)
/* Half divider value. */
#define PWM_HALF_DIVIDER            ((uint8) 2u)
/* The minimum period tick setting value when left or right alignment. */
#define PWM_MINPERIODTICK_LEFTANDRIGHT    ((uint32) 0x01UL)
/* The minimum period tick setting value when center alignment. */
#define PWM_MINPERIODTICK_CENTER          ((uint32) 0x02UL)
/* The mask value for getting line state from line buffer. */
#define PWM_LINESTATE_MASK          ((uint8) 15u)
/*==================[type definitions]=======================================*/

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/

#define PWM_START_SEC_CODE_ASIL_B
#include <Pwm_MemMap.h>

/** \brief Pwm_TranslateNotificationToInterrupt
 **
 ** Transforms the notification reason into the more sophisticated
 ** HW interrupt reason.
 ** \param [in]  ChannelPtr    Pointer to the channel configuration.
 ** \param [in]  Notification  Type of notification 
 **                            PWM_RISING_EDGE or 
 **                            PWM_FALLING_EDGE or 
 **                            PWM_BOTH_EDGES.
 ** \return Converted interrupt reason type.
 */
static FUNC(Pwm_InterruptReasonType, PWM_CODE) Pwm_TranslateNotificationToInterrupt
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
);

/** \brief Pwm_DutyTickDetected
 **
 ** This function implements the duty limit detection.
 ** Duty tick shall be set according to alignment type.
 ** 
 ** Preconditions:
 ** - Channel state values for duty has to be updated before (API SetDutyCycle or
 **   SetPeriodAndDuty).
 **
 ** \param [in]   ChannelPtr  Pointer to the channel configuration.
 ** \param [out]  DutyLimitTickPtr  Pointer to duty tick value (shall be used after
 **                           calling this function).
 **
 ** \return Return PWM_TRUE if duty limit (0% or 100%) was detected,
 **         else return PWM_FALSE.
 **
 */
static FUNC(boolean, PWM_CODE) Pwm_DutyTickDetected
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  P2VAR(Pwm_PeriodType, AUTOMATIC, PWM_APPL_DATA) DutyLimitTickPtr
);

/** \brief Pwm_CheckChannelState_Idle
 **
 ** Verifies register settings for channel state IDLE.
 **
 ** \param [in]  ChannelStatusPtr  Pointer to where to store the current 
 **                                channel specific status parameters.
 ** \param [in]  ChannelPtr        Pointer to the channel configuration.
 **
 ** \return Return PWM_TRUE if s/w and h/w status of channel are in sync,
 **         PWM_FALSE if not.
 **
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelState_Idle
(
  P2VAR(Pwm_ChannelStatusType, AUTOMATIC, PWM_APPL_DATA) ChannelStatusPtr,
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_CheckChannelState_Started
 **
 ** Verifies register settings for channel state STARTED.
 **
 ** \param [in]  ChannelStatusPtr  Pointer to where to store the current
 **                                channel specific status parameters.
 ** \param [in]  ChannelPtr        Pointer to the channel configuration.
 **
 ** \return Return PWM_TRUE if s/w and h/w status of channel are in sync,
 **         PWM_FALSE if not.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelState_Started
(
  P2VAR(Pwm_ChannelStatusType, AUTOMATIC, PWM_APPL_DATA) ChannelStatusPtr,
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_CheckChannelState_Notify
 **
 ** Verifies register settings for channel state NOTIFY.
 **
 ** \param [in]  ChannelPtr  Pointer to the channel configuration.
 **
 ** \return Return PWM_TRUE if s/w and h/w status of channel are in sync,
 **         PWM_FALSE if not.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelState_Notify
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_UpdateRunningChannel
 **
 ** Updates channel counter for duty and period update a running channel.
 **
 ** \param [in]  ChannelPtr     Pointer to the channel configuration.
 ** \param [in]  EndPeriodFlag  Enable/disable the update of the period at 
 **                             the end of the current period.
 **
 */
static FUNC(void, PWM_CODE) Pwm_UpdateRunningChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) EndPeriodFlag
);

/** \brief Pwm_UpdateStoppedChannel
 **
 ** Updates channel counter for duty and period update a stopped channel.
 **
 ** \param [in]  ChannelPtr      Pointer to the channel configuration.
 ** \param [in]  StartDelayFlag  Enable/disable the output of StartDelay.
 **                              (PWM_TRUE = Enable, PWM_FALSE = Disable)
 **
 */
static FUNC(void, PWM_CODE) Pwm_UpdateStoppedChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) StartDelayFlag
);

/** \brief Pwm_StartChannel
 **
 ** Start a channel.
 **
 ** \param [in]  ChannelPtr      Pointer to the channel configuration.
 ** \param [in]  StartDelayFlag  Enable/disable the output of StartDelay.
 **                              (PWM_TRUE = Enable, PWM_FALSE = Disable)
 **
 */
static FUNC(void, PWM_CODE) Pwm_StartChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) StartDelayFlag
);

/** \brief Pwm_GetPrescalerValue
 **
 ** Get channel prescaler value.
 **
 ** \param [in]  TickFrequency    Tick frequency of channel configuration.
 ** \param [in]  ClockFrequency   Input clock frequency.
 **
 ** \return If clock frequency is valid value return calculated prescaler value.
 **         Else return PWM_INVALID_PRESCALER.
 */
static FUNC(uint8, PWM_CODE) Pwm_GetPrescalerValue
(
  VAR(Pwm_ClkFrequencyType, AUTOMATIC) TickFrequency,
  VAR(Pwm_ClkFrequencyType, AUTOMATIC) ClockFrequency
);

/** \brief Pwm_CheckPeriodAndTrigger
 **
 ** \param [in] ChannelPtr     Pointer to the channel configuration.
 ** \param [in] PeriodTicks    Period value in ticks.
 ** \param [in] DutyTicks      Duty value in ticks.
 ** \param [in] TriggerTicks   Delay time for output trigger.
 ** \param [in] MaskFlag       Channel masked status.
 **
 ** \return PWM_TRUE if period and output trigger ticks are in valid range, 
 **         PWM_FALSE otherwise.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckPeriodAndTrigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks,
  VAR(boolean, AUTOMATIC) MaskFlag
);

/** \brief Pwm_CheckDutyAndTrigger
 **
 ** Check if duty cycle and output trigger ticks are in valid range.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** \param [in] PeriodTicks   Period value in ticks.
 ** \param [in] DutyTicks     Duty value in ticks.
 ** \param [in] TriggerTicks  Delay time for output trigger.
 **
 ** \return Returns PWM_TRUE if duty cycle and output trigger ticks are in 
 **         valid range, PWM_FALSE otherwise.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckDutyAndTrigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks
);

/** \brief Pwm_GetPeriodTickValue
 **
 ** Calculate the period tick value (value of PERIOD) according to the alignment type.
 **
 ** Preconditions:
 ** - Channel state values for period has to be updated before (API SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return period tick value to be set in register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetPeriodTickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_GetDutyTickValue
 **
 ** Calculate the duty tick value (value of CC0) according to the alignment type.
 **
 ** Preconditions:
 ** - Channel state values for duty and period has to be updated before (API SetDutyCycle
 **   or SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return duty tick value to be set in register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetDutyTickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_GetTriggerTickValue
 **
 ** Calculate the trigger tick value (value of CC1) according to the alignment type
 ** and update channel match up down status when center alignment.
 **
 ** Preconditions:
 ** - Channel state values for duty, period and trigger tick has to be updated before
 **   (API SetDutyCycle or SetPeriodAndDuty or Pwm_SetTriggerDelay).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return output trigger tick value to be set in register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetTriggerTickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_LimitInterval
 **
 ** Limits the settings to the HW.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 */
static FUNC(void, PWM_CODE) Pwm_LimitInterval
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_CheckChannelMaskStatus
 **
 ** Check if current duty tick and period tick shall mask channel.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 ** \param [in] PeriodTickValue Period tick value.
 ** \param [in] DutyTickValue Duty tick value.
 **
 ** \return Return PWM_TRUE if current duty tick and period tick shall mask channel,
 **         PWM_FALSE if not.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelMaskStatus
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue
);

/** \brief Pwm_SetDisableModeInternal
 **
 ** Set channel disable mode before channel running.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] StartDelayFlag  Enable/disable the output of StartDelay.
 **                             (PWM_TRUE = Enable, PWM_FALSE = Disable)
 **
 */
static FUNC(void, PWM_CODE) Pwm_SetDisableModeInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) StartDelayFlag
);

/** \brief Pwm_GetCC0TickValue
 **
 ** Calculate the CC0 register value when output offset is enable.
 **
 ** Preconditions:
 ** - Channel state values for duty and period has to be updated before (API SetDutyCycle
 **   or SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return tick value to be set in CC0 register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetCC0TickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_GetCC1TickValue
 **
 ** Calculate the CC1 register value when output offset is enable.
 **
 ** Preconditions:
 ** - Channel state values for duty and period has to be updated before (API SetDutyCycle
 **   or SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return tick value to be set in CC1 register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetCC1TickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
);

/** \brief Pwm_CheckDutyAndOffsetTick
 **
 ** Check if duty cycle and OffsetTick are in valid range.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** \param [in] PeriodTicks   Period value in ticks.
 ** \param [in] DutyTicks     Duty value in ticks.
 ** \param [in] OffsetTick    Offset time for PWM output.
 **
 ** \return Returns PWM_TRUE if duty cycle and OffsetTick are in valid range, 
 **         PWM_FALSE otherwise.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckDutyAndOffsetTick
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) OffsetTick
);

#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[external constants]=====================================*/

/*==================[internal constants]=====================================*/

/*==================[external data]==========================================*/

/*==================[internal data]==========================================*/

#define PWM_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/** \brief Driver status
 **
 ** Holds current status of driver
 */
static VAR(Pwm_DriverStatusType, PWM_VAR_INIT) Pwm_DriverStatus = PWM_S_UNINITIALIZED;

#define PWM_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[external function definitions]==========================*/

#define PWM_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/** \brief Pwm_DeInitInternal
 **
 ** Internal implementation of PWM driver deinitialization. 
 ** Stops and deactivates all channels, and reset all common variables.
 **
 ** \param [in] ConfigPtr  Pointer to configuration set.
 **
 */
FUNC(void, PWM_CODE) Pwm_DeInitInternal
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  P2VAR(Pwm_ChannelStateType, AUTOMATIC, PWM_APPL_DATA) ChStatePtr;
  VAR(Pwm_ChannelType, AUTOMATIC) Channel;
  
  /* De-Initialize all configured channels */
  for (Channel = 0u; Channel < ConfigPtr->NumberOfChannels; Channel++)
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigPtr->ChannelConfigPtr[Channel]);
    /* Get channel status pointer */
    ChStatePtr = ChannelPtr->ChannelStatePtr;

    /* Set de-initialize to hardware channel */
    Pwm_RaDeInitChannel(ChannelPtr);

    /* Set initial value to channel status */
    ChStatePtr->NotifyReason = PWM_NOTIFY_UNINIT;
    ChStatePtr->DelayTicks = 0u;
    ChStatePtr->OutputOffsetTicks = 0u;
    ChStatePtr->DutyCycle = 0u;
    ChStatePtr->PeriodTicks = 0u;
    ChStatePtr->PrescalerRegisterValue = 0u;
    ChStatePtr->TriggerTicks = 0u;
    ChStatePtr->Flags = 0u;
    ChStatePtr->MatchUpEnable = PWM_FALSE;
    ChStatePtr->MatchDownEnable = PWM_FALSE;

    /* Check if delay timer is valid */
    if (NULL_PTR != ChannelPtr->DelayConfigPtr)
    {
      /* De-initialize Delay Timer on hardware */
      Pwm_DeInitDelayTimer(ChannelPtr->DelayConfigPtr);
    }
  }
}

/** \brief Pwm_DisableNotificationInternal
 **
 ** Internal implementation: disabling of the PWM signal edge notification.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_DisableNotificationInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Critical section is not needed, because function is
     non-reentrant for the same channel. For different channels
     there is no interference */
  Pwm_RaDisableNotification(ChannelPtr->BaseAddress);
  
  /* Set notify reason */
  ChannelPtr->ChannelStatePtr->NotifyReason = PWM_NOTIFY_UNINIT;

  /* The HW interrupt is disabled before changing the SW state, so
     that the ISR cannot encounter SW state "notification disabled" */
  /* Clear channel notification status flag */
  ChannelPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_NOTIFY);
}

/** \brief Pwm_EnableNotificationInternal
 **
 ** Enabling of the PWM signal edge notification according to Notification parameter.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] Notification    Type of notification:
 **                             PWM_RISING_EDGE,
 **                             PWM_FALLING_EDGE or
 **                             PWM_BOTH_EDGES
 **
 */
FUNC(void, PWM_CODE) Pwm_EnableNotificationInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
)
{
  /* Notification takes place in the ISR.
   * The interrupt is possible on duty end, period end or both.
   * Transform the notification reason dependent on active output (duty time) level.
   */
  /* Lock configuration change */
  ChannelPtr->ChannelStatePtr->NotifyReason = 
       Pwm_TranslateNotificationToInterrupt(ChannelPtr, Notification);
    
  /* Critical section is not needed, because function is
     non-reentrant for the same channel. For different channels
     there is no interference */
  /* Set channel notification status flag */
  ChannelPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_NOTIFY;
  
  /* The SW state is set before the HW interrupt is enabled, so
     that the ISR always encounters SW state "notification enabled" */
  /* Current DutyCycle is not 0% and not 100% */
  if ((PWM_DUTY_0_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle) &&
      (PWM_DUTY_100_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle))
  {
    Pwm_RaEnableNotification(ChannelPtr);
  }
  /* Current DutyCycle is 0% or 100% */
  else
  {
    Pwm_RaDisableNotification(ChannelPtr->BaseAddress);
  }
}

/** \brief Pwm_DisableTriggerInternal
 **
 ** Internal implementation: disabling of the output trigger.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_DisableTriggerInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Check if trigger is enabled state */
  if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_TRIGGER))
  {
    /* Clear channel trigger enable status flag */
    ChannelPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_TRIGGER);
    /* Check if channel is in start state */
    if (PWM_CH_STATE_STARTED == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
    {
      /* Check if delay timer is valid */
      if(NULL_PTR != ChannelPtr->DelayConfigPtr)
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
      }

      /* Retain channel output when counter is disabled or stopped */
      Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Set trigger to disable on HW, this should be set when counter disabled */
      Pwm_RaChangeTrigger(ChannelPtr, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
      /* Set software trigger command */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
    else
    {
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Set trigger to disable on HW, this should be set when counter disabled */
      Pwm_RaChangeTrigger(ChannelPtr, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
    }
  }
}

/** \brief Pwm_EnableTriggerInternal
 **
 ** Internal implementation: enabling of output trigger.
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_EnableTriggerInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Check if trigger is disabled state */
  if (0u == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_TRIGGER))
  {
    /* Set channel trigger enable status flag */
    ChannelPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_TRIGGER;
    /* Check if channel is in start state */
    if (PWM_CH_STATE_STARTED == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
    {
      /* Check if delay timer is valid */
      if(NULL_PTR != ChannelPtr->DelayConfigPtr)
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
      }

      /* Retain channel output when counter is disabled or stopped */
      Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
      
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Set trigger to enable on HW, this should be set when counter disabled */
      Pwm_RaChangeTrigger(ChannelPtr, PWM_TRUE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
      /* Set software trigger command */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
    else
    {
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Set trigger to enable on HW, this should be set when counter disabled */
      Pwm_RaChangeTrigger(ChannelPtr, PWM_TRUE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
    }
  }
}

/** \brief Pwm_GetOutputStateInternal
 **
 ** Read the internal state of the PWM output.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 **
 ** \return    Output state types
 **            PWM_HIGH: The PWM output state is high.
 **            PWM_LOW:  The PWM output state is low.
 **
 */
FUNC(Pwm_OutputStateType, PWM_CODE) Pwm_GetOutputStateInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_OutputStateType, AUTOMATIC) OutputState;
  
  /* Get line_out state */
  OutputState = Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress);

  return OutputState;
}

/** \brief Pwm_InitInternal
 **
 ** PWM driver initialization.
 **
 ** \param [in] ConfigPtr           Pointer to configuration set.
 ** \param [in] EnableTrigger       Whether enable output trigger at init
 **                                 (PWM_TRUE = Yes, PWM_FALSE = No).
 **
 */
FUNC(void, PWM_CODE) Pwm_InitInternal
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr,
  VAR(boolean, AUTOMATIC) EnableTrigger
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  P2CONST(Pwm_DelayConfigType, AUTOMATIC, PWM_APPL_CONST) DelayPtr;
  P2VAR(Pwm_ChannelStateType, AUTOMATIC, PWM_APPL_DATA) ChStatePtr;
  VAR(Pwm_ChannelType, AUTOMATIC) Channel;

  /* Initialize all configured channels */
  for (Channel = 0u; Channel < ConfigPtr->NumberOfChannels; Channel++)
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigPtr->ChannelConfigPtr[Channel]);
    /* Get channel status pointer */
    ChStatePtr = ChannelPtr->ChannelStatePtr;
    /* Set default value to channel status */
    ChStatePtr->Flags = 0u;
    ChStatePtr->NotifyReason = PWM_NOTIFY_UNINIT;
    ChStatePtr->OutputOffsetTicks = ChannelPtr->OutputOffsetTicks;
    ChStatePtr->DutyCycle = ChannelPtr->DefaultDuty;
    ChStatePtr->PeriodTicks = ChannelPtr->DefaultPeriodTicks;
    ChStatePtr->PrescalerRegisterValue = ChannelPtr->DefaultPrescalerValue;
    
    /* Checks the precondition for the values and performs update to PeriodTicks and DutyCycle */
    Pwm_LimitInterval(ChannelPtr);

    /* Initialize channel on hardware */
    Pwm_RaInitChannel(ChannelPtr);

    /* Get delay timer config pointer */
    DelayPtr = ChannelPtr->DelayConfigPtr;

    /* Check if delay timer is valid */
    if (NULL_PTR != DelayPtr)
    {
      /* Set hardware capture trigger, this should be set when counter disabled */
      Pwm_RaSetHwCapture0Trigger(ChannelPtr->BaseAddress, DelayPtr->DelayTrigger);
      if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
      {
        if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
        {
          /* Initialize Delay Timer on hardware */
          Pwm_InitDelayTimer(ChannelPtr);
        }
      }
      else
      {
        /* Initialize Delay Timer on hardware */
        Pwm_InitDelayTimer(ChannelPtr);
      }
      /* Set Delay value */
      ChannelPtr->ChannelStatePtr->DelayTicks = DelayPtr->StartDelay;
    }
    else
    {
      /* Set Delay value */
      ChannelPtr->ChannelStatePtr->DelayTicks = 0u;
    }

    /* Check if channel support set output trigger */
    if (PWM_TRIGGER_DISABLE == ChannelPtr->TriggerOutputSelect)
    {
      /* Clear trigger ticks */
      ChStatePtr->TriggerTicks = 0u;
    }
    else
    {
      /* Set default value to trigger ticks */
      ChStatePtr->TriggerTicks = ChannelPtr->DefaultTriggerOutputTicks;
      
      /* Check if support enable trigger at init or if support start channel at init*/
      if ((PWM_TRUE == EnableTrigger) || (PWM_TRUE == ChannelPtr->StartAtInit))
      {
        /* Set trigger enable status flag */
        ChStatePtr->Flags |= PWM_CH_STATE_TRIGGER;

        /* Set trigger to enable on hardware, this should be set when counter disabled */
        Pwm_RaChangeTrigger(ChannelPtr, PWM_TRUE);
      }
    }

    /* Check if channel support start at init */
    if (PWM_TRUE == ChannelPtr->StartAtInit)
    {
      /* Enter critical section */
      Pwm_EnterCriticalSection();

      /* Check if support start channel by hardware trigger */
      if (PWM_INVALID_TRIGGERVALUE != ChannelPtr->InputStartTrigger)
      {
        if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
        {
          /* IdleState is high */
          if (PWM_HIGH == ChannelPtr->IdleState)
          {
            Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_HIGH);
          }
          /* IdleState is low */
          else
          {
            Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_LOW);
          }
        }
        else
        {
          /* Set channel disable mode */
          Pwm_SetDisableModeInternal(ChannelPtr, PWM_TRUE);
        }

        /* Set wait hardware trigger flag */
        ChStatePtr->Flags |= PWM_CH_STATE_WAITHWTRIGGER;
        
        /* Check if delay timer is valid */
        if (NULL_PTR != DelayPtr)
        {
          if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
          {
            if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
            {
              /* Set hardware reload trigger, this should be set when counter disabled */
              Pwm_RaSetHwReloadTrigger(DelayPtr->DelayBaseAddress, ChannelPtr->InputStartTrigger);
              /* Enable counter */
              Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
            }
          }
          else
          {
            /* Set hardware reload trigger, this should be set when counter disabled */
            Pwm_RaSetHwReloadTrigger(DelayPtr->DelayBaseAddress, ChannelPtr->InputStartTrigger);
            /* Enable counter */
            Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
          }
        }

        /* Set hardware reload trigger, this should be set when counter disabled */
        Pwm_RaSetHwReloadTrigger(ChannelPtr->BaseAddress, ChannelPtr->InputStartTrigger);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
        /* Update timer */
        Pwm_UpdateStoppedChannel(ChannelPtr, PWM_TRUE);
      }
      /* Start channel by software trigger */
      else
      {
        /* Set channel disable mode */
        Pwm_SetDisableModeInternal(ChannelPtr, PWM_TRUE);

        /* Check if delay timer is valid */
        if (NULL_PTR != DelayPtr)
        {
          if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
          {
            if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
            {
              /* Enable counter */
              Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
            }
          }
          else
          {
            /* Enable counter */
            Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
          }
        }

        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
        /* Update timer */
        Pwm_UpdateStoppedChannel(ChannelPtr, PWM_TRUE);

        if(PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
        {
          if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
          {
            /* Start Channel */
            Pwm_StartChannel(ChannelPtr, PWM_TRUE);
          }
          else
          {
            /* Start Channel */
            Pwm_StartChannel(ChannelPtr, PWM_FALSE);
          }
        }
        else
        {
          /* Start Channel */
          Pwm_StartChannel(ChannelPtr, PWM_TRUE);
        }
      }
      /* Exit critical section */
      Pwm_ExitCriticalSection();
      /* Set channel start status flag */
      ChStatePtr->Flags |= PWM_CH_STATE_STARTED;
    }
    /* StartAtInit is false */
    else
    {
      /* Check if delay timer is valid */
      if (NULL_PTR != DelayPtr)
      {
        /* Enable counter */
        Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
      }
      /* IdleState is high */
      if (PWM_HIGH == ChannelPtr->IdleState)
      {
        Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_HIGH);
      }
      /* IdleState is low */
      else
      {
        Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_LOW);
      }
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
    }
  }
}

/** \brief Pwm_SetOutputToIdleInternal
 **
 ** Sets the PWM output to the configured Idle state.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetOutputToIdleInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* IdleState is high */
  if (PWM_HIGH == ChannelPtr->IdleState)
  {
    Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_HIGH);
  }
  /* IdleState is low */
  else
  {
    Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_LOW);
  }
  
  /* Check if delay timer is valid */
  if(NULL_PTR != ChannelPtr->DelayConfigPtr)
  {
    /* Disable counter */
    Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
    /* Enable counter */
    Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
  }

  /* Disable counter */
  Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
  /* Enable counter */
  Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
  /* Clear channel start status flag */
  ChannelPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_STARTED);
}

/** \brief Pwm_SetOutputStatusInternal
 **
 ** Sets the PWM output to the specified state.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 ** \param [in] State       Output state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetOutputStatusInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_OutputStateType, AUTOMATIC) State
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickValue;
  /* Get period tick register value */
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue = Pwm_GetPeriodTickValue(ChannelPtr);
  
  /* Output offset is enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
  {
    /* Get cc0 tick register value */
    DutyTickValue = Pwm_GetCC0TickValue(ChannelPtr);
    /* Get cc1 tick register value */
    TriggerTickValue = Pwm_GetCC1TickValue(ChannelPtr);
  }
  /* Output offset is disable */
  else
  {
    /* Get cc0 tick register value */
    DutyTickValue = Pwm_GetDutyTickValue(ChannelPtr);
    /* Get cc1 tick register value */
    TriggerTickValue = Pwm_GetTriggerTickValue(ChannelPtr);
  }

  /* Check if delay timer is valid */
  if(NULL_PTR != ChannelPtr->DelayConfigPtr)
  {
    /* Disable counter */
    Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
    /* Enable counter */
    Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
  }

  /* Update buff register value to avoid miss exchange */
  Pwm_RaUpdateChannelBuff(ChannelPtr, PeriodTickValue, DutyTickValue, TriggerTickValue);
  
  /* Enter critical section */
  Pwm_EnterCriticalSection();

  /* Set line_out state on hardware */
  Pwm_RaSetStatusLineOut(ChannelPtr->BaseAddress, State);

  /* Check if channel is waiting update */
  if (PWM_FALSE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr))
  {
    /* Check line_sel is PWM */
    if (PWM_FALSE == Pwm_RaCheckChannelStatus_LineSelIsPWM(ChannelPtr->BaseAddress))
    {
      /* Enable software capture0 trigger */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
    }
  }

  /* Exit critical section */
  Pwm_ExitCriticalSection();
}

/** \brief Pwm_SetChannelOutputBufferInternal
 **
 ** Sets the PWM line and complementary output to the specified state.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 ** \param [in] LineState       PWM line output state.
 ** \param [in] LineCompState   PWM line complementary output state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetChannelOutputBufferInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_OutputLineStateType, AUTOMATIC) LineState,
  VAR(Pwm_OutputLineStateType, AUTOMATIC) LineCompState
)
{  
  /* Set LineSelBuff */
  ChannelPtr->ChannelStatePtr->LineSelBuff = (uint32)((uint32)LineState |
                               ((uint32)LineCompState << PWM_TCPWM_LINE_SEL_COMPL_OUT_SEL_P));

}

/** \brief Pwm_UpdateDutyChannelOutputBufferInternal
 **
 ** Updates channel counter for duty and channel outputbuffer.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_UpdateDutyChannelOutputBufferInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{  
  /* Enter critical section */
  Pwm_EnterCriticalSection();

  /* Update running channel */
  Pwm_UpdateRunningChannel(ChannelPtr, PWM_TRUE);

  /* Exit critical section */
  Pwm_ExitCriticalSection();
}

/** \brief Pwm_SetDutyCycleInternal
 **
 ** Sets the PWM channel to a new duty cycle.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] DutyCycle       Duty cycle to be set.
 ** \param [in] EndPeriodFlag   Enable/disable the update of the period at
 **                             the end of the current period.
 ** \param [in] AutoReloadFlag  Enable/disable the reload of the channel
 **                             when the channel is in waiting update state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetDutyCycleInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(uint16, AUTOMATIC) DutyCycle,
  VAR(boolean, AUTOMATIC) EndPeriodFlag,
  VAR(boolean, AUTOMATIC) AutoReloadFlag
)
{ 
  VAR(uint16, AUTOMATIC) PreDutyCycle;
  VAR(boolean, AUTOMATIC) WaitingStatus;

  /* Save prior duty cycle */
  PreDutyCycle = ChannelPtr->ChannelStatePtr->DutyCycle;
  /* Update duty value */
  ChannelPtr->ChannelStatePtr->DutyCycle = DutyCycle;
  
  /* Checks the precondition for the values and performs update to DutyCycle */
  Pwm_LimitInterval(ChannelPtr);

  /* Check if notification is enable */
  if (PWM_CH_STATE_NOTIFY == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_NOTIFY))
  {
    /* Current DutyCycle is 0% or 100% */
    if ((PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle) || 
        (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle))
    {
       Pwm_RaDisableNotification(ChannelPtr->BaseAddress);
    }
    /* Prior DutyCycle is 0% or 100% */
    else if((PWM_DUTY_0_PERCENTAGE == PreDutyCycle) || (PWM_DUTY_100_PERCENTAGE == PreDutyCycle))
    {
      /* Enable notification */
      Pwm_RaEnableNotification(ChannelPtr);
    }
    else
    {
      /* Do nothing */
    }
  }

  /* Check if channel is in start state */
  if (0u == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
  {
    if(PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
    {
      /* Update timer */
      Pwm_UpdateStoppedChannel(ChannelPtr, PWM_FALSE);
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Set channel disable mode */
      Pwm_SetDisableModeInternal(ChannelPtr, PWM_FALSE);
      /* Start Channel */
      Pwm_StartChannel(ChannelPtr, PWM_FALSE);
    }
    else
    {
      /* Update timer */
      Pwm_UpdateStoppedChannel(ChannelPtr, PWM_TRUE);
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Set channel disable mode */
      Pwm_SetDisableModeInternal(ChannelPtr, PWM_TRUE);
      /* Start Channel */
      Pwm_StartChannel(ChannelPtr, PWM_TRUE);
    }
    /* Exit critical section */
    Pwm_ExitCriticalSection();
    /* Set channel start status flag */
    ChannelPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_STARTED;
  }
  else
  {
    /* Get waiting update status */
    WaitingStatus = Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr);
    /* Update dutycycle at current period or waiting update */
    if ((PWM_FALSE == EndPeriodFlag) || ((PWM_TRUE == WaitingStatus) && (PWM_TRUE == AutoReloadFlag)))
    {
      /* Check if delay timer is valid */
      if(NULL_PTR != ChannelPtr->DelayConfigPtr)
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
      }

      /* Retain channel output when counter is disabled or stopped */
      Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
      
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
      /* Set software trigger command */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
    /* Update dutycycle at the end of current period */
    else
    {
      /* Enter critical section */
      Pwm_EnterCriticalSection();
     /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, EndPeriodFlag);
      if(PWM_TRUE == AutoReloadFlag)
      {
        /* Set software trigger command */
        Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
      }
      else
      {
        /* Check if channel is waiting update */
        if(PWM_FALSE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr))
        {
          /* Set software trigger command */
          Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
        }
      }
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
  }
}

/** \brief Pwm_SetDutyCycleBufferInternal
 **
 ** Sets new duty cycle value to the buffer register of PWM channel.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] DutyCycle       Duty cycle to be set to the buffer register.
 */
FUNC(void, PWM_CODE) Pwm_SetDutyCycleBufferInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(uint16, AUTOMATIC) DutyCycle
)
{ 
  VAR(uint16, AUTOMATIC) PreDutyCycle;

  /* Save prior duty cycle */
  PreDutyCycle = ChannelPtr->ChannelStatePtr->DutyCycle;
  /* Update duty value */
  ChannelPtr->ChannelStatePtr->DutyCycle = DutyCycle;
  
  /* Checks the precondition for the values and performs update to DutyCycle */
  Pwm_LimitInterval(ChannelPtr);

  /* Check if notification is enable */
  if (PWM_CH_STATE_NOTIFY == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_NOTIFY))
  {
    /* Current DutyCycle is 0% or 100% */
    if ((PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle) || 
        (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle))
    {
       Pwm_RaDisableNotification(ChannelPtr->BaseAddress);
    }
    /* Prior DutyCycle is 0% or 100% */
    else if((PWM_DUTY_0_PERCENTAGE == PreDutyCycle) || (PWM_DUTY_100_PERCENTAGE == PreDutyCycle))
    {
      /* Enable notification */
      Pwm_RaEnableNotification(ChannelPtr);
    }
    else
    {
      /* Do nothing */
    }
  }
}

/** \brief Pwm_SetPeriodAndDutyInternal
 **
 ** Sets the PWM channel to a new period and duty cycle.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] PeriodTicks     Period ticks of the PWM signal: 
 **                             Minimum=0x0000, Maximum=0xFFFE.
 ** \param [in] DutyCycle       Duty cycle to be set.
 ** \param [in] EndPeriodFlag   Enable/disable the update of the period
 **                             at the end of the current period.
 ** \param [in] AutoReloadFlag  Enable/disable the reload of the channel
 **                             when the channel is in waiting update state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetPeriodAndDutyInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(uint16, AUTOMATIC) DutyCycle,
  VAR(boolean, AUTOMATIC) EndPeriodFlag,
  VAR(boolean, AUTOMATIC) AutoReloadFlag
)
{
  VAR(uint16, AUTOMATIC) PreDutyCycle;
  VAR(Pwm_PeriodType, AUTOMATIC) PrePeriodTicks;
  VAR(boolean, AUTOMATIC) WaitingStatus;

  /* Save prior duty cycle */
  PreDutyCycle = ChannelPtr->ChannelStatePtr->DutyCycle;
  /* Save prior period ticks */
  PrePeriodTicks = ChannelPtr->ChannelStatePtr->PeriodTicks;
  /* Update period ticks */
  ChannelPtr->ChannelStatePtr->PeriodTicks = PeriodTicks;
  /* Update duty cycle */
  ChannelPtr->ChannelStatePtr->DutyCycle = DutyCycle;
  
  /* Checks the precondition for the values and performs update to PeriodTicks and DutyCycle */
  Pwm_LimitInterval(ChannelPtr);
  /* OutputOffsetScaled enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetScaled)
  {
    /* Update output offset ticks value */
    ChannelPtr->ChannelStatePtr->OutputOffsetTicks = (ChannelPtr->ChannelStatePtr->OutputOffsetTicks *
                                                      ChannelPtr->ChannelStatePtr->PeriodTicks) / PrePeriodTicks;
  }

  /* HwTriggerOutputScaled enable */
  if (PWM_TRUE == ChannelPtr->HwTriggerOutputScaled)
  {
    /* Update trigger ticks value */
    ChannelPtr->ChannelStatePtr->TriggerTicks = (ChannelPtr->ChannelStatePtr->TriggerTicks *
                                                 ChannelPtr->ChannelStatePtr->PeriodTicks) / PrePeriodTicks;
  }

  /* Check if notification is enable */
  if (PWM_CH_STATE_NOTIFY == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_NOTIFY))
  {
    /* Current DutyCycle is 0% or 100% */
    if ((PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle) ||
        (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle))
    {
       Pwm_RaDisableNotification(ChannelPtr->BaseAddress);
    }
    /* Prior DutyCycle is 0% or 100% */
    else if ((PWM_DUTY_0_PERCENTAGE == PreDutyCycle) || (PWM_DUTY_100_PERCENTAGE == PreDutyCycle))
    {
      /* Enable notification */
      Pwm_RaEnableNotification(ChannelPtr);
    }
    else
    {
      /* Do nothing */
    }
  }

  /* Check if channel is in start state */
  if (0u == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
  {
    if(PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
    {
      /* Update timer */
      Pwm_UpdateStoppedChannel(ChannelPtr, PWM_FALSE);
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Set channel disable mode */
      Pwm_SetDisableModeInternal(ChannelPtr, PWM_FALSE);
      /* Start Channel */
      Pwm_StartChannel(ChannelPtr, PWM_FALSE);
    }
    else
    {
      /* Update timer */
      Pwm_UpdateStoppedChannel(ChannelPtr, PWM_TRUE);
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Set channel disable mode */
      Pwm_SetDisableModeInternal(ChannelPtr, PWM_TRUE);
      /* Start Channel */
      Pwm_StartChannel(ChannelPtr, PWM_TRUE);
    }
    /* Exit critical section */
    Pwm_ExitCriticalSection();
    /* Set channel start status flag */
    ChannelPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_STARTED;
  }
  else
  {
    /* Get waiting update state */
    WaitingStatus = Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr);
    /* Update dutycycle at current period or waiting update */
    if ((PWM_FALSE == EndPeriodFlag) || ((PWM_TRUE == WaitingStatus) && (PWM_TRUE == AutoReloadFlag)))
    {
      /* Check if delay timer is valid */
      if(NULL_PTR != ChannelPtr->DelayConfigPtr)
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
      }

      /* Retain channel output when counter is disabled or stopped */
      Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
      
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
      /* Set software trigger command */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
    /* Update dutycycle at the end of current period */
    else
    {
      /* Enter critical section */
      Pwm_EnterCriticalSection();
     /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, EndPeriodFlag);
      if(PWM_TRUE == AutoReloadFlag)
      {
        /* Set software trigger command */
        Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
      }
      else
      {
        /* Check if channel is waiting update */
        if(PWM_FALSE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr))
        {
          /* Set software trigger command */
          Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
        }
      }
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
  }
}

/** \brief Pwm_GetDriverStatus
 **
 ** Provides current driver status.
 **
 ** \return Driver status.
 */
FUNC(Pwm_DriverStatusType, PWM_CODE) Pwm_GetDriverStatus(void)
{
  return Pwm_DriverStatus;
}

/** \brief Pwm_SetDriverStatus
 ** 
 ** Sets current driver status.
 **
 ** \param [in] DrvStatus   Sets current driver status.
 */
FUNC(void, PWM_CODE) Pwm_SetDriverStatus
(
  VAR(Pwm_DriverStatusType, AUTOMATIC) DrvStatus
)
{
  Pwm_DriverStatus = DrvStatus;
}

/** \brief Pwm_InterruptHandlerInternal
 **
 ** Generic interrupt handler that is called from specific interrupt handlers.
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_InterruptHandlerInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(uint32, AUTOMATIC) DutyMatchIntFlag;
  VAR(uint32, AUTOMATIC) PeriodMatchIntFlag;
  VAR(uint32, AUTOMATIC) InterruptPendingFlag;

  /* Get interrupt pending flag */
  InterruptPendingFlag = Pwm_RaGetInterruptPendingFlag(ChannelPtr->BaseAddress);
  /* Clear the interrupt flag by base address */
  Pwm_RaClearInterruptFlag(ChannelPtr->BaseAddress);

  /* Check channel notification status */
  if ((0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_NOTIFY)) &&
      (NULL_PTR != ChannelPtr->NotifyFunction))
  {
    /* Output offset is enable */
    if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
    {
      DutyMatchIntFlag = PWM_TCPWM_INTR_MASKED_CC1_MATCH;
      PeriodMatchIntFlag = PWM_TCPWM_INTR_MASKED_CC0_MATCH;
    }
    /* Output offset is disable */
    else
    {
      DutyMatchIntFlag = PWM_TCPWM_INTR_MASKED_CC0_MATCH;
      PeriodMatchIntFlag = PWM_TCPWM_INTR_MASKED_TC;
    }

    /* Check interrupt pending flag */
    if (0u != (InterruptPendingFlag & DutyMatchIntFlag))
    {
       if ((PWM_END_OF_DUTY == ChannelPtr->ChannelStatePtr->NotifyReason) ||
           (PWM_END_OF_BOTH == ChannelPtr->ChannelStatePtr->NotifyReason))
       {
         /* Call notification function */
         (ChannelPtr->NotifyFunction)();
       }
    }
    else if (0u != (InterruptPendingFlag & PeriodMatchIntFlag))
    {
       if ((PWM_END_OF_PERIOD == ChannelPtr->ChannelStatePtr->NotifyReason) ||
           (PWM_END_OF_BOTH == ChannelPtr->ChannelStatePtr->NotifyReason))
       {
         /* Call notification function */
         (ChannelPtr->NotifyFunction)();
       }
    }
    else
    {
      /* Do nothing */
    }
  }
}

/** \brief Pwm_StartGroupTriggerInternal
 **
 ** Start all PWM channels in specified channel group.
 **
 ** \param [in] ConfigDataPtr       Pointer to configuration set.
 ** \param [in] ChannelGroupNumber  Numeric identifier of channel group.
 **
 */
FUNC(void, PWM_CODE) Pwm_StartGroupTriggerInternal
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr,
  VAR(Pwm_ChannelGroupType, AUTOMATIC) ChannelGroupNumber
)
{
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelIdx;
  VAR(Pwm_ChannelType, AUTOMATIC) GrpChannel;
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  P2CONST(Pwm_DelayConfigType, AUTOMATIC, PWM_APPL_CONST) DelayPtr;
  P2CONST(Pwm_ChannelGroupConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelGroupPtr = 
    &(ConfigDataPtr->GroupConfigPtr[ChannelGroupNumber]);

  /* Start all channels in specified group */
  for (ChannelIdx = 0u; ChannelIdx < ChannelGroupPtr->NumberOfChannels; ChannelIdx++)
  {
    /* Get channel identifier */
    GrpChannel = ChannelGroupPtr->ChannelListPtr[ChannelIdx];
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[GrpChannel]);

    /* Check if channel is in start state */
    if (PWM_CH_STATE_STARTED == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
    {
      /* Clear channel start status flag */
      ChannelPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_STARTED);
    }
    
    /* Enter critical section */
    Pwm_EnterCriticalSection();

    /* Get delay timer config pointer */
    DelayPtr = ChannelPtr->DelayConfigPtr;

    /* Check if support start channel by hardware trigger */
    if (PWM_INVALID_TRIGGERVALUE != ChannelGroupPtr->InputTrigger)
    {
      if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
      {
        /* IdleState is high */
        if (PWM_HIGH == ChannelPtr->IdleState)
        {
          Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_HIGH);
        }
        /* IdleState is low */
        else
        {
          Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_LOW);
        }
      }
      else
      {
        /* Set channel disable mode */
        Pwm_SetDisableModeInternal(ChannelPtr, PWM_TRUE);
      }
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Set wait hardware trigger flag */
      ChannelPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_WAITHWTRIGGER;

      /* Check if delay timer is valid */
      if (NULL_PTR != DelayPtr)
      {
        if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
        {
          if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
          {
            /* Disable counter */
            Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_FALSE);
            /* Set hardware reload trigger, this should be set when counter disabled */
            Pwm_RaSetHwReloadTrigger(DelayPtr->DelayBaseAddress, ChannelGroupPtr->InputTrigger);
            /* Enable counter */
            Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
          }
        }
        else
        {
          /* Disable counter */
          Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_FALSE);
          /* Set hardware reload trigger, this should be set when counter disabled */
          Pwm_RaSetHwReloadTrigger(DelayPtr->DelayBaseAddress, ChannelGroupPtr->InputTrigger);
          /* Enable counter */
          Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
        }
      }

      /* Set hardware reload trigger, this should be set when counter disabled */
      Pwm_RaSetHwReloadTrigger(ChannelPtr->BaseAddress, ChannelGroupPtr->InputTrigger);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update ticks value on hardware */
      Pwm_UpdateStoppedChannel(ChannelPtr, PWM_TRUE);
    }
    else
    {
      /* Set channel disable mode */
      Pwm_SetDisableModeInternal(ChannelPtr, PWM_TRUE);
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);

      /* Check if delay timer is valid */
      if(NULL_PTR != DelayPtr)
      {
        if (PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
        {
          if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
          {
            /* Disable counter */
            Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_FALSE);
            /* Enable counter */
            Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
          }
        }
        else
        {
          /* Disable counter */
          Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_FALSE);
          /* Enable counter */
          Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
        }
      }

      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update timer */
      Pwm_UpdateStoppedChannel(ChannelPtr, PWM_TRUE);

      if(PWM_TRUE == ChannelPtr->GroupStartDelayEnable)
      {
        if (PWM_TRUE == ChannelPtr->MaxChannelIdInGroup)
        {
          /* Start Channel */
          Pwm_StartChannel(ChannelPtr, PWM_TRUE);
        }
        else
        {
          /* Start Channel */
          Pwm_StartChannel(ChannelPtr, PWM_FALSE);
        }
      }
      else
      {
        /* Start Channel */
        Pwm_StartChannel(ChannelPtr, PWM_TRUE);
      }
    }
    /* Exit critical section */
    Pwm_ExitCriticalSection();
    
    /* Set channel start status flag */
    ChannelPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_STARTED;
  }
}

/** \brief Pwm_StopGroupTriggerInternal
 **
 ** Stop all PWM channels in specified channel group.
 **
 ** \param [in] ConfigDataPtr       Pointer to configuration set.
 ** \param [in] ChannelGroupNumber  Numeric identifier of channel group.
 **
 */
FUNC(void, PWM_CODE) Pwm_StopGroupTriggerInternal
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr,
  VAR(Pwm_ChannelGroupType, AUTOMATIC) ChannelGroupNumber
)
{
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelIdx;
  VAR(Pwm_ChannelType, AUTOMATIC) GrpChannel;
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelCfgPtr;
  P2CONST(Pwm_ChannelGroupConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelGroupPtr = 
    &(ConfigDataPtr->GroupConfigPtr[ChannelGroupNumber]);

  /* Stop all channels in specified group */
  for (ChannelIdx = 0u; ChannelIdx < ChannelGroupPtr->NumberOfChannels; ChannelIdx++)
  {
    /* Get channel identifier */
    GrpChannel = ChannelGroupPtr->ChannelListPtr[ChannelIdx];
    /* Get config pointer for specified channel */
    ChannelCfgPtr = &(ConfigDataPtr->ChannelConfigPtr[GrpChannel]);
    /* Clear channel start status flag */
    ChannelCfgPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_STARTED);
    
    /* IdleState is high */
    if (PWM_HIGH == ChannelCfgPtr->IdleState)
    {
      Pwm_RaSetDisableMode(ChannelCfgPtr->BaseAddress, PWM_DISABLEMODE_HIGH);
    }
    /* IdleState is low */
    else
    {
      Pwm_RaSetDisableMode(ChannelCfgPtr->BaseAddress, PWM_DISABLEMODE_LOW);
    }
    
    /* Check if support stop group by hardware trigger */
    if (PWM_INVALID_TRIGGERVALUE == ChannelCfgPtr->InputStopTrigger)
    {
      /* Check if delay timer is valid */
      if(NULL_PTR != ChannelCfgPtr->DelayConfigPtr)
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelCfgPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelCfgPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
      }

      /* Disable counter */
      Pwm_RaEnableChannel(ChannelCfgPtr->BaseAddress, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelCfgPtr->BaseAddress, PWM_TRUE);
    }
    else
    {
      /* Set wait hardware trigger flag */
      ChannelCfgPtr->ChannelStatePtr->Flags |= PWM_CH_STATE_WAITHWTRIGGER;
    }
  }
}

/** \brief Pwm_SetOutputOffsetInternal
 **
 ** Set output offset ticks value for the specified channel.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] OffsetTick      Tick time to offset output.
 ** \param [in] AutoReloadFlag  Enable/disable the reload of the channel
 **                             when the channel is in waiting update state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetOutputOffsetInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) OffsetTick,
  VAR(boolean, AUTOMATIC) AutoReloadFlag
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickValue;

  /* Update offset ticks */
  ChannelPtr->ChannelStatePtr->OutputOffsetTicks = OffsetTick;
  
  /* Set registers only when running */
  /* Check if channel is in start state */
  if (PWM_CH_STATE_STARTED == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
  {
    /* Get period tick register value */
    PeriodTickValue = Pwm_GetPeriodTickValue(ChannelPtr);
    /* Get duty tick register value */
    DutyTickValue = Pwm_GetCC0TickValue(ChannelPtr);
    /* Get trigger tick register value */
    TriggerTickValue = Pwm_GetCC1TickValue(ChannelPtr);

    /* Check if channel is waiting update */
    if ((PWM_TRUE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr)) && (PWM_TRUE == AutoReloadFlag))
    {
      /* Check if delay timer is valid */
      if(NULL_PTR != ChannelPtr->DelayConfigPtr)
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
      }

      /* Retain channel output when counter is disabled or stopped */
      Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
      
      /* Enter critical section */
      Pwm_EnterCriticalSection();
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
      /* Set software trigger command */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
      /* Exit critical section */
      Pwm_ExitCriticalSection();
    }
    else
    {
      /* Perform timing parameter update to buffer register */
      Pwm_RaUpdateChannelBuff(ChannelPtr, PeriodTickValue, DutyTickValue, TriggerTickValue);

      if(PWM_TRUE == AutoReloadFlag)
      {
        /* Set software trigger command */
        Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
      }
      else
      {
        /* Check if channel is waiting update */
        if(PWM_FALSE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr))
        {
          /* Set software trigger command */
          Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
        }
      }
    }
  }
}

/** \brief Pwm_SetTriggerDelayInternal
 **
 ** Set delay time for output trigger.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] TriggerTicks    Delay time for output trigger.
 ** \param [in] AutoReloadFlag  Enable/disable the reload of the channel
 **                             when the channel is in waiting update state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetTriggerDelayInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks,
  VAR(boolean, AUTOMATIC) AutoReloadFlag
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickRegValue;
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickRegValue;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickRegValue;

  /* Update output trigger ticks value */
  ChannelPtr->ChannelStatePtr->TriggerTicks = TriggerTicks;

  /* Set registers only during running */
  /* Check if channel is in start state */
  if (PWM_CH_STATE_STARTED == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
  {
    /* Check if delay timer is valid */
    if(NULL_PTR != ChannelPtr->DelayConfigPtr)
    {
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
    }

    /* Get trigger tick value to be set in register cc1 and set match up down enable status */
    TriggerTickRegValue = Pwm_GetTriggerTickValue(ChannelPtr);
    /* Get period tick register value */
    PeriodTickRegValue = Pwm_GetPeriodTickValue(ChannelPtr);
    /* Get duty tick register value */
    DutyTickRegValue = Pwm_GetDutyTickValue(ChannelPtr);
    /* Update buff register value to avoid miss exchange */
    Pwm_RaUpdateChannelBuff(ChannelPtr, PeriodTickRegValue, DutyTickRegValue, TriggerTickRegValue);
    /* Enter critical section */
    Pwm_EnterCriticalSection();
    /* Center alignment */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Set cc1 match up down enable status on hardware */
      Pwm_RaUpdateCcMatchEvent(ChannelPtr);
    }

    /* Check if channel is waiting update */
    if ((PWM_TRUE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr)) && (PWM_TRUE == AutoReloadFlag))
    {
      /* Retain channel output when counter is disabled or stopped */
      Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
      
      /* Disable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
      /* Enable counter */
      Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      /* Update running channel */
      Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
      /* Set software trigger command */
      Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
    }
    else
    {
      if(PWM_TRUE == AutoReloadFlag)
      {
        /* Set software trigger command */
        Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
      }
      else
      {
        /* Check if channel is waiting update */
        if(PWM_FALSE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr))
        {
          /* Set software trigger command */
          Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_CAPTURE0_TRIGGER);
        }
      }
    }
    /* Exit critical section */
    Pwm_ExitCriticalSection();
  }
}

/** \brief Pwm_SetPrescalerInternal
 **
 ** Calculate prescaler value and update value on hardware.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] ClockFrequency  Input clock frequency.
 **
 ** \return If calculated prescaler value is valid, return PWM_TRUE,
 **         else return PWM_FALSE.
 **
 */
FUNC(boolean, PWM_CODE) Pwm_SetPrescalerInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  VAR(boolean, AUTOMATIC) CheckResult;
  VAR(uint8, AUTOMATIC) PreValue;

  /* Check clock frequency and get prescaler value */
  PreValue = Pwm_GetPrescalerValue(ChannelPtr->TickFrequency, ClockFrequency);

  /* Check if calculated PreValue is invalid */
  if (PWM_INVALID_PRESCALER == PreValue)
  {
    CheckResult = PWM_FALSE;
  }
  /* PreValue is valid */
  else
  {
    CheckResult = PWM_TRUE;
    /* PreValue equals to current register value */
    if (ChannelPtr->ChannelStatePtr->PrescalerRegisterValue != PreValue)
    {
      /* Update prescaler value */
      ChannelPtr->ChannelStatePtr->PrescalerRegisterValue = PreValue;
      /* Check if channel is in start state */
      if (PWM_CH_STATE_STARTED == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
      {
        /* Check if delay timer is valid */
        if(NULL_PTR != ChannelPtr->DelayConfigPtr)
        {
          /* Disable counter */
          Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_FALSE);
          /* Enable counter */
          Pwm_RaEnableChannel(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_TRUE);
        }

        /* Retain channel output when counter is disabled or stopped */
        Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, PWM_DISABLEMODE_RETAIN);
        /* Enter critical section */
        Pwm_EnterCriticalSection();
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
        /* Set prescaler value */
        Pwm_RaSetPrescalerValue(ChannelPtr);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
        /* Update running channel */
        Pwm_UpdateRunningChannel(ChannelPtr, PWM_FALSE);
        /* Set software trigger command */
        Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);
        /* Exit critical section */
        Pwm_ExitCriticalSection();
      }
      else
      {
        /* Disable counter */
        Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_FALSE);
        /* Set prescaler value */
        Pwm_RaSetPrescalerValue(ChannelPtr);
        /* Enable counter */
        Pwm_RaEnableChannel(ChannelPtr->BaseAddress, PWM_TRUE);
      }
    }
  }

  return CheckResult;
}

/** \brief Pwm_GetChannelStatusInternal
 **
 ** Internal implementation: Reads and verifies the current status of a channel.
 **
 ** \param [out] ChannelStatusPtr  Pointer to where to store the current channel
 **                                specific status parameters.
 ** \param [in]  ChannelPtr        Pointer to the channel configuration.
 **
 ** \return PWM_TRUE: Software and hardware states are in sync.
 **         PWM_FALSE: Software and hardware states are inconsistent.
 **
 */
FUNC(boolean, PWM_CODE) Pwm_GetChannelStatusInternal
(
  P2VAR(Pwm_ChannelStatusType, AUTOMATIC, PWM_APPL_DATA) ChannelStatusPtr,
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(boolean, AUTOMATIC) StatusGood = PWM_TRUE;

  /* Copy channel status */
  ChannelStatusPtr->ChannelId = ChannelPtr->ChannelId;
  ChannelStatusPtr->DelayTicks = ChannelPtr->ChannelStatePtr->DelayTicks;
  ChannelStatusPtr->OutputOffsetTicks = ChannelPtr->ChannelStatePtr->OutputOffsetTicks;
  ChannelStatusPtr->DutyCycle = ChannelPtr->ChannelStatePtr->DutyCycle;
  ChannelStatusPtr->TriggerTicks = ChannelPtr->ChannelStatePtr->TriggerTicks;
  ChannelStatusPtr->PeriodTicks = ChannelPtr->ChannelStatePtr->PeriodTicks;
  ChannelStatusPtr->Prescaler = ChannelPtr->ChannelStatePtr->PrescalerRegisterValue;
  ChannelStatusPtr->Status = 0u;

  /* Set notification status */
  if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_NOTIFY))
  {
    ChannelStatusPtr->NotificationEnabled = PWM_TRUE;
  }
  else
  {
    ChannelStatusPtr->NotificationEnabled = PWM_FALSE;
  }
  /* Set trigger status */
  if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_TRIGGER))
  {
    ChannelStatusPtr->TriggerEnabled = PWM_TRUE;
  }
  else
  {
    ChannelStatusPtr->TriggerEnabled = PWM_FALSE;
  }

  /* Driver initialized */
  if (PWM_S_INITIALIZED == Pwm_DriverStatus)
  {
    /* Compare SW state with HW state */
    /* Check if channel is in start state */
    /* Channel is not in start state */
    if (0u == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
    {
      StatusGood = Pwm_CheckChannelState_Idle(ChannelStatusPtr, ChannelPtr);
    }
    /* Channel is in start state */
    else
    {
      StatusGood = Pwm_CheckChannelState_Started(ChannelStatusPtr, ChannelPtr);
    }
    /* Check NOTIFY state */
    if (PWM_TRUE == StatusGood)
    {
      StatusGood = Pwm_CheckChannelState_Notify(ChannelPtr);
    }
  }
  /* Driver uninitialized */
  else
  {
    /* Check channel enable state */
    if (PWM_FALSE != Pwm_RaCheckChannelStatus_Enable(ChannelPtr->BaseAddress))
    {
      StatusGood = PWM_FALSE;
    }
  }

  return StatusGood;
}

/** \brief Pwm_ClearChannelInterruptByBaseAddr
 **
 ** Clear the interrupt flag by base address of HW timer.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 */
FUNC(void, PWM_CODE) Pwm_ClearChannelInterruptByBaseAddr
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  Pwm_RaClearInterruptFlag(BaseAddress);
}

/** \brief Pwm_CheckDutyCycleInternal
 **
 ** Check duty cycle range.
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 ** \param [in] PeriodTicks  Period tick of the PWM signal.
 ** \param [in] DutyCycle    Duty cycle to be check.
 **
 ** \return Return PWM_TRUE if duty cycle is in valid range, 
 **                PWM_FALSE otherwise.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckDutyCycleInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(uint16, AUTOMATIC) DutyCycle
)
{
  VAR(boolean, AUTOMATIC) CheckResult;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks;
  VAR(Pwm_PeriodType, AUTOMATIC) NewTriggerTicks;
  VAR(Pwm_PeriodType, AUTOMATIC) NewOffsetTicks;
  VAR(boolean, AUTOMATIC) MaskFlag;

  /* Check if DutyCycle is out of range */
  if (DutyCycle > PWM_DUTY_100_PERCENTAGE)
  {
    CheckResult = PWM_FALSE;
  }
  else
  {
    /* Calculate duty ticks value */
    DutyTicks = (PeriodTicks * DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
    /* Get channel masked status using current duty ticks and period ticks */
    MaskFlag = Pwm_CheckChannelMaskStatus(ChannelPtr, PeriodTicks, DutyTicks);
    
    /* Channel not masked */
    if (PWM_FALSE == MaskFlag)
    {
      /* Check if output offset is enable */
      if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
      {
        /* OutputOffsetScaled enable */
        if (PWM_TRUE == ChannelPtr->OutputOffsetScaled)
        {
          /* Calculate new offset ticks */
          NewOffsetTicks = (ChannelPtr->ChannelStatePtr->OutputOffsetTicks * PeriodTicks) / 
                           ChannelPtr->ChannelStatePtr->PeriodTicks;
        }
        /* OutputOffsetScaled disable */
        else
        {
          NewOffsetTicks = ChannelPtr->ChannelStatePtr->OutputOffsetTicks;
        }
        CheckResult = Pwm_CheckDutyAndOffsetTick(ChannelPtr, 
                                                 PeriodTicks, 
                                                 DutyTicks, 
                                                 NewOffsetTicks);
      }
      /* Check if channel support set output trigger */
      else if (PWM_TRIGGER_DISABLE != ChannelPtr->TriggerOutputSelect)
      {
        /* HwTriggerOutputScaled enable */
        if (PWM_TRUE == ChannelPtr->HwTriggerOutputScaled)
        {
          /* Calculate new trigger ticks */
          NewTriggerTicks = (ChannelPtr->ChannelStatePtr->TriggerTicks * PeriodTicks) / 
                             ChannelPtr->ChannelStatePtr->PeriodTicks;
        }
        /* HwTriggerOutputScaled disable */
        else
        {
          NewTriggerTicks = ChannelPtr->ChannelStatePtr->TriggerTicks;
        }
        /* Check duty ticks and trigger ticks value */
        CheckResult = Pwm_CheckDutyAndTrigger(ChannelPtr, 
                                              PeriodTicks, 
                                              DutyTicks, 
                                              NewTriggerTicks);
      }
      else
      {
        CheckResult = PWM_TRUE;
      }
    }
    /* Channel is masked */
    else
    {
      CheckResult = PWM_TRUE;
    }
  }

  return CheckResult;
}

/** \brief Pwm_CheckPeriodInternal
 **
 ** Check period range.
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 ** \param [in] PeriodTicks  Period in ticks to be check.
 ** \param [in] DutyCycle    Duty cycle value.
 **
 ** \return Return PWM_TRUE if PeriodTicks is in valid range, 
 **         PWM_FALSE otherwise.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckPeriodInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(uint16, AUTOMATIC) DutyCycle
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks;
  VAR(Pwm_PeriodType, AUTOMATIC) OutputTriggerTicks;
  VAR(boolean, AUTOMATIC) MaskFlag;
  VAR(boolean, AUTOMATIC) CheckResult = PWM_TRUE;

  /* Calculate duty ticks value */
  DutyTicks = (PeriodTicks * DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
  /* Get trigger ticks value */
  OutputTriggerTicks = ChannelPtr->ChannelStatePtr->TriggerTicks;
  /* Get channel masked status using current duty ticks and period ticks */
  MaskFlag = Pwm_CheckChannelMaskStatus(ChannelPtr, PeriodTicks, DutyTicks);

  if ((PWM_TRUE == ChannelPtr->OutputOffsetEnable) && (PWM_FALSE == ChannelPtr->OutputOffsetScaled))
  {
    /* Channel is masked */
    if (PWM_TRUE == MaskFlag)
    {
      if (PeriodTicks <= ChannelPtr->ChannelStatePtr->OutputOffsetTicks)
      {
        CheckResult = PWM_FALSE;
      }
    }
  }
  else if ((PWM_TRIGGER_DISABLE != ChannelPtr->TriggerOutputSelect) && (PWM_FALSE == ChannelPtr->HwTriggerOutputScaled))
  {
    if (PWM_FALSE == Pwm_CheckPeriodAndTrigger(ChannelPtr, PeriodTicks, DutyTicks, OutputTriggerTicks, MaskFlag))
    {
      CheckResult = PWM_FALSE;
    }
  }
  else
  {
    CheckResult = PWM_TRUE;
  }

  return CheckResult;
}

/** \brief Pwm_CheckTriggerTicksInternal
 **
 ** Check output trigger ticks range.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** \param [in] TriggerTicks  Delay time for output trigger.
 ** 
 ** \return PWM_TRUE if output trigger ticks is in valid range, 
 **         PWM_FALSE otherwise.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckTriggerTicksInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks
)
{
  VAR(boolean, AUTOMATIC) CheckResult;
  VAR(boolean, AUTOMATIC) MaskFlag;
  /* Get current period tick value */
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue = ChannelPtr->ChannelStatePtr->PeriodTicks;
  /* Get current duty tick value */
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks = (PeriodTickValue * ChannelPtr->ChannelStatePtr->DutyCycle)
                                            >> PWM_DUTY_CYCLETOTICK_SHIFT;
  /* Get channel masked status using current duty ticks and period ticks */
  MaskFlag = Pwm_CheckChannelMaskStatus(ChannelPtr, PeriodTickValue, DutyTicks);
  
  if (PWM_FALSE == Pwm_CheckPeriodAndTrigger(ChannelPtr, PeriodTickValue, DutyTicks, TriggerTicks, MaskFlag))
  {
    CheckResult = PWM_FALSE;
  }
  else
  {
    if (PWM_FALSE == MaskFlag)
    {
      if (PWM_FALSE == Pwm_CheckDutyAndTrigger(ChannelPtr, PeriodTickValue, DutyTicks, TriggerTicks))
      {
        CheckResult = PWM_FALSE;
      }
      else
      {
        CheckResult = PWM_TRUE;
      }
    }
    else
    {
        CheckResult = PWM_TRUE;
    }
  }
  return CheckResult;
}

/** \brief Pwm_CheckChannelStatus_Running
 **
 ** Check whether channel is in running state.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** 
 ** \return PWM_TRUE if channel is in running state, 
 **         PWM_FALSE otherwise.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckChannelStatus_Running
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(boolean, AUTOMATIC) RunnningState;
  
  /* Check SW running status */
  if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
  {
    RunnningState = PWM_TRUE;
  }
  else
  {
    RunnningState = PWM_FALSE;
  }
  
  return RunnningState;
}

/** \brief Pwm_CheckOutputOffsetInternal
 **
 ** Check if OffsetTick is in valid range.
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 ** \param [in] OffsetTick   Offset time for PWM output.
 **
 ** \return     PWM_TRUE:  OffsetTick is valid value.
 **             PWM_FALSE: OffsetTick is invalid value.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckOutputOffsetInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) OffsetTick
)
{
  VAR(boolean, AUTOMATIC) CheckResult;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks;
  
  /* Duty cycle is not 0% and 100% */
  if ((PWM_DUTY_100_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle) && 
      (PWM_DUTY_0_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle))
  {
    /* Duty tick value */
    DutyTicks = (ChannelPtr->ChannelStatePtr->PeriodTicks * 
                 ChannelPtr->ChannelStatePtr->DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
    /* Check OffsetTick */
    CheckResult = Pwm_CheckDutyAndOffsetTick(ChannelPtr, 
                                             ChannelPtr->ChannelStatePtr->PeriodTicks, 
                                             DutyTicks, 
                                             OffsetTick);
  }
  /* Duty cycle is 0% or 100% */
  else 
  {
    if (OffsetTick >= ChannelPtr->ChannelStatePtr->PeriodTicks)
    {
      CheckResult = PWM_FALSE;
    }
    else
    {
      CheckResult = PWM_TRUE;
    }
  }
  return CheckResult;
}

/** \brief Pwm_CheckChannelStatus_WaitingTrigger
 **
 ** Check whether channel is in waiting HW start/stop trigger state.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** 
 ** \return  PWM_TRUE: Channel is waiting HW start/stop trigger.
 **          PWM_FALSE: Channel is not waiting HW start/stop trigger.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckChannelStatus_WaitingTrigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(boolean, AUTOMATIC) result;
  
  /* Check SW status */
  if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_STARTED))
  {
    /* Check HW status */
    if (PWM_TRUE != Pwm_RaCheckWaitingTrigger_Running(ChannelPtr->BaseAddress))
    {
      result = PWM_TRUE;
    }
    else
    {
      result = PWM_FALSE;
      /* Clear wait hardware trigger flag */
      ChannelPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_WAITHWTRIGGER);
    }
  }
  else
  {
    /* Check HW status */
    if (PWM_TRUE != Pwm_RaCheckChannelStatus_Stop(ChannelPtr->BaseAddress))
    {
      result = PWM_TRUE;
    }
    else
    {
      result = PWM_FALSE;
      /* Clear wait hardware trigger flag */
      ChannelPtr->ChannelStatePtr->Flags &= ((uint8)~PWM_CH_STATE_WAITHWTRIGGER);
    }
  }
  return result;
}

/** \brief Pwm_CheckGroupChannelsStatus_WaitingTrigger
 **
 ** Check whether channels in specified channel group are in waiting HW start/stop trigger state.
 **
 ** \param [in] ConfigDataPtr       Pointer to configuration set.
 ** \param [in] ChannelGroupNumber  Numeric identifier of channel group.
 ** 
 ** \return  PWM_TRUE: Channels in specified channel group are waiting HW start/stop trigger.
 **          PWM_FALSE: All channels in specified channel group are not waiting HW start/stop trigger.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckGroupChannelsStatus_WaitingTrigger
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr,
  VAR(Pwm_ChannelGroupType, AUTOMATIC) ChannelGroupNumber
)
{
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelIdx;
  VAR(Pwm_ChannelType, AUTOMATIC) GrpChannel;
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  P2CONST(Pwm_ChannelGroupConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelGroupPtr = 
    &(ConfigDataPtr->GroupConfigPtr[ChannelGroupNumber]);
  VAR(boolean, AUTOMATIC) result = PWM_FALSE;
  
  /* All channels in specified channel group */
  for (ChannelIdx = 0u; ChannelIdx < ChannelGroupPtr->NumberOfChannels; ChannelIdx++)
  {
    /* Get channel identifier */
    GrpChannel = ChannelGroupPtr->ChannelListPtr[ChannelIdx];
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[GrpChannel]);
    
    if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      result = PWM_TRUE;
      break;
    }
  }

  return result;
}

/** \brief Pwm_CheckGroupPrescalerValue
 **
 ** Check whether channels in specified channel group have inconsistent prescaler value.
 **
 ** Preconditions: PwmGroupStartDelay is enable.
 **
 ** \param [in] ConfigDataPtr       Pointer to configuration set.
 ** \param [in] ChannelGroupNumber  Numeric identifier of channel group.
 ** 
 ** \return  PWM_TRUE: Channels in specified channel group have inconsistent prescaler value.
 **          PWM_FALSE: Channels in specified channel group have consistent prescaler value.
 */
FUNC(boolean, PWM_CODE) Pwm_CheckGroupPrescalerValue
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr,
  VAR(Pwm_ChannelGroupType, AUTOMATIC) ChannelGroupNumber
)
{
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelIdx;
  VAR(Pwm_ChannelType, AUTOMATIC) GrpChannel;
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  P2CONST(Pwm_ChannelGroupConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelGroupPtr = 
    &(ConfigDataPtr->GroupConfigPtr[ChannelGroupNumber]);
  VAR(boolean, AUTOMATIC) result = PWM_FALSE;
  VAR(uint8, AUTOMATIC) PrescalerValue = 0xFFu;

  /* All channels in specified channel group */
  for (ChannelIdx = 0u; ChannelIdx < ChannelGroupPtr->NumberOfChannels; ChannelIdx++)
  {
    /* Get channel identifier */
    GrpChannel = ChannelGroupPtr->ChannelListPtr[ChannelIdx];
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[GrpChannel]);

    if ((PWM_TRUE == ChannelPtr->GroupStartDelayEnable) && (NULL_PTR != ChannelPtr->DelayConfigPtr))
    {
      /* Check whether channels in specified channel group have inconsistent prescaler value */
      if (PrescalerValue == 0xFFu)
      {
        PrescalerValue = ChannelPtr->ChannelStatePtr->PrescalerRegisterValue;
      }
      if (PrescalerValue != ChannelPtr->ChannelStatePtr->PrescalerRegisterValue )
      {
        result = PWM_TRUE;
        break;
      }
    }
  }

  return result;
}

#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[internal function definitions]==========================*/

#define PWM_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/** \brief Pwm_TranslateNotificationToInterrupt
 **
 **  Transforms the notification reason into the more sophisticated
 **  HW interrupt reason(Output offset disable):
 **    ActiveOutput  Notification   return
 **  left aligned
 **    PWM_LOW       FALLING        end of PERIOD(tc)
 **    PWM_HIGH      FALLING        end of DUTY(cc0 match)
 **    PWM_LOW       RISING         end of DUTY(cc0 match)
 **    PWM_HIGH      RISING         end of PERIOD(tc)
 **    any           BOTH           end of both(tc and cc0 match)
 **  right aligned
 **    PWM_LOW       FALLING        end of DUTY(cc0 match)
 **    PWM_HIGH      FALLING        end of PERIOD(tc)
 **    PWM_LOW       RISING         end of PERIOD(tc)
 **    PWM_HIGH      RISING         end of DUTY(cc0 match)
 **    any           BOTH           end of both(tc and cc0 match)
 **  center aligned
 **    any           FALLING        Not support(return end of DUTY)
 **    any           RISING         Not support(return end of DUTY)
 **    any           BOTH           end of DUTY(cc0 match)
 **    note:cc0 match always detects both edges if center alignment
 **
 **  HW interrupt reason(Output offset enable):
 **    ActiveOutput  Notification   return
 **  left aligned
 **    PWM_LOW       FALLING        end of PERIOD(cc0 match)
 **    PWM_HIGH      FALLING        end of DUTY(cc1 match)
 **    PWM_LOW       RISING         end of DUTY(cc1 match)
 **    PWM_HIGH      RISING         end of PERIOD(cc0 match)
 **    any           BOTH           end of both(cc0 and cc1 match)
 **  center aligned
 **    any           FALLING        Not support(return end of DUTY)
 **    any           RISING         Not support(return end of DUTY)
 **    any           BOTH           end of both(cc0 match and cc1 match)
 **
 ** \param [in]  ChannelPtr    Pointer to the channel configuration.
 ** \param [in]  Notification  Type of notification 
 **                            PWM_RISING_EDGE or 
 **                            PWM_FALLING_EDGE or 
 **                            PWM_BOTH_EDGES.
 ** \return Converted interrupt reason type.
 */
static FUNC(Pwm_InterruptReasonType, PWM_CODE) Pwm_TranslateNotificationToInterrupt
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
)
{
  VAR(Pwm_InterruptReasonType, AUTOMATIC) TransResult;
  /* Both edges */
  if (PWM_BOTH_EDGES == Notification)
  {
    /* Center alignment(output offset is disable) */
    if ((PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment) && (PWM_FALSE == ChannelPtr->OutputOffsetEnable))
    {
      /* Both edges is independent of the polarity */
      TransResult = PWM_END_OF_DUTY;
    }
    /* Left alignment or right alignment or center alignment(output offset is enable) */
    else
    {
      /* Both edges is independent of the polarity */
      TransResult = PWM_END_OF_BOTH;
    }
  }
  /* Rising edge */
  else if (PWM_RISING_EDGE == Notification)
  {
    /* Active output is high */
    if (PWM_HIGH == ChannelPtr->ActiveOutput)
    {
      /* Right alignment */
      if (ChannelPtr->OutAlignment == PWM_RIGHT_ALIGNED)
      {
        TransResult = PWM_END_OF_DUTY;
      }
      else
      {
        TransResult = PWM_END_OF_PERIOD;
      }
    }
    /* Active output is low */
    else
    {
      /* Right alignment */
      if (ChannelPtr->OutAlignment == PWM_RIGHT_ALIGNED)
      {
        TransResult = PWM_END_OF_PERIOD;
      }
      else
      {
        TransResult = PWM_END_OF_DUTY;
      }
    }
  }
  /* Falling edge */
  else
  {
    /* Active output is high */
    if (PWM_HIGH == ChannelPtr->ActiveOutput)
    {
      /* Right alignment */
      if (ChannelPtr->OutAlignment == PWM_RIGHT_ALIGNED)
      {
        TransResult = PWM_END_OF_PERIOD;
      }
      else
      {
        TransResult = PWM_END_OF_DUTY;
      }
    }
    /* Active output is low */
    else
    {
      /* Right alignment */
      if (ChannelPtr->OutAlignment == PWM_RIGHT_ALIGNED)
      {
        TransResult = PWM_END_OF_DUTY;
      }
      else
      {
        TransResult = PWM_END_OF_PERIOD;
      }
    }
  }

  return TransResult;
}

/** \brief Pwm_DutyTickDetected
 **
 ** This function implements the duty limit detection.
 ** Duty tick shall be set according to alignment type.
 ** 
 ** Preconditions:
 ** - Channel state values for duty has to be updated before (API SetDutyCycle or
 **   SetPeriodAndDuty).
 **
 ** \param [in]   ChannelPtr  Pointer to the channel configuration.
 ** \param [out]  DutyLimitTickPtr  Pointer to duty tick value (shall be used after
 **                           calling this function).
 **
 ** \return Return PWM_TRUE if duty limit (0% or 100%) was detected,
 **         else return PWM_FALSE.
 **
 */
static FUNC(boolean, PWM_CODE) Pwm_DutyTickDetected
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  P2VAR(Pwm_PeriodType, AUTOMATIC, PWM_APPL_DATA) DutyLimitTickPtr
)
{
  VAR(boolean, AUTOMATIC) LimitDuty;

  /* Duty cycle is 100% */
  if (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle)
  {
    /* Left alignment */
    if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Disable cc0 match event generation */
      *DutyLimitTickPtr = Pwm_GetPeriodTickValue(ChannelPtr) + 1u;
    }
    /* Right alignment */
    else if (PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Enable cc0 match event generation */
      *DutyLimitTickPtr = Pwm_GetPeriodTickValue(ChannelPtr);
    }
    /* Center alignment */
    else
    {
      /* Enable cc0 match event generation */
      *DutyLimitTickPtr = 0u;
    }
    LimitDuty = PWM_TRUE;
  }
  /* Duty cycle is 0% */
  else if (PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle)
  {
    /* Left alignment */
    if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Enable cc0 match event generation */
      *DutyLimitTickPtr = 0u;
    }
    /* Right alignment */
    else if (PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Disable cc0 match event generation */
      *DutyLimitTickPtr = PWM_16BIT_TICK_MAX;
    }
    /* Center alignment */
    else
    {
      /* Disable cc0 match event generation */
      *DutyLimitTickPtr = Pwm_GetPeriodTickValue(ChannelPtr) + 1u;
    }
    LimitDuty = PWM_TRUE;
  }
  /* Duty cycle is not 0% and not 100% */
  else
  {
    LimitDuty = PWM_FALSE;
  }

  return LimitDuty;
}
/** \brief Pwm_CheckChannelState_Idle
 **
 ** Verifies register settings for channel state IDLE.
 **
 ** \param [in]  ChannelStatusPtr  Pointer to where to store the current 
 **                                channel specific status parameters.
 ** \param [in]  ChannelPtr        Pointer to the channel configuration.
 **
 ** \return Return PWM_TRUE if s/w and h/w status of channel are in sync,
 **         PWM_FALSE if not.
 **
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelState_Idle
(
  P2VAR(Pwm_ChannelStatusType, AUTOMATIC, PWM_APPL_DATA) ChannelStatusPtr,
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_OutputStateType, AUTOMATIC) OutputState;
  VAR(boolean, AUTOMATIC) StatusGood = PWM_TRUE;
  
  /* Set counter enable state */
  if (PWM_FALSE == Pwm_RaCheckChannelStatus_Stop(ChannelPtr->BaseAddress))
  {
    /* Check if channel is waiting hardware trigger */
    if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_WAITHWTRIGGER))
    {
      ChannelStatusPtr->Status |= (PWM_CH_COND_WAIT_HWTRIGGER | PWM_CH_COND_TIMER_ENABLED);
    }
    else
    {
      StatusGood = PWM_FALSE;
      ChannelStatusPtr->Status |= PWM_CH_COND_TIMER_ENABLED;
    }
  }
  else
  {
    ChannelStatusPtr->Status |= PWM_CH_COND_TIMER_DISABLED;
    
    OutputState = Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress);
    /* Set channel idle state */
    if (PWM_HIGH == OutputState)
    {
      ChannelStatusPtr->Status |= PWM_CH_COND_IDLE_HIGH;
    }
    else
    {
      ChannelStatusPtr->Status |= PWM_CH_COND_IDLE_LOW;
    }
    /* Check channel IdleState */
    if (ChannelPtr->IdleState != OutputState)
    {
      StatusGood = PWM_FALSE;
    }
  }

  return StatusGood;
}

/** \brief Pwm_CheckChannelState_Started
 **
 ** Verifies register settings for channel state STARTED.
 **
 ** \param [in]  ChannelStatusPtr  Pointer to where to store the current
 **                                channel specific status parameters.
 ** \param [in]  ChannelPtr        Pointer to the channel configuration.
 **
 ** \return Return PWM_TRUE if s/w and h/w status of channel are in sync,
 **         PWM_FALSE if not.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelState_Started
(
  P2VAR(Pwm_ChannelStatusType, AUTOMATIC, PWM_APPL_DATA) ChannelStatusPtr,
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue;
  VAR(uint8, AUTOMATIC) PrescalerValue;
  VAR(boolean, AUTOMATIC) StatusGood = PWM_TRUE;

  /* Set channel idle state */
  if (PWM_HIGH == ChannelPtr->IdleState)
  {
    ChannelStatusPtr->Status |= PWM_CH_COND_IDLE_HIGH;
  }
  else
  {
    ChannelStatusPtr->Status |= PWM_CH_COND_IDLE_LOW;
  }
  
  /* Set counter enable state */
  if (PWM_TRUE == Pwm_RaCheckChannelStatus_Running(ChannelPtr->BaseAddress))
  {
    ChannelStatusPtr->Status |= PWM_CH_COND_TIMER_ENABLED;

    /* Check if channel is waiting update */
    if (PWM_TRUE == Pwm_RaCheckChannelStatus_WaitingUpdate(ChannelPtr))
    {
      ChannelStatusPtr->Status |= PWM_CH_COND_WAIT_UPDATE;
    }
    /* Deviation from MISRA-C:2012 Rule-10.5, Rule-10.8
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4342, 4394 1 */
    else if (PWM_LINESTATE_PWM == (Pwm_OutputLineStateType)(ChannelPtr->ChannelStatePtr->LineSelBuff & PWM_LINESTATE_MASK))
    {
      /* Duty 100% */
      if (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle) 
      {
        /* Channel output is high */
        if (PWM_HIGH == Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress))
        {
          /* Active output is low */
          if (PWM_LOW == ChannelPtr->ActiveOutput)
          {
            StatusGood = PWM_FALSE;
          }
        }
        /* Channel output is low */
        else
        {
          /* Active output is high */
          if (PWM_HIGH == ChannelPtr->ActiveOutput)
          {
            StatusGood = PWM_FALSE;
          }
        }
      }
      /* Duty 0% */
      else if (PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle)
      { 
        /* Channel output is high */
        if(PWM_HIGH == Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress))
        { 
          /* Active output is high */
          if (PWM_HIGH == ChannelPtr->ActiveOutput)
          { 
            StatusGood = PWM_FALSE;
          }
        }
        /* Channel output is low */
        else
        {
          /* Active output is low */
          if (PWM_LOW == ChannelPtr->ActiveOutput)
          {
            StatusGood = PWM_FALSE;
          }
        }
      }
      else
      {
        /* Do nothing */
      }
    }
    /* Deviation from MISRA-C:2012 Rule-10.5, Rule-10.8
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4342, 4394 1 */
    else if (PWM_LINESTATE_PWM_INV == (Pwm_OutputLineStateType)(ChannelPtr->ChannelStatePtr->LineSelBuff & PWM_LINESTATE_MASK))
    {
      /* Duty 100% */
      if (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle) 
      {
        /* Channel output is high */
        if(PWM_HIGH == Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress))
        { 
          /* Active output is high */
          if (PWM_HIGH == ChannelPtr->ActiveOutput)
          { 
            StatusGood = PWM_FALSE;
          }
        }
        /* Channel output is low */
        else
        {
          /* Active output is low */
          if (PWM_LOW == ChannelPtr->ActiveOutput)
          {
            StatusGood = PWM_FALSE;
          }
        }
      }
      /* Duty 0% */
      else if (PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle)
      { 
        /* Channel output is high */
        if (PWM_HIGH == Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress))
        {
          /* Active output is low */
          if (PWM_LOW == ChannelPtr->ActiveOutput)
          {
            StatusGood = PWM_FALSE;
          }
        }
        /* Channel output is low */
        else
        {
          /* Active output is high */
          if (PWM_HIGH == ChannelPtr->ActiveOutput)
          {
            StatusGood = PWM_FALSE;
          }
        }
      }
      else
      {
        /* Do nothing */
      }
    }
    /* Deviation from MISRA-C:2012 Rule-10.5, Rule-10.8
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4342, 4394 1 */
    else if (PWM_LINESTATE_HIGH == (Pwm_OutputLineStateType)(ChannelPtr->ChannelStatePtr->LineSelBuff & PWM_LINESTATE_MASK))
    { 
      /* Channel output is low */
      if (PWM_LOW == Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress))
      {
        StatusGood = PWM_FALSE;
      }
    }
    /* Deviation from MISRA-C:2012 Rule-10.5, Rule-10.8
       Justification: As a result of this expression, it will not exceed the essential type. */
    /* PRQA S 4342, 4394 1 */
    else if (PWM_LINESTATE_LOW == (Pwm_OutputLineStateType)(ChannelPtr->ChannelStatePtr->LineSelBuff & PWM_LINESTATE_MASK))
    { 
      /* Channel output is high */
      if (PWM_HIGH == Pwm_RaGetStatusLineOut(ChannelPtr->BaseAddress))
      {
        StatusGood = PWM_FALSE;
      }
    }
    else
    {
      /* Do nothing */
    }
  }
  else
  {
    /* Check if channel is waiting hardware trigger */
    if (0u != (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_WAITHWTRIGGER))
    {
      ChannelStatusPtr->Status |= (PWM_CH_COND_WAIT_HWTRIGGER|PWM_CH_COND_TIMER_DISABLED);
    }
    else
    {
      StatusGood = PWM_FALSE;
      ChannelStatusPtr->Status |= PWM_CH_COND_TIMER_DISABLED;
    }
  }

  /* Check period */
  /* Checks period and period buff because they may be exchanged */
  PeriodTickValue = Pwm_GetPeriodTickValue(ChannelPtr);
  /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
     Justification: This deviation is due to '&&' and '||' operator, but side effects cannot be caused. */
  /* PRQA S 3415 2 */
  if ((Pwm_RaGetPeriodBuff(ChannelPtr->BaseAddress) != PeriodTickValue) &&
      (Pwm_RaGetPeriod(ChannelPtr->BaseAddress) != PeriodTickValue))
  {
    StatusGood = PWM_FALSE;
  }

  /* Output offset is enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
  {
    DutyTickValue = Pwm_GetCC0TickValue(ChannelPtr);
    TriggerTickValue = Pwm_GetCC1TickValue(ChannelPtr);
  }
  /* Output offset is disable */
  else
  {
    DutyTickValue = Pwm_GetDutyTickValue(ChannelPtr);
    TriggerTickValue = Pwm_GetTriggerTickValue(ChannelPtr);
  }
  
  /* Checks cc0 buff and cc0 because they may be exchanged */
  /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
     Justification: This deviation is due to '&&' and '||' operator, but side effects cannot be caused. */
  /* PRQA S 3415 2 */
  if ((Pwm_RaGetCc0Buff(ChannelPtr->BaseAddress) != DutyTickValue) &&
      (Pwm_RaGetCc0(ChannelPtr->BaseAddress) != DutyTickValue))
  {
    StatusGood = PWM_FALSE;
  }

  /* Checks cc1 buff and cc1 because they may be exchanged */
  /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
     Justification: This deviation is due to '&&' and '||' operator, but side effects cannot be caused. */
  /* PRQA S 3415 2 */
  if ((Pwm_RaGetCc1Buff(ChannelPtr->BaseAddress) != TriggerTickValue) &&
      (Pwm_RaGetCc1(ChannelPtr->BaseAddress) != TriggerTickValue))
  {
    StatusGood = PWM_FALSE;
  }

  /* Check prescaler */
  PrescalerValue = Pwm_RaGetPrescaler(ChannelPtr->BaseAddress);
  if (PrescalerValue != ChannelPtr->ChannelStatePtr->PrescalerRegisterValue)
  {
    StatusGood = PWM_FALSE;
  }
  
  /* Check whether HW and SW trigger status are in sync */
  if (0u == (ChannelPtr->ChannelStatePtr->Flags & PWM_CH_STATE_TRIGGER))
  {
    if (PWM_FALSE == Pwm_RaCheckChannelStatus_Trigger(ChannelPtr, PWM_FALSE))
    {
      StatusGood = PWM_FALSE;
    }
  }
  else
  {
    if (PWM_FALSE == Pwm_RaCheckChannelStatus_Trigger(ChannelPtr, PWM_TRUE))
    {
      StatusGood = PWM_FALSE;
    }
  }
  return StatusGood;
}

/** \brief Pwm_CheckChannelState_Notify
 **
 ** Verifies register settings for channel state NOTIFY.
 **
 ** \param [in]  ChannelPtr  Pointer to the channel configuration.
 **
 ** \return Return PWM_TRUE if s/w and h/w status of channel are in sync,
 **         PWM_FALSE if not.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelState_Notify
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(boolean, AUTOMATIC) StatusGood;
  
  /* Check whether HW and SW interrupt status are in sync */
  StatusGood = Pwm_RaCheckChannelStatus_Interrupt(ChannelPtr);

  return StatusGood;
}

/** \brief Pwm_UpdateRunningChannel
 **
 ** Updates channel counter for duty and period update a running channel.
 **
 ** \param [in]  ChannelPtr     Pointer to the channel configuration.
 ** \param [in]  EndPeriodFlag  Enable/disable the update of the period at 
 **                             the end of the current period.
 **
 */
static FUNC(void, PWM_CODE) Pwm_UpdateRunningChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) EndPeriodFlag
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickValue;
  /* Get period tick register value */
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue = Pwm_GetPeriodTickValue(ChannelPtr);
  
  /* Output offset is enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
  {
    /* Get cc0 tick register value */
    DutyTickValue = Pwm_GetCC0TickValue(ChannelPtr);
    /* Get cc1 tick register value */
    TriggerTickValue = Pwm_GetCC1TickValue(ChannelPtr);
  }
  /* Output offset is disable */
  else
  {
    /* Get cc0 tick register value */
    DutyTickValue = Pwm_GetDutyTickValue(ChannelPtr);
    /* Get cc1 tick register value */
    TriggerTickValue = Pwm_GetTriggerTickValue(ChannelPtr);
  }

  /* Perform timing parameter update to buffer register */
  Pwm_RaUpdateChannelBuff(ChannelPtr, PeriodTickValue, DutyTickValue, TriggerTickValue);
  
  /* Period and duty update immediately */
  if (EndPeriodFlag == PWM_FALSE)
  {
    /* Perform timing parameter update */
    Pwm_RaUpdateChannel(ChannelPtr, PeriodTickValue, DutyTickValue, TriggerTickValue);
    /* Set line_out state on hardware */
    Pwm_RaSetChannelOut(ChannelPtr);
  }
  
  /* Output offset is disable and center align */
  if ((PWM_FALSE == ChannelPtr->OutputOffsetEnable) && (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment))
  {
    /* Set cc1 match up down enable status on hardware */
    Pwm_RaUpdateCcMatchEvent(ChannelPtr);
  }
}

/** \brief Pwm_UpdateStoppedChannel
 **
 ** Updates channel counter for duty and period update a stopped channel.
 **
 ** \param [in]  ChannelPtr      Pointer to the channel configuration.
 ** \param [in]  StartDelayFlag  Enable/disable the output of StartDelay.
 **                              (PWM_TRUE = Enable, PWM_FALSE = Disable)
 **
 */
static FUNC(void, PWM_CODE) Pwm_UpdateStoppedChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) StartDelayFlag
)
{
  P2CONST(Pwm_DelayConfigType, AUTOMATIC, PWM_APPL_CONST) DelayPtr;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickValue;
  /* Get period tick register value */
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue = Pwm_GetPeriodTickValue(ChannelPtr);
  
  /* Output offset is enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
  {
    /* Get cc0 tick register value */
    DutyTickValue = Pwm_GetCC0TickValue(ChannelPtr);
    /* Get cc1 tick register value */
    TriggerTickValue = Pwm_GetCC1TickValue(ChannelPtr);
  }
  /* Output offset is disable */
  else
  {
    /* Get cc0 tick register value */
    DutyTickValue = Pwm_GetDutyTickValue(ChannelPtr);
    /* Get cc1 tick register value */
    TriggerTickValue = Pwm_GetTriggerTickValue(ChannelPtr);
    /* Center alignment */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Set cc1 match up down enable status on hardware */
      Pwm_RaUpdateCcMatchEvent(ChannelPtr);
    }
  }

  /* Perform timing parameter update to buffer register */
  Pwm_RaUpdateChannelBuff(ChannelPtr, PeriodTickValue, DutyTickValue, TriggerTickValue);

  /* Get delay timer config pointer */
  DelayPtr = ChannelPtr->DelayConfigPtr;

  /* Check if delay timer is valid */
  if ((NULL_PTR != DelayPtr) && (PWM_TRUE == StartDelayFlag))
  {
    /* Center alignment */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Output offset is enable */
      if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
      {
        PeriodTickValue = DelayPtr->StartDelay - 1u;
      }
      /* Output offset is disable */
      else
      {
        if (PWM_MINPERIODTICK_CENTER > DelayPtr->StartDelay)
        {
          PeriodTickValue = 1u;
        }
        else
        {
          PeriodTickValue = DelayPtr->StartDelay / PWM_HALF_DIVIDER;
        }
      }
      DutyTickValue = ChannelPtr->TimerMax;
    }
    /* Right alignment */
    else if (PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
    {
      PeriodTickValue = DelayPtr->StartDelay - 1u;
      DutyTickValue = ChannelPtr->TimerMax;
    }
    /* Left alignment */
    else
    {
      PeriodTickValue = DelayPtr->StartDelay - 1u;
      /* Output offset is disable and Group start delay is enable */
      if ((PWM_FALSE == ChannelPtr->OutputOffsetEnable) && 
          (PWM_TRUE == ChannelPtr->GroupStartDelayEnable))
      {
        DutyTickValue = 0u;
      }
      else
      {
        DutyTickValue = ChannelPtr->TimerMax;
      }
    }
    TriggerTickValue = ChannelPtr->TimerMax;
  }
    
  /* Perform timing parameter update */
  Pwm_RaUpdateChannel(ChannelPtr, PeriodTickValue, DutyTickValue, TriggerTickValue);
}

/** \brief Pwm_StartChannel
 **
 ** Start a channel.
 **
 ** \param [in]  ChannelPtr      Pointer to the channel configuration.
 ** \param [in]  StartDelayFlag  Enable/disable the output of StartDelay.
 **                              (PWM_TRUE = Enable, PWM_FALSE = Disable)
 **
 */
static FUNC(void, PWM_CODE) Pwm_StartChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) StartDelayFlag
)
{
  /* Set software trigger command */
  Pwm_RaEnableSwTrigger(ChannelPtr->BaseAddress, PWM_SW_RELOAD_TRIGGER);

  /* Check if delay timer is valid */
  if ((NULL_PTR != ChannelPtr->DelayConfigPtr) && (PWM_TRUE == StartDelayFlag))
  {
    /* Set software trigger command */
    Pwm_RaEnableSwTrigger(ChannelPtr->DelayConfigPtr->DelayBaseAddress, PWM_SW_RELOAD_TRIGGER);
  }
}

/** \brief Pwm_GetPrescalerValue
 **
 ** Get channel prescaler value.
 **
 ** \param [in]  TickFrequency    Tick frequency of channel configuration.
 ** \param [in]  ClockFrequency   Input clock frequency.
 **
 ** \return If clock frequency is valid value return calculated prescaler value.
 **         Else return PWM_INVALID_PRESCALER.
 */
static FUNC(uint8, PWM_CODE) Pwm_GetPrescalerValue
(
  VAR(Pwm_ClkFrequencyType, AUTOMATIC) TickFrequency,
  VAR(Pwm_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  VAR(uint32, AUTOMATIC) Divider;
  VAR(uint8, AUTOMATIC) PrescalerValue;
  
  Divider = ClockFrequency / TickFrequency;
 
  /* Input clock frequency check */
  if ( PWM_PRESCALING_DIVIDE_NONE == Divider )
  {
    PrescalerValue = PWM_INVALID_PRESCALER;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_1 + PWM_PRESCALING_DIVIDE_BY_2) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_1;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_2 + PWM_PRESCALING_DIVIDE_BY_4) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_2;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_4 + PWM_PRESCALING_DIVIDE_BY_8) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_4;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_8 + PWM_PRESCALING_DIVIDE_BY_16) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_8;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_16 + PWM_PRESCALING_DIVIDE_BY_32) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_16;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_32 + PWM_PRESCALING_DIVIDE_BY_64) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_32;
  }
  else if (Divider <= ((PWM_PRESCALING_DIVIDE_BY_64 + PWM_PRESCALING_DIVIDE_BY_128) / PWM_HALF_DIVIDER))
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_64;
  }
  else 
  {
    PrescalerValue = PWM_PRESCALER_DIVIDE_BY_128;
  }
  
  return PrescalerValue;
}

/** \brief Pwm_CheckPeriodAndTrigger
 **
 ** \param [in] ChannelPtr     Pointer to the channel configuration.
 ** \param [in] PeriodTicks    Period value in ticks.
 ** \param [in] DutyTicks      Duty value in ticks.
 ** \param [in] TriggerTicks   Delay time for output trigger.
 ** \param [in] MaskFlag       Channel masked status.
 **
 ** \return PWM_TRUE if period and output trigger ticks are in valid range, 
 **         PWM_FALSE otherwise.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckPeriodAndTrigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks,
  VAR(boolean, AUTOMATIC) MaskFlag
)
{
  VAR(boolean, AUTOMATIC) CheckResult = PWM_TRUE;
  /* Trigger synchronizes with period or trigger synchronizes with duty when channel is masked */
  if ((PWM_TRIGGER_SYNC_PERIOD == ChannelPtr->TriggerFactor) ||
      ((PWM_TRIGGER_SYNC_DUTY == ChannelPtr->TriggerFactor) && (PWM_TRUE == MaskFlag)))
  { 
    if (TriggerTicks > PeriodTicks)
    {
      CheckResult = PWM_FALSE;
    }
  }
  /* Trigger synchronizes with duty and duty is not 0%/100% */
  else
  {
    /* Center alignment */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (TriggerTicks > ((PeriodTicks + DutyTicks) / PWM_HALF_DIVIDER))
      {
        CheckResult = PWM_FALSE;
      }
    }
    /* Left alignment */
    else if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (TriggerTicks > PeriodTicks)
      {
        CheckResult = PWM_FALSE;
      }
    }
    /* Right alignment */
    else
    {
      /* Do nothing */
    }
  }

  return CheckResult;
}

/** \brief Pwm_CheckDutyAndTrigger
 **
 ** Check if duty cycle and output trigger ticks are in valid range.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** \param [in] PeriodTicks   Period value in ticks.
 ** \param [in] DutyTicks     Duty value in ticks.
 ** \param [in] TriggerTicks  Delay time for output trigger.
 **
 ** \return Returns PWM_TRUE if duty cycle and output trigger ticks are in 
 **         valid range, PWM_FALSE otherwise.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckDutyAndTrigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks
)
{
  VAR(boolean, AUTOMATIC) CheckResult = PWM_TRUE;
  
  /* Trigger synchronizes with duty */
  if (PWM_TRIGGER_SYNC_DUTY == ChannelPtr->TriggerFactor)
  {
    /* Right alignment */
    if (PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (TriggerTicks > DutyTicks)
      {
        CheckResult = PWM_FALSE;
      }
    }
    /* Center alignment */
    else if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (TriggerTicks > ((PeriodTicks + DutyTicks) / PWM_HALF_DIVIDER))
      {
        CheckResult = PWM_FALSE;
      }
    }
    /* Left alignment */
    else
    {
      /* Do nothing */
    }
  }

  return CheckResult;
}

/** \brief Pwm_GetPeriodTickValue
 **
 ** Calculate the period tick value (value of PERIOD) according to the alignment type.
 **
 ** Preconditions:
 ** - Channel state values for period has to be updated before (API SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return period tick value to be set in register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetPeriodTickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue;

  /* Center alignment(output offset is disable) */
  if ((PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment) && (PWM_FALSE == ChannelPtr->OutputOffsetEnable))
  {
    PeriodTickValue = ChannelPtr->ChannelStatePtr->PeriodTicks / PWM_HALF_DIVIDER;
  }
  /* Right alignment or left alignment or center alignment(output offset is enable) */
  else
  {
    PeriodTickValue = ChannelPtr->ChannelStatePtr->PeriodTicks - 1u;
  }

  return PeriodTickValue;
}

/** \brief Pwm_GetDutyTickValue
 **
 ** Calculate the duty tick value (value of CC0) according to the alignment type.
 **
 ** Preconditions:
 ** - Channel state values for duty and period has to be updated before (API SetDutyCycle
 **   or SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return duty tick value to be set in register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetDutyTickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyLimitTick;

  /* Check whether duty cycle is 0% or 100% */
  if (PWM_TRUE == Pwm_DutyTickDetected(ChannelPtr, &DutyLimitTick))
  {
    /* 0%/100% detected results in appropriate duty tick */
    DutyTickValue = DutyLimitTick;
  }
  else
  {
    /* Duty tick value */
    DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks * 
                    ChannelPtr->ChannelStatePtr->DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
    
    /* Center alignment */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* DutyTick is 1 */
      if (1u == DutyTickValue)
      {
        /* DutyTick should not be the same value as half of PeriodTick */
        DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks / PWM_HALF_DIVIDER) - DutyTickValue;
      }
      else
      {
        DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks - DutyTickValue) / PWM_HALF_DIVIDER;
      }
    }
    /* Right alignment */
    else if(PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
    {
      DutyTickValue = DutyTickValue - 1u;
    }
    /* Left alignment */
    else
    {
      /* Do nothing */
    }
  }

  return DutyTickValue;
}

/** \brief Pwm_GetTriggerTickValue
 **
 ** Calculate the trigger tick value (value of CC1) according to the alignment type
 ** and update channel match up down status when center alignment.
 **
 ** Preconditions:
 ** - Channel state values for duty, period and trigger tick has to be updated before
 **   (API SetDutyCycle or SetPeriodAndDuty or Pwm_SetTriggerDelay).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return output trigger tick value to be set in register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetTriggerTickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue;
  
  /* Get period tick register value */
  PeriodTickValue = Pwm_GetPeriodTickValue(ChannelPtr);

  /* Center alignment */
  if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
  {
    /* Trigger synchronizes with duty and dutycycle is not 0% and 100% */
    if ((PWM_TRIGGER_SYNC_DUTY == ChannelPtr->TriggerFactor) &&
        (PWM_DUTY_0_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle) &&
        (PWM_DUTY_100_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle))
    {
      DutyTickValue = Pwm_GetDutyTickValue(ChannelPtr);
      TriggerTickValue = DutyTickValue + ChannelPtr->ChannelStatePtr->TriggerTicks;
    }
    /* Trigger synchronizes with duty when dutycycle is 0%/100% or trigger synchronizes with period */
    else
    {
      TriggerTickValue = ChannelPtr->ChannelStatePtr->TriggerTicks;
    }
    
    if (TriggerTickValue >= (PWM_HALF_DIVIDER * PeriodTickValue))
    {
      TriggerTickValue = 0u;
    }
    
    if (TriggerTickValue >= PeriodTickValue)
    {
      TriggerTickValue = (PWM_HALF_DIVIDER * PeriodTickValue) - TriggerTickValue;
      ChannelPtr->ChannelStatePtr->MatchUpEnable = PWM_FALSE;
      ChannelPtr->ChannelStatePtr->MatchDownEnable = PWM_TRUE;
    }
    else
    {
      ChannelPtr->ChannelStatePtr->MatchUpEnable = PWM_TRUE;
      ChannelPtr->ChannelStatePtr->MatchDownEnable = PWM_FALSE;
    }
  }
  /* Right alignment */
  else if (PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
  {
    /* Trigger synchronizes with duty and dutycycle is not 0% and 100% */
    if ((PWM_TRIGGER_SYNC_DUTY == ChannelPtr->TriggerFactor  ) && 
        (PWM_DUTY_0_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle) &&
        (PWM_DUTY_100_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle))
    {
      /* Get duty tick register value */
      DutyTickValue = Pwm_GetDutyTickValue(ChannelPtr);
      if (ChannelPtr->ChannelStatePtr->TriggerTicks < DutyTickValue)
      {
        TriggerTickValue = DutyTickValue - ChannelPtr->ChannelStatePtr->TriggerTicks;
      }
      else
      {
        TriggerTickValue = PeriodTickValue;
      }
    }
    /* Trigger synchronizes with duty when dutycycle is 0%/100% or trigger synchronizes with period */
    else
    {
      if (ChannelPtr->ChannelStatePtr->TriggerTicks < PeriodTickValue)
      {
        TriggerTickValue = PeriodTickValue - ChannelPtr->ChannelStatePtr->TriggerTicks;
      }
      else
      {
        TriggerTickValue = PeriodTickValue;
      }
    }
  }
  /* Left alignment */
  else
  {
    if (ChannelPtr->ChannelStatePtr->TriggerTicks < PeriodTickValue)
    {
      TriggerTickValue = ChannelPtr->ChannelStatePtr->TriggerTicks;
    }
    else
    {
      TriggerTickValue = 0u;
    }
  }

  return TriggerTickValue;
}

/** \brief Pwm_LimitInterval
 **
 ** Limits the settings to the HW.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 */
static FUNC(void, PWM_CODE) Pwm_LimitInterval
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  
  /* PeriodTicks is 0 */
  if (ChannelPtr->ChannelStatePtr->PeriodTicks == 0u)
  {
    ChannelPtr->ChannelStatePtr->DutyCycle = PWM_DUTY_0_PERCENTAGE;
    /* Left align or Right align */
    if (PWM_CENTER_ALIGNED != ChannelPtr->OutAlignment)
    {
      ChannelPtr->ChannelStatePtr->PeriodTicks = PWM_MINPERIODTICK_LEFTANDRIGHT;
    }
    /* Center align */
    else
    {
      ChannelPtr->ChannelStatePtr->PeriodTicks = PWM_MINPERIODTICK_CENTER;
    }
  }
  /* PeriodTicks is not 0 */
  else
  {
    /* Center align */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (ChannelPtr->ChannelStatePtr->PeriodTicks < PWM_MINPERIODTICK_CENTER)
      {
        ChannelPtr->ChannelStatePtr->PeriodTicks = PWM_MINPERIODTICK_CENTER;
      }
    }
    /* Get duty tick value */
    DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks *
                     ChannelPtr->ChannelStatePtr->DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
    
    if (0u == DutyTickValue)
    {
      ChannelPtr->ChannelStatePtr->DutyCycle = PWM_DUTY_0_PERCENTAGE;
    }
    else
    {
      /* Center alignment */
      if ((PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment) &&
          (PWM_DUTY_100_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle))
      {
        /* DutyTick is 1 */
        if (1u == DutyTickValue)
        {
          /* DutyTick should not be the same value as half of PeriodTick */
          DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks / PWM_HALF_DIVIDER) - DutyTickValue;
        }
        else
        {
          DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks - DutyTickValue) / PWM_HALF_DIVIDER;
        }
        
        if (0u == DutyTickValue)
        {
          ChannelPtr->ChannelStatePtr->DutyCycle = PWM_DUTY_100_PERCENTAGE;
        }
      }
    }
  }
}

/** \brief Pwm_CheckChannelMaskStatus
 **
 ** Check if current duty tick and period tick shall mask channel.
 **
 ** \param [in] ChannelPtr  Pointer to the channel configuration.
 ** \param [in] PeriodTickValue Period tick value.
 ** \param [in] DutyTickValue Duty tick value.
 **
 ** \return Return PWM_TRUE if current duty tick and period tick shall mask channel,
 **         PWM_FALSE if not.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckChannelMaskStatus
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTickValue,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue
)
{
  VAR(boolean, AUTOMATIC) MaskFlag;
  VAR(Pwm_PeriodType, AUTOMATIC) TempDutyTickValue;
  
  if ((DutyTickValue == 0u) || (DutyTickValue == PeriodTickValue))
  {
    MaskFlag = PWM_TRUE;
  }
  else
  {
    /* Center alignment */
    if (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (1u == DutyTickValue)
      {
        TempDutyTickValue = (PeriodTickValue / PWM_HALF_DIVIDER) - DutyTickValue;
      }
      else
      {
        TempDutyTickValue = (PeriodTickValue - DutyTickValue) / PWM_HALF_DIVIDER;
      }
      
      if (0u == TempDutyTickValue)
      {
        MaskFlag = PWM_TRUE;
      }
      else
      {
        MaskFlag = PWM_FALSE;
      }
    }
    else
    {
      MaskFlag = PWM_FALSE;
    }
  }
  return MaskFlag;
}

/** \brief Pwm_SetDisableModeInternal
 **
 ** Set channel disable mode before channel running.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] StartDelayFlag  Enable/disable the output of StartDelay.
 **                             (PWM_TRUE = Enable, PWM_FALSE = Disable)
 **
 */
static FUNC(void, PWM_CODE) Pwm_SetDisableModeInternal
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) StartDelayFlag
)
{
  VAR(uint8, AUTOMATIC) DisableMode;
  
  /* Start delay is not 0 */
  if ((0u != ChannelPtr->ChannelStatePtr->DelayTicks) && (PWM_TRUE == StartDelayFlag))
  {
    if ((PWM_FALSE == ChannelPtr->OutputOffsetEnable) && (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment))
    {
      /* After counter running, the output is active ouput */
      DisableMode = (ChannelPtr->ActiveOutput == PWM_HIGH) ? PWM_DISABLEMODE_HIGH : PWM_DISABLEMODE_LOW;
    }
    else
    {
      /* After counter running, the output is inactive ouput */
      DisableMode = (ChannelPtr->ActiveOutput == PWM_HIGH) ? PWM_DISABLEMODE_LOW : PWM_DISABLEMODE_HIGH;
    }
  }
  /* Start delay is 0 */
  else
  {
    /* Left alignment */
    if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      if (((0u == ChannelPtr->ChannelStatePtr->OutputOffsetTicks) &&
           (ChannelPtr->ChannelStatePtr->DutyCycle != PWM_DUTY_0_PERCENTAGE)) ||
          (ChannelPtr->ChannelStatePtr->DutyCycle == PWM_DUTY_100_PERCENTAGE))
      {
        /* After counter running, the output is active ouput */
        DisableMode = (ChannelPtr->ActiveOutput == PWM_HIGH) ? PWM_DISABLEMODE_HIGH : PWM_DISABLEMODE_LOW;
      }
      else
      {
        /* After counter running, the output is inactive ouput */
        DisableMode = (ChannelPtr->ActiveOutput == PWM_HIGH) ? PWM_DISABLEMODE_LOW : PWM_DISABLEMODE_HIGH;
      }
    }
    /* Right or center alignment */
    else
    {
      if (ChannelPtr->ChannelStatePtr->DutyCycle == PWM_DUTY_100_PERCENTAGE)
      {
        /* After counter running, the output is active ouput */
        DisableMode = (ChannelPtr->ActiveOutput == PWM_HIGH) ? PWM_DISABLEMODE_HIGH : PWM_DISABLEMODE_LOW;
      }
      else
      {
        /* After counter running, the output is inactive ouput */
        DisableMode = (ChannelPtr->ActiveOutput == PWM_HIGH) ? PWM_DISABLEMODE_LOW : PWM_DISABLEMODE_HIGH;
      }
    }
  }

  /* Set channel disable mode */
  Pwm_RaSetDisableMode(ChannelPtr->BaseAddress, DisableMode);
}

/** \brief Pwm_GetCC0TickValue
 **
 ** Calculate the CC0 register value when output offset is enable.
 **
 ** Preconditions:
 ** - Channel state values for duty and period has to be updated before (API SetDutyCycle
 **   or SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return tick value to be set in CC0 register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetCC0TickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) Cc0TickValue;
  
  /* Duty cycle is 100% */
  if (PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle)
  {
    /* Enable cc0 match event generation */
    Cc0TickValue = 0u;
  }
  /* Duty cycle is 0% */
  else if (PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle)
  {
    /* Disable cc0 match event generation */
    Cc0TickValue = Pwm_GetPeriodTickValue(ChannelPtr) + 1u;
  }
  /* Duty cycle is not 0% and 100% */
  else
  {
    /* Duty tick value */
    DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks * 
                    ChannelPtr->ChannelStatePtr->DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
    
    /* Left alignment */
    if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      Cc0TickValue = ChannelPtr->ChannelStatePtr->OutputOffsetTicks;
    }
    /* Center alignment */
    else
    {
      /* DutyTick is 1 and OutputOffsetTicks is 0 */
      if ((1u == DutyTickValue) && (0x0u == ChannelPtr->ChannelStatePtr->OutputOffsetTicks))
      {
        Cc0TickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks / PWM_HALF_DIVIDER) - DutyTickValue;
      }
      else
      {
        Cc0TickValue = ((ChannelPtr->ChannelStatePtr->PeriodTicks - DutyTickValue) / PWM_HALF_DIVIDER) + 
                       ChannelPtr->ChannelStatePtr->OutputOffsetTicks;
      }
    }
  }
  return Cc0TickValue;
}

/** \brief Pwm_GetCC1TickValue
 **
 ** Calculate the CC1 register value when output offset is enable.
 **
 ** Preconditions:
 ** - Channel state values for duty and period has to be updated before (API SetDutyCycle
 **   or SetPeriodAndDuty).
 **
 ** \param [in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Return tick value to be set in CC1 register.
 */
static FUNC(Pwm_PeriodType, PWM_CODE) Pwm_GetCC1TickValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTickValue;
  VAR(Pwm_PeriodType, AUTOMATIC) Cc1TickValue;
  
  /* Duty cycle is 0% or 100% */
  if ((PWM_DUTY_100_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle) || 
      (PWM_DUTY_0_PERCENTAGE == ChannelPtr->ChannelStatePtr->DutyCycle))
  {
    /* Disable cc1 match event generation */
    Cc1TickValue = Pwm_GetPeriodTickValue(ChannelPtr) + 1u;
  }
  /* Duty cycle is not 0% and 100% */
  else
  {
    /* Duty tick value */
    DutyTickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks * 
                    ChannelPtr->ChannelStatePtr->DutyCycle) >> PWM_DUTY_CYCLETOTICK_SHIFT;
    /* Left alignment */
    if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      Cc1TickValue = DutyTickValue + ChannelPtr->ChannelStatePtr->OutputOffsetTicks;
    }
    /* Center alignment */
    else
    {
      /* DutyTick is 1 and OutputOffsetTicks is 0 */
      if ((1u == DutyTickValue) && (0x0u == ChannelPtr->ChannelStatePtr->OutputOffsetTicks))
      {
        Cc1TickValue = (ChannelPtr->ChannelStatePtr->PeriodTicks / PWM_HALF_DIVIDER) + DutyTickValue;
      }
      else
      {
        Cc1TickValue = ((ChannelPtr->ChannelStatePtr->PeriodTicks + DutyTickValue) / PWM_HALF_DIVIDER) + 
                       ChannelPtr->ChannelStatePtr->OutputOffsetTicks;
      }
    }
  }
  return Cc1TickValue;
}

/** \brief Pwm_CheckDutyAndOffsetTick
 **
 ** Check if duty cycle and OffsetTick are in valid range.
 **
 ** \param [in] ChannelPtr    Pointer to the channel configuration.
 ** \param [in] PeriodTicks   Period value in ticks.
 ** \param [in] DutyTicks     Duty value in ticks.
 ** \param [in] OffsetTick    Offset time for PWM output.
 **
 ** \return Returns PWM_TRUE if duty cycle and OffsetTick are in valid range, 
 **         PWM_FALSE otherwise.
 */
static FUNC(boolean, PWM_CODE) Pwm_CheckDutyAndOffsetTick
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(Pwm_PeriodType, AUTOMATIC) PeriodTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) DutyTicks,
  VAR(Pwm_PeriodType, AUTOMATIC) OffsetTick
)
{
  VAR(boolean, AUTOMATIC) CheckResult;
  
  /* Left alignment */
  if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
  {
    if (OffsetTick > (PeriodTicks - DutyTicks - 1u))
    {
      CheckResult = PWM_FALSE;
    }
    else
    {
      CheckResult = PWM_TRUE;
    }
  }
  /* Center alignment */
  else
  {
    if (OffsetTick > ((PeriodTicks - DutyTicks - 1u) / PWM_HALF_DIVIDER))
    {
      CheckResult = PWM_FALSE;
    }
    else
    {
      CheckResult = PWM_TRUE;
    }
  }
  
  return CheckResult;
}

#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[end of file]============================================*/
