/** \brief AUTOSAR Pwm Driver
 **
 ** This file contains the implementation of the AUTOSAR Pwm driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/

#include <Pwm.h>
#include <Pwm_Internal.h>
#include <Pwm_Det.h>
#include <SchM_Pwm.h>          /* SchM_Pwm declarations */

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/

#define PWM_START_SEC_CODE_ASIL_B
#include <Pwm_MemMap.h>

/** \brief Pwm_GetConfigPtr
 **
 ** Returns the pointer of the current configuration set.
 **
 ** \return Pointer of data stored current configuration set information.
 **
 */
static FUNC_P2CONST(Pwm_ConfigType, PWM_APPL_CONST, PWM_CODE) Pwm_GetConfigPtr(void);
#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>
/*==================[external data]==========================================*/

/*==================[external constants]=====================================*/

/*==================[internal data]==========================================*/
#define PWM_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/* This data is pointer to actually used configuration set. */
static P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) Pwm_ConfigPtr = NULL_PTR;

#define PWM_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[internal constants]=====================================*/

/*==================[external function definitions]==========================*/

#define PWM_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/** \brief Pwm_Init
 **
 ** Service for PWM initialization.
 **
 ** This function initializes all configured channels. All channels are started
 ** (creating a PWM output) dependent on their static configuration.
 ** Channels with 0% or 100% duty create a constant output level.
 ** Notifications are disabled for all channels.
 ** Triggers are enabled or disabled for all channels by configuration.
 **
 ** Note: If the period or duty value results in a HW limit (in generally some
 **       ticks near 0 or (duty-x)<period) the appropriate constant level will
 **       be forced. No development error is reported.
 **
 ** Preconditions:
 ** - No Init call should be done before.
 **
 ** \param [in] ConfigPtr   Pointer to configuration set.
 **
 */
FUNC(void, PWM_CODE) Pwm_Init
(
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr
)
{
  /* Check config data pointer */
  if (PWM_FALSE == Pwm_CheckConfigPtr(ConfigPtr))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_INIT_FAILED, PWM_API_INIT);
  }
  /* Check if module is uninitialized */
  else if (PWM_S_UNINITIALIZED != Pwm_GetDriverStatus())
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_ALREADY_INITIALIZED, PWM_API_INIT);
  }
  else
  {
#if (PWM_ENABLETRIGGER_SUPPORTED == STD_ON)
    /* Unsupport enable output trigger at init */
    Pwm_InitInternal(ConfigPtr, PWM_FALSE);
#else
    /* Support enable output trigger at init */
    Pwm_InitInternal(ConfigPtr, PWM_TRUE);
#endif
    /* Set global config pointer */
    Pwm_ConfigPtr = ConfigPtr;
    /* Update driver status */
    Pwm_SetDriverStatus(PWM_S_INITIALIZED);
  }
}

#if (PWM_DE_INIT_API == STD_ON)
/** \brief Pwm_DeInit
 **
 ** Service for PWM De-Initialization.
 **
 */
FUNC(void, PWM_CODE) Pwm_DeInit(void)
{
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if (PWM_S_INITIALIZED != Pwm_GetDriverStatus())
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_DEINIT);
  }
  else if (PWM_FALSE == ConfigState)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_DEINIT);
    /* Set driver status to uninitialized */
    Pwm_SetDriverStatus(PWM_S_UNINITIALIZED);
  }
  else
  {
    /* De-initialize driver */
    Pwm_DeInitInternal(ConfigDataPtr);
    /* Set Driver status to uninitialized */
    Pwm_SetDriverStatus(PWM_S_UNINITIALIZED);
  }
}
#endif /* (PWM_DE_INIT_API == STD_ON) */

#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
/** \brief Pwm_DisableNotification
 **
 ** Service to disable the PWM signal edge notification.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 **
 */
FUNC(void, PWM_CODE) Pwm_DisableNotification
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_DISABLENOTIFICATION);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_DISABLENOTIFICATION);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Set notification disable */
    Pwm_DisableNotificationInternal(ChannelPtr);
  }
}

/** \brief Pwm_EnableNotification
 **
 ** Service to enable the PWM signal edge notification according to notification
 ** parameter.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the PWM channel.
 ** \param [in] Notification   Type of notification:
 **                            PWM_RISING_EDGE or
 **                            PWM_FALLING_EDGE or
 **                            PWM_BOTH_EDGES.
 **
 */
FUNC(void, PWM_CODE) Pwm_EnableNotification
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_EdgeNotificationType, AUTOMATIC) Notification
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_ENABLENOTIFICATION);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_ENABLENOTIFICATION);
  }
  /* Check if Notification is valid */
  else if ((PWM_RISING_EDGE != Notification) && 
           (PWM_FALLING_EDGE != Notification) && 
           (PWM_BOTH_EDGES != Notification))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_NOTIFICATION, PWM_API_ENABLENOTIFICATION);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Only PWM_BOTH_EDGES is allowed if center alignment */
    if (((PWM_RISING_EDGE == Notification) || (PWM_FALLING_EDGE == Notification)) && 
        (PWM_CENTER_ALIGNED == ChannelPtr->OutAlignment))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_NOTIFICATION, PWM_API_ENABLENOTIFICATION);
    }
    else
    {
      /* Set notification enable */
      Pwm_EnableNotificationInternal(ChannelPtr, Notification);
    }
  }
}
#endif /* (PWM_NOTIFICATION_SUPPORTED == STD_ON) */

#if (PWM_ENABLETRIGGER_SUPPORTED == STD_ON)
/** \brief Pwm_DisableTrigger
 **
 ** Service to disable the output trigger on the specified channel.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 **
 */
FUNC(void, PWM_CODE) Pwm_DisableTrigger
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_DISABLETRIGGER);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_DISABLETRIGGER);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check whether channel is waiting trigger */
    if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_DISABLETRIGGER);
    }
    else
    {
      /* Set trigger disable */
      Pwm_DisableTriggerInternal(ChannelPtr);
    }
  }
}

/** \brief Pwm_EnableTrigger
 **
 ** Service to enable the output trigger on the specified channel.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the PWM channel.
 **
 */
FUNC(void, PWM_CODE) Pwm_EnableTrigger
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_ENABLETRIGGER);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_ENABLETRIGGER);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check if channel support set output trigger */
    if (PWM_TRIGGER_DISABLE == ChannelPtr->TriggerOutputSelect)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_ENABLETRIGGER);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_ENABLETRIGGER);
    }
    else
    {
      /* Set trigger enable */
      Pwm_EnableTriggerInternal(ChannelPtr);
    }
  }
}
#endif /* (PWM_ENABLETRIGGER_SUPPORTED == STD_ON) */

#if (PWM_GET_OUTPUT_STATE_API == STD_ON)
/** \brief Pwm_GetOutputState
 **
 **  Read the internal state of the PWM output.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 **
 ** \return  Output state types
 **          PWM_HIGH: The PWM output state is high.
 **          PWM_LOW: The PWM output state is low.
 **
 */
FUNC(Pwm_OutputStateType, PWM_CODE) Pwm_GetOutputState
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Default on error */
  VAR(Pwm_OutputStateType, AUTOMATIC) CurrentOutputState = PWM_LOW;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_GETOUTPUTSTATE);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_GETOUTPUTSTATE);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Get output state */
    CurrentOutputState = Pwm_GetOutputStateInternal(ChannelPtr);
  }

  return CurrentOutputState;
}
#endif /* (PWM_GET_OUTPUT_STATE_API == STD_ON) */

#if (PWM_GET_VERSION_INFO_API == STD_ON)
/** \brief Pwm_GetVersionInfo
 **
 ** Service returns the version information of this module.
 **
 ** \param [out] versioninfo   Pointer to where to store the version information of
 **                            this module.
 **
 */
FUNC(void, PWM_CODE) Pwm_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, PWM_APPL_DATA) versioninfo
)
{
  /* Check if input parameter valid */
  if (NULL_PTR == versioninfo)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_POINTER, PWM_API_GETVERSIONINFO);
  }
  else
  {
    versioninfo->vendorID = PWM_VENDOR_ID;
    versioninfo->moduleID = PWM_MODULE_ID;
    versioninfo->sw_major_version = PWM_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = PWM_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = PWM_SW_PATCH_VERSION;
  }
}
#endif /* (PWM_GET_VERSION_INFO_API == STD_ON) */

#if (PWM_SET_DUTY_CYCLE_API == STD_ON)
/** \brief Pwm_SetDutyCycle
 **
 ** Service sets the duty cycle of the PWM channel.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] DutyCycle       Value of DutyCycle: Min=0x0000 Max=0x8000.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetDutyCycle
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(uint16, AUTOMATIC) DutyCycle
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETDUTYCYCLE);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETDUTYCYCLE);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);

    /* Check if duty cycle is in valid range */
    if (PWM_FALSE == Pwm_CheckDutyCycleInternal(ChannelPtr, 
            ChannelPtr->ChannelStatePtr->PeriodTicks, DutyCycle))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_DUTY_OUT_OF_RANGE, PWM_API_SETDUTYCYCLE);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETDUTYCYCLE);
    }
    else
    {
      /* Set duty cycle */
      Pwm_SetDutyCycleInternal(ChannelPtr, DutyCycle,
          (boolean)PWM_DUTYCYCLE_UPDATEDENDPERIOD,
          (boolean)PWM_WAITINGUPDATE_SUPPORTED);
    }
  }
}
#endif /* (PWM_SET_DUTY_CYCLE_API == STD_ON) */

#if (PWM_SET_DUTYCYCLE_BUFFER_API == STD_ON)
/** \brief Pwm_SetDutyCycleBuffer
 **
 ** Service sets the duty cycle of the PWM channel to only buffer register.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] DutyCycle       Value of DutyCycle: Min=0x0000 Max=0x8000.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetDutyCycleBuffer
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(uint16, AUTOMATIC) DutyCycle
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETDUTYCYCLEBUFFER);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETDUTYCYCLEBUFFER);
  }
  else
  {
    /* Get config pointer for specified channel */
    /* Deviation from MISRA-C:2004 rule 17.4.
       Justification: Pointer access by array-subscripting is required for access to data structure member. */
    /* PRQA S 491 1 */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);

    /* Check if duty cycle is in valid range */
    if (PWM_FALSE == Pwm_CheckDutyCycleInternal(ChannelPtr, 
            ChannelPtr->ChannelStatePtr->PeriodTicks, DutyCycle))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_DUTY_OUT_OF_RANGE, PWM_API_SETDUTYCYCLEBUFFER);
    }
	/* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETDUTYCYCLEBUFFER);
    }
    else
    {
      /* Set duty cycle */
      Pwm_SetDutyCycleBufferInternal(ChannelPtr, DutyCycle);
      /* Update duty cycle and channel output */
      Pwm_UpdateDutyChannelOutputBufferInternal(ChannelPtr);
    }
  }
}
#endif /* (PWM_SET_DUTYCYCLE_BUFFER_API == STD_ON) */

#if (PWM_SET_DUTYANDCHANNEL_OUTPUTBUFFER_API == STD_ON)
/** \brief Pwm_SetDutyAndChannelOutputBuffer
 **
 ** Service sets the duty cycle and channel line and line complementary output 
 ** of the PWM channel to only buffer registers.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] DutyCycle       Value of DutyCycle: Min=0x0000 Max=0x8000.
 ** \param [in] LineState       PWM line output state.
 ** \param [in] LineCompState   PWM line complementary output state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetDutyAndChannelOutputBuffer
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(uint16, AUTOMATIC) DutyCycle,
  VAR(Pwm_OutputLineStateType, AUTOMATIC) LineState,
  VAR(Pwm_OutputLineStateType, AUTOMATIC) LineCompState
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
  }
  /* Check if line output is valid */
  else if ((PWM_LINESTATE_HIGH != LineState) && (PWM_LINESTATE_LOW != LineState) && (PWM_LINESTATE_PWM != LineState) && (PWM_LINESTATE_PWM_INV != LineState) && (PWM_LINESTATE_HIGHZ != LineState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_STATE, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
  }
  /* Check if complementary line output is valid */
  else if ((PWM_LINESTATE_HIGH != LineCompState) && (PWM_LINESTATE_LOW != LineCompState) && (PWM_LINESTATE_PWM != LineCompState) && (PWM_LINESTATE_PWM_INV != LineCompState) && (PWM_LINESTATE_HIGHZ != LineCompState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_STATE, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
  }  
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);

    /* Check if duty cycle is in valid range */
    if (PWM_FALSE == Pwm_CheckDutyCycleInternal(ChannelPtr, 
            ChannelPtr->ChannelStatePtr->PeriodTicks, DutyCycle))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_DUTY_OUT_OF_RANGE, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
    }
    /* Check if current channel support set output state */
    else if (PWM_FALSE == ChannelPtr->SetOutputEnable)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
    }
	/* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETDUTYCHANNELOUTPUTBUFFER);
    }    
    else
    {
      /* Set duty cycle */
      Pwm_SetDutyCycleBufferInternal(ChannelPtr, DutyCycle);
      /* Set output state */
      Pwm_SetChannelOutputBufferInternal(ChannelPtr, LineState, LineCompState);
      /* Update duty cycle and channel output */
      Pwm_UpdateDutyChannelOutputBufferInternal(ChannelPtr);
    }
  }
}
#endif /* (PWM_SET_DUTYANDCHANNEL_OUTPUTBUFFER_API == STD_ON) */

#if (PWM_SET_OUTPUT_TO_IDLE_API == STD_ON)
/** \brief Pwm_SetOutputToIdle
 **
 ** Service sets the PWM output to the configured Idle state.
 **
 ** \param [in] ChannelNumber  Numeric identifier of the PWM channel.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetOutputToIdle
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETOUTPUTTOIDLE);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETOUTPUTTOIDLE);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    
    /* Check whether channel is waiting trigger */
    if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETOUTPUTTOIDLE);
    }
    else
    {
      /* Set output state */
      Pwm_SetOutputToIdleInternal(ChannelPtr);
    }
  }
}
#endif /* (PWM_SET_OUTPUT_TO_IDLE_API == STD_ON) */

#if (PWM_SET_OUTPUT_STATUS_API == STD_ON)
/** \brief Pwm_SetChannelOutput
 **
 ** Service sets the PWM output to the specified state.
 ** Starting with the next PWM period, the PWM output shall be resumed.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] State           PWM output state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetChannelOutput
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_OutputStateType, AUTOMATIC) State
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETCHANNELOUTPUT);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETCHANNELOUTPUT);
  }
  /* Check if state is valid */
  else if ((PWM_HIGH != State) && (PWM_LOW != State))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_STATE, PWM_API_SETCHANNELOUTPUT);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check if current channel support set output state */
    if (PWM_FALSE == ChannelPtr->SetOutputEnable)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETCHANNELOUTPUT);
    }
    /* Check if channel is in running state */
    else if(PWM_TRUE != Pwm_CheckChannelStatus_Running(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_IDLE, PWM_API_SETCHANNELOUTPUT);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETCHANNELOUTPUT);
    }
    else
    {
      /* Set output state */
      Pwm_SetOutputStatusInternal(ChannelPtr, State);
    }
  }
}
#endif /* (PWM_SET_OUTPUT_STATUS_API == STD_ON) */

#if (PWM_SET_CHANNEL_OUTPUTBUFFER_API == STD_ON)
/** \brief Pwm_SetChannelOutputBuffer
 **
 ** Service sets the PWM line output and complementary output to specified state.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] LineState       PWM line output state.
 ** \param [in] LineCompState   PWM line complementary output state.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetChannelOutputBuffer
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_OutputLineStateType, AUTOMATIC) LineState,
  VAR(Pwm_OutputLineStateType, AUTOMATIC) LineCompState
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETCHANNELOUTPUTBUFFER);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETCHANNELOUTPUTBUFFER);
  }
  /* Check if line output is valid */
  else if ((PWM_LINESTATE_HIGH != LineState) && (PWM_LINESTATE_LOW != LineState) && (PWM_LINESTATE_PWM != LineState) && (PWM_LINESTATE_PWM_INV != LineState) && (PWM_LINESTATE_HIGHZ != LineState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_STATE, PWM_API_SETCHANNELOUTPUTBUFFER);
  }
  /* Check if complementary line output is valid */
  else if ((PWM_LINESTATE_HIGH != LineCompState) && (PWM_LINESTATE_LOW != LineCompState) && (PWM_LINESTATE_PWM != LineCompState) && (PWM_LINESTATE_PWM_INV != LineCompState) && (PWM_LINESTATE_HIGHZ != LineCompState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_STATE, PWM_API_SETCHANNELOUTPUTBUFFER);
  }  
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check if current channel support set output state */
    if (PWM_FALSE == ChannelPtr->SetOutputEnable)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETCHANNELOUTPUTBUFFER);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETCHANNELOUTPUTBUFFER);
    }    
    else
    {
      /* Set output state */
      Pwm_SetChannelOutputBufferInternal(ChannelPtr, LineState, LineCompState);
      /* Update duty cycle and channel output */
      Pwm_UpdateDutyChannelOutputBufferInternal(ChannelPtr);
    }
  }
}
#endif /* (PWM_SET_CHANNEL_OUTPUTBUFFER_API == STD_ON) */

#if (PWM_SET_OUT_OFFSET_API == STD_ON)
/** \brief Pwm_SetOutputOffset
 **
 ** Service to set offset the PWM duty output.
 ** Set the PWM output offset time based on PWM period.
 ** It is applied each period.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] OffsetTick      Offset time for PWM output.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetOutputOffset
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_PeriodType, AUTOMATIC) OffsetTick
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETOUTPUTOFFSET);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETOUTPUTOFFSET);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);

    /* Check if channel OutputOffset is enable */
    if (PWM_FALSE == ChannelPtr->OutputOffsetEnable)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETOUTPUTOFFSET);
    }
    /* Check if OffsetTick is valid */
    else if (PWM_FALSE == Pwm_CheckOutputOffsetInternal(ChannelPtr, OffsetTick))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_TICK, PWM_API_SETOUTPUTOFFSET);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETOUTPUTOFFSET);
    }
    else
    {
      /* Set output offset */
      Pwm_SetOutputOffsetInternal(ChannelPtr, OffsetTick, (boolean)PWM_WAITINGUPDATE_SUPPORTED);
    }
  }
}
#endif /* (PWM_SET_OUT_OFFSET_API == STD_ON) */

#if (PWM_SET_TRIGGER_DELAY_API == STD_ON)
/** \brief Pwm_SetTriggerDelay
 **
 ** Service to set offset for output trigger.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] TriggerTicks    Delay time for output trigger.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetTriggerDelay
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_PeriodType, AUTOMATIC) TriggerTicks
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETTRIGGERDELAY);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETTRIGGERDELAY);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check if channel support set output trigger */
    if (PWM_TRIGGER_DISABLE == ChannelPtr->TriggerOutputSelect)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETTRIGGERDELAY);
    }
    /* Check if channel support set output offset */
    else if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETTRIGGERDELAY);
    }
    /* Check if OffsetTick is in valid range */
    else if (PWM_FALSE == Pwm_CheckTriggerTicksInternal(ChannelPtr, TriggerTicks))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_TICK, PWM_API_SETTRIGGERDELAY);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETTRIGGERDELAY);
    }
    else
    {
      /* Set output trigger offset */
      Pwm_SetTriggerDelayInternal(ChannelPtr, TriggerTicks, (boolean)PWM_WAITINGUPDATE_SUPPORTED);
    }
  }
}
#endif /* (PWM_SET_TRIGGER_DELAY_API == STD_ON) */

#if (PWM_SET_PRESCALER_API == STD_ON)
/** \brief Pwm_SetPrescaler
 **
 ** Service to set prescaler for the specified channel.
 **
 ** \param [in] ChannelNumber    Numeric identifier of the PWM channel.
 ** \param [in] ClockFrequency   Input clock frequency.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetPrescaler
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETPRESCALER);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETPRESCALER);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check whether channel is waiting trigger */
    if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETPRESCALER);
    }
    /* Checks the effective range of the division ratio and set the prescaler value */
    else if (PWM_FALSE == Pwm_SetPrescalerInternal(ChannelPtr, ClockFrequency))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CLOCK, PWM_API_SETPRESCALER);
    }
    else
    {
      /* Do nothing */
    }
  }
}
#endif /* (PWM_SET_PRESCALER_API == STD_ON) */

#if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON)
/** \brief Pwm_SetPeriodAndDuty
 **
 ** Service sets the period and the duty cycle of a PWM channel.
 **
 ** \param [in] ChannelNumber   Numeric identifier of the PWM channel.
 ** \param [in] Period          Period of the PWM signal.
 ** \param [in] DutyCycle       Value of DutyCycle: Min=0x0000 Max=0x8000.
 **
 */
FUNC(void, PWM_CODE) Pwm_SetPeriodAndDuty
(
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber,
  VAR(Pwm_PeriodType, AUTOMATIC) Period,
  VAR(uint16, AUTOMATIC) DutyCycle
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_SETPERIODANDDUTY);
  }
  /* Check if ChannelNumber is valid */
  else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_SETPERIODANDDUTY);
  }
  else
  {
    /* Get config pointer for specified channel */
    ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
    /* Check if period can be changed */
    if (PWM_VARIABLE_PERIOD != ChannelPtr->ChannelClass)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PERIOD_UNCHANGEABLE, PWM_API_SETPERIODANDDUTY);
    }
    /* Check if Period is in valid range */
    else if (Period > PWM_PERIOD_MAX)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PERIOD_OUT_OF_RANGE, PWM_API_SETPERIODANDDUTY);
    }
    /* Check if DutyCycle is in valid range */
    else if (PWM_FALSE == Pwm_CheckDutyCycleInternal(ChannelPtr, Period, DutyCycle))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_DUTY_OUT_OF_RANGE, PWM_API_SETPERIODANDDUTY);
    }
    /* Check if Period is in valid range */
    else if (PWM_FALSE == Pwm_CheckPeriodInternal(ChannelPtr, Period, DutyCycle))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PERIOD_OUT_OF_RANGE, PWM_API_SETPERIODANDDUTY);
    }
    /* Check whether channel is waiting trigger */
    else if (PWM_TRUE == Pwm_CheckChannelStatus_WaitingTrigger(ChannelPtr))
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_SETPERIODANDDUTY);
    }
    else
    {
      /* Set period and duty */
      Pwm_SetPeriodAndDutyInternal
      (ChannelPtr,
       Period,
       DutyCycle,
       (boolean)PWM_PERIOD_UPDATEDENDPERIOD,
       (boolean)PWM_WAITINGUPDATE_SUPPORTED);
    }
  }
}
#endif /* (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) */

/** \brief Pwm_InterruptHandler
 **
 ** Handles channel interrupt. This function is called only within the ISR.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 ** \param [in] ResourceIndex    Hardware resource index.
 **
 */
FUNC(void, PWM_CODE) Pwm_InterruptHandler
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(uint16, AUTOMATIC) ResourceIndex
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  VAR( Pwm_ChannelType, AUTOMATIC ) ChannelNumber;
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Clear the interrupt flag by base address */
    Pwm_ClearChannelInterruptByBaseAddr(BaseAddress);

    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_INTERRUPTHANDLER);
  }
  else
  {
    /* Get channel identifier */
    ChannelNumber = ConfigDataPtr->HWResourcePtr[ResourceIndex];
    
    /* Check if ChannelNumber is valid */
    if (ChannelNumber < ConfigDataPtr->NumberOfChannels)
    {
      /* Get config pointer for specified channel */
      ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
      /* Handle interrupt */
      Pwm_InterruptHandlerInternal(ChannelPtr);
    }
    else
    {
      /* Clear the interrupt flag by base address */
      Pwm_ClearChannelInterruptByBaseAddr(BaseAddress);
    }
  }
}

/** \brief Pwm_StartGroupTrigger
 **
 ** Service to start the trigger all PWM channels in specified channel group.
 **
 ** \param [in] ChannelGroupNumber     Numeric identifier of a PWM channel group.
 **
 */
FUNC(void, PWM_CODE) Pwm_StartGroupTrigger
(
  VAR(Pwm_ChannelGroupType, AUTOMATIC) ChannelGroupNumber
)
{
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_STARTGROUPTRIGGER);
  }
  /* Check if ChannelGroupNumber is valid */
  else if (ChannelGroupNumber >= ConfigDataPtr->NumberOfGroups)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_GROUP, PWM_API_STARTGROUPTRIGGER);
  }
  /* Check whether channels in specified channel group is waiting trigger */
  else if (PWM_TRUE == Pwm_CheckGroupChannelsStatus_WaitingTrigger(ConfigDataPtr, ChannelGroupNumber))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_STARTGROUPTRIGGER);
  }
  /* Check whether channels in specified channel group have inconsistent prescaler value */
  else if (PWM_TRUE == Pwm_CheckGroupPrescalerValue(ConfigDataPtr, ChannelGroupNumber))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_DIFFERENT_PRESCALER, PWM_API_STARTGROUPTRIGGER);
  }
  else
  {
    /* Start channels in group */
    Pwm_StartGroupTriggerInternal(ConfigDataPtr, ChannelGroupNumber);
  }
}

#if (PWM_STOPGROUPTRIGGER_SUPPORTED == STD_ON)
/** \brief Pwm_StopGroupTrigger
 **
 ** Service to stop the trigger all Pwm channels in specified channel group.
 **
 ** \param [in] ChannelGroupNumber     Numeric identifier of a PWM channel group.
 **
 */
FUNC(void, PWM_CODE) Pwm_StopGroupTrigger
(
  VAR(Pwm_ChannelGroupType, AUTOMATIC) ChannelGroupNumber
)
{
  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);

  /* Check configuration status and driver status. */
  if ((PWM_S_INITIALIZED != Pwm_GetDriverStatus()) || (PWM_FALSE == ConfigState))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_UNINIT, PWM_API_STOPGROUPTRIGGER);
  }
  /* Check if ChannelGroupNumber is valid */
  else if (ChannelGroupNumber >= ConfigDataPtr->NumberOfGroups)
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_GROUP, PWM_API_STOPGROUPTRIGGER);
  }
  /* Check whether channels in specified channel group is waiting trigger */
  else if (PWM_TRUE == Pwm_CheckGroupChannelsStatus_WaitingTrigger(ConfigDataPtr, ChannelGroupNumber))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_WAITING_TRIGGER, PWM_API_STOPGROUPTRIGGER);
  }
  else
  {
    /* Stop channels in group */
    Pwm_StopGroupTriggerInternal(ConfigDataPtr, ChannelGroupNumber);
  }
}
#endif /* (PWM_STOPGROUPTRIGGER_SUPPORTED == STD_ON) */

/** \brief Pwm_GetChannelStatus
 **
 ** Service to read the current status of the channel.
 **
 ** The function reads out several hardware register and puts them in a 
 ** structure which reflects the internal state. 
 ** In this structure the values "periodTicks" and "dutyTicks" correspond to the
 ** ticks which are used for creation of the PWM signal, but they are not 
 ** identical to the values from the hardware registers. This is due to a 
 ** hardware limitation of the registers which is taken into account by this 
 ** function.
 **
 ** \param [out] DriverStatusPtr    Pointer of driver status data.
 ** \param [out] ChannelStatusPtr   Pointer to where to store the current channel
 **                                 specific status parameters.
 ** \param [in]  ChannelNumber      Numeric identifier of the PWM channel.
 **
 ** \return     E_OK: Software and hardware states are in sync.
 **             E_NOT_OK: Software and hardware states are inconsistent.
 ** 
 */
FUNC(Std_ReturnType, PWM_CODE) Pwm_GetChannelStatus
(
  P2VAR(Pwm_DriverStatusType, AUTOMATIC, PWM_APPL_DATA)  DriverStatusPtr,
  P2VAR(Pwm_ChannelStatusType, AUTOMATIC, PWM_APPL_DATA) ChannelStatusPtr,
  VAR(Pwm_ChannelType, AUTOMATIC) ChannelNumber
)
{
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr;
  VAR(Std_ReturnType, AUTOMATIC) CheckResult = E_NOT_OK;

  /* Get global config pointer */
  P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigDataPtr = Pwm_GetConfigPtr();
  /* Get configuration status */
  VAR(boolean, AUTOMATIC) ConfigState = Pwm_CheckConfigPtr(ConfigDataPtr);
  /* Get driver status */
  VAR(Pwm_DriverStatusType, AUTOMATIC) DriverState = Pwm_GetDriverStatus();

  /* Check if pointer is null */
  if ((NULL_PTR == DriverStatusPtr) || (NULL_PTR == ChannelStatusPtr))
  {
    /* Report an error */
    Pwm_ReportError(PWM_E_PARAM_POINTER, PWM_API_GETCHANNELSTATUS);
  }
  else 
  {
    /* Set driver state */
    *DriverStatusPtr = DriverState;
    
    /* Check ConfigDataPtr and driver status */
    if ((PWM_S_INITIALIZED != DriverState) && (NULL_PTR == ConfigDataPtr))
    {
      /* Nothing is checked when not initialized after reset */
      CheckResult = E_OK;
    }
    /* Check configuration status */
    else if (PWM_FALSE == ConfigState)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_UNINIT, PWM_API_GETCHANNELSTATUS);
    }
    /* Check if ChannelNumber is valid */
    else if (ChannelNumber >= ConfigDataPtr->NumberOfChannels)
    {
      /* Report an error */
      Pwm_ReportError(PWM_E_PARAM_CHANNEL, PWM_API_GETCHANNELSTATUS);
    }
    else
    {
      /* Get config pointer for specified channel */
      ChannelPtr = &(ConfigDataPtr->ChannelConfigPtr[ChannelNumber]);
      /* Get channel status information */
      if (PWM_TRUE == Pwm_GetChannelStatusInternal(ChannelStatusPtr, ChannelPtr))
      {
        /* Set CheckResult */
        CheckResult = E_OK;
      }
    }
  }
  return CheckResult;
}

/** \brief Pwm_EnterCriticalSection
 **
 ** This function enters exclusive area (call SchM module).
  */
FUNC(void, PWM_CODE) Pwm_EnterCriticalSection(void)
{
  SchM_Enter_Pwm_PWM_EXCLUSIVE_AREA_0();
}

/** \brief Pwm_ExitCriticalSection
 **
 ** This function exits exclusive area (call SchM module).
 */
FUNC(void, PWM_CODE) Pwm_ExitCriticalSection(void)
{
  SchM_Exit_Pwm_PWM_EXCLUSIVE_AREA_0();
}

#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[internal function definitions]==========================*/

#define PWM_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/** \brief Pwm_GetConfigPtr
 **
 ** Returns the pointer of the current configuration set.
 **
 ** \return Pointer of data stored current configuration set information.
 **
 */
static FUNC_P2CONST(Pwm_ConfigType, PWM_APPL_CONST, PWM_CODE) Pwm_GetConfigPtr(void)
{
  return(Pwm_ConfigPtr);
}

#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>
/*==================[end of file]============================================*/
