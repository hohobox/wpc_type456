/*-----------------------------------------------------------------------------
* Hyundai-AutoEver Cryptography Library
* Copyright (c) 2015-2016 Hyundai-AutoEver all rights reserved.
------------------------------------------------------------------------------*/
/**
* \file		Hmg_Tdes.h
* \date		Oct. 2016.
* \version	1.6.0
* \author	Hyundai_Autoever Automotive Security Techology Team
* \brief	TDES(Triple DES) algorithm implementation
* \see		NIST SP 800-67
*/

/* DEFINE TO PREVENT RECURSIVE INCLUSION -------------------------------------*/
#ifndef HMG_TDES_H_
#define HMG_TDES_H_

/* INCLUDES ------------------------------------------------------------------*/
#include "Hmg_Common.h"

/* EXPORTED DEFINES ----------------------------------------------------------*/

/** Encryption */
#define HMG_ENC (0U)
/** Decryption */
#define HMG_DEC (1U)

/** \brief Byte size for DES one-block */
#define HMG_DES_BLOCK_BYTE_SIZE		8U
/** \brief the number of rounds for DES algorithm */
#define HMG_DES_ROUNDS				16U
/** \brief Double-word size on DES one-block */
#define	HMG_DES_BLOCK_DWORD_SIZE	2U
/** \brief DES key size */
#define	HMG_DES_KEY_BYTE_SIZE		8U


#define HMG_DES_WEAKKEYS    64U

/** \brief Double-word size on DES one-block */
#define HMG_TDES_ENCRYPT		(HMG_ENC)
/** \brief Double-word size on DES one-block */
#define HMG_TDES_DECRYPT		(HMG_DEC)
/** \brief 268,435,455 := 2G*8-byte encryption available */
#define HMG_TDES_DATA_MAX_LEN	0x0fffffffU
/** \brief Number of TDES keys */
#define	HMG_TDES_THREE_KEY		3U

/* EXPORTED MACROS -----------------------------------------------------------*/

/* EXPORTED TYPES ------------------------------------------------------------*/
/** \brief Half des_block 32-bit. */
typedef unsigned long HmgDesBlock32;

/** \brief Des key schedueling  */
typedef struct ctDesKey{
	HmgDesBlock32 l;	/**< left 32-bit block */
	HmgDesBlock32 r;	/**< right 32-bit block */
} HmgDesKey;

typedef struct stTdesEcbCtx {
    HmgDesKey tdeskey[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS];
    uint32 totalLen;
} HmgTdesEcbCtx;

typedef struct stTdesCbcCtx {
    HmgDesKey tdeskey[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS];
    uint32 totalLen;
    uint8 iv[HMG_DES_BLOCK_BYTE_SIZE];
} HmgTdesCbcCtx;

typedef struct stTdesCtrCtx {
    HmgDesKey tdeskey[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS];
    uint32 totalLen;
    uint8 block[HMG_DES_BLOCK_BYTE_SIZE];
    uint8 blockLen;
} HmgTdesCtrCtx;

typedef struct stTdesCmacCtx {
    HmgDesKey tdeskey[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS];
    uint32 totalLen;
    uint8 block[HMG_DES_BLOCK_BYTE_SIZE];
    uint8 blockLen;
} HmgTdesCmacCtx;

/* EXPORTED VARIABLES --------------------------------------------------------*/

/* EXPORTED FUNCTIONS --------------------------------------------------------*/


/** \brief  TDES key schedule
*
* Generate round keys for TDES operation, 
* after check whether the keys are all equal, that is, single key is used
* Becuase single key leads DES algorithm, we do prevent DES only used.
* If Weak key check is on, this function also check whether the key is weak.
* \param[out]	ks		key schedule output for TDES round operations
* \param[in]	key		three DES keys (3 * 8 = 24 bytes required)
* \return		success or failure
* \see			Hmg_DesKeySchedule(), Hmg_TdesSingleKeyCheck()
*/
extern uint8 Hmg_TdesSetKey(
	HMG_OUT	HmgDesKey 	key[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS],
	HMG_IN	uint8		keyT[HMG_TDES_THREE_KEY * HMG_DES_KEY_BYTE_SIZE]
	);

#ifdef HMG_ENABLE_TDES_ECB
/** \brief  TDES ECB mode Encryption / Decryption
*
* Generate ciphertext or plaintext with ECB(Electronic CodeBook) mode on TDES.
* As set mode, it decides encryption or decryption.
* \param[out]	out		Encrypted ciphertext or decrypted plaintext output
* \param[in]	in		Plaintext or ciphertext input to be crypted
* \param[in]	inLen		Input length
* \param[in]	key		Triple keys generated byy TDES key scheduling
* \param[in]	mode	Encryption or decryption mode
* \return		success or failure
* \see			HMG_TDES_ENCRYPT, HMG_TDES_DECRYPT, Hmg_TdesKeySchedule()
*/
extern uint8 Hmg_TdesEcbCrypt(
	HMG_OUT		uint8 *out,
	HMG_IN		uint8 *in,
	HMG_IN		uint32 inLen,
	HMG_IN		HmgDesKey  key[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS],
	HMG_IN		uint8 mode
	);



uint8 Hmg_TdesEcbEncStart(
    HMG_INOUT HmgTdesEcbCtx* tdesEcbCtx,
    HMG_IN uint8 *key,
    HMG_IN uint8 keyLen
    );
uint8 Hmg_TdesEcbEncUpdate(
    HMG_INOUT HmgTdesEcbCtx* tdesEcbCtx,
    HMG_OUT uint8* out,
    HMG_IN uint8* in,
    HMG_IN uint32 inLen
    );
uint8 Hmg_TdesEcbEncFinish(
    HMG_IN HmgTdesEcbCtx* tdesEcbCtx,
    HMG_OUT uint32* totalLen
    );

uint8 Hmg_TdesEcbDecStart(
    HMG_INOUT HmgTdesEcbCtx* tdesEcbCtx,
    HMG_IN uint8 *key,
    HMG_IN uint8 keyLen
    );
uint8 Hmg_TdesEcbDecUpdate(
    HMG_INOUT HmgTdesEcbCtx* tdesEcbCtx,
    HMG_OUT uint8* out,
    HMG_IN uint8* in,
    HMG_IN uint32 inLen
    );
uint8 Hmg_TdesEcbDecFinish(
    HMG_IN HmgTdesEcbCtx* tdesEcbCtx,
    HMG_OUT uint32* totalLen
    );


#endif
#ifdef HMG_ENABLE_TDES_CBC

/** \brief  TDES CBC mode Encryption / Decryption
*
* Generate ciphertext or plaintext with CBC(Cipher Block Chaining) mode on TDES.
* As set mode, it decides encryption or decryption.
* \param[out]	out		Encrypted ciphertext or decrypted plaintext output
* \param[in]	in		Plaintext or ciphertext input to be crypted
* \param[in]	iv		Initialization vector
* \param[in]	key		Triple keys generated byy TDES key scheduling
* \param[in]	inLen		Input length
* \param[in]	mode	Encryption or decryption mode
* \return		success or failure
* \see			HMG_TDES_ENCRYPT, HMG_TDES_DECRYPT, Hmg_TdesKeySchedule()
*/
extern uint8 Hmg_TdesCbcCrypt(
	HMG_OUT		uint8 *out,
	HMG_IN		uint8 *in,
	HMG_IN		uint32 inLen,
	HMG_IN		uint8 iv[],
	HMG_IN		HmgDesKey  key[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS],
	HMG_IN		uint8 mode
	);

uint8 Hmg_TdesCbcEncStart(
    HMG_INOUT HmgTdesCbcCtx* tdesCbcCtx,
    HMG_IN uint8 *iv,
    HMG_IN uint8 ivLen,
    HMG_IN uint8 *key,
    HMG_IN uint8 keyLen
    );
uint8 Hmg_TdesCbcEncUpdate(
    HMG_INOUT HmgTdesCbcCtx* tdesCbcCtx,
    HMG_OUT uint8* out,
    HMG_IN uint8* in,
    HMG_IN uint32 inLen
    );
uint8 Hmg_TdesCbcEncFinish(
    HMG_IN HmgTdesCbcCtx* tdesCbcCtx,
    HMG_OUT uint32* totalLen
    );

uint8 Hmg_TdesCbcDecStart(
    HMG_INOUT HmgTdesCbcCtx* tdesCbcCtx,
    HMG_IN uint8 *iv,
    HMG_IN uint8 ivLen,
    HMG_IN uint8 *key,
    HMG_IN uint8 keyLen
    );
uint8 Hmg_TdesCbcDecUpdate(
    HMG_INOUT HmgTdesCbcCtx* tdesCbcCtx,
    HMG_OUT uint8* out,
    HMG_IN uint8* in,
    HMG_IN uint32 inLen
    );
uint8 Hmg_TdesCbcDecFinish(
    HMG_IN HmgTdesCbcCtx* tdesCbcCtx,
    HMG_OUT uint32* totalLen
    );


#endif
#ifdef HMG_ENABLE_TDES_CTR

/** \brief  TDES Counter mode Encryption / Decryption
*
* Generate ciphertext or plaintext with Counter mode on TDES.
* Counter mode encryption and decryption have same operation.
* So there is no encryption mode unlikely CBC and ECB mode.
* The counter is initiated with IV and the last half 32-bit is used as counter
* , which is increamented by one, and when it reaches maximum bit, get back to zero.
* \param[out]	out		Encrypted ciphertext or decrypted plaintext output
* \param[in]	in		Plaintext or ciphertext input to be crypted
* \param[in]	iv		Initialization vector
* \param[in]	key		Triple keys generated byy TDES key scheduling
* \param[in]	inLen	Input length
* \return		success or failure
* \see
*/
extern uint8 Hmg_TdesCtrCrypt(
	HMG_OUT		uint8 *out,
	HMG_IN		uint8 *in,
	HMG_IN		uint32 inLen,
	HMG_IN		uint8 iv[],
	HMG_IN		HmgDesKey  key[HMG_TDES_THREE_KEY][HMG_DES_ROUNDS]
	);

uint8 Hmg_TdesCtrStart(
    HMG_INOUT HmgTdesCtrCtx* tdesCtrCtx,
    HMG_IN uint8 *iv,
    HMG_IN uint8 ivLen,
    HMG_IN uint8 *key,
    HMG_IN uint8 keyLen
    );
uint8 Hmg_TdesCtrUpdate(
    HMG_INOUT HmgTdesCtrCtx* tdesCtrCtx,
    HMG_OUT uint8* out,
    HMG_IN uint8* in,
    HMG_IN uint32 inLen
    );
uint8 Hmg_TdesCtrFinish(
    HMG_IN HmgTdesCtrCtx* tdesCtrCtx,
    HMG_OUT uint32* totalLen
    );


#endif
#ifdef HMG_ENABLE_TDES_CMAC

/** \brief  TDES Cmac(CBC message Authentication code)
*
* Generate Cmac on TDES.
* \param[out]	tag		MAC data output
* \param[in]	key		TDES key
* \param[in]	msg		Input message to be digested
* \param[in]	msgLen	Input message length
* \return		success or failure
* \see
*/
uint8 Hmg_TdesCmac(
	HMG_OUT uint8 tag[8],
	HMG_IN uint8 *key,
	HMG_IN uint8 *msg,
	HMG_IN uint32 msgLen
	);

uint8 Hmg_TdesCmacStart(
    HMG_INOUT HmgTdesCmacCtx *cmacCtx,
    HMG_IN uint8 *key,
    HMG_IN uint8  keyLen
    );
uint8 Hmg_TdesCmacUpdate(
    HMG_INOUT HmgTdesCmacCtx *cmacCtx,
    HMG_IN uint8 *msg,
    HMG_IN uint32 msgLen
    );
uint8 Hmg_TdesCmacFinish(
    HMG_INOUT HmgTdesCmacCtx *cmacCtx,
    HMG_OUT uint8 tag[8],
    HMG_OUT uint32 *totalLen
    );

#endif

#endif
/* END OF FILE ---------------------------------------------------------------*/
