/** \file Icu_Channel_TimeStamp.c
 **
 ** This file contains timestamp mode internal architecture function for
 ** the AUTOSAR Icu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Icu_Channel_TimeStamp.h>
#include <Icu_Internal.h>
#include <Icu_Resource.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/
#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>

/** \brief Icu_StopTimestampChannelState
 **
 ** This function implements to stop channel and clear input trigger.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in]  ChannelCtrl     Control the channel stop or no stop.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_StopTimestampChannelState
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
);


#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>


/** \brief Icu_StartTimestampDma_Internal
 **
 ** This function implements to start timestamp measurement, if channel uses DW.
 **
 ** \param[in] ChannelPtr     Pointer to the channel configuration.
 ** \param[in] BufferPtr      Pointer to the buffer-array where the timestamp values shall be placed.
 ** \param[in] BufferSize     Size of the external buffer(number of entries).
 ** \param[in] NotifyInterval Notification interval (number of events).
 **                           This parameter cannot be checked in a reasonable way.
 ** \param[in] ChannelCtrl    Control the channel start or no start.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StartTimestampDma_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  P2VAR(Icu_ValueType, AUTOMATIC, ICU_APPL_DATA)            BufferPtr,
  VAR(uint16, AUTOMATIC)                                    BufferSize,
  VAR(uint16, AUTOMATIC)                                    NotifyInterval,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
  Icu_EnterCritiSec();

  ChExtStatePtr->EdgeNumber     = 0U;       /* set edge counter to 0 for notification */
  ChExtStatePtr->BufferPos      = 0U;
  ChExtStatePtr->BufferPtr      = BufferPtr;
  if (ChExtCfgPtr->Notification != NULL_PTR)
  {
    ChExtStatePtr->BufferSize     = BufferSize;
    ChExtStatePtr->NotifyInterval = NotifyInterval;
  }

  /* DataWire Enable  */
  Icu_Resource_Tcpwm_DwSetting(ChannelPtr);
  if (ChannelCtrl == ICU_CHSTART)
  {
    FuncTablePtr->drvReloadCountTrigger(ChannelPtr);
  }
  /* Enable DW interrupt */
  Icu_Resource_Tcpwm_DwInterruptEnable(ChannelPtr);
  /* Set running status */
  ChannelPtr->StatePtr->Status = ICU_RUNNING;

  Icu_ExitCritiSec();
}

/** \brief Icu_StopTimestampDma_Internal
 **
 ** This function implements to stop timestamp measurement, if channel uses DW.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] ChannelCtrl  Control the channel stop or no stop.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StopTimestampDma_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  Icu_EnterCritiSec();

  /* Disable DW transfer */
  Icu_Resource_Tcpwm_DwDisable(ChannelPtr);
  Icu_StopTimestampChannelState(ChannelPtr, ChannelCtrl);
  /* Update buffer index */
  ChExtStatePtr->BufferPos = Icu_Resource_Tcpwm_GetDwBuffIndex(ChannelPtr);
  /* Disable DW interrupt */
  Icu_Resource_Tcpwm_DwInterruptDisable(ChannelPtr);

  Icu_ExitCritiSec();
}

/** \brief Icu_GetTimestampIndexDma_Internal
 **
 ** This function reads the timestamp index of the given channel, if channel uses DW.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Timestamp index of the given channel.
 ** */
FUNC(Icu_IndexType, ICU_CODE) Icu_GetTimestampIndexDma_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  Icu_EnterCritiSec();

  if (ChannelPtr->StatePtr->Status == ICU_RUNNING)
  {
    /* Get buffer index */
    ChExtStatePtr->BufferPos = Icu_Resource_Tcpwm_GetDwBuffIndex(ChannelPtr);
  }

  Icu_ExitCritiSec();

  return ChExtStatePtr->BufferPos;
}

/** \brief Icu_CheckBufferSizeDma_Internal
 **
 ** This function implements to check timestamp buffer size, if channel uses DW.
 **
 ** \param[in] ChannelPtr     Pointer to the channel configuration.
 ** \param[in] BufferSize     Size of the external buffer(number of entries).
 ** \param[in] NotifyInterval Notification interval (number of events).
 **                           This parameter cannot be checked in a reasonable way.
 **
 ** \return    The return whether buffer size occurs error.
 **            TRUE:  No error occur.
 **            FALSE: Error occur.
 ** */
FUNC(boolean, ICU_CODE) Icu_CheckBufferSizeDma_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint16, AUTOMATIC)                                    BufferSize,
  VAR(uint16, AUTOMATIC)                                    NotifyInterval
)
{
  boolean SizeCondition = FALSE;
  uint16 Xcount;
  uint16 Ycount;
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  if (ChExtCfgPtr->UseDMA == TRUE)
  {
    if (ChExtCfgPtr->Notification == NULL_PTR)
    {
      for(Ycount=1U; Ycount <= ICU_DW_COUNT_SIZE; Ycount++)
      {
        if( ((BufferSize % Ycount) == 0U) && ((BufferSize / Ycount) <= ICU_DW_COUNT_SIZE))
        {
          Xcount = BufferSize / Ycount;
          SizeCondition = TRUE;
          ChExtStatePtr->BufferSize     = BufferSize;
          ChExtStatePtr->NotifyInterval = Xcount;
          break;
        }
      }
    }
    else
    {
      if ((BufferSize / NotifyInterval) <= ICU_DW_COUNT_SIZE)
      {
        SizeCondition = TRUE;
      }
    }
  }
  else
  {
    SizeCondition = TRUE;
  }

  return SizeCondition;
}

/** \brief Icu_StartTimestamp_Internal
 **
 ** This function implements to start timestamp measurement.
 **
 ** \param[in] ChannelPtr     Pointer to the channel configuration.
 ** \param[in] BufferPtr      Pointer to the buffer-array where the timestamp values shall be placed.
 ** \param[in] BufferSize     Size of the external buffer(number of entries).
 ** \param[in] NotifyInterval Notification interval (number of events).
 **                           This parameter cannot be checked in a reasonable way.
 ** \param[in] ChannelCtrl    Control the channel start or no start.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StartTimestamp_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  P2VAR(Icu_ValueType, AUTOMATIC, ICU_APPL_DATA)            BufferPtr,
  VAR(uint16, AUTOMATIC)                                    BufferSize,
  VAR(uint16, AUTOMATIC)                                    NotifyInterval,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  Icu_EnterCritiSec();

  ChExtStatePtr->EdgeNumber     = 0U;       /* set edge counter to 0 for notification */
  ChExtStatePtr->BufferPos      = 0U;
  ChExtStatePtr->BufferPtr      = BufferPtr;
  ChExtStatePtr->BufferSize     = BufferSize;
  ChExtStatePtr->NotifyInterval = NotifyInterval;

  FuncTablePtr->drvClearInterruptRequestFlag(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
  /* TCPWM Interrupt Enable */
  FuncTablePtr->drvIsrEnable(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);

  if (ChannelCtrl == ICU_CHSTART)
  {
    FuncTablePtr->drvReloadCountTrigger(ChannelPtr);
  }
  /* Set running status */
  ChannelPtr->StatePtr->Status = ICU_RUNNING;

  Icu_ExitCritiSec();

}

/** \brief Icu_StopTimestamp_Internal
 **
 ** This function implements to stop timestamp measurement.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] ChannelCtrl  Control the channel stop or no stop.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StopTimestamp_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();

  Icu_EnterCritiSec();

  Icu_StopTimestampChannelState(ChannelPtr, ChannelCtrl);
  /* Disable CC0_MATCH interrupt */
  FuncTablePtr->drvIsrDisable(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);

  Icu_ExitCritiSec();
}

/** \brief Icu_GetTimestampIndex_Internal
 **
 ** This function reads the timestamp index of the given channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Timestamp index of the given channel.
 ** */
FUNC(Icu_IndexType, ICU_CODE) Icu_GetTimestampIndex_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  Icu_IndexType  ret;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  ret= ChExtStatePtr->BufferPos;  /* Get Status Data Index */

  return ret;
}

/** \brief Icu_TimeStamp_InterruptEvent
 **
 ** This function is the ISR of timestamp mode.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntrFlag     Interrupt request flag of channel.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_TimeStamp_InterruptEvent
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC) IntrFlag
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  P2CONST(Icu_drvFctTable_t,     AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();
  boolean NotiFlag = FALSE;
  boolean OverNotiFlag = FALSE;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;

  /* Check if channel is in running state */
  if (ICU_RUNNING == ChannelPtr->StatePtr->Status)
  {
    Icu_EnterCritiSec();

    /* Check if capture interrupt(cc0_match) is detected */
    if (0U != (ICU_INT_CAPTURE & IntrFlag))
    {
      uint16  BufPos = ChExtStatePtr->BufferPos;
      ChExtStatePtr->BufferPtr[BufPos] = Icu_Resource_Tcpwm_GetCc0Counter(ChannelPtr);
      BufPos++;
      if (BufPos >= ChExtStatePtr->BufferSize)
      {
        if (ChExtCfgPtr->BufferMode == ICU_CIRCULAR_BUFFER)
        {
          /* Cyclic buffering; filling the buffer continues from the beginning */
          BufPos = 0U;
        }
        else /* (ChExtCfgPtr->BufferMode == ICU_LINEAR_BUFFER) */
        {
          /* Linear buffering; filling the buffer will just be done once */
          Icu_StopTimestampChannelState(ChannelPtr, ICU_CHSTOP);
          /* Disable capture(cc0_match) interrupt */
          FuncTablePtr->drvIsrDisable(ChannelPtr, ICU_MASK_INTR_MASK_CC0_MATCH);
        }
      }
      ChExtStatePtr->BufferPos = BufPos;
      if (ChExtCfgPtr->Notification != NULL_PTR)
      {
        ChExtStatePtr->EdgeNumber++;
        /* Check if call notification function */
        if (ChExtStatePtr->NotifyInterval == ChExtStatePtr->EdgeNumber)
        {
          ChExtStatePtr->EdgeNumber = 0U;
          /* Check if notification is configured */
          if (ChExtStatePtr->NotifyEnabled == TRUE)
          {
            NotiFlag = TRUE;
          }
        }
      }
    }
    /* Check if overflow interrupt(tc) is detected */
    if (0U != (ICU_INT_OVERFLOW & IntrFlag))
    {
      if (ChannelPtr->OverflowNotification  != NULL_PTR)
      {
        OverNotiFlag = TRUE;
      }
    }

    Icu_ExitCritiSec();

    /* Check if call notification function */
    if (NotiFlag == TRUE)
    {
      ChExtCfgPtr->Notification();
    }
    /* Check if call overflow notification function */
    if (OverNotiFlag == TRUE)
    {
      ChannelPtr->OverflowNotification();
    }
  }
}

/** \brief Icu_TimeStamp_Dw_InterruptEvent
 **
 ** Internal function of the DataWire ISRs is based on timestamp mode to call interrupt event.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_TimeStamp_Dw_InterruptEvent
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean DwIntrFlag;
  uint8 EventStatus;
  uint32 DWStatus;
  P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE) DWReg;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 2 */
  ChExtCfgPtr = (P2CONST(Icu_TimeStampExtensionConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  /* Get DW base address */
  DWReg = (volatile P2VAR(Icu_DataWireRegType, ICU_CONST, REGSPACE))(ChExtCfgPtr->DWBaseAddress);

  DwIntrFlag = Icu_Resource_Tcpwm_DwGetInterruptFlag(DWReg);
  Icu_ClearDwIsr_Internal(DWReg);
  /* Check if channel is in running state */
  if (ICU_RUNNING == ChannelPtr->StatePtr->Status)
  {
    /* Check if DW interrupt if detected */
    if (TRUE == DwIntrFlag) /* DW interrupt was detected */
    {
      /* Enter critical section */
      Icu_EnterCritiSec();
      DWStatus = Icu_Resource_Tcpwm_GetDWStatus(ChannelPtr);
      DWStatus &= ICU_DW_MASK_CH_INTR_CAUSE;
      /* Completion status */
      if (DWStatus == ICU_DW_STATUS_COMPLETION)
      {
        if (ChExtCfgPtr->BufferMode == ICU_LINEAR_BUFFER)
        {
          /* Linear buffering; filling the buffer will just be done once */
          if(0u == Icu_Resource_Tcpwm_GetDwBuffIndex(ChannelPtr))
          {
            /* Disable DW transfer */
            Icu_Resource_Tcpwm_DwDisable(ChannelPtr);
            /* Disable channel */
            Icu_StopTimestampChannelState(ChannelPtr, ICU_CHSTOP);
            /* Disable DW interrupt */
            Icu_Resource_Tcpwm_DwInterruptDisable(ChannelPtr);
            /* Get BufferIndex */
            ChExtStatePtr->BufferPos = ChExtStatePtr->BufferSize;
          }
        }
        EventStatus = ICU_DEM_EVENT_STATUS_PASSED;
      }
      /* Error status */
      else if (DWStatus > ICU_DW_STATUS_COMPLETION)
      {
        /* Disable DW transfer */
        Icu_Resource_Tcpwm_DwDisable(ChannelPtr);
        /* Disable channel */
        Icu_StopTimestampChannelState(ChannelPtr, ICU_CHSTOP);
        /* Disable DW interrupt */
        Icu_Resource_Tcpwm_DwInterruptDisable(ChannelPtr);
        /* Update buffer index */
        ChExtStatePtr->BufferPos = Icu_Resource_Tcpwm_GetDwBuffIndex(ChannelPtr);
        EventStatus = ICU_DEM_EVENT_STATUS_FAILED;
      }
      else
      {
        /* Specifies the source of the interrupt cause: NO_INTR */
        EventStatus = ICU_DEM_EVENT_STATUS_PASSED;
      }
      Icu_ExitCritiSec();

      /* Call Dem report function */
      Icu_DemReportEvent(ICU_API_DW_INTERRUPT_EVENT, ICU_E_HW_ERROR, EventStatus);
      /* Check if DmaErrorNotification is configured  */
      if ((ChExtCfgPtr->DmaErrorNotification != NULL_PTR) && (EventStatus == ICU_DEM_EVENT_STATUS_FAILED))
      {
        /* Call IcuDmaErrorNotification function (outside critical section) */
        ChExtCfgPtr->DmaErrorNotification();
      }
      /* Check if notification is configured and notification is enabled */
      if ((ChExtCfgPtr->Notification != NULL_PTR) && (ChExtStatePtr->NotifyEnabled == TRUE) &&
          (DWStatus == ICU_DW_STATUS_COMPLETION))
      {
        /* Call notification function (outside critical section) */
        ChExtCfgPtr->Notification();
      }
    }
  }
}


/** \brief Icu_SetTimeStampNotification
 **
 ** This function implements to enable/disable the notification of a channel in timestamp mode.
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 ** \param[in] Noti       Value depended to set the notification state of the specified channel.
 **
 ** \return    None.
 ** */

FUNC(void, ICU_CODE) Icu_SetTimeStampNotification
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   Noti
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  ChExtStatePtr->NotifyEnabled = Noti;

}


/* \brief Icu_SetTimeStampOverflowNotification
 **
 ** This function implements to enable/disable the overflow notification of a channel in timestamp mode.
 **
 ** \param[in] ChannelPtr  Pointer to the channel configuration.
 ** \param[in] OverNoti    Value depended to set the overflow notification state of the specified channel.
 ** \param[in] Mode        ICU_MODE_NORMAL or ICU_MODE_SLEEP.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_SetTimeStampOverflowNotification
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   OverNoti,
  VAR(Icu_ModeType, AUTOMATIC)                              Mode
)
{
  P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_TimeStampChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtStatePtr->OverflowNotifyEnabled = OverNoti;
  if (ICU_MODE_NORMAL == Mode)
  {
    if (OverNoti == TRUE)
    {
      FuncTablePtr->drvClearInterruptRequestFlag(ChannelPtr, ICU_MASK_INTR_MASK_TC);
      /* Enable TC interrupt */
      FuncTablePtr->drvIsrEnable(ChannelPtr, ICU_MASK_INTR_MASK_TC);
    }
    else
    {
      /* Disable TC interrupt */
      FuncTablePtr->drvIsrDisable(ChannelPtr, ICU_MASK_INTR_MASK_TC);
    }
  }
}


#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[internal function definitions]=========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/** \brief Icu_StopTimestampChannelState
 **
 ** This function implements to stop channel and clear input trigger.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in]  ChannelCtrl     Control the channel stop or no stop.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_StopTimestampChannelState
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ChannelCtrlType, AUTOMATIC)                       ChannelCtrl
)
{
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();
  if (ChannelCtrl == ICU_CHSTOP)
  {
    /* Clear input trigger */
    FuncTablePtr->drvCtrlEnable(ChannelPtr, FALSE);
    FuncTablePtr->drvClearInputTrigger(ChannelPtr);
    FuncTablePtr->drvCtrlEnable(ChannelPtr, TRUE);
  }

  ChannelPtr->StatePtr->Status = ICU_STOPPED;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/*==================[end of file]===========================================*/
