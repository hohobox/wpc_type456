/** \file Icu_Channel_SignalMeasurement.c
 **
 ** This file contains signal measurement mode internal architecture
 ** function for the AUTOSAR Icu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Icu_Channel_SignalMeasurement.h>
#include <Icu_Internal.h>
#include <Icu_Resource.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>

/** \brief Icu_StartSignalMeasurement_Internal
 **
 ** This function implements to start signal measurement for given channel.
 **
 ** \param[in] ChannelPtr           Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StartSignalMeasurement_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32 RegValue;
  uint32 EdgeMode;
  uint32 StopEdge;
  uint32 ReloadEdge;
  Icu_ActivationType ActEdge;
  Icu_ActivationType InactEdge;

  P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST) ChExtCfgPtr;
  P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA) ChStatePtr;
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 3 */
  ChExtCfgPtr = (P2CONST(Icu_SignalMeasExtConfigType, AUTOMATIC, ICU_APPL_CONST)) ChannelPtr->ExtConfigPtr;
  ChStatePtr  = (P2VAR(Icu_ChannelCommonStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->StatePtr;
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  Icu_EnterCritiSec();
  FuncTablePtr->drvCtrlEnable(ChannelPtr, FALSE);
  /*
   *   Edge set by START/RELOAD/STOP/CAPTURE
   */
  RegValue = FuncTablePtr->drvGetActivationCondition(ChannelPtr);
  if ((ChExtCfgPtr->MeasurementProperty == ICU_HIGH_TIME)||
      (ChExtCfgPtr->MeasurementProperty == ICU_LOW_TIME))
  {
    ActEdge = (ChExtCfgPtr->MeasurementProperty == ICU_HIGH_TIME) ? ICU_RISING_EDGE : ICU_FALLING_EDGE;
    StopEdge = (ChExtCfgPtr->MeasurementProperty == ICU_HIGH_TIME) ? ICU_REGS_ICS_FALLING_EDGE : ICU_REGS_ICS_RISING_EDGE;
    ReloadEdge = (ChExtCfgPtr->MeasurementProperty == ICU_HIGH_TIME) ? ICU_REGS_ICS_RISING_EDGE : ICU_REGS_ICS_FALLING_EDGE;
    /* Set StopEdge to CAPTURE0_EDGE */
    RegValue &= ~ICU_MASK_TR_IN_EDGE_SEL_CAPTURE0_EDGE;
    RegValue |= StopEdge;
    /* Set StopEdge to STOP_EDGE */
    RegValue &= ~ICU_MASK_TR_IN_EDGE_SEL_STOP_EDGE;
    RegValue |= (uint32)(StopEdge << ICU_SHIFT_TR_IN_EDGE_SEL_STOP_EDGE);
  }
  else  /* ((ICU_PERIOD_TIME)|| (ICU_DUTY_CYCLE)) */
  {
    ActEdge = (ChannelPtr->StatePtr->ActivationEdge == ICU_RISING_EDGE) ? ICU_RISING_EDGE : ICU_FALLING_EDGE;
    ReloadEdge = Icu_Resource_Tcpwm_CalEdgeMode(ActEdge);
    RegValue &= ~ICU_MASK_TR_IN_EDGE_SEL_CAPTURE0_EDGE;
    if (ChExtCfgPtr->MeasurementProperty == ICU_PERIOD_TIME)
    {
      RegValue |= (uint32)ReloadEdge;
    }
    else  /* (ICU_DUTY_CYCLE) */
    {
      InactEdge = (ActEdge == ICU_RISING_EDGE) ? ICU_FALLING_EDGE : ICU_RISING_EDGE;
      EdgeMode = Icu_Resource_Tcpwm_CalEdgeMode(InactEdge);
      RegValue |= (uint32)EdgeMode;
      RegValue &= ~ICU_MASK_TR_IN_EDGE_SEL_CAPTURE1_EDGE;
      RegValue |= (uint32)(ReloadEdge << ICU_SHIFT_TR_IN_EDGE_SEL_CAPTURE1_EDGE);
    }
  }
  RegValue &= ~ICU_MASK_TR_IN_EDGE_SEL_RELOAD_EDGE;
  RegValue |= (uint32)(ReloadEdge << ICU_SHIFT_TR_IN_EDGE_SEL_RELOAD_EDGE);

  ChStatePtr->ActivationEdge = ActEdge;
  FuncTablePtr->drvSetActivationCondition(ChannelPtr, RegValue);
  FuncTablePtr->drvSetInputTrigger(ChannelPtr, ChannelPtr->InputTrigger);
  FuncTablePtr->drvCtrlEnable(ChannelPtr, TRUE);

  Icu_Resource_Tcpwm_ResetCounter(ChannelPtr, ICU_CC0_COUNT|ICU_CC1_COUNT|ICU_CC0_BUFF_COUNT|ICU_CC1_BUFF_COUNT);
  /* Set running status */
  ChStatePtr->Status = ICU_RUNNING;
  ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_INPUTSTATE] = ICU_IDLE;
  ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT] = ICU_IDLE;

  Icu_ExitCritiSec();
}

/** \brief Icu_StopSignalMeasurement_Internal
 **
 ** This function implements to stop signal measurement for given channel.
 **
 ** \param[in] ChannelPtr           Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_StopSignalMeasurement_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  P2CONST(Icu_drvFctTable_t,     AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 3 */
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  Icu_EnterCritiSec();

  ChannelPtr->StatePtr->Status = ICU_STOPPED;
  /* Clear input trigger */
  FuncTablePtr->drvCtrlEnable(ChannelPtr, FALSE);
  FuncTablePtr->drvClearInputTrigger(ChannelPtr);
  FuncTablePtr->drvCtrlEnable(ChannelPtr, TRUE);
  /* Set idle state */
  ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_INPUTSTATE] = ICU_IDLE;
  ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT] = ICU_IDLE;
  Icu_ExitCritiSec();
}

/** \brief Icu_GetTimeElapsed_Internal
 **
 ** This function implements to get time elapsed in given channel.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    The elapsed signal low time for the given channel.
 ** */
FUNC(Icu_ValueType, ICU_CODE) Icu_GetTimeElapsed_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_ValueType RetTime;
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  Icu_EnterCritiSec();

  /* Check new capture event */
  if (ChannelPtr->StatePtr->Status == ICU_RUNNING)
  {
    Icu_CheckNewMeas(ChannelPtr);
  }
  /* If new capture event has occurred, get time elapsed */
  if (ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT] == ICU_ACTIVE)
  {
    /* Get captured counter value. */
    RetTime = ChExtStatePtr->Time[ICU_CAPTURE_FLAG_MEASUREMENT];
    /* Set own input state flag to 'IDLE' */
    ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT] = ICU_IDLE;
  }
  /* If no data was captured yet, return 0 */
  else
  {
    /* Set return value to zero. */
    RetTime = 0u;
  }

  Icu_ExitCritiSec();

  return RetTime;
}

/** \brief Icu_GetDutyCycleValues_Internal
 **
 ** This function implements to read the coherent active time and period time
 ** for the given ICU Channel.
 **
 ** \param[in] ChannelPtr        Pointer to the channel configuration.
 ** \param[out] DutyCycleValuePtr Pointer to a buffer where the results
 ** (high time and period time) shall be placed.
 **
 ** \return    None.
 **
 ** */
FUNC(void, ICU_CODE) Icu_GetDutyCycleValues_Internal
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  P2VAR(Icu_DutyCycleType, AUTOMATIC, ICU_APPL_DATA) DutyCycleValuePtr
)
{
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;

  /* Enter to critical section */
  Icu_EnterCritiSec();

  /* Check new capture event */
  if (ChannelPtr->StatePtr->Status == ICU_RUNNING)
  {
    Icu_CheckNewMeas(ChannelPtr);
  }
  /*
    Note: Must refer to the object Icu_SignalMeasChannelStateType 
    in the critical section to avoid interference.
  */
  /* If new capture event has occurred, get active time and period time */
  if (ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT] == ICU_ACTIVE)
  {
    /* Store period and active time. */
    DutyCycleValuePtr->PeriodTime = ChExtStatePtr->Time[ICU_CAPTURE_FLAG_MEASUREMENT];
    DutyCycleValuePtr->ActiveTime = ChExtStatePtr->ActiveTime[ICU_CAPTURE_FLAG_MEASUREMENT];
    /* Set own input state flag to 'IDLE' */
    ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_MEASUREMENT] = ICU_IDLE;
  }
  /* If no data was captured yet, return 0 */
  else
  {
    /* Store zeros to indicate that no data is available. */
    DutyCycleValuePtr->PeriodTime = 0u;
    DutyCycleValuePtr->ActiveTime = 0u;
  }

  /* Leave from critical section */
  Icu_ExitCritiSec();
}


/** \brief Icu_Measure_InterruptEvent
 **
 ** This function is the ISR of measure mode.
 **
 ** \param[in] ChannelPtr    Pointer to the channel configuration.
 ** \param[in] IntrFlag      Interrupt request flag of channel.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Measure_InterruptEvent
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC) IntrFlag
)
{
  /* Check is channel is in running state and overflow interrupt is detected */
  if ((0U != (ICU_INT_OVERFLOW & IntrFlag))         &&
      (ICU_RUNNING == ChannelPtr->StatePtr->Status) &&
      (ChannelPtr->OverflowNotification != NULL_PTR))
  {
    ChannelPtr->OverflowNotification();
  }
}


/* \brief Icu_SetMeasurementOverflowNotification
 **
 ** This function implements to enable/disable the overflow notification of a channel in signal measurement.
 **
 ** \param[in] ChannelPtr  Pointer to the channel configuration.
 ** \param[in] OverNoti    Value depended to set the overflow notification state of the specified channel.
 ** \param[in] Mode        ICU_MODE_NORMAL or ICU_MODE_SLEEP.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_SetMeasurementOverflowNotification
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   OverNoti,
  VAR(Icu_ModeType, AUTOMATIC)                              Mode
)
{
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;
  P2CONST(Icu_drvFctTable_t, AUTOMATIC, ICU_APPL_CONST) FuncTablePtr = Icu_Tcpwm_GetFuncTable();

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  ChExtStatePtr->OverflowNotifyEnabled = OverNoti;
  if (ICU_MODE_NORMAL == Mode)
  {
    if (OverNoti == TRUE)
    {
      FuncTablePtr->drvClearInterruptRequestFlag(ChannelPtr, ICU_MASK_INTR_MASK_TC);
      /* TCPWM Interrupt Enable */
      FuncTablePtr->drvIsrEnable(ChannelPtr, ICU_MASK_INTR_MASK_TC);
    }
    else
    {
      /* TCPWM interrupt disable */
      FuncTablePtr->drvIsrDisable(ChannelPtr, ICU_MASK_INTR_MASK_TC);
    }
  }
}


/* \brief Icu_GetMeasurementInputState
 **
 ** This function implements to get the input the state of a channel in signal measurement.
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    ICU_ACTIVE: An activation edge has been detected.
 **            ICU_IDLE: No activation edge has been detected 
 **            since the last call of Icu_GetInputState () or Icu_Init ().
 **
 ** */
FUNC(Icu_InputStateType, ICU_CODE) Icu_GetMeasurementInputState
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  Icu_InputStateType InState_Internal;
  P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA) ChExtStatePtr;

  Icu_EnterCritiSec();

  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.5
     Justification: It is a necessary for Extension State access. */
  /* PRQA S 316 1 */
  ChExtStatePtr = (P2VAR(Icu_SignalMeasChannelStateType, AUTOMATIC, ICU_APPL_DATA)) ChannelPtr->ExtStatePtr;
  /* Check new capture event */
  if (ChannelPtr->StatePtr->Status == ICU_RUNNING)
  {
    Icu_CheckNewMeas(ChannelPtr);
  }

  /* Note: Must refer to the object Icu_SignalMeasChannelStateType in the critical section to avoid interference. */
  /* Get own input state */
  InState_Internal = ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_INPUTSTATE];
  /* Set own input state flag to 'IDLE' */
  ChExtStatePtr->InputState[ICU_CAPTURE_FLAG_INPUTSTATE] = ICU_IDLE;

  Icu_ExitCritiSec();

  return InState_Internal;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
