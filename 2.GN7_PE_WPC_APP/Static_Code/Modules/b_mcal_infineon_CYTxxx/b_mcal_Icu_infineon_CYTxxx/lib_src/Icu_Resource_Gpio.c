/** \file  Icu_Resource_Gpio.c
 ** \brief AUTOSAR Icu ICU Driver
 **
 ** This file contains the implementation of the AUTOSAR module Icu
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Icu_Resource.h>

/*==================[prototypes]============================================*/

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/
#define ICU_START_SEC_CODE_ASIL_B
#include <Icu_MemMap.h>

/** \brief Icu_Resource_Gpio_SetActivationCondition
 **
 ** This function sets the activation condition of a specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] RegValue     Register value.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_SetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    RegValue
);

/** \brief Icu_Resource_Gpio_InterruptDisable
 **
 ** This function disables the interrupt of a specific GPIO channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt flag. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_InterruptDisable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
);

/** \brief Icu_Resource_Gpio_InterruptEnable
 **
 ** This function enables the interrupt of a specific GPIO channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt flag. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_InterruptEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
);

/** \brief Icu_Resource_Gpio_ClearInterruptRequestFlag
 **
 ** This function clears the interrupt request flag bit of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt flag. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_ClearInterruptRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
);

/** \brief Icu_Resource_Gpio_GetIsrRequestFlag
 **
 ** The function gets Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Interrupt request flag value.
 **            ICU_NO_INT      : No interrupt flag.
 **            ICU_INT_CAPTURE : Capture interrupt flag.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Gpio_GetIsrRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_GetActivationCondition
 **
 ** This function gets INTR_CFG register value.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    INTR_CFG register value.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Gpio_GetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_Init
 **
 ** This function initializes the resource of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_Init
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_GetInputLevel
 **
 ** This function gets the current level of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Input level of GPIO.
 ** */
static FUNC(Icu_LevelType, ICU_CODE) Icu_Resource_Gpio_GetInputLevel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);


/** \brief Icu_Resource_Gpio_DeInit
 **
 ** This function de-initializes the resource of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_DeInit
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_StartCountTrigger
 **
 ** This function starts count trigger of a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **                       In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_StartCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_ReloadCountTrigger
 **
 ** This function reloads count trigger of a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **                         In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_ReloadCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckDeinitRegister
 **
 ** This function checks GPIO register value when channel uninitialized.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Returns the check result.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckDeinitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckInitRegister
 **
 ** This function checks GPIO register value when channel initialized.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Returns the check result.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckInitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_SetInputStartTrigger
 **
 ** This function selects input trigger for a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 ** \param[in] TriggerSrc Trigger source. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_SetInputStartTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                   TriggerSrc
);

/** \brief Icu_Resource_Gpio_SetReloadTriggerEdge
 **
 ** This function sets reload trigger edge for a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_SetReloadTriggerEdge
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_ClearInputTrigger
 **
 ** The function clears input trigger. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_ClearInputTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CalculateActivation
 **
 ** This function calculates edge value to set INTR_CFG register.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Activation   Activation type.
 **
 ** \return    Calculated INTR_CFG register value.
 **
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Gpio_CalculateActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        Activation
);

/** \brief Icu_Resource_Gpio_CtrlEnable
 **
 ** This function sets CTRL register enable or disable. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration. In GPIO it is not be used.
 ** \param[in] CtrlMode     Control counter enable or disable. In GPIO it is not be used.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_CtrlEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   CtrlMode
);

/** \brief Icu_Resource_Gpio_CheckActivation
 **
 ** The function checks activation of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Activation edge of an ICU channel.
 ** */
static FUNC(Icu_ActivationType, ICU_CODE) Icu_Resource_Gpio_CheckActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckIsrAbility
 **
 ** The function checks Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Isr ability of an ICU channel.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckOverflowIsrAbility
 **
 ** The function checks Overflow Isr ability of channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return     In GPIO, the return value is fixed as FALSE.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckOverflowIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_GetPrescalerValue
 **
 ** The function gets DT register value of channel. In GPIO, it does nothing and it returns 0U.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    In GPIO, the return value is fixed as 0u.
 ** */
static FUNC(uint8, ICU_CODE) Icu_Resource_Gpio_GetPrescalerValue
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckChRunning
 **
 ** The function checks running state of channel. In GPIO, it does nothing and returns TRUE.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    Result of checking running state.In GPIO, the return value is fixed as TRUE.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckChRunning
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckChStop
 **
 ** The function checks stopped state of channel. In GPIO, it does nothing and returns TRUE.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    Result of checking stopped state. In GPIO, the return value is fixed as TRUE.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckChStop
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

/** \brief Icu_Resource_Gpio_CheckCaptureIntrCause
 **
 ** This function checks if capture interrupt was detected.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of detecting edge.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckCaptureIntrCause
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
);

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

#define ICU_START_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: Since the section to place data is specified, it should be placed in a different location from the reference function. */
/* PRQA S 3218 29 */
static CONST(Icu_drvFctTable_t,ICU_CONST) Icu_GpioDrvFctTable =
{
  (Icu_drvVoidFct_t)         &Icu_Resource_Gpio_Init,
  (Icu_drvVoidFct2_t)        &Icu_Resource_Gpio_SetActivationCondition,
  (Icu_drvVoidFct3_t)        &Icu_Resource_Gpio_InterruptEnable,
  (Icu_drvVoidFct3_t)        &Icu_Resource_Gpio_InterruptDisable,
  (Icu_drvVoidFct3_t)        &Icu_Resource_Gpio_ClearInterruptRequestFlag,
  (Icu_drvRegValFct_t)       &Icu_Resource_Gpio_GetIsrRequestFlag,
  (Icu_drvRegValFct_t)       &Icu_Resource_Gpio_GetActivationCondition,
  (Icu_drvEdgeFct_t)         &Icu_Resource_Gpio_GetInputLevel,
  (Icu_drvVoidFct_t)         &Icu_Resource_Gpio_DeInit,
  (Icu_drvVoidFct_t)         &Icu_Resource_Gpio_StartCountTrigger,
  (Icu_drvVoidFct_t)         &Icu_Resource_Gpio_ReloadCountTrigger,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckDeinitRegister,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckInitRegister,
  (Icu_drvTriggerFct_t)      &Icu_Resource_Gpio_SetInputStartTrigger,
  (Icu_drvVoidFct_t)         &Icu_Resource_Gpio_SetReloadTriggerEdge,
  (Icu_drvVoidFct_t)         &Icu_Resource_Gpio_ClearInputTrigger,
  (Icu_drvCalValFct_t)       &Icu_Resource_Gpio_CalculateActivation,
  (Icu_drvCtrlFct_t)         &Icu_Resource_Gpio_CtrlEnable,
  (Icu_drvCheckActFct_t)     &Icu_Resource_Gpio_CheckActivation,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckIsrAbility,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckOverflowIsrAbility,
  (Icu_drvDividFct_t)        &Icu_Resource_Gpio_GetPrescalerValue,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckChRunning,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckChStop,
  (Icu_drvCheckRegFct_t)     &Icu_Resource_Gpio_CheckCaptureIntrCause
};
#define ICU_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h> 

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/** \brief Icu_Gpio_GetFuncTable
 **
 ** This function gets the address of the functional table of GPIO in register layer.
 **
 ** \param[in] None.
 **
 ** \return   Return the pointer to Icu_drvFctTable_t.
 ** */
FUNC_P2CONST(Icu_drvFctTable_t, ICU_APPL_CONST, ICU_CODE) Icu_Gpio_GetFuncTable(void)
{
  return &Icu_GpioDrvFctTable;
}

/** \brief Icu_Resource_Gpio_ClearInterruptByBaseAddr
 **
 ** This function clears the interrupt request flag bit of GPIO.
 **
 ** \param[in] BaseAddress  Channel base address.
 ** \param[in] ResourceId   Resource Id.
 **
 ** \return    None.
 ** */
FUNC(void, ICU_CODE) Icu_Resource_Gpio_ClearInterruptByBaseAddr
(
  volatile P2VAR(uint32, ICU_CONST, REGSPACE) BaseAddress,
  VAR(Icu_ResourceType, AUTOMATIC)            ResourceId
)
{
  uint32 IcuMask;
  uint32 ResInt;
  uint32 ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(BaseAddress);

  ResID = (ResourceId & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  /* Get value of INTR_CFG:FLT_SEL */
  ResInt = (uint32)(GpioReg->Intr_cfg & ICU_MASK_INTR_CFG_FLT_SEL) >> ICU_SHIFT_INTR_CFG_FLT_SEL;

  /* Filter enable */
  if(ResInt == ResID)
  {
    /* Set 1 to INTR:FLT_EDGE and INTR:EDGE* field */
    IcuMask = ((ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE) | (ICU_REGS_MASK_VALUE_1BIT << ResID));
  }
  /* Filter disable */
  else
  {
    /* Set 1 to INTR:EDGE* field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }

  /* Read INTR register (This read ensures that the write is effective) */
  (void)GpioReg->Intr;

  /* Write IcuMask to register INTR */
  GpioReg->Intr = IcuMask;

  /* Read INTR register (This read ensures that the write has been flushed to hardware) */
  (void)GpioReg->Intr;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[internal function definitions]==========================*/
#define ICU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/** \brief Icu_Resource_Gpio_SetActivationCondition
 **
 ** This function sets the activation condition of a specific channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] RegValue     Register value.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_SetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    RegValue
)
{
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  
  /* Set RegValue to register INTR_CFG */
  GpioReg->Intr_cfg = RegValue;
}

/** \brief Icu_Resource_Gpio_InterruptDisable
 **
 ** This function disables the interrupt of a specific GPIO channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt flag. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_InterruptDisable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
)
{
  uint32       IcuMask;
  uint32       ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)IntValue;

  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    /* Set 1 to INTR_MASK:FLT_EDGE field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE;
  }
  /* Filter disable */
  else
  {
    /* Set 1 to INTR_MASK:EDGE* field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }

  /* XOR IcuMask to clear register INTR_MASK. */
  GpioReg->Intr_mask &= ~IcuMask;
  /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
  (void)GpioReg->Intr_mask;
}

/** \brief Icu_Resource_Gpio_InterruptEnable
 **
 ** This function enables the interrupt of a specific GPIO channel.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt flag. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_InterruptEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
)
{
  uint32       IcuMask;
  uint32       ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)IntValue;

  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    /* Set 1 to INTR_MASK:FLT_EDGE field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE;
  }
  /* Filter disable */
  else
  {
    /* Set 1 to INTR_MASK:EDGE* field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }

  /* OR IcuMask to register INTR_MASK */
  GpioReg->Intr_mask |= IcuMask;
  /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
  (void)GpioReg->Intr_mask;
}

/** \brief Icu_Resource_Gpio_ClearInterruptRequestFlag
 **
 ** This function clears the interrupt request flag bit of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] IntValue     Interrupt flag. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_ClearInterruptRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC)                                    IntValue
)
{
  uint32 IcuMask;
  uint32 ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)IntValue;

  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    /* Set 1 to INTR:FLT_EDGE and INTR:EDGE* field */
    IcuMask = ((ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE) | (ICU_REGS_MASK_VALUE_1BIT << ResID));
  }
  /* Filter disable */
  else
  {
    /* Set 1 to INTR:EDGE* field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }

  /* Read INTR register (This read ensures that the write is effective) */
  (void)GpioReg->Intr;

  /* Write IcuMask to register INTR */
  GpioReg->Intr = IcuMask;

  /* Read INTR register (This read ensures that the write has been flushed to hardware) */
  (void)GpioReg->Intr;
}

/** \brief Icu_Resource_Gpio_GetIsrRequestFlag
 **
 ** The function gets Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Interrupt request flag value.
 **            ICU_NO_INT      : No interrupt flag.
 **            ICU_INT_CAPTURE : Capture interrupt flag.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Gpio_GetIsrRequestFlag
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32   IcuMask;
  uint32   ResID;
  uint32   retval;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE;
  }
  /* Filter disable */
  else
  {
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }
  retval = (uint32)(((GpioReg->Intr_masked & IcuMask) != 0x00u) ? ICU_INT_CAPTURE : ICU_NO_INT);

  return retval;
}

/** \brief Icu_Resource_Gpio_GetActivationCondition
 **
 ** This function gets INTR_CFG register value.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    INTR_CFG register value.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Gpio_GetActivationCondition
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32 retval;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Return value of register INTR_CFG */
  retval = (uint32)GpioReg->Intr_cfg;

  return retval;
}

/** \brief Icu_Resource_Gpio_Init
 **
 ** This function initializes the resource of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_Init
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32   ResID;
  uint32   RegValue;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID    = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  
  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
     /* Get value of register INTR_CFG */
     RegValue = GpioReg->Intr_cfg;
     RegValue &= ~ICU_MASK_INTR_CFG_FLT_SEL;
     /* Set ResID to INTR_CFG:FLT_SEL field */
     RegValue |= (uint32)(ResID << ICU_SHIFT_INTR_CFG_FLT_SEL);
     GpioReg->Intr_cfg = RegValue;
  }
}

/** \brief Icu_Resource_Gpio_DeInit
 **
 ** This function de-initializes the resource of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_DeInit
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32   ResID;
  uint32   RegValue;
  uint32   IcuShift;
  uint32   EdgeMask;
  uint32   IcuMask;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  ResID    = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;

  /* Get value of register INTR_CFG */
  RegValue = GpioReg->Intr_cfg;
  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
     /* Set 0 to INTR_CFG:FLT_EDGE_SEL field and INTR_CFG:FLT_SEL field */
     RegValue &= ~(ICU_MASK_INTR_CFG_FLT_EDGE_SEL|ICU_MASK_INTR_CFG_FLT_SEL);
     /* Set 1 to INTR_MASK:FLT_EDGE field */
     IcuMask = ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE;
  }
  else
  {
    /* Set 1 to INTR_MASK:EDGE* field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }

  /* Get EDGE*_SEL bit position value */
  IcuShift = ICU_REGS_INTR_CFG_SHIFT_2BIT * ResID;
  /* Get EDGE*_SEL bit mask value */
  EdgeMask = ICU_MASK_INTR_CFG_EDGE_SEL << IcuShift;

  /* Set 0 to INTR_CFG:EDGE*_SEL */
  RegValue &= ~EdgeMask;
  
  /* Write RegValue to register INTR_CFG */
  GpioReg->Intr_cfg = RegValue;
  /* XOR IcuMask to clear register INTR_MASK. */
  GpioReg->Intr_mask &= ~IcuMask;
  /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
  (void)GpioReg->Intr_mask;
}

/** \brief Icu_Resource_Gpio_GetInputLevel
 **
 ** This function gets the current level of GPIO.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Input level of GPIO.
 ** */
static FUNC(Icu_LevelType, ICU_CODE) Icu_Resource_Gpio_GetInputLevel
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32       IcuMask;
  uint32       IcuShift;
  uint32       CurEdge;
  Icu_LevelType retval;
  uint32       ResID;

  volatile     P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;

  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    /* Get bits mask value of INTR:FLT_IN_IN field */
    IcuMask = ICU_MASK_INTR_FLT_IN_IN;
    /* Get bits shift value of INTR:FLT_IN_IN field */
    IcuShift = ICU_SHIFT_INTR_FLT_IN_IN;
  }
  /* Filter disable */
  else
  {
    /* Get bits mask value of INTR:IN_IN* field */
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << (ResID + ICU_SHIFT_INTR_IN_IN0);
    /* Get bits shift value of INTR:IN_IN* field */
    IcuShift = ResID + ICU_SHIFT_INTR_IN_IN0;
  }

  /* Get value of INTR:IN_IN* field or INTR:FLT_IN_IN field */
  CurEdge = (GpioReg->Intr & IcuMask) >> IcuShift;
  
  /* Current output state is high */
  if (CurEdge == ICU_REGS_LEVEL_HIGH)
  {
    retval = ICU_HIGH;
  }
  else
  {
    retval = ICU_LOW;
  }

  return retval;
}

/** \brief Icu_Resource_Gpio_StartCountTrigger
 **
 ** This function starts count trigger of a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **                         In GPIO it is not be used.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_StartCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
}

/** \brief Icu_Resource_Gpio_ReloadCountTrigger
 **
 ** This function reloads count trigger of a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **                         In GPIO it is not be used.
 **
 ** \return    None.
 **
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_ReloadCountTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
}

/** \brief Icu_Resource_Gpio_CheckDeinitRegister
 **
 ** This function checks GPIO register value when channel uninitialized.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Result of checking register.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckDeinitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  boolean retval = TRUE;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    if (0U != (GpioReg->Intr_cfg & ICU_MASK_INTR_CFG_FLT_SEL))
    {
        retval = FALSE;
    }
  }

  return retval;
}

/** \brief Icu_Resource_Gpio_CheckInitRegister
 **
 ** This function checks GPIO register value when channel initialized.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return Result of checking register.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckInitRegister
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32   ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  boolean retval = TRUE;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    if ((GpioReg->Intr_cfg & ICU_MASK_INTR_CFG_FLT_SEL) != (uint32)(ResID << ICU_SHIFT_INTR_CFG_FLT_SEL))
    {
        retval = FALSE;
    }
  }
  return retval;
}

/** \brief Icu_Resource_Gpio_SetInputStartTrigger
 **
 ** This function selects input trigger for a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 ** \param[in] TriggerSrc Trigger source. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_SetInputStartTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(uint8, AUTOMATIC)                                   TriggerSrc
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 2 */
  (void)ChannelPtr;
  (void)TriggerSrc;
}

/** \brief Icu_Resource_Gpio_SetReloadTriggerEdge
 **
 ** This function sets reload trigger edge for a specific channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_SetReloadTriggerEdge
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
}


/** \brief Icu_Resource_Gpio_ClearInputTrigger
 **
 ** The function clears input trigger. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_ClearInputTrigger
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
}

/** \brief Icu_Resource_Gpio_CalculateActivation
 **
 ** This function calculates edge value to set INTR_CFG register.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 ** \param[in] Activation   Activation type.
 **
 ** \return    Calculated INTR_CFG register value.
 ** */
static FUNC(uint32, ICU_CODE) Icu_Resource_Gpio_CalculateActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(Icu_ActivationType, AUTOMATIC)                        Activation
)
{
  boolean  ret;
  uint32   IcuShift;
  uint32   retval;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  uint32   EdgeMode = ICU_REGS_INTR_CFG_DISABLE;
  uint32   EdgeMask = ICU_MASK_INTR_CFG_EDGE_SEL;
  uint32   ResID    = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ret    = TRUE;
  retval = (uint32)GpioReg->Intr_cfg;

  /* Check Activation */
  switch (Activation)
  {
    case ICU_INIT_EDGE:
      EdgeMode = ICU_REGS_INTR_CFG_DISABLE;
      break;
    case ICU_RISING_EDGE:
      EdgeMode = ICU_REGS_INTR_CFG_RISING;
      break;
    case ICU_FALLING_EDGE:
      EdgeMode = ICU_REGS_INTR_CFG_FALLING;
      break;
    case ICU_BOTH_EDGES:
      EdgeMode = ICU_REGS_INTR_CFG_BOTH;
      break;
    default: /* invalid activation condition */
      ret = FALSE;
      break;
  }
  if (ret == TRUE)
  {
    /* Filter enable */
    if (ChannelPtr->FilterEnable == TRUE)
    {
      IcuShift = ICU_SHIFT_INTR_CFG_FLT_EDGE_SEL;
    }
    /* Filter disable */
    else
    {
      IcuShift = ICU_REGS_INTR_CFG_SHIFT_2BIT * ResID;
    }

    EdgeMode <<= IcuShift;
    EdgeMask <<= IcuShift;

    retval = (retval & ~EdgeMask) | EdgeMode;
  } 

  return retval;
}

/** \brief Icu_Resource_Gpio_CtrlEnable
 **
 ** This function sets CTRL register enable or disable. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration. In GPIO it is not be used.
 ** \param[in] CtrlMode     Control counter enable or disable. In GPIO it is not be used.
 **
 ** \return    None.
 ** */
static FUNC(void, ICU_CODE) Icu_Resource_Gpio_CtrlEnable
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC)                                   CtrlMode
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 2 */
  (void)ChannelPtr;
  (void)CtrlMode;
}

/** \brief Icu_Resource_Gpio_CheckActivation
 **
 ** The function checks activation of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Activation edge of an ICU channel.
 ** */
static FUNC(Icu_ActivationType, ICU_CODE) Icu_Resource_Gpio_CheckActivation
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32   IcuMask;
  uint32   IcuShift;
  uint32   EdgeMode;
  Icu_ActivationType retval;
  uint32   ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;

  /* Filter enable */
  if(ChannelPtr->FilterEnable == TRUE)
  {
    IcuShift = ICU_SHIFT_INTR_CFG_FLT_EDGE_SEL;
    IcuMask = ICU_MASK_INTR_CFG_FLT_EDGE_SEL;
  }
  /* Filter disable */
  else
  {
    IcuShift = ICU_REGS_INTR_CFG_SHIFT_2BIT * ResID;
    IcuMask = ICU_MASK_INTR_CFG_EDGE_SEL << IcuShift;
  }
  /* Get value of register INTR_CFG:FLT_EDGE_SEL or INTR_CFG:EDGE*_SEL */
  EdgeMode = (uint32)(GpioReg->Intr_cfg & IcuMask) >> IcuShift;

  switch (EdgeMode)
  {
    case ICU_REGS_INTR_CFG_RISING:
      retval = ICU_RISING_EDGE;
      break;

    case ICU_REGS_INTR_CFG_FALLING:
      retval = ICU_FALLING_EDGE;
      break;

    case ICU_REGS_INTR_CFG_BOTH:
      retval = ICU_BOTH_EDGES;
      break;

    default: /* case ICU_REGS_INTR_CFG_DISABLE */
      retval = ICU_INIT_EDGE;
      break;
  }
  return retval;
}

/** \brief Icu_Resource_Gpio_CheckIsrAbility
 **
 ** The function checks Isr ability of channel.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration.
 **
 ** \return    Isr ability of an ICU channel.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  uint32   IcuMask;
  uint32   ResID;
  boolean  retval;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE;
  }
  /* Filter disable */
  else
  {
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }
  retval = ((GpioReg->Intr_mask & IcuMask) != 0x00u) ? TRUE: FALSE;

  return retval;
}

/** \brief Icu_Resource_Gpio_CheckOverflowIsrAbility
 **
 ** The function checks Overflow Isr ability of channel. In GPIO, it does nothing.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return     In GPIO, the return value is fixed as FALSE.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckOverflowIsrAbility
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
  return FALSE;
}

/** \brief Icu_Resource_Gpio_GetPrescalerValue
 **
 ** The function gets DT register value of channel. In GPIO, it does nothing and it returns 0U.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    In GPIO, the return value is fixed as 0u.
 ** */
static FUNC(uint8, ICU_CODE) Icu_Resource_Gpio_GetPrescalerValue
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
  return 0u;
}

/** \brief Icu_Resource_Gpio_CheckChRunning
 **
 ** The function checks running state of channel. In GPIO, it does nothing and returns TRUE.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    Result of checking running state.In GPIO, the return value is fixed as TRUE.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckChRunning
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
  return TRUE;

}

/** \brief Icu_Resource_Gpio_CheckChStop
 **
 ** The function checks stopped state of channel. In GPIO, it does nothing and returns TRUE.
 **
 **
 ** \param[in] ChannelPtr Pointer to the channel configuration. In GPIO it is not be used.
 **
 ** \return    Result of checking stopped state. In GPIO, the return value is fixed as TRUE.
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckChStop
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  /* This read is for unused parameter */
  /* Deviation from MISRA-C:2004 rule 14.2, MISRA-C:2012 Rule-2.2
     Justification: To avoid compiler warning. */
  /* PRQA S 3112 1 */
  (void)ChannelPtr;
  return TRUE;
}

/** \brief Icu_Resource_Gpio_CheckCaptureIntrCause
 **
 ** This function checks if capture interrupt was detected.
 **
 **
 ** \param[in] ChannelPtr   Pointer to the channel configuration.
 **
 ** \return    Result of detecting edge.
 **
 ** */
static FUNC(boolean, ICU_CODE) Icu_Resource_Gpio_CheckCaptureIntrCause
(
  P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_APPL_CONST) ChannelPtr
)
{
  boolean  retval;
  uint32   IcuMask;
  uint32   ResID;
  volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE) GpioReg;
  /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 310 1 */
  GpioReg = (volatile P2VAR(Icu_GpioRegType, ICU_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  ResID = (ChannelPtr->ResourceID & ICU_MASK_PIN_NUMBER) % ICU_REGS_PIN_NUMBER;
  /* Filter enable */
  if (ChannelPtr->FilterEnable == TRUE)
  {
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ICU_SHIFT_INTR_FLT_EDGE;
  }
  /* Filter disable */
  else
  {
    IcuMask = ICU_REGS_MASK_VALUE_1BIT << ResID;
  }
  retval = ((GpioReg->Intr & IcuMask) != 0x00u) ? TRUE : FALSE;

  return retval;
}

#define ICU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Icu_MemMap.h>

/*==================[end of file]============================================*/
