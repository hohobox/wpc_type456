/** \brief AUTOSAR Fee Flash EEPROM Emulation
 **
 ** This file contains the implementation of the AUTOSAR module Fee.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-FEE42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
*/

/*****************************************************************************/
/* Include files                                                             */
/*****************************************************************************/
#include "Fee_Internal.h"

/*****************************************************************************/
/* Local pre-processor symbols/macros ('#define')                            */
/*****************************************************************************/
/*****************************************************************************/
/* Global variable definitions (declared in header file with 'extern')       */
/*****************************************************************************/
/*****************************************************************************/
/* Local variable definitions ('static')                                     */
/*****************************************************************************/
#define FEE_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
#include "Fee_MemMap.h"

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: An area of this variable must be maintained even out of a function scope. */
/* PRQA S 3218 11 */
static VAR(Fee_SectorFirstProcType, AUTOMATIC) Fee_SectorFirstProc = FEE_SECTOR_FIRST_START;  /* entry point for Fee_GetSectorFirst */
static VAR(uint16, AUTOMATIC)  Fee_BlkIdxSearchBlkInRecycle = (uint16)FEE_ZERO;    /* block number index */
static VAR(uint16, AUTOMATIC)  Fee_BlkSearchCntInInit  = (uint16)FEE_ZERO;    /* block search count in initialization */
static VAR(uint16, AUTOMATIC)  Fee_BlkSearchPageNoInInit[3] = {(uint16)FEE_ZERO, (uint16)FEE_ZERO, (uint16)FEE_ZERO };    /* store block page number */
static VAR(Fee_BlockAddrIndexType, AUTOMATIC)   Fee_BlockManagementInfoOldBlock = 
{
    /* BlkAddr */        (uint32)FEE_BLKIDX_NO_BLOCK_EXIST,
    /* BlkStatus */      (uint8)FEE_BLKIDX_NO_BLOCK_EXIST,
    /* BlkBlankCheck */  (uint8)FEE_BLANK_CHECK_UNDO
};
static VAR(uint8, AUTOMATIC)  Fee_EraseCountInAdjusting = (uint8)FEE_ZERO;
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: An area of this variable must be maintained even out of a function scope. */
/* PRQA S 3218 1 */
static VAR(uint8, AUTOMATIC)  Fee_ConsiderThisBlockAsMaxBlock = (uint8)FEE_OFF;
/* After comparing PageNo to find last valid block in flash, to save the block in this variable */
static VAR(Fee_BlockAddrIndexType, AUTOMATIC)   Fee_LastValidBlockInFlash = 
{
    /* BlkAddr */        (uint32)FEE_BLKIDX_NO_BLOCK_EXIST,
    /* BlkStatus */      (uint8)FEE_BLKIDX_NO_BLOCK_EXIST,
    /* BlkBlankCheck */  (uint8)FEE_BLANK_CHECK_UNDO
};
/* During recycle, decide copy data to buffer or not */
static VAR(uint8, AUTOMATIC)  Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH;
/* Save block infor when searching from workflash */
static VAR(Fee_SearchWorkFlashInfoType, AUTOMATIC)   Fee_BlockInforDuringSearchWorkFlash[2U] = 
{
    {
        /* write_start_flag */   (uint32)FEE_NULL,
        /* bnum_pnum */          (uint32)FEE_NULL,
        /* valid_status */       (uint32)FEE_NULL,
        /* invalid_status */     (uint32)FEE_NULL
    },
    {
        /* write_start_flag */   (uint32)FEE_NULL,
        /* bnum_pnum */          (uint32)FEE_NULL,
        /* valid_status */       (uint32)FEE_NULL,
        /* invalid_status */     (uint32)FEE_NULL
    }
};
/* Count searching from workflash */
/* Deviation from MISRA-C:2004 rule 1.2, 5.1, MISRA-C:2012 Rule-1.3, Rule-5.2
   Justification: After analysis, the variable names has no problem. */
/* PRQA S 779 1 */
static VAR(uint8, AUTOMATIC) Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
/* Search at last block in flash */
static VAR(uint8, AUTOMATIC)  Fee_LastBlockIsFound = (uint8)FEE_OFF;
/* Recycle pattern */
static VAR(uint8, AUTOMATIC)  Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;

#define FEE_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


#define FEE_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: An area of this variable must be maintained even out of a function scope. */
/* PRQA S 3218 5 */
static P2VAR(uint32, AUTOMATIC, AUTOMATIC) Fee_SectorFirstStatusPtr1;            /* pointer to sector status */
static P2VAR(uint32, AUTOMATIC, AUTOMATIC) Fee_SectorFirstStatusPtr2;            /* pointer to sector status */
static P2VAR(uint32, AUTOMATIC, AUTOMATIC) Fee_SectorFirstStatusPtr3;            /* pointer to sector status */
static P2VAR(uint32, AUTOMATIC, AUTOMATIC) Fee_SectorFirstBlockInfoPtr;          /* pointer to block head */
static P2VAR(uint32, AUTOMATIC, AUTOMATIC) Fee_SectorFirstEraseCompleteFlagPtr;  /* pointer to erase complete flag */

#define FEE_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"


/*****************************************************************************/
/* Local function prototypes ('static')                                      */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/* Get read or recycle source sector. */
static FUNC(uint8, FEE_CODE) Fee_GetSectorEffective(void);

/* Erase the specified sector. */
static FUNC(uint8, FEE_CODE) Fee_EraseProc(
  VAR(uint8, AUTOMATIC) target_status,
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) now_proc_ptr);
  
/* Create index during init. */
static FUNC(uint8, FEE_CODE) Fee_CreateBlockByInit(
  VAR(uint8, AUTOMATIC) sector_no);

/* Write valid or invalid flag for all valid / invalid blocks. */
static FUNC(uint8, FEE_CODE) Fee_OverWriteBlockFlag(void);

/* Use index to search valid block during recycle. */
static FUNC(uint8, FEE_CODE) Fee_SearchValidBlock(
  P2VAR(Fee_BlockManagementInfoType*, AUTOMATIC, FEE_APPL_DATA) src_ptr);

/* In intialization search function, update block index */
static FUNC(uint8, FEE_CODE) Fee_InitSearchBlockindexUpdate(
  P2VAR(Fee_BlockManagementInfoType*, AUTOMATIC, FEE_APPL_DATA)now_block_ptr,
  P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA)page_no_current_ptr,
  P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA)used_reserve_size_ptr,
  P2VAR(Fee_SearchCreateBlockProcType, AUTOMATIC, FEE_APPL_DATA) temp_proc_ptr,
  VAR(uint8, AUTOMATIC) valid_or_not,
  VAR(uint8, AUTOMATIC) blankcheck_or_not);

/* When configuration is changed, adjusting work flash. */
static FUNC(uint8, FEE_CODE) Fee_AdjustingWorkFlash(
  VAR(uint8, AUTOMATIC) src_sector_no_old_cfg);

/* Set sector of old configuration to moving sector. */
static FUNC(uint8, FEE_CODE) Fee_SetOldSector(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint8, AUTOMATIC) status);

/* Search valid block one by one on work flash. */
static FUNC(uint8, FEE_CODE) Fee_SearchValidBlockOldConfig(
  P2VAR(Fee_BlockManagementInfoType*, AUTOMATIC, FEE_APPL_DATA) src_ptr,
  VAR(uint32, AUTOMATIC) write_start_flag,
  VAR(uint32,AUTOMATIC) bnum_pnum,
  VAR(uint32,AUTOMATIC) valid_status,
  VAR(uint32,AUTOMATIC) invalid_status,
  VAR(uint8,AUTOMATIC) src_sector_no);

/* Calculate PSC. */
static FUNC(uint32, FEE_CODE) Fee_CalculatePSC(void);

/* check old Config and compare with new config. */
static FUNC(uint8, FEE_CODE) Fee_CheckOldConfigAndCompare( 
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) config_difference_ptr);

/* get sector status from Flash. */
static FUNC(uint8, FEE_CODE) Fee_CaculateOldSectorStatus(
  VAR(uint32,FEE_CODE) current_address);

#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/*****************************************************************************/
/* Function implementation - global ('extern') and local ('static')          */
/*****************************************************************************/
#define FEE_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

/** \brief Fee_RecycleStart
**
** Start periodic processing of recycling.
**
** \param[in]  sector_no   recycling source sector
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_RecycleStart(
  VAR(uint8, AUTOMATIC) sector_no)
{
    Fee_PeriInfo.Fee_RecycleSrc = sector_no;
    Fee_PeriInfo.Fee_MainState |= FEE_MAIN_STATE_RECYCLING;              /* set main state */

    return;
}


/** \brief Fee_RecyclePolling
**
** Periodic processing of recycling.
**
** \return     result of operation
** \retval     FEE_OK     success
** \retval     FEE_NG     failed
** \retval     FEE_CONT   continue
**
*/
FUNC(uint8, FEE_CODE) Fee_RecyclePolling(void)
{
    VAR(Fee_RecycleProcType, AUTOMATIC)                       proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                     retval;                       /* return value */
    VAR(uint8, AUTOMATIC)                                     src_sector_no;                /* recycling source sector */
    VAR(uint8, AUTOMATIC)                                     dst_sector_no;                /* recycling destination sector */
    VAR(MemIf_JobResultType, AUTOMATIC)                       retjob;                       /* result of fls job */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  src_ptr;                      /* pointer to block of source */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  dst_ptr;                      /* pointer to block of destination */
    VAR(uint32, AUTOMATIC)                                    recycleflag;                  /* sector recycle flag */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                        src_data_ptr;                 /* pointer to data of source */
    VAR(uint16, AUTOMATIC)                                    blk_idx;                      /* block number index */
    VAR(uint16, AUTOMATIC)                                    used_pages_size;              /* size counter of used pages for calculating Fee_BlkPageAreaEmptyAddr and page number of Fee_BlkMgtInfoBuffer */
    VAR(uint16, AUTOMATIC)                                    used_reserve_size;            /* size counter of used reserve space for calculating Fee_ImmDataReserveSize */
    VAR(uint32, AUTOMATIC)                                    flag_from_flash;              /* temporary variable for storing the flag read from flash */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                        sector_start_addr_ptr;        /* pointer to start address of sector */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                    block_addr_index;             /* index of blocks */
    VAR(Fee_BlockConfigType, AUTOMATIC)                       blk_cfg;                      /* Block configuration array */
    VAR(uint16, AUTOMATIC)                                    blk_empty_size;               /* empty size */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                       blk_page_area_empty_addr_ptr; /* pointer to empty address for page area */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  blk_mgt_area_empty_addr_ptr;  /* pointer to empty address for block management area */
    VAR(uint8, AUTOMATIC)                                     no_of_sec;                    /* Number of defined sectors */
    VAR(Fee_ConfigType, AUTOMATIC)                            fee_cfg;                      /* fee configuration */
    VAR(uint32, AUTOMATIC)                                    psc_ptr;                      /* pointer to PSC */
    VAR(uint32, AUTOMATIC)                                    psc_blkchk;                   /* check psc area is blank or not */
    VAR(uint16, AUTOMATIC)                                    cnt_block_index;              /* block number index */
    VAR(uint16, AUTOMATIC)                                    cnt;                          /* loop count */
    VAR(uint32, AUTOMATIC)                                    valid_status;                 /* check valid status */
    VAR(uint32, AUTOMATIC)                                    invalid_status;               /* check invalid status */
    VAR(uint32, AUTOMATIC)                                    write_start_flag;             /* check write start flag */
    VAR(uint32, AUTOMATIC)                                    bnum_pnum;                    /* check block number and page number */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  src_ptr_temp_ptr;             /* pointer to block of source */
    VAR(uint8, AUTOMATIC)                                     search_from_flash;            /* search from flash */
    VAR(uint16, AUTOMATIC)                                    cnt_temp;                     /* count */
    VAR(uint16, AUTOMATIC)                                    cnt_temp_max;                 /* record the count with max addr */
    VAR(Fee_FaultType, AUTOMATIC)                             fee_fault;                    /* get fault information from FLS */
    VAR(uint8, AUTOMATIC)                                     retry_count;                  /* trying twice for finding disable sector */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                    block_addr_index_check;       /* before moving block, check index firstly */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                       data_ptr;                     /* block data buffer for last valid block */
    VAR(uint16, AUTOMATIC)                                    max_page_no;                  /* save max PageNo */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)  use_index_src_ptr;            /* pointer to block of source */
    VAR(Fee_BlockManagementInfoType, AUTOMATIC)               pre_block;                    /* the pre block of current block */
    VAR(uint16, AUTOMATIC)                                    pre_blk_idx;                  /* block number index */
    VAR(uint8, AUTOMATIC)                                     create_index_result;          /* return value of create index */

    src_sector_no     = Fee_PeriInfo.Fee_RecycleSrc;
    dst_sector_no     = FEE_NONE_SECTOR;
    retval            = FEE_CONT;
    src_ptr           = (Fee_BlockManagementInfoType*)FEE_NULL;
    dst_ptr           = (Fee_BlockManagementInfoType*)FEE_NULL;
    src_data_ptr      = (uint8*)FEE_NULL;
    used_pages_size   = (uint16)FEE_ZERO;
    used_reserve_size = (uint16)FEE_ZERO;
    retjob            = MEMIF_JOB_OK;
    cnt_block_index   = (uint16)FEE_ZERO;
    search_from_flash = FEE_OFF;
    cnt_temp          = (uint16)FEE_ZERO;
    cnt_temp_max      = (uint16)FEE_ZERO;
    retry_count       = (uint8)FEE_ZERO;
    use_index_src_ptr = (Fee_BlockManagementInfoType*)FEE_NULL;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_RecycleProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_RECYCLE_START )
    {
        Fee_SetSectorStatus(src_sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_MOVING);
        Fee_SetSectorStatusMirror(src_sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_MOVING);

        /* => 1.get recycle flag */
        proc = FEE_RECYCLE_FLAG_GET;
    }
    else
    {
        FEE_POP_STACK_USHORT(cnt_block_index)
        /* If periodic processing is continued, pop related data of under processing. */
        FEE_POP_STACK_USHORT(blk_idx)
        FEE_POP_STACK_USHORT(used_reserve_size)
        FEE_POP_STACK_USHORT(used_pages_size)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(dst_ptr, Fee_BlockManagementInfoType)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(src_data_ptr, uint8)
        FEE_POP_STACK_UCHAR(dst_sector_no)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(src_ptr, Fee_BlockManagementInfoType)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 6 */
        FEE_POP_STACK_ULONG(write_start_flag)
        FEE_POP_STACK_ULONG(bnum_pnum)
        FEE_POP_STACK_ULONG(valid_status)
        FEE_POP_STACK_ULONG(invalid_status)
        FEE_POP_STACK_UCHAR(search_from_flash)
        FEE_POP_STACK_UCHAR(retry_count)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(use_index_src_ptr, Fee_BlockManagementInfoType)
    }

    no_of_sec       = Fee_GetNoOfSec();

    /* check corruption in Fee_RecycleSrc */
    if( (Fee_PeriInfo.Fee_RecycleSrc == (uint8)FEE_ZERO) || (Fee_PeriInfo.Fee_RecycleSrc > no_of_sec) )
    {
        Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
        /* => X.end of periodic processing */
        proc = FEE_RECYCLE_END;
    }

/* 1.get recycle flag */
    if( proc == FEE_RECYCLE_FLAG_GET )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        sector_start_addr_ptr = FEE_GET_FLASH_SECTOR_START_ADDR(src_sector_no);

        if( FEE_OFF == Fee_GetSectorBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306,488 1 */
            recycleflag = Fee_FlsGetReadAddr((uint32)(sector_start_addr_ptr + FEE_SECTOR_STATUS_SIZE)); /* check recycle flag */

            /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
                Justification: 64bit is supported by the long long in ARM. */
            /* PRQA S 580 1 */
            if( recycleflag != FEE_NULL )
            {
                /* => 2-a.ready for erase former recycling source sector */
                FEE_SET_PROC(FEE_RECYCLE_READY_FOR_ERASE_GARBAGE_SECTOR)
            }
            else
            {
                /* => 2.set recycle flag */
                FEE_SET_PROC(FEE_RECYCLE_FLAG_SET)
            }
        }
        else
        {
            Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            Fee_FlsReadImmediateSync((uint32)(sector_start_addr_ptr + FEE_SECTOR_STATUS_SIZE), &Fee_InfoDataBuffer, FEE_SECTOR_RECYCLE_FLAG_SIZE); /* read recycle flag */
            fee_fault = Fee_GetFlsFault();
            Fee_FlsDisableDMA();

            if(fee_fault == FEE_FAULT_NONE)
            {
                if( Fee_InfoDataBuffer == FEE_SECTOR_STATUS_DATA_SET ) /* check recycle flag */
                {
                    /* => 2-a.ready for erase former recycling source sector */
                    proc = FEE_RECYCLE_READY_FOR_ERASE_GARBAGE_SECTOR;
                }
                else
                {
                    /* => 2.set recycle flag */
                    proc = FEE_RECYCLE_FLAG_SET;
                }
            }
            else /* 1bit ECC error, 2bit ECC error, other error */
            {
                /* It's just recycle flag, so if there's a problem reading it, just write it again. */

                /* => 2.set recycle flag */
                proc = FEE_RECYCLE_FLAG_SET;
            }       
        }
    }

/* 2.set recycle flag */
    if( proc == FEE_RECYCLE_FLAG_SET )
    {
        retval = Fee_SetSector(src_sector_no, FEE_RECYCLE_FLAG);

        if( retval == FEE_OK )
        {
            /* => 2-a.ready for erase former recycling destination sector */
            FEE_SET_PROC(FEE_RECYCLE_READY_FOR_ERASE_GARBAGE_SECTOR)
        }
        else if( retval == FEE_NG )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* continue */
        }
    }

/* 2-a.ready for erase former recycling destination sector */
    if( proc == FEE_RECYCLE_READY_FOR_ERASE_GARBAGE_SECTOR )
    {
        dst_sector_no = Fee_GetSector(FEE_SECTOR_DISABLE);     /* get former recycling destination sector */

        if( dst_sector_no != FEE_NONE_SECTOR )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840 1 */
            psc_ptr = (uint32)(FEE_GET_FLASH_SECTOR_START_ADDR(dst_sector_no) + FEE_PSC_OFFSET);
            /* Deviation from MISRA-C:2004 rule 11.3, 3.1, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            psc_blkchk = Fee_FlsGetReadAddr(psc_ptr);

            /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
                Justification: 64bit is supported by the long long in ARM. */
            /* PRQA S 580 1 */
            if(  psc_blkchk != FEE_NULL )
            {
                /* If data exist, the sector that dst_sector_no points is erased  because it is recycling destination sector. */
                Fee_SetSectorStatus(dst_sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_GARBAGE);
                Fee_SetSectorStatusMirror(dst_sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_GARBAGE);
            }
        }

        /* => 3.erase garbage sector */
        proc = FEE_RECYCLE_ERASE_GARBAGE_SECTOR;

    }

/* 3.erase garbage sector */
    if( proc == FEE_RECYCLE_ERASE_GARBAGE_SECTOR )
    {
        retval = Fee_Erase();

        if( retval == FEE_OK )
        {
            /* => 4.set moving sector */
            proc = FEE_RECYCLE_SET_MOVING_SECTOR;
        }
        else if( retval == FEE_NG )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* continue */
        }
    }

/* 4.set moving sector */
    if( proc == FEE_RECYCLE_SET_MOVING_SECTOR )
    {
        retval = Fee_SetSector(src_sector_no, FEE_SECTOR_MOVING);

        if( retval == FEE_OK )
        {
            /* => 5.get destination sector */
            proc = FEE_RECYCLE_GET_DST_SECTOR;
        }
        else if( retval == FEE_NG )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* continue */
        }

    }

/* 5.get destination sector */
    if( proc == FEE_RECYCLE_GET_DST_SECTOR )
    {
        dst_sector_no = Fee_GetSector(FEE_SECTOR_DISABLE);

        if( dst_sector_no == FEE_NONE_SECTOR )
        {
            /* During recycle process, when the first acquisition of an invalid sector fails, erased again instead of a failure directly. */
            if( retry_count == FEE_ZERO )
            {
                retry_count++;
                /* => 3.erase garbage sector */
                proc = FEE_RECYCLE_ERASE_GARBAGE_SECTOR;
                /* reset address index of blocks */
                Fee_ResetBlockIndex();
            }
            else
            {
                /* If it failed in the getting of the moving destination sector, end processing of recycling. */
                Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

                /* => X.end of periodic processing */
                proc = FEE_RECYCLE_END;

            }
        }
        else
        {
            /* => 6.set psc */
            proc = FEE_RECYCLE_SET_PSC;
        }
    }

/* 6.set psc */
    if( proc == FEE_RECYCLE_SET_PSC )
    {
        Fee_InfoDataBuffer = Fee_CalculatePSC();

        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        psc_ptr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(dst_sector_no) + FEE_PSC_OFFSET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite(psc_ptr, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_PSC_SIZE);

        /* => 6-a.check result of writing psc */
        FEE_SET_PROC(FEE_RECYCLE_SET_PSC_CHECK)
    }

/* 6-a.check result of writing psc */
    if( proc == FEE_RECYCLE_SET_PSC_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)(FEE_GET_FLASH_SECTOR_START_ADDR(src_sector_no) + FEE_TOP_BLOCK_OFFSET);
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            dst_ptr = (Fee_BlockManagementInfoType*)(FEE_GET_FLASH_SECTOR_START_ADDR(dst_sector_no) + FEE_TOP_BLOCK_OFFSET);

            max_page_no = (uint16)FEE_BLOCK_INITIAL_PAGE_NO;
            for(cnt_temp = 0; cnt_temp < Fee_GetNoOfBlocks(); cnt_temp++)
            {
                block_addr_index_check = Fee_GetBlockAddrIndex(cnt_temp);
                if( block_addr_index_check.BlkAddr == FEE_BLKIDX_NEED_REFRESH )
                {
                    search_from_flash = FEE_ON;
                }

                if(( block_addr_index_check.BlkStatus == FEE_BLKIDX_VALID_BLOCK ) ||
                   ( block_addr_index_check.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE ) )
                {
                    Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                    Fee_FlsEnableDMA();
                    /* ReadOperation */
                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                    Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 1 */
                    Fee_FlsReadImmediateSync((uint32)block_addr_index_check.BlkAddr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                    fee_fault = Fee_GetFlsFault();
                    Fee_FlsDisableDMA();

                    if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                    {
                        if( max_page_no < Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum)
                        {
                            cnt_temp_max = cnt_temp;
                            max_page_no = Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum;
                        }
                    }
                }
            }
            if(FEE_ON != search_from_flash)
            {
                block_addr_index_check = Fee_GetBlockAddrIndex(cnt_temp_max);
                fee_cfg = Fee_GetCfg();
                /* Deviation from MISRA-C:2012 Rule-12.1
                  Justification: This is the necessary algrithm. */
                /* PRQA S 3395 1 */
                if(((max_page_no * fee_cfg.FeeVirtualPageSize + FEE_ERASE_COMPLETE_FLAG_SIZE) % FEE_CHECK_BYTES_ALIGN) != (uint8)0)
                {
                    Fee_LastValidBlockInFlash.BlkAddr = block_addr_index_check.BlkAddr;
                    Fee_LastValidBlockInFlash.BlkStatus = block_addr_index_check.BlkStatus;
                }
            }

            Fee_BlkIdxSearchBlkInRecycle = (uint16)FEE_ZERO;
            Fee_PageNoFront = (uint16)FEE_ZERO;

            Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH;
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;
            Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;
            if((STD_ON == Fee_GetDefinedThresholdPageSize()) && (FEE_ON == search_from_flash))
            {
                /* => 6-b.re-create block index */
                proc = FEE_RECYCLE_RECREATE_BLOCK_INDEX;
            }
            else
            {
                /* => 7-1.get write start flag blank or not */
                FEE_SET_PROC(FEE_RECYCLE_GET_WRITESTARTFLAG)
            }
            break;

        case MEMIF_JOB_FAILED:
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 6-b.re-create block index */
    if( proc == FEE_RECYCLE_RECREATE_BLOCK_INDEX )
    {
        create_index_result =  Fee_CreateBlockByInit(src_sector_no);

        switch(create_index_result)
        {
        case FEE_OK:
            search_from_flash = FEE_OFF;

            max_page_no = (uint16)FEE_BLOCK_INITIAL_PAGE_NO;
            for(cnt_temp = 0; cnt_temp < Fee_GetNoOfBlocks(); cnt_temp++)
            {
                block_addr_index_check = Fee_GetBlockAddrIndex(cnt_temp);

                if(( block_addr_index_check.BlkStatus == FEE_BLKIDX_VALID_BLOCK ) ||
                   ( block_addr_index_check.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE ) )
                {
                    Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                    Fee_FlsEnableDMA();
                    /* ReadOperation */
                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                    Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 1 */
                    Fee_FlsReadImmediateSync((uint32)block_addr_index_check.BlkAddr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                    fee_fault = Fee_GetFlsFault();
                    Fee_FlsDisableDMA();

                    if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                    {
                        if( max_page_no < Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum)
                        {
                            cnt_temp_max = cnt_temp;
                            max_page_no = Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum;
                        }
                    }
                }
            }

            block_addr_index_check = Fee_GetBlockAddrIndex(cnt_temp_max);
            fee_cfg = Fee_GetCfg();
            /* Deviation from MISRA-C:2012 Rule-12.1
              Justification: This is the necessary algrithm. */
            /* PRQA S 3395 1 */
            if(((max_page_no * fee_cfg.FeeVirtualPageSize + FEE_ERASE_COMPLETE_FLAG_SIZE) % FEE_CHECK_BYTES_ALIGN) != (uint8)0)
            {
                Fee_LastValidBlockInFlash.BlkAddr = block_addr_index_check.BlkAddr;
                Fee_LastValidBlockInFlash.BlkStatus = block_addr_index_check.BlkStatus;
            }

            Fee_BlkIdxSearchBlkInRecycle = (uint16)FEE_ZERO;
            Fee_PageNoFront = (uint16)FEE_ZERO;

            Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH;
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;
            Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;

            /* => 7-1.get write start flag blank or not */
            FEE_SET_PROC(FEE_RECYCLE_GET_WRITESTARTFLAG)
            break;
        case FEE_NG:
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
            break;
        default:/* FEE_CONT */
            /* continue */
            break;
        }
    }

/* 7-1.get write start flag blank or not */
    if( proc == FEE_RECYCLE_GET_WRITESTARTFLAG )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            write_start_flag = Fee_FlsGetReadAddr((uint32)src_ptr); /* check WriteFlag */

            /* => 7-2.get blocknumber and page number blank or not */
            FEE_SET_PROC(FEE_RECYCLE_GET_BNUMANDPNUM)
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr, &Fee_InfoDataBuffer, FEE_BLOCK_WRITEFLAG_SIZE);
            fee_fault = Fee_GetFlsFault();

            if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
            {
                /* It itself is recycle processing. It doesn't matter if 1 bit ECC appears. */
                
                write_start_flag = Fee_InfoDataBuffer;
                /* => 7-2.get blocknumber and page number blank or not */
                proc = FEE_RECYCLE_GET_BNUMANDPNUM;
            }
            else /* 2bit ECC error, other error */
            {
                /* If 2bit ECC error / other errors occur, the block will not be moved to destination sector. */
                if(Fee_LastBlockIsFound == (uint8)FEE_OFF)
                {
                    /* If Fee_LastBlockIsFound is ON, so already searched at last block in flash, do no more search */
                    /* update current position */
                    /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic. */
                    /* PRQA S 310,488,3305 1 */
                    src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
                }

                /* => 7-1.get write start flag blank or not */
                proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
            }
        }
    }

/* 7-2.get blocknumber and page number blank or not */
    if( proc == FEE_RECYCLE_GET_BNUMANDPNUM )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        bnum_pnum = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE);

        /* => 7-3.get valid flag blank or not */
        proc = FEE_RECYCLE_GET_VALIDFLAG;
    }

/* 7-3.get valid flag blank or not */
    if( proc == FEE_RECYCLE_GET_VALIDFLAG )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            valid_status = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */

            /* => 7-4.get invalid flag blank or not */
            proc = FEE_RECYCLE_GET_INVALIDFLG;
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE, &Fee_InfoDataBuffer, FEE_BLOCK_STATUS_SIZE);
            fee_fault = Fee_GetFlsFault();

            if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
            {
                /* It itself is recycle processing. It doesn't matter if 1 bit ECC appears. */
                
                valid_status = Fee_InfoDataBuffer;

                /* => 7-4.get invalid flag blank or not */
                proc = FEE_RECYCLE_GET_INVALIDFLG;
            }
            else /* 2bit ECC error, other error */
            {
                /* If 2bit ECC error / other errors occur, the block will not be moved to destination sector. */
                if(Fee_LastBlockIsFound == (uint8)FEE_OFF)
                {
                    /* If Fee_LastBlockIsFound is ON, so already searched at last block in flash, do no more search */
                    /* update current position */
                    /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic. */
                    /* PRQA S 310,488,3305 1 */
                    src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
                }

                /* => 7-1.get write start flag blank or not */
                proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
            }
        }
    }

/* 7-4.get invalid flag blank or not */
    if( proc == FEE_RECYCLE_GET_INVALIDFLG )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            invalid_status = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

            /* => 7-4-a. save block infor to variable */
            FEE_SET_PROC(FEE_RECYCLE_SAVE_BLOCK_INFOR)
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, &Fee_InfoDataBuffer, FEE_BLOCK_STATUS_SIZE);
            fee_fault = Fee_GetFlsFault();

            if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
            {
                /* It itself is recycle processing. It doesn't matter if 1 bit ECC appears. */
                
                invalid_status = Fee_InfoDataBuffer;

                /* => 7-4-a. save block infor to variable  */
                proc = FEE_RECYCLE_SAVE_BLOCK_INFOR;
            }
            else /* 2bit ECC error, other error */
            {
                invalid_status = FEE_BLOCK_INITIAL_VALUE;

                /* => 7-4-a. save block infor to variable  */
                proc = FEE_RECYCLE_SAVE_BLOCK_INFOR;
            }

            Fee_FlsDisableDMA();
        }
    }

/* 7-4-a. save block infor to variable */
    if(proc == FEE_RECYCLE_SAVE_BLOCK_INFOR)
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            if( write_start_flag == FEE_NULL )
            {
                Fee_LastBlockIsFound = (uint8)FEE_ON; /* write_start_flag is blank */
            }
            else
            {
                Fee_LastBlockIsFound = (uint8)FEE_OFF; /* write_start_flag is not blank */
            }
        }
        else
        {
            if( write_start_flag != FEE_BLOCK_FLAG_VALUE )
            {
                Fee_LastBlockIsFound = (uint8)FEE_ON; /* write_start_flag is blank */
            }
            else
            {
                Fee_LastBlockIsFound = (uint8)FEE_OFF; /* write_start_flag is not blank */
            }
        }

        if(Fee_BlockInforDuringSearchWorkFlashCnt == 0U)
        {
            Fee_BlockInforDuringSearchWorkFlash[0].write_start_flag = write_start_flag;
            Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum = bnum_pnum;
            Fee_BlockInforDuringSearchWorkFlash[0].valid_status = valid_status;
            Fee_BlockInforDuringSearchWorkFlash[0].invalid_status = invalid_status;

            /* Save first one, then search the second one directly */

            /* update current position */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);

            /* => 7-1.get write start flag blank or not */
            proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
        }
        else if(Fee_BlockInforDuringSearchWorkFlashCnt == 1U)
        {
            Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag = write_start_flag;
            Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum = bnum_pnum;
            Fee_BlockInforDuringSearchWorkFlash[1].valid_status = valid_status;
            Fee_BlockInforDuringSearchWorkFlash[1].invalid_status = invalid_status;

            /* => 7-5.search enable block from source sector  */
            proc = FEE_RECYCLE_GET_ENABLE_DATA;
        }
        else /* Fee_BlockInforDuringSearchWorkFlashCnt == 2,3... */
        {
            Fee_BlockInforDuringSearchWorkFlash[0] = Fee_BlockInforDuringSearchWorkFlash[1];
            Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag = write_start_flag;
            Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum = bnum_pnum;
            Fee_BlockInforDuringSearchWorkFlash[1].valid_status = valid_status;
            Fee_BlockInforDuringSearchWorkFlash[1].invalid_status = invalid_status;

            /* => 7-5.search enable block from source sector  */
            proc = FEE_RECYCLE_GET_ENABLE_DATA;
        }
        Fee_BlockInforDuringSearchWorkFlashCnt++;
    }

/* 7-5.search enable block from source sector */
    if( proc == FEE_RECYCLE_GET_ENABLE_DATA )
    {
        if(search_from_flash == FEE_ON ) /* For all operation, if anyone block index is need_refresh, search from flash */
        {
            /* search from flash */
            Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;
            src_ptr_temp_ptr = src_ptr;
            retval = Fee_SearchValidBlockOldConfig(&src_ptr,
            Fee_BlockInforDuringSearchWorkFlash[0].write_start_flag,
            Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum,
            Fee_BlockInforDuringSearchWorkFlash[0].valid_status,
            Fee_BlockInforDuringSearchWorkFlash[0].invalid_status,
            src_sector_no);
            if(
            ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
            (FEE_NULL == Fee_BlockInforDuringSearchWorkFlash[1].invalid_status)) ||
            ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].invalid_status))
            )
            {
                /* when next block is valid block and invalid block do nothing */
            }
            else
            {
                pre_block.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                Fee_FlsEnableDMA();
                /* ReadOperation */
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                Fee_FlsReadImmediateSync(Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum, &pre_block.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                fee_fault = Fee_GetFlsFault();
                Fee_FlsDisableDMA();
                if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                {
                     /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                     pre_blk_idx = Fee_BlockNumberToIndex(pre_block.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                     Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                }
            }
            if( src_ptr_temp_ptr != src_ptr)
            {
                /* => 7-1.get write start flag blank or not */
                FEE_SET_PROC(FEE_RECYCLE_GET_WRITESTARTFLAG)
            }
        }
        else if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_RECOVERING) == FEE_MAIN_STATE_RECOVERING ) /* Init, CleanupAndErase */
        {
            /* Fee_RecycleFlag is only set in recover operation. */
            /* If Fee_RecycleFlag is ON, it means that all index is create complete. */

            /* Fee_RecycleFlag is FEE_ON , and Fee_RecycleImmediateFlag is FEE_ON, do Fee_SearchValidBlockOldConfig */
            /* Fee_RecycleFlag is FEE_ON , and Fee_RecycleImmediateFlag is FEE_OFF, do Fee_SearchValidBlock */
            /* Fee_RecycleFlag is FEE_OFF , and Fee_RecycleImmediateFlag is FEE_ON, do Fee_SearchValidBlockOldConfig */
            /* Fee_RecycleFlag is FEE_OFF , and Fee_RecycleImmediateFlag is FEE_OFF, do Fee_SearchValidBlockOldConfig */
            if(( Fee_RecycleFlag == FEE_ON ) && (Fee_RecycleImmediateFlag == FEE_OFF))
            {
                /* search from index */
                Fee_RecyclePattern = FEE_RECYCLE_USE_INDEX;
                retval = Fee_SearchValidBlock(&use_index_src_ptr);
            }
            else
            {
                /* search from flash */
                Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;
                src_ptr_temp_ptr = src_ptr;
                retval = Fee_SearchValidBlockOldConfig(&src_ptr,
                Fee_BlockInforDuringSearchWorkFlash[0].write_start_flag,
                Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum,
                Fee_BlockInforDuringSearchWorkFlash[0].valid_status,
                Fee_BlockInforDuringSearchWorkFlash[0].invalid_status,
                src_sector_no);
                if(
                ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
                (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
                (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
                (FEE_NULL == Fee_BlockInforDuringSearchWorkFlash[1].invalid_status)) ||
                ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
                (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
                (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
                (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].invalid_status))
                )
                {
                    /* when next block is valid block and invalid block do nothing */
                }
                else
                {
                    pre_block.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                    Fee_FlsEnableDMA();
                    /* ReadOperation */
                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                    Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 1 */
                    Fee_FlsReadImmediateSync(Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum, &pre_block.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                    fee_fault = Fee_GetFlsFault();
                    Fee_FlsDisableDMA();
                    if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                    {
                         /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                         pre_blk_idx = Fee_BlockNumberToIndex(pre_block.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                         Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                    }
                }
                if( src_ptr_temp_ptr != src_ptr)
                {
                    /* => 7-1.get write start flag blank or not */
                    FEE_SET_PROC(FEE_RECYCLE_GET_WRITESTARTFLAG)
                }
            }
        }
        else if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_WRITING) == FEE_MAIN_STATE_WRITING ) /* Write */
        {
            /* search from index */
            Fee_RecyclePattern = FEE_RECYCLE_USE_INDEX;
            retval = Fee_SearchValidBlock(&use_index_src_ptr);
        }
        else if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_INVALIDATING) == FEE_MAIN_STATE_INVALIDATING ) /* Invalidate */
        {
            /* search from index */
            Fee_RecyclePattern = FEE_RECYCLE_USE_INDEX;
            retval = Fee_SearchValidBlock(&use_index_src_ptr);
        }
        else
        {
            /* no possible case */
            /* search from flash */
            Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;
            src_ptr_temp_ptr = src_ptr;
            retval = Fee_SearchValidBlockOldConfig(&src_ptr,
            Fee_BlockInforDuringSearchWorkFlash[0].write_start_flag,
            Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum,
            Fee_BlockInforDuringSearchWorkFlash[0].valid_status,
            Fee_BlockInforDuringSearchWorkFlash[0].invalid_status,
            src_sector_no);
            if(
            ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
            (FEE_NULL == Fee_BlockInforDuringSearchWorkFlash[1].invalid_status)) ||
            ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
            (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].invalid_status))
            )
            {
                /* when next block is valid block and invalid block do nothing */
            }
            else
            {
                pre_block.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                Fee_FlsEnableDMA();
                /* ReadOperation */
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                Fee_FlsReadImmediateSync(Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum, &pre_block.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                fee_fault = Fee_GetFlsFault();
                Fee_FlsDisableDMA();
                if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                {
                     /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                     pre_blk_idx = Fee_BlockNumberToIndex(pre_block.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                     Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                }
            }
            if( src_ptr_temp_ptr != src_ptr)
            {
                /* => 7-1.get write start flag blank or not */
                FEE_SET_PROC(FEE_RECYCLE_GET_WRITESTARTFLAG)
            }
        }

        switch(retval)
        {
        case FEE_BLOCK_NONE_SEARCH:
            /* block search complete */
            /* clear empty address */
            Fee_SetBlkMgtAreaEmptyAddr((Fee_BlockManagementInfoType*)FEE_NULL);
            Fee_SetBlkPageAreaEmptyAddr((uint32*)FEE_NULL);
            search_from_flash = FEE_OFF;
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;

            /* => 12.set enable sector */
            proc = FEE_RECYCLE_SET_ENABLE_SECTOR;
            break;
        case FEE_OK:

            /* => 7-6.get block no page no */
            FEE_SET_PROC(FEE_RECYCLE_GET_BLOCKNO_PAGENO)

            break;
        case FEE_NG:
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;

            break;
        default:/* FEE_CONT */

            /* continue */
            break;
        }
    }

/* 7-6.get block no page no */
    if(proc == FEE_RECYCLE_GET_BLOCKNO_PAGENO)
    {
        Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        if(Fee_RecyclePattern == FEE_RECYCLE_USE_INDEX)
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
            Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)use_index_src_ptr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_InfoDataBuffer, FEE_BLOCK_BLKNUMPAGENUM_SIZE);
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
            Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync(Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum, &Fee_InfoDataBuffer, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        }
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = Fee_InfoDataBuffer;

            /* block exist */
            fee_cfg = Fee_GetCfg();
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested. */
            /* PRQA S 306,488,1840,1860 1 */
            src_data_ptr = Fee_CalPhysicalAddrFromPageNo(src_sector_no, Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
            flag_from_flash = (uint32)Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum;
            blk_idx = Fee_BlockNumberToIndex((uint16)flag_from_flash);

            blk_cfg = Fee_GetBlkCfg(blk_idx);
            used_pages_size += Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize);

            if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_INITIALIZING) == FEE_MAIN_STATE_INITIALIZING )
            {
                if( blk_cfg.FeeImmediateData == TRUE )
                {
                    used_reserve_size += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                }
            }

            Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.PageNum = (uint16)(used_pages_size/fee_cfg.FeeVirtualPageSize);
            /* => 9-0.copy src data to buffer for last valid block */
            proc = FEE_RECYCLE_COPY_TO_BUFFER_FOR_LAST_VALID_BLOCK;
        }
        else /* 2bit ECC error, other error */
        {
            if((Fee_RecyclePattern == FEE_RECYCLE_SEARCH_FLASH) && (Fee_LastBlockIsFound == (uint8)FEE_OFF))
            {
                /* If Fee_LastBlockIsFound is ON, so already searched at last block in flash, do no more search */
                /* update current position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
                /* => 7-1.get write start flag blank or not */
                proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
            }
            else if((Fee_RecyclePattern == FEE_RECYCLE_SEARCH_FLASH) && (Fee_LastBlockIsFound == (uint8)FEE_ON))
            {
                /* => 7-1.get write start flag blank or not */
                proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
            }
            else /*Fee_RecyclePattern is FEE_RECYCLE_USE_INDEX*/
            {
                /* => 7-5.search enable block from source sector */
                proc = FEE_RECYCLE_GET_ENABLE_DATA;
            }
        }
    }

/* 8.set erasing sector destination */
    if( proc == FEE_RECYCLE_SET_ERASING_SECTORDST )
    {
        retval = Fee_SetSector(dst_sector_no, FEE_SECTOR_GARBAGE);

        if( retval == FEE_OK )
        {
            /* => 5.get destination sector */
            proc = FEE_RECYCLE_GET_DST_SECTOR;
        }
        else if( retval == FEE_NG )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* continue */
        }
    }

/* 9-0.copy src data to buffer for last valid block */
    if( proc == FEE_RECYCLE_COPY_TO_BUFFER_FOR_LAST_VALID_BLOCK )
    {
        blk_idx = Fee_BlockNumberToIndex((uint16)Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
        block_addr_index_check = Fee_GetBlockAddrIndex(blk_idx);

        /* Fee_LastValidBlockInFlash is UseIndex pattern */
        /* Fee_LastBlockIsFound is SearchFlash pattern */
        /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
           MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
            Justification: Cast between a pointer to object and an integral type.
            This deviation is due to doing pointer arithmetic.
            This deviation is due to an integer type cast to do pointer arithmetic. 
            It is no problem because side effects cannot be caused */
        /* PRQA S 3395,3415 14 */
        if(
          (
            (Fee_LastValidBlockInFlash.BlkAddr   == block_addr_index_check.BlkAddr) &&
            (Fee_LastValidBlockInFlash.BlkStatus == block_addr_index_check.BlkStatus)
          ) ||
          (
            (Fee_LastBlockIsFound == (uint8)FEE_ON) &&
            (((Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum * fee_cfg.FeeVirtualPageSize + FEE_ERASE_COMPLETE_FLAG_SIZE) % FEE_CHECK_BYTES_ALIGN) != (uint8)0)
          ) ||
          (
            (Fee_GetIsNextBlockCorrupt(Fee_CurrentConfigNo, blk_idx) == FEE_NEXT_BLOCK_IS_CORRUPT) &&
            (((Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum * fee_cfg.FeeVirtualPageSize + FEE_ERASE_COMPLETE_FLAG_SIZE) % FEE_CHECK_BYTES_ALIGN) != (uint8)0)
          )
          )
        {
            /* copy last valid block to buffer */
            data_ptr     = Fee_GetDataBufferRecycle();
            blk_cfg      = Fee_GetBlkCfg(blk_idx);
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
            Justification: Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 310 1*/
            retval = Fee_MemCpy1((uint8*)data_ptr, src_data_ptr, (uint16)Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize));
            if( retval == FEE_OK )
            {
                /* => 9.write block */
                proc = FEE_RECYCLE_WRITE_BLOCK;
                Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH; /* set for UseIndex pattern */
            }
            else
            {
                /* continue */
                /* => 9-0.copy src data to buffer for last valid block */
            }
        }
        else
        {
            /* no need to copy last valid block to buffer */
            /* => 9.write block */
            proc = FEE_RECYCLE_WRITE_BLOCK;
            Fee_UseFlashOrBuffer = FEE_USE_FLASH_TO_FLASH; /* set for UseIndex pattern */
        }
    }

/* 9.write block */
    if( proc == FEE_RECYCLE_WRITE_BLOCK )
    {
        if(Fee_UseFlashOrBuffer == FEE_USE_FLASH_TO_FLASH)
        {
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            Implementation often uses pointer access by array-subscripting.*/
            /* PRQA S 310 1 */
            retval = Fee_WriteBlock(dst_sector_no, dst_ptr, (uint8*)src_data_ptr, FEE_ADJUSTING_USE_NEW_STRUCT);
        }
        else
        {
            data_ptr     = Fee_GetDataBufferRecycle();
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            Implementation often uses pointer access by array-subscripting.*/
            /* PRQA S 310 1 */
            retval = Fee_WriteBlock(dst_sector_no, dst_ptr, (uint8*)data_ptr, FEE_ADJUSTING_USE_NEW_STRUCT);
        }

        if( retval == FEE_OK )
        {
            block_addr_index = Fee_GetBlockAddrIndex(blk_idx);
            if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE )
            {
                /* => 10.invalid multi valid blocks */
                proc = FEE_RECYCLE_BLOCK_INVALID;
            }
            else
            {
                /* => 11.update index after block copy */
                proc = FEE_RECYCLE_WRITE_BLOCK_UPDATE_INDEX;
            }
        }
        else if( retval == FEE_NG )
        {
            used_pages_size = (uint16)FEE_ZERO;
            used_reserve_size = (uint16)FEE_ZERO;

            /* => 8.set erasing sector destination */
            proc = FEE_RECYCLE_SET_ERASING_SECTORDST;
        }
        else
        {
            /* continue */
        }
    }

/* 10.invalid multi valid blocks */
    if( proc == FEE_RECYCLE_BLOCK_INVALID )
    {
        Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;

        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite(block_addr_index.BlkAddr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */

        /* => 10-1.check result of invalidating old block */
        FEE_SET_PROC(FEE_RECYCLE_BLOCK_INVALID_CHECK)
    }

/* 10-1.check the result of invaliding multi valid blocks */
    if( proc == FEE_RECYCLE_BLOCK_INVALID_CHECK )
    {
       retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 11.update index after block copy */
            proc = FEE_RECYCLE_WRITE_BLOCK_UPDATE_INDEX;
            break;

        case MEMIF_JOB_FAILED:
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 11.update index after block copy */
    if( proc == FEE_RECYCLE_WRITE_BLOCK_UPDATE_INDEX )
    {
        /* update address index of blocks */
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        block_addr_index.BlkAddr       = (uint32)dst_ptr;
        block_addr_index.BlkStatus     = FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE;
        block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
        Fee_SetBlockAddrIndex(blk_idx, block_addr_index);

        if((Fee_RecyclePattern == FEE_RECYCLE_SEARCH_FLASH) && (Fee_LastBlockIsFound == (uint8)FEE_OFF))
        {
            /* If Fee_LastBlockIsFound is ON, so already searched at last block in flash, do no more search */
            /* update current position */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
            /* => 7-1.get write start flag blank or not */
            proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
        }
        else if((Fee_RecyclePattern == FEE_RECYCLE_SEARCH_FLASH) && (Fee_LastBlockIsFound == (uint8)FEE_ON))
        {
            /* => 7-1.get write start flag blank or not */
            proc = FEE_RECYCLE_GET_WRITESTARTFLAG;
        }
        else /*Fee_RecyclePattern is FEE_RECYCLE_USE_INDEX*/
        {
            /* => 7-5.search enable block from source sector */
            proc = FEE_RECYCLE_GET_ENABLE_DATA;
        }

        /* update current position */
        /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
        Justification: Casting to different object pointer type. And this casting is safety by judgment.
                        This deviation is due to doing pointer arithmetic. */
        /* PRQA S 310,488,3305 1 */
        dst_ptr = (Fee_BlockManagementInfoType*)((uint8*)dst_ptr + FEE_BLOCK_MANAGE_SIZE);
    }

/* 12.set enable sector */
    if( proc == FEE_RECYCLE_SET_ENABLE_SECTOR )
    {
        retval = Fee_SetSector(dst_sector_no, FEE_SECTOR_ENABLE);

        if( retval == FEE_OK )
        {
            /* update empty address and empty size */
            blk_mgt_area_empty_addr_ptr = dst_ptr;
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic. */
            /* PRQA S 306,310,488,3395,3305 1 */
            blk_page_area_empty_addr_ptr = (uint32*)((Fee_GetFlashSectorEraseFlagAddr(dst_sector_no)) - used_pages_size);
            Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);

            /* calculate immediate date reserve size if it was not be calculated at initialize phase */
            /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
               Justification: This implementation is adopted for avoiding more nesting.
               It is no problem because side effects cannot be caused. */
            /* PRQA S 3415 1 */
            if(( FEE_ON == Fee_RecycleImmediateFlag ) && ( STD_OFF == Fee_GetDefinedThresholdPageSize() ))
            {
                Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] -= used_reserve_size;
            }

            /* => 13.set erasing sector source */
            proc = FEE_RECYCLE_SET_ERASING_SECTORSRC;

        }
        else if( retval == FEE_NG )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* continue */
        }

    }

/* 13.set erasing sector source */
    if( proc == FEE_RECYCLE_SET_ERASING_SECTORSRC )
    {
        retval = Fee_SetSector(src_sector_no, FEE_SECTOR_GARBAGE);

        if( retval == FEE_OK )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;

            /* => 14.change block index status */
            proc = FEE_RECYCLE_CHANGE_BLK_IDX_STATUS;
        }
        else if( retval == FEE_NG )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;

            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* continue */
        }
    }    

/* 14. change block index status */
    if( proc == FEE_RECYCLE_CHANGE_BLK_IDX_STATUS )
    {
        cnt = 0;
        while( (cnt_block_index < Fee_GetNoOfBlocks()) && (cnt < FEE_CPY_BLK_INDEX_MAX) )
        {
            block_addr_index = Fee_GetBlockAddrIndex(cnt_block_index);
            if(block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE)
            {
                block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;
                Fee_SetBlockAddrIndex(cnt_block_index, block_addr_index);
            }
            cnt_block_index++;
            cnt++;
        }

        if( cnt_block_index >= Fee_GetNoOfBlocks() )
        {
            /* => X.end of periodic processing */
            proc = FEE_RECYCLE_END;
        }
        else
        {
            /* do not change proc, continue copy index */
        }
    }


/* X.end of periodic processing */
    if( proc == FEE_RECYCLE_END )
    {
        if( Fee_PeriInfo.Fee_MainError == MEMIF_JOB_OK )
        {
            retval = FEE_OK;
        }
        else
        {
            /* reset address index of blocks */
            Fee_ResetBlockIndex();
            retval = FEE_NG;
        }
        proc = FEE_RECYCLE_START;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(use_index_src_ptr)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 2 */
        FEE_PUSH_STACK_UCHAR(retry_count)
        FEE_PUSH_STACK_UCHAR(search_from_flash)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 4 */
        FEE_PUSH_STACK_ULONG(invalid_status)
        FEE_PUSH_STACK_ULONG(valid_status)
        FEE_PUSH_STACK_ULONG(bnum_pnum)
        FEE_PUSH_STACK_ULONG(write_start_flag)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(src_ptr)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_UCHAR(dst_sector_no)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(src_data_ptr)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(dst_ptr)
        FEE_PUSH_STACK_USHORT(used_pages_size)
        FEE_PUSH_STACK_USHORT(used_reserve_size)
        FEE_PUSH_STACK_USHORT(blk_idx)
        FEE_PUSH_STACK_USHORT(cnt_block_index)
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    if( proc != FEE_RECYCLE_START )
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_RecycleFinal
**
** End periodic processing of recycling.
**
** \return     result of operation
** \retval     FEE_OK     success
** \retval     FEE_NG     failed
**
*/
FUNC(uint8, FEE_CODE) Fee_RecycleFinal(void)
{
    VAR(uint8, AUTOMATIC) retval;      /* return value */
    VAR(uint16, AUTOMATIC) cnt;        /* count */

    /* initialize fee_recycle_src */
    Fee_PeriInfo.Fee_RecycleSrc = (uint8)FEE_ZERO;
    /* recycling flag OFF */
    Fee_PeriInfo.Fee_MainState &= FEE_MAIN_STATE_RECYCEND;

    Fee_RecycleFlag = FEE_OFF; /* clear to OFF */
    Fee_RecycleImmediateFlag = FEE_OFF; /* clear to OFF */
    Fee_ConfigUnmatchFlag = FEE_OFF; /* clear to OFF */

    Fee_LastValidBlockInFlash.BlkAddr = (uint32)FEE_BLKIDX_NO_BLOCK_EXIST;
    Fee_LastValidBlockInFlash.BlkStatus = (uint8)FEE_BLKIDX_NO_BLOCK_EXIST;
    Fee_LastValidBlockInFlash.BlkBlankCheck = (uint8)FEE_BLANK_CHECK_UNDO;
    Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH;
    Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
    Fee_LastBlockIsFound = (uint8)FEE_OFF;
    Fee_RecyclePattern = FEE_RECYCLE_SEARCH_FLASH;

    for( cnt = (uint16)FEE_ZERO; cnt < (uint16)Fee_ConfigInfo[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfBlocks; cnt++ )
    {
        Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, cnt, FEE_NEXT_BLOCK_IS_NOT_CORRUPT);
    }

    if( Fee_PeriInfo.Fee_MainError == MEMIF_JOB_OK )
    {
        retval = FEE_OK;
    }
    else
    {
        retval = FEE_NG;
    }

    return retval;
}


/** \brief Fee_Recover
**
** Recover sector.
** This function is called by Fee_MainInit.
** If there is a necessity, recycling sector.
**
** \param[in]  none
**
** \return     result of operation
** \retval     FEE_OK                   success
** \retval     FEE_NG                   failed
** \retval     FEE_INVALID_SECTOR_NO    invalid sector
** \retval     FEE_CONT                 continue
**
*/
FUNC(uint8, FEE_CODE) Fee_Recover(void)
{
    VAR(Fee_RecoverProcType, AUTOMATIC)            proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                          retval;                       /* return value */
    VAR(uint8, AUTOMATIC)                          sector_no;                    /* number of sector */
    VAR(uint8, AUTOMATIC)                          enable_sector_no;             /* number of enable sector */
    VAR(uint16, AUTOMATIC)                         blk_empty_size;               /* empty size */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)            blk_page_area_empty_addr_ptr;     /* pointer to empty address for page area */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC) blk_mgt_area_empty_addr_ptr; /* pointer to empty address for block management area */
    VAR(uint32, AUTOMATIC)                         block_start_addr;             /* start address of block mgt area */
    VAR(MemIf_JobResultType, AUTOMATIC)            retjob;                       /* result of fls job */
    VAR(uint32, AUTOMATIC)                         write_flag;                   /* write flag */
    VAR(uint8, AUTOMATIC)                          config_difference;            /* old config is same or not with new config */
    VAR(uint32, AUTOMATIC)                         psc_ptr;                      /* pointer to PSC */
    VAR(uint32, AUTOMATIC)                         sector_flag;                  /* pointer to sector recycle flag */
    VAR(Fee_FaultType, AUTOMATIC)                  fee_fault;                    /* get fault information from FLS */
    VAR(uint16, AUTOMATIC)                         cnt_block_index;              /* block number index */
    VAR(uint16, AUTOMATIC)                         block_cnt;                    /* block count */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)         block_addr_index;             /* index of blocks */
    VAR(uint32, AUTOMATIC)                         start_addr;                   /* flash start address */
    VAR(uint32, AUTOMATIC)                         end_addr;                     /* flash end address */

    retval            = FEE_CONT;
    sector_no         = (uint8)FEE_NULL;
    enable_sector_no  = (uint8)FEE_NULL;
    sector_flag       = (uint32)FEE_NULL;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_RecoverProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_RECOVER_START )
    {
        /* Before block search, clear block search count. */
        Fee_BlkSearchCntInInit = (uint16)FEE_ZERO;
        
        /* =>1.check old config */
        proc = FEE_RECOVER_CHECK_OLD_CONFIG;
    }
    else
    {
        /* If periodic processing is continued, pop related data under processing. */
        FEE_POP_STACK_UCHAR(sector_no)
        FEE_POP_STACK_UCHAR(enable_sector_no)
    }
/* 1.check old config */
    if( proc == FEE_RECOVER_CHECK_OLD_CONFIG)
    {
        /* check old config infomation and compare */
        retval = Fee_CheckOldConfigAndCompare(&config_difference);

        if(retval == FEE_OK )
        {
            if( config_difference == FEE_CONFIG_IS_DIFFERENT )
            {
                /* => 16. configuration is changed, adjusting work flash */
                proc = FEE_RECOVER_ADJUSTING_WORK_FLASH;
            }
            else
            {
                /* => 2. check odd sector */
                proc = FEE_RECOVER_CHECK_ODD_SECTORS;
            }
        }
        else if(retval == FEE_NG)
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* continue do nothing */
        }
    }

/* 2.check odd sector */
    if( proc == FEE_RECOVER_CHECK_ODD_SECTORS )
    {
        enable_sector_no = Fee_GetSector(FEE_SECTOR_ENABLE);

        if( enable_sector_no == FEE_NONE_SECTOR )
        {
            /* no enable sector */
            sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);

            if( sector_no == FEE_INVALID_SECTOR_NO )
            {
                Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
                retval         = FEE_INVALID_SECTOR_NO;
                /* =>X.end of periodic processing */
                proc           = FEE_RECOVER_END;
            }
            else if( sector_no == FEE_NONE_SECTOR )
            {
                /* only disable sector or two or more unknown sector */
                /* =>3.get disable sector */
                proc = FEE_RECOVER_GET_DISABLE_SECTOR;
            }
            else
            {
                /* sector_no is moving sector */
                if( Fee_GetDelayRecycleOperation() == FEE_ON )
                {
                    /* delay recycle operation is on, do not recycle */

                    Fee_RecycleFlag = FEE_ON;

                    /* one enable sector and no moving sector */
                    /* =>2-a.check recycle need */
                    proc = FEE_RECOVER_CHECK_RECYCLE_NEED;
                }
                else
                {
                    /* default : delay recycle operation is off, do recycle */

                    /* =>13.recycle sector start */
                    proc = FEE_RECOVER_RECYCLE_START;
                }
            }
        }
        else
        {
            /* enable sector exist */
            enable_sector_no = Fee_GetSector(FEE_SECTOR_EFFECTIVE);

            if( enable_sector_no == FEE_INVALID_SECTOR_NO )
            {
                /* =>X.end of periodic processing */
                Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
                retval         = FEE_INVALID_SECTOR_NO;
                proc           = FEE_RECOVER_END;
            }
            else
            {
                sector_no = Fee_GetSector(FEE_SECTOR_MOVING);

                if( sector_no == FEE_NONE_SECTOR )
                {
                    sector_no = enable_sector_no;

                    /* one enable sector and no moving sector */
                    /* =>2-a.check recycle need */
                    proc = FEE_RECOVER_CHECK_RECYCLE_NEED;
                }
                else
                {
                    /* one enable sector and moving sector exist */
                    /* =>7.overwrite enable sector */
                    proc = FEE_RECOVER_OVERWRITE_ENABLESECTOR;
                }
            }
        }
    }

/* 2-a.check recycle need */
    if( proc == FEE_RECOVER_CHECK_RECYCLE_NEED )
    {
        if( Fee_ModuleState == FEE_STAT_RECYC )
        {
            /* =>13.recycle sector start */
            proc = FEE_RECOVER_RECYCLE_START;
        }
        else
        {
            if( FEE_OFF == Fee_GetSectorBlankCheckOff() )
            {
                /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, 21.1, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
                   Justification: Cast between a pointer to object and an integral type.
                                  Casting to different object pointer type. And this casting is safety by judgment.
                                  This deviation is due to doing pointer arithmetic.
                                  This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
                /* PRQA S 306,310,488,1840,2912 1 */
                sector_flag = Fee_FlsGetReadAddr((uint32)(FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_SECTOR_STATUS_SIZE)); /* check recycle flag */

                /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
                    Justification: 64bit is supported by the long long in ARM. */
                /* PRQA S 580 1 */
                if(( sector_flag == FEE_NULL ) && ( Fee_RecycleFlag == FEE_OFF ) && ( Fee_RecycleImmediateFlag == FEE_OFF ))
                {
                    /* =>9.get and check blank area on valid flash */
                    proc = FEE_RECOVER_GET_BLANK_AREA;
                }
                else
                {
                    if( Fee_GetDelayRecycleOperation() == FEE_ON )
                    {
                        /* delay recycle operation is on, do not recycle */
                        Fee_RecycleFlag = FEE_ON;
                        /* =>9.get and check blank area on valid flash */
                        proc = FEE_RECOVER_GET_BLANK_AREA;
                    }
                    else
                    {
                        /* default : delay recycle operation is off, do recycle */
                        /* =>13.recycle sector start */
                        FEE_SET_PROC(FEE_RECOVER_RECYCLE_START)
                    }
                }
            }
            else
            {
                Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
                Fee_FlsEnableDMA();
                /* ReadOperation */
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                   Justification: Cast between a pointer to object and an integral type.
                                  This deviation is due to doing pointer arithmetic. */
                /* PRQA S 306,488 1 */
                Fee_FlsReadImmediateSync((uint32)(FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_SECTOR_STATUS_SIZE), &Fee_InfoDataBuffer, FEE_SECTOR_RECYCLE_FLAG_SIZE); /* read recycle flag */
                fee_fault = Fee_GetFlsFault();
                Fee_FlsDisableDMA();

                if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                {
                    if(( Fee_InfoDataBuffer != FEE_SECTOR_STATUS_DATA_SET ) && ( Fee_RecycleFlag == FEE_OFF ) && ( Fee_RecycleImmediateFlag == FEE_OFF ))
                    {
                        /* =>9.get and check blank area on valid flash */
                        proc = FEE_RECOVER_GET_BLANK_AREA;
                    }
                    else
                    {
                        if( Fee_GetDelayRecycleOperation() == FEE_ON )
                        {
                            /* delay recycle operation is on, do not recycle */
                            Fee_RecycleFlag = FEE_ON;
                            /* =>9.get and check blank area on valid flash */
                            proc = FEE_RECOVER_GET_BLANK_AREA;
                        }
                        else
                        {
                            /* default : delay recycle operation is off, do recycle */
                            /* =>13.recycle sector start */
                            proc = FEE_RECOVER_RECYCLE_START;
                        }

                    }
                }
                else /* 2bit ECC error, other error */
                {
                    /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, 21.1, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
                       Justification: Cast between a pointer to object and an integral type.
                                      Casting to different object pointer type. And this casting is safety by judgment.
                                      This deviation is due to doing pointer arithmetic.
                                      This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
                    /* PRQA S 306,310,488,1840,2912 1 */
                    sector_flag = Fee_FlsGetReadAddr((uint32)(FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_SECTOR_STATUS_SIZE)); /* check recycle flag */

                    /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
                        Justification: 64bit is supported by the long long in ARM. */
                    /* PRQA S 580 1 */
                    if(( sector_flag == FEE_NULL ) && ( Fee_RecycleFlag == FEE_OFF ) && ( Fee_RecycleImmediateFlag == FEE_OFF ))
                    {
                        /* =>9.get and check blank area on valid flash */
                        proc = FEE_RECOVER_GET_BLANK_AREA;
                    }
                    else
                    {
                        if( Fee_GetDelayRecycleOperation() == FEE_ON )
                        {
                            /* delay recycle operation is on, do not recycle */
                            Fee_RecycleFlag = FEE_ON;
                            /* =>9.get and check blank area on valid flash */
                            proc = FEE_RECOVER_GET_BLANK_AREA;
                        }
                        else
                        {
                            /* default : delay recycle operation is off, do recycle */
                            /* =>13.recycle sector start */
                            FEE_SET_PROC(FEE_RECOVER_RECYCLE_START)
                        }
                    }
                }
            }
        }
    }

/* 3.get disable sector */
    if( proc == FEE_RECOVER_GET_DISABLE_SECTOR )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_DISABLE);

        if( sector_no == FEE_NONE_SECTOR )
        { /* FEE_INVALID_SECTOR_NO is not need checking because it has checked */
            /* =>3-a.erase sector */
            FEE_SET_PROC(FEE_RECOVER_ERASE_FOR_NOW)
        }
        else
        {
            /* =>4.overwrite erase complete flag of disable sector */
            proc = FEE_RECOVER_OVERWRITE_ERASE_FLAG;
        }
    }

/* 3-a.erase sector */
    if( proc == FEE_RECOVER_ERASE_FOR_NOW )
    {
        retval = Fee_GetLibFuncTable()->EraseOrWriteFlagFunc();

        if( retval == FEE_OK )
        {
            /* =>3-b.re-get disable sector */
            FEE_SET_PROC(FEE_RECOVER_REGET_DISABLE_SECTOR)
        }
        else if( retval == FEE_NG )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* continue */
        }

    }

/* 3-b.re-get disable sector */
    if( proc == FEE_RECOVER_REGET_DISABLE_SECTOR )
    {
        sector_no = Fee_GetSector(FEE_SECTOR_DISABLE);

        if( ( sector_no == FEE_NONE_SECTOR ) || ( sector_no == FEE_INVALID_SECTOR_NO ) )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* =>4.overwrite erase complete flag of disable sector */
            proc = FEE_RECOVER_OVERWRITE_ERASE_FLAG;
        }
    }

/* 4.overwrite erase complete flag of disable sector */
    if( proc == FEE_RECOVER_OVERWRITE_ERASE_FLAG )
    {
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
           Justification: 64bit is supported by the long long in ARM. */
        /* PRQA S 580 1 */
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_SET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic. */
        /* PRQA S 306,310,488,3395 1 */
        (void)Fee_FlsWrite((uint32)(Fee_GetFlashSectorEraseFlagAddr(sector_no)), (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_ERASE_COMPLETE_FLAG_SIZE);

        /* =>4-a.check overwrite erase complete flag */
        FEE_SET_PROC(FEE_RECOVER_OVERWRITE_ERASE_FLAG_CHECK)
    }

/* 4-a.check overwrite erase complete flag */
    if( proc == FEE_RECOVER_OVERWRITE_ERASE_FLAG_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* set disable sector to array of sector status */
            Fee_SetSectorStatus(sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_DISABLE);
            Fee_SetSectorStatusMirror(sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_DISABLE);
            /* =>5.set psc */
            proc = FEE_RECOVER_SET_PSC;
            break;

        case MEMIF_JOB_FAILED:
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* 5.set psc */
    if( proc == FEE_RECOVER_SET_PSC )
    {
        Fee_InfoDataBuffer = Fee_CalculatePSC();
        /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
        /* PRQA S 306,310,488,1840 1 */
        psc_ptr = (uint32)(FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_PSC_OFFSET);

        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite(psc_ptr, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_PSC_SIZE);

        /* => 5-a.check result of writing psc */
        FEE_SET_PROC(FEE_RECOVER_SET_PSC_CHECK)
    }

/* 5-a.check result of writing psc */
    if( proc == FEE_RECOVER_SET_PSC_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* =>6.set enable sector */
            proc = FEE_RECOVER_SET_ENABLE_SECTOR;
            break;

        case MEMIF_JOB_FAILED:
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 6.set enable sector */
    if( proc == FEE_RECOVER_SET_ENABLE_SECTOR )
    {
        retval = Fee_SetSector(sector_no, FEE_SECTOR_ENABLE);
        if( retval == FEE_OK )
        {
            /* update empty address and empty size */
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            blk_mgt_area_empty_addr_ptr = (Fee_BlockManagementInfoType*)((uint8*)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_TOP_BLOCK_OFFSET);
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic. */
            /* PRQA S 306,310,488,3395,3305 1 */
            blk_page_area_empty_addr_ptr = (uint32*)(Fee_GetFlashSectorEraseFlagAddr(sector_no));
            Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);

            retval         = FEE_OK;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else if( retval == FEE_NG )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* continue */
        }
    }

/* 7.overwrite enable sector */
    if( proc == FEE_RECOVER_OVERWRITE_ENABLESECTOR )
    {
        retval = Fee_SetSector(enable_sector_no, FEE_SECTOR_ENABLE);

        if( retval == FEE_OK )
        {
            /* =>8.set erasing sector  */
            proc = FEE_RECOVER_SET_ERASING_SECTOR;
        }
        else if( retval == FEE_NG )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* continue */
        }
    }

/* 8.set erasing sector */
    if( proc == FEE_RECOVER_SET_ERASING_SECTOR )
    {
        retval = Fee_SetSector(sector_no, FEE_SECTOR_GARBAGE);

        if( retval == FEE_OK )
        {
            sector_no = enable_sector_no;

            if( Fee_ModuleState != FEE_STAT_RECYC )
            {
                /* =>9.get and check blank area on valid flash */
                proc = FEE_RECOVER_GET_BLANK_AREA;
            }
            else
            {
                /* =>13.recycle sector start */
                proc = FEE_RECOVER_RECYCLE_START;
            }
        }
        else if( retval == FEE_NG )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* continue */
        }
    }

/* 9.get and check blank area on valid flash */
    if( proc == FEE_RECOVER_GET_BLANK_AREA )
    {
        /* get flash blank address */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        block_start_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_TOP_BLOCK_OFFSET;

        if( FEE_OFF == Fee_GetSectorBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            write_flag = Fee_FlsGetReadAddr(block_start_addr); /* check WriteFlag */

            /* For all the block patterns, the decision of recycling is implemented in Fee_CreateBlockByInit() */
            if( write_flag == FEE_NULL )
            {
                /* when this sector has no blocks, rewrite the valid status */
                /* =>10.overwrite sector status flag1 when the valid sector has no block */
                FEE_SET_PROC(FEE_RECOVER_OVERWRITE_ENABLE_STATUS)
            }
            else
            {
                /* =>11.create index for blocks */
                FEE_SET_PROC(FEE_RECOVER_CREATE_BLOCK_INDEX)
            }
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync(block_start_addr, &Fee_InfoDataBuffer, FEE_BLOCK_WRITEFLAG_SIZE);
            fee_fault = Fee_GetFlsFault();
            Fee_FlsDisableDMA();

            if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
            {
                if( Fee_InfoDataBuffer != FEE_BLOCK_FLAG_VALUE ) /* read WriteFlag */
                {
                    /* when this sector has no blocks, rewrite the valid status */
                    /* =>10.overwrite sector status flag1 when the valid sector has no block */
                    proc = FEE_RECOVER_OVERWRITE_ENABLE_STATUS;
                }
                else
                {
                    /* =>11.create index for blocks */
                    proc = FEE_RECOVER_CREATE_BLOCK_INDEX;
                }
            }
            else /* 2bit ECC error, other error */
            {
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                   Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                write_flag = Fee_FlsGetReadAddr(block_start_addr); /* check WriteFlag */

                /* For all the block patterns, the decision of recycling is implemented in Fee_CreateBlockByInit() */
                if( write_flag == FEE_NULL )
                {
                    /* when this sector has no blocks, rewrite the valid status */
                    /* =>10.overwrite sector status flag1 when the valid sector has no block */
                    FEE_SET_PROC(FEE_RECOVER_OVERWRITE_ENABLE_STATUS)
                }
                else
                {
                    /* =>13.recycle sector start */
                    proc = FEE_RECOVER_RECYCLE_START;
                }
            }
        }
    }

/* 10.overwrite sector status flag1 when the valid sector has no block */
    if( proc == FEE_RECOVER_OVERWRITE_ENABLE_STATUS )
    {
        retval = Fee_SetSector(sector_no, FEE_SECTOR_ENABLE);

        if( retval == FEE_OK )
        {
            /* =>11.create index for blocks */
            proc = FEE_RECOVER_CREATE_BLOCK_INDEX;
        }
        else if( retval == FEE_NG )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* =>X.end of periodic processing */
            proc           = FEE_RECOVER_END;
        }
        else
        {
            /* continue */
        }
    }

/* 11.create index for blocks */
    if( proc == FEE_RECOVER_CREATE_BLOCK_INDEX )
    {
        retval =  Fee_CreateBlockByInit(sector_no);

        switch(retval)
        {
        case FEE_NG:
            Fee_BlkSearchCntInInit = (uint16)FEE_ZERO; /* search finish, clear block count */
            /* If error is occurred in Fee_CreateBlockByInit(), terminate recover. */
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
            break;
        case FEE_OK:
            Fee_BlkSearchCntInInit = (uint16)FEE_ZERO; /* search finish, clear block count */
            /* Fee_RecycleFlag : create block index complete */
            /* Fee_RecycleImmediateFlag : create block index is stopped, do recycle immediately */
            /* Fee_ConfigUnmatchFlag : Case of config unmatch is found, do recycle, no matter delay recyle operation is on or off */
            if( FEE_ON == Fee_ConfigUnmatchFlag )
            {
                /*no matter delay recycle operation is on or off, do recycle */
                /* After all the indexes are created, but it needs to do recycle. */
                /* =>13.recycle sector start */
                proc = FEE_RECOVER_RECYCLE_START;
            }
            else if((Fee_RecycleFlag == FEE_ON) || (Fee_RecycleImmediateFlag == FEE_ON))
            {
                if( Fee_GetDelayRecycleOperation() == FEE_ON )
                {
                    /* delay recycle operation is on, do not recycle */
                    /* success to create index for all blocks */
                    /* =>12.Overwrite invalid flag for all invalid blocks and valid flag for the last valid block */
                    FEE_SET_PROC(FEE_RECOVER_OVERWRITE_BLOCK_FLAG)
                }
                else
                {
                    if(STD_ON == Fee_GetDefinedThresholdPageSize())
                    {
                        /* delay recycle operation is on, do not recycle */
                        /* success to create index for all blocks */
                        /* =>12.Overwrite invalid flag for all invalid blocks and valid flag for the last valid block */
                        FEE_SET_PROC(FEE_RECOVER_OVERWRITE_BLOCK_FLAG)
                    }
                    else
                    {
                        /* default : delay recycle operation is off, do recycle */
                        /* After all the indexes are created, but it needs to do recycle. */
                        /* =>13.recycle sector start */
                        proc = FEE_RECOVER_RECYCLE_START;
                    }
                }
            }
            else
            {
                /* success to create index for all blocks */
                /* =>12.Overwrite invalid flag for all invalid blocks and valid flag for the last valid block */
                FEE_SET_PROC(FEE_RECOVER_OVERWRITE_BLOCK_FLAG)
            }

            break;
        default:/* FEE_CONT */

            /* continue */
            break;
        }
    }

/* 12.Overwrite invalid flag for all invalid blocks and valid flag for the last valid block */
    if( proc == FEE_RECOVER_OVERWRITE_BLOCK_FLAG )
    {
        retval = Fee_OverWriteBlockFlag();

        if( retval == FEE_OK )
        {
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
        }
        else if( retval == FEE_NG )
        {
            retval = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
        }
        else
        {
            /* continue */
        }
    }

/* 13.recycle sector start */
    if( proc == FEE_RECOVER_RECYCLE_START )
    {
        Fee_RecycleStart(sector_no);
        /* =>14.recycle sector */
        proc = FEE_RECOVER_RECYCLE;
    }

/* 14.recycle sector */
    if( proc == FEE_RECOVER_RECYCLE )
    {
        /* recycling */
        retval = Fee_RecyclePolling();
        if( retval != FEE_CONT )
        {
            /* => 15.check result of recycling */
            FEE_SET_PROC(FEE_RECOVER_RECYCLE_CHECK)
        }
    }

/* 15.check result of recycling */
    if( proc == FEE_RECOVER_RECYCLE_CHECK )
    {
        retval = Fee_RecycleFinal();

        if( retval == FEE_OK )
        {
            retval         = FEE_OK;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
        }
        else
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
        }
    }

/* 16.configuration is changed, adjusting work flash */
    if( proc == FEE_RECOVER_ADJUSTING_WORK_FLASH )
    {
        retval = Fee_AdjustingWorkFlash(Fee_OldSectorStatusArray[2].FeeOldLogicalNumber);

        if( retval == FEE_OK )
        {
            retval         = FEE_OK;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
        }
        else if( retval == FEE_NG )
        {
            retval         = FEE_NG;
            Fee_PeriInfo.Fee_MainError = MEMIF_JOB_FAILED;
            /* => X.end of periodic processing */
            proc = FEE_RECOVER_END;
        }
        else
        {
            /* FEE_CONT */
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_RECOVER_END )
    {
        if( retval == FEE_OK )
        {
            block_cnt  = Fee_GetNoOfBlocks();
            start_addr = Fee_GetSecTopAddr();
            /* Deviation from MISRA-C:2012 Rule-12.1
              Justification: This is the necessary algrithm. */
            /* PRQA S 3395 1 */
            end_addr   = Fee_GetSecTopAddr() + Fee_GetNoOfSec() * Fee_GetSectorSize() + Fee_GetRemainSize();
            for( cnt_block_index = (uint16)0; cnt_block_index < block_cnt; cnt_block_index++ )
            {
                block_addr_index = Fee_GetBlockAddrIndex(cnt_block_index);
                if(block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK)
                {
                    if((block_addr_index.BlkAddr < start_addr) || (block_addr_index.BlkAddr > end_addr))
                    {
                        block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
                        Fee_SetBlockAddrIndex(cnt_block_index, block_addr_index);
                    }
                }
            }
        }

        proc = FEE_RECOVER_START;
    }
    else
    {
        FEE_PUSH_STACK_UCHAR(enable_sector_no)
        FEE_PUSH_STACK_UCHAR(sector_no)
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    if( proc != FEE_RECOVER_START )
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_GetSector
**
** Get sector number that is specified sector status.
**
** \param[in]  status    specified sector status
**
** \return     sector number or error information
** \retval     1-FEE_NUMBER_OF_SECTORS    sector number
** \retval     FEE_NONE_SECTOR        none sector
** \retval     FEE_INVALID_SECTOR_NO  invalid sector
**
*/
FUNC(uint8, FEE_CODE) Fee_GetSector(
  VAR(uint8, AUTOMATIC) status)
{
    VAR(uint8, AUTOMATIC) retval;             /* return value */
    VAR(uint8, AUTOMATIC) disable_sector;     /* variable for disable sector */
    VAR(uint8, AUTOMATIC) used_sector;        /* variable for not disable sector */
    VAR(uint8, AUTOMATIC) cnt;                /* loop counter */
    VAR(uint8, AUTOMATIC) sec_num;            /* sector number */

    retval         = FEE_NONE_SECTOR;
    disable_sector = (uint8)FEE_ZERO;
    used_sector    = (uint8)FEE_ZERO;

    if( status == FEE_SECTOR_DISABLE )
    {
        /* disable sector */
        sec_num = Fee_GetNoOfSec();
        for( cnt = (uint8)FEE_ZERO; cnt < sec_num; cnt++ )
        {
            if( Fee_GetSectorStatus(cnt) == FEE_SECTOR_DISABLE )
            {
                if( (cnt + FEE_SECTOR_STATUS_OFFSET) == (used_sector + (uint8)1) )
                {
                    disable_sector = cnt + FEE_SECTOR_STATUS_OFFSET;
                }
            }
            else
            {
                used_sector = cnt + FEE_SECTOR_STATUS_OFFSET;
            }
        }
        retval = disable_sector;
    }
    else if( status == FEE_SECTOR_EFFECTIVE )
    {
        /* read or recycle source */
        retval = Fee_GetSectorEffective();
    }
    else
    {
        /* excluding disable sector */
        sec_num = Fee_GetNoOfSec();
        for( cnt = (uint8)FEE_ZERO; (cnt < sec_num) && (retval == FEE_NONE_SECTOR); cnt++ )
        {
            if( Fee_GetSectorStatus(cnt) == status )
            {
                retval = cnt + FEE_SECTOR_STATUS_OFFSET;
            }
        }
    }

    return retval;
}


/** \brief Fee_GetSectorFirst
**
** If Fee_SectorStatus[] is initial value, get sector status from FEE.
** This function has divided in the first configuration and the latter configuration.
**
** \param[in]  config_no  first configuration or latter configuration.
**                        value range : 1, 2
**
** \param[in]  sector_no  get sector status from flash area one by one.
**                        value range : 1, 2, 3...
**
** \return     uint8
**             FEE_OK     sector status confirm finish
**             FEE_NG     blank check error has been encountered when sector status confirm 
**             FEE_CONT   sector status comfirm continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 3 */
FUNC(uint8, FEE_CODE) Fee_GetSectorFirst(
  VAR(uint8, AUTOMATIC) config_no,
  VAR(uint8, AUTOMATIC) sector_no)
{
    VAR(uint8, AUTOMATIC)                     retval;                        /* return value */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)       status_ptr;                    /* pointer to sector status */
    VAR(uint8, AUTOMATIC)                     status_tmp;                    /* sector status */
    VAR(uint32, AUTOMATIC)                    status_flag1;                  /* blank check for status flag */
    VAR(uint32, AUTOMATIC)                    status_flag2;                  /* blank check for status flag */
    VAR(uint32, AUTOMATIC)                    status_flag3;                  /* blank check for status flag */
    VAR(uint32, AUTOMATIC)                    block_info;                    /* blank check for block head */
    VAR(uint32, AUTOMATIC)                    erase_flag;                    /* blank check for erase flag */
    VAR(Fee_FaultType, AUTOMATIC)             fee_fault;                     /* get fault information from FLS */

    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is initialization. */
    /* PRQA S 2982 1 */
    retval = FEE_CONT;
    Fee_FlsEnableDMA();

/* 0.entry of periodic processing */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_START )
    {
        /* Deviation from MISRA-C:2004 rule 10.3, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.8
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          Casting to different type for consistency. */
        /* PRQA S 306,310,488,4391,3305 1 */
        status_ptr = (uint32*)(FEE_GET_FLASH_SECTOR_START_ADDR(sector_no)); /* get sector top address */
        Fee_SectorFirstStatusPtr1 = status_ptr; /* get flag1 address */
        status_ptr++;
        Fee_SectorFirstStatusPtr2 = status_ptr; /* get flag2 address */
        status_ptr++;
        Fee_SectorFirstStatusPtr3 = status_ptr; /* get flag3 address */
        status_ptr++;
        status_ptr++;
        status_ptr++;
        Fee_SectorFirstBlockInfoPtr = status_ptr; /* get block head address */
        /* Deviation from MISRA-C:2004 rule 10.3, 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.8, Rule-12.1
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Casting to different type for consistency.*/
        /* PRQA S 306,310,488,4391,3395,3305 1 */
        Fee_SectorFirstEraseCompleteFlagPtr = (uint32*)(Fee_GetFlashSectorEraseFlagAddr(sector_no)); /* get erase flag address */

        /* => 1.check erase complete flag */
        Fee_SectorFirstProc = FEE_SECTOR_FIRST_CHK_ERASE_FLAG;
    }
    else
    {
        /* do nothing */
    }

/* 1.check erase complete flag */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_CHK_ERASE_FLAG )
    {
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)Fee_SectorFirstEraseCompleteFlagPtr, &Fee_InfoDataBuffer, FEE_ERASE_COMPLETE_FLAG_SIZE);
        fee_fault = Fee_GetFlsFault();

        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
        }

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        erase_flag = Fee_FlsGetReadAddr((uint32)Fee_SectorFirstEraseCompleteFlagPtr);

        if( ( erase_flag != FEE_NULL ) && ( Fee_InfoDataBuffer == FEE_SECTOR_STATUS_DATA_SET ) )
        {
            /* => 2.check garbage flag */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_CHK_GARBAGE_FLAG;
        }
        else
        {
            /* unknown sector */
            status_tmp = FEE_SECTOR_UNKNOWN;

            /* => X.end of periodic processing */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_END;
        }
    }

/* 2.check garbage flag */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_CHK_GARBAGE_FLAG )
    {
        /* check flag3 */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        status_flag3 = Fee_FlsGetReadAddr((uint32)Fee_SectorFirstStatusPtr3);

        if( status_flag3 != FEE_NULL )
        {
            /* garbage sector */
            status_tmp = FEE_SECTOR_GARBAGE;

            /* => X.end of periodic processing */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_END;
        }
        else
        {
            /* => 3.check moving flag */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_CHK_MOVING_FLAG;
        }
    }

/* 3.check moving flag */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_CHK_MOVING_FLAG )
    {
        /* check flag2 */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        status_flag2 = Fee_FlsGetReadAddr((uint32)Fee_SectorFirstStatusPtr2);

        if( status_flag2 != FEE_NULL )
        {
            /* moving sector */
            status_tmp = FEE_SECTOR_MOVING;

            /* => X.end of periodic processing */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_END;
        }
        else
        {
            /* => 4.check valid flag */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_CHK_VALID_FLAG;

        }
    }

/* 4.check valid flag */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_CHK_VALID_FLAG )
    {
        /* check flag1 */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        status_flag1 = Fee_FlsGetReadAddr((uint32)Fee_SectorFirstStatusPtr1);

        if( status_flag1 != FEE_NULL )
        {
            /* valid sector */
            status_tmp = FEE_SECTOR_ENABLE;

            /* => X.end of periodic processing */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_END;
        }
        else
        {
            /* => 5.check block head information */
            Fee_SectorFirstProc = FEE_SECTOR_FIRST_CHK_BLOCK_HEAD_INFO;
        }
    }

/* 5.check block head information */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_CHK_BLOCK_HEAD_INFO )
    {
        /* check block head */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        block_info = Fee_FlsGetReadAddr((uint32)Fee_SectorFirstBlockInfoPtr);

        if( block_info != FEE_NULL )
        {
            /* unknown sector */
            status_tmp = FEE_SECTOR_UNKNOWN;
        }
        else
        {
            /* invalid sector */
            status_tmp = FEE_SECTOR_DISABLE;
        }

        /* => X.end of periodic processing */
        Fee_SectorFirstProc = FEE_SECTOR_FIRST_END;
    }

/* X.end of periodic processing  */
    if( Fee_SectorFirstProc == FEE_SECTOR_FIRST_END )
    {
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The status_tmp is only used after it is initialized by the former mainfunction. */
        /* PRQA S 2962 2 */
        Fee_SetSectorStatusElementWithCfg(config_no, sector_no - FEE_SECTOR_STATUS_OFFSET, status_tmp);
        Fee_SetSectorStatusMirrorElementWithCfg(config_no, sector_no - FEE_SECTOR_STATUS_OFFSET, status_tmp);

        Fee_SectorFirstProc = FEE_SECTOR_FIRST_START;
        if ( MEMIF_JOB_FAILED == Fee_JobResult )
        {
            /* FAULT_OTHERERROR has been encountered when blank check */
            retval = FEE_NG;
        }
        else
        {
            retval = FEE_OK;
        }
    }
    else
    {
        retval = FEE_CONT;
    }
    Fee_FlsDisableDMA();

    return retval;
}


/** \brief Fee_GetSectorEffective
**
** Get read or recycle source sector.
**
** \param      none
**
** \return     sector number or error information
** \retval     1-FEE_NUMBER_OF_SECTORS    sector number
** \retval     FEE_NONE_SECTOR        none sector
** \retval     FEE_INVALID_SECTOR_NO  invalid sector
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
static FUNC(uint8, FEE_CODE) Fee_GetSectorEffective(void)
{
    VAR(uint8, AUTOMATIC) retval;            /* return value */
    VAR(uint8, AUTOMATIC) status_tmp;        /* temporarily for sector status */
    VAR(uint8, AUTOMATIC) enable_sector;     /* temporarily for enable sector */
    VAR(uint8, AUTOMATIC) moving_sector;     /* temporarily for moving sector */
    VAR(uint8, AUTOMATIC) cnt;               /* loop counter */

    enable_sector  = FEE_NONE_SECTOR;
    moving_sector  = FEE_NONE_SECTOR;

    for( cnt = (uint8)FEE_ZERO; cnt < Fee_GetNoOfSec(); cnt++ )
    {
        status_tmp = Fee_GetSectorStatus(cnt);
        if( status_tmp == FEE_SECTOR_ENABLE )
        {
            if( enable_sector == FEE_NONE_SECTOR )
            {
                enable_sector = cnt + FEE_SECTOR_STATUS_OFFSET;
            }
            else
            {
                /* if there are two or more enable sector, return to INVALID_SECTOR_NO */
                enable_sector = FEE_INVALID_SECTOR_NO;
            }
        }
        if( status_tmp == FEE_SECTOR_MOVING )
        {
            if( moving_sector == FEE_NONE_SECTOR )
            {
                moving_sector = cnt + FEE_SECTOR_STATUS_OFFSET;
            }
            else
            {
                /* if there are two or more moving sector, return to INVALID_SECTOR_NO */
                moving_sector = FEE_INVALID_SECTOR_NO;
            }
        }
    }

    if( enable_sector == FEE_NONE_SECTOR )
    {
        if( moving_sector == FEE_NONE_SECTOR )
        {
            retval = FEE_NONE_SECTOR;
        }
        else
        {
            retval = moving_sector;
        }
    }
    else
    {
        retval = enable_sector;
    }

    return retval;
}


/** \brief Fee_SetSector
**
** Set specified status or recycle flag to sector of specified sector number.
**
** \param[in]  sector_no  sector number
** \param[in]  status     specified status or recycle flag
**
** \return     result of processing
** \retval     FEE_OK     success
** \retval     FEE_NG     failed
** \retval     FEE_CONT   continue
**
*/
FUNC(uint8, FEE_CODE) Fee_SetSector(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint8, AUTOMATIC) status)
{
    VAR(Fee_SetStatusProcType, AUTOMATIC)  proc;               /* position of the processing */
    VAR(uint8, AUTOMATIC)                  retval;             /* return value */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)     write_addr_ptr;     /* pointer to write address */
    VAR(uint8, AUTOMATIC)                  write_end_pos;      /* end position of writing */
    VAR(uint8, AUTOMATIC)                  write_pos;          /* position of writing */
    VAR(uint32, AUTOMATIC)                 check_data;         /* temporarily for recycle flag */
    VAR(uint32, AUTOMATIC)                 flag_from_flash;    /* temporary variable for storing the flag read from flash */
    VAR(uint8, AUTOMATIC)                  sector_status;      /* sector status */

    retval = FEE_OK;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SetStatusProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_SET_STATUS_START )
    {
        if( status == FEE_SECTOR_MOVING )
        {
            /* moving sector */
            /* Deviation from MISRA-C:2012 Rule-10.1
               Justification: This is the algrithm. */
            /* PRQA S 4544 1 */
            write_end_pos = (uint8)(FEE_SECTOR_ONE_STATUS_SIZE << 1);
            write_pos     = (uint8)FEE_ZERO;
        }
        else if( status == FEE_RECYCLE_FLAG )
        {
            /* set recycle flag */
            write_end_pos = (uint8)(FEE_SECTOR_STATUS_SIZE + FEE_SECTOR_RECYCLE_FLAG_SIZE);
            write_pos     = (uint8)(FEE_SECTOR_STATUS_SIZE);
        }
        else
        {
            /* enable or garbage sector */
            write_end_pos = (uint8)(FEE_SECTOR_ONE_STATUS_SIZE * ((status - FEE_SECTOR_ENABLE) + (uint8)1));
            write_pos     = (uint8)(FEE_SECTOR_ONE_STATUS_SIZE * (status - FEE_SECTOR_ENABLE ));
        }
        /* =>1.set sector status */
        proc = FEE_SET_STATUS_SET;
    }
    else
    {
        FEE_POP_STACK_UCHAR(write_pos)
        FEE_POP_STACK_UCHAR(write_end_pos)
    }

/* 1.set sector status */
    if( proc == FEE_SET_STATUS_SET )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        write_addr_ptr = FEE_GET_FLASH_SECTOR_START_ADDR(sector_no);
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
           Justification: 64bit is supported by the long long in ARM. */
        /* PRQA S 580 1 */
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_SET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,310,488 1 */
        (void)Fee_FlsWrite((uint32)(write_addr_ptr + write_pos), (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_SECTOR_ONE_STATUS_SIZE);
        if( status == FEE_RECYCLE_FLAG )
        {
            /* =>5.check result of writing recycle flag */
            FEE_SET_PROC(FEE_SET_STATUS_RECYCLE_FLAG_CHECK)
        }
        else
        {
            /* =>2.check completion of writing sector status */
            FEE_SET_PROC(FEE_SET_STATUS_SET_FINAL)
        }
    }

/* 2.check completion of writing sector status */
    if( proc == FEE_SET_STATUS_SET_FINAL )
    {
        write_pos += (uint8)FEE_SECTOR_ONE_STATUS_SIZE;
        if( write_pos >= write_end_pos )
        {
            /* =>3.check result of writing sector status  */
            FEE_SET_PROC(FEE_SET_STATUS_CHECK)
        }
        else
        {
            /* =>1.set sector status */
            FEE_SET_PROC(FEE_SET_STATUS_SET)
        }
    }

/* 3.check result of writing sector status  */
    if( proc == FEE_SET_STATUS_CHECK )
    {
        if( Fee_FlsGetJobResult() == MEMIF_JOB_OK )
        {
            Fee_SetSectorStatus(sector_no - FEE_SECTOR_STATUS_OFFSET, status);
            Fee_SetSectorStatusMirror(sector_no - FEE_SECTOR_STATUS_OFFSET, status);
            retval = FEE_OK;
            /* =>X.end of periodic processing */
            proc = FEE_SET_STATUS_END;
        }
        else
        {
            if( status == FEE_SECTOR_GARBAGE )
            {
                /* Deviation from MISRA-C:2004 rule 10.5, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.8
                   Justification: Cast between a pointer to object and an integral type.
                                  This deviation is due to doing pointer arithmetic.
                                  The result type of shift conversion must be explicit. */
                /* PRQA S 306,488,4399 1 */
                write_addr_ptr = FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + (uint32)(FEE_SECTOR_ONE_STATUS_SIZE << 1U);
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
                   Justification: Casting to different object pointer type. And this casting is safety by judgment. */
                /* PRQA S 306,310 1 */
                flag_from_flash = Fee_FlsGetReadAddr((uint32)write_addr_ptr);

                if( flag_from_flash != FEE_NULL )
                {
                    Fee_SetSectorStatus(sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_GARBAGE);
                    Fee_SetSectorStatusMirror(sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_GARBAGE);
                    retval = FEE_OK;
                }
                else
                {
                    retval = FEE_NG;
                }
                /* =>X.end of periodic processing */
                proc = FEE_SET_STATUS_END;
            }
            else
            {
                Fee_SetSectorStatus(FEE_ZERO, FEE_SECTOR_NOSTATUS);
                Fee_SetSectorStatusMirror(FEE_ZERO, FEE_SECTOR_NOSTATUS);
                /* =>4.re-check result of writing sector status */
                FEE_SET_PROC(FEE_SET_STATUS_RECHECK)
            }
        }
    }

/* 5.check result of writing recycle flag */
    if( proc == FEE_SET_STATUS_RECYCLE_FLAG_CHECK )
    {
        if( Fee_FlsGetJobResult() == MEMIF_JOB_OK )
        {
            retval = FEE_OK;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            write_addr_ptr = FEE_GET_FLASH_SECTOR_START_ADDR(sector_no);
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,310,488 1 */
            check_data = Fee_FlsGetReadAddr((uint32)(write_addr_ptr + write_pos));

            if( check_data != FEE_NULL )
            {
                retval = FEE_OK;
            }
            else
            {
                retval = FEE_NG;
            }
        }
        /* =>X.end of periodic processing */
        proc = FEE_SET_STATUS_END;
    }

/* 4.re-check result of writing sector status */
    if( proc == FEE_SET_STATUS_RECHECK )
    {
        sector_status = Fee_GetSectorStatus(sector_no - FEE_SECTOR_STATUS_OFFSET);
        if( sector_status == status )
        {
            retval = FEE_OK;
        }
        else
        {
            retval = FEE_NG;
        }
        proc = FEE_SET_STATUS_END;
    }

/* X.end of periodic processing */
    if( proc == FEE_SET_STATUS_END )
    {
        /* =>0.entry of periodic processing */
        proc = FEE_SET_STATUS_START;
    }
    else
    {
        FEE_PUSH_STACK_UCHAR(write_end_pos)
        FEE_PUSH_STACK_UCHAR(write_pos)
    }

    FEE_PUSH_PROC(proc)

    if( proc != FEE_SET_STATUS_START )
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_Erase
**
** Erase garbage sector and odd sector.
**
** \return     result of erase
** \retval     FEE_OK    success
** \retval     FEE_NG    failed
** \retval     FEE_CONT  continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
FUNC(uint8, FEE_CODE) Fee_Erase(void)
{
    VAR(Fee_EraseProcType, AUTOMATIC)  proc;          /* position of the processing */
    VAR(uint8, AUTOMATIC)              retval;        /* return value */
    VAR(uint8, AUTOMATIC)              target_status; /* target status */

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_EraseProcType)

    if( proc == FEE_ERASE_START )
    {
        target_status = FEE_SECTOR_GARBAGE;   /* erase garbage sector */
    }
    else
    {
        FEE_POP_STACK_UCHAR(target_status)
    }

    /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
       Justification: Casting to different object pointer type. And this casting is safety by judgment. */
    /* PRQA S 310 1 */
    retval = Fee_EraseProc(target_status, (uint8*)&proc);

    if( retval == FEE_OK )
    {
        if( target_status == FEE_SECTOR_GARBAGE )
        {
            target_status = FEE_SECTOR_UNKNOWN; /* erase odd sector */
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
               Justification: Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 310 1 */
            retval = Fee_EraseProc(target_status, (uint8*)&proc);
        }
    }

    if( retval == FEE_CONT )
    {
        FEE_PUSH_STACK_UCHAR(target_status)
    }

    FEE_PUSH_PROC(proc)

    return retval;
}


/** \brief Fee_EraseProc
**
** Erase the specified sector.
**
** \param[in]     target_status  specified status
** \param[in,out] now_proc       position of the processing
**
** \return     result of operation
** \retval     FEE_OK    success
** \retval     FEE_NG    failed
** \retval     FEE_CONT  continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 3 */
static FUNC(uint8, FEE_CODE) Fee_EraseProc(
  VAR(uint8, AUTOMATIC) target_status,
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) now_proc_ptr)
{
    VAR(Fee_EraseProcType, AUTOMATIC)    proc;            /* position of the processing */
    VAR(uint8, AUTOMATIC)                retval;          /* return value */
    VAR(uint8, AUTOMATIC)                sector_no;       /* sector nomber */
    VAR(uint8, AUTOMATIC)                erase_result;    /* result of erase one sector */

    retval       = FEE_OK;
    sector_no    = FEE_NONE_SECTOR;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    proc = (Fee_EraseProcType)*now_proc_ptr;

/* 0.entry of periodic processing */
    if( proc == FEE_ERASE_START )
    {
        /* => 1.search erase sector */
        proc = FEE_ERASE_GET_ERASE_SECTOR;
    }
    else
    {
        FEE_POP_STACK_UCHAR(sector_no)     /* pop sector number */
    }

/* 1.search erase sector */
    if( proc == FEE_ERASE_GET_ERASE_SECTOR )
    {
        sector_no = Fee_GetSector(target_status);    /* get sector number from specified sector status */

        if( sector_no == FEE_NONE_SECTOR )
        {
            /* => X.end of periodic processing */
            retval = FEE_OK;
            proc = FEE_ERASE_END;
        }
        else
        {
            /* => 2.erase sector */
            FEE_SET_PROC(FEE_ERASE_ERASE_SECTOR)
        }
    }

/* 2.erase sector */
    if( proc == FEE_ERASE_ERASE_SECTOR )
    {
        erase_result = Fee_EraseSector(sector_no);

        switch(erase_result)
        {
        case FEE_OK:
            /* get next sector to erase */
            /* => 1.search erase sector */
            proc = FEE_ERASE_GET_ERASE_SECTOR;
            break;

        case FEE_NG:
            /* => X.end of periodic processing */
            proc = FEE_ERASE_END;
            retval = FEE_NG;
            break;

        default: /* FEE_CONT */
            /* do nothing */
            break;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_ERASE_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_ERASE_START;
    }
    else
    {
        retval = FEE_CONT;
        FEE_PUSH_STACK_UCHAR(sector_no)     /* evacuate sector number */
    }

    *now_proc_ptr = (uint8)proc;    /* set position of the processing to pointer */

    return retval;
}


/** \brief Fee_WriteEraseCompleteFlag
**
** Write erase completed flag.
**
** \return     result of writing
** \retval     FEE_OK    success
** \retval     FEE_NG    failed
** \retval     FEE_CONT  continue
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-2.1, Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1503,1505 1 */
FUNC(uint8, FEE_CODE) Fee_WriteEraseCompleteFlag(void)
{
    VAR(Fee_WriteFlagProcType, AUTOMATIC)    proc;            /* position of the processing */
    VAR(uint8, AUTOMATIC)                    cnt_sector;      /* loop counter */
    VAR(MemIf_JobResultType, AUTOMATIC)      retjob;          /* result of fls job */
    VAR(uint8, AUTOMATIC)                    retval;          /* return value */

    cnt_sector = (uint8)FEE_ZERO;
    retval     = FEE_CONT;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_WriteFlagProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_WRITE_FLAG_START )
    {
        /* => 1.write flag */
        proc = FEE_WRITE_FLAG_WRITE;
    }
    else
    {
        FEE_POP_STACK_UCHAR(cnt_sector)
    }

/* 1.write flag */
    if( proc == FEE_WRITE_FLAG_WRITE )
    {
        if( cnt_sector < Fee_GetNoOfSec() )
        {
            /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
               Justification: 64bit is supported by the long long in ARM. */
            /* PRQA S 580 1 */
            Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_SET;
            /* Deviation from MISRA-C:2004 rule 10.3, 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.8, Rule-12.1
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              Casting to different type for consistency. */
            /* PRQA S 306,310,488,4391,3395 1 */
            (void)Fee_FlsWrite((uint32)(Fee_GetFlashSectorEraseFlagAddr(cnt_sector + (uint8)1)), (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_ERASE_COMPLETE_FLAG_SIZE);

            /* => 2.check result of writing erase complete flag */
            FEE_SET_PROC(FEE_WRITE_FLAG_CHECK)
        }
        else
        {
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_WRITE_FLAG_END;
        }
    }

/* 2.check result of writing erase complete flag */
    if( proc == FEE_WRITE_FLAG_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* set disable sector to array of sector status */
            Fee_SetSectorStatus(cnt_sector, FEE_SECTOR_DISABLE);
            Fee_SetSectorStatusMirror(cnt_sector, FEE_SECTOR_DISABLE);
            cnt_sector++;
            /* => 1.write flag */
            proc = FEE_WRITE_FLAG_WRITE;
            break;

        case MEMIF_JOB_FAILED:
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_WRITE_FLAG_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_WRITE_FLAG_END )
    {
        /* => 0.entry of periodic processing */
        FEE_PUSH_PROC(FEE_WRITE_FLAG_START)
    }
    else
    {
        FEE_PUSH_PROC(proc)
        FEE_PUSH_STACK_UCHAR(cnt_sector)
    }

    return retval;
}

/** \brief Fee_CreateBlockByInit
**
** In intialization, create index for blocks and pick out recycle cases
**
** \param[in]     sector_no  sector number
**
** \return     result
** \retval     FEE_OK                   Search has reached the blank area and no error during search
** \retval     FEE_NG                   Error occour during search
** \retval     FEE_CONT                 continue
**
*/
static FUNC(uint8, FEE_CODE) Fee_CreateBlockByInit(
  VAR(uint8, AUTOMATIC) sector_no)
{
    VAR(Fee_SearchCreateBlockProcType, AUTOMATIC)                   proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                           retval;                       /* return value */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)        now_block_ptr;                /* pointer to current block */
    VAR(uint16, AUTOMATIC)                                          used_reserve_size;            /* size counter of used reserve space for calculating Fee_ImmDataReserveSize */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)        blk_mgt_area_empty_addr_ptr;  /* pointer to empty address for block management area */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC )                            blk_page_area_empty_addr_ptr; /* pointer to empty address for page area */
    VAR(uint16, AUTOMATIC)                                          blk_empty_size;               /* empty size */
    VAR(uint32, AUTOMATIC)                                          write_flag;                   /* write flag */
    VAR(uint32, AUTOMATIC)                                          pageid_blkno;                 /* check pageid and block no */
    VAR(uint32, AUTOMATIC)                                          valid_status;                 /* check valid status */
    VAR(uint32, AUTOMATIC)                                          invalid_status;               /* check invalid status */
    VAR(uint32, AUTOMATIC)                                          block_start_addr;             /* start address of block mgt area */
    VAR(MemIf_JobResultType, AUTOMATIC)                             retjob;                       /* result of fls job */
    VAR(uint16, AUTOMATIC)                                          page_no_current;              /* current page number */
    VAR(Fee_ConfigType, AUTOMATIC)                                  fee_cfg;                      /* fee configuration */
    VAR(uint8, AUTOMATIC)                                           temp_proc;                    /* temp proc for calling Fee_InitSearchBlockindexUpdate */
    VAR(uint8, AUTOMATIC)                                           valid_or_not;                 /* parameter for calling Fee_InitSearchBlockindexUpdate */
    VAR(uint8, AUTOMATIC)                                           blankcheck_or_not;            /* parameter for calling Fee_InitSearchBlockindexUpdate */
    VAR(Fee_FaultType, AUTOMATIC)                                   fee_fault;                    /* get fault information from FLS */

    retval              = FEE_CONT;
    fee_cfg             = Fee_GetCfg();

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SearchCreateBlockProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_SEARCH_CREATE_START )
    {
        used_reserve_size   = (uint16)FEE_ZERO;
        page_no_current     = (uint16)FEE_ZERO;

        Fee_PeriInfo.Fee_MainError = MEMIF_JOB_OK;
        /* get flash blank address */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        block_start_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no) + FEE_TOP_BLOCK_OFFSET;

        /* set search position */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        now_block_ptr = (Fee_BlockManagementInfoType*)block_start_addr;
        /* =>1.search nonintegrated block */
        proc = FEE_SEARCH_CREATE_ACTION;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(now_block_ptr, Fee_BlockManagementInfoType)
        FEE_POP_STACK_USHORT(used_reserve_size)
        FEE_POP_STACK_USHORT(page_no_current)
        FEE_POP_STACK_UCHAR(valid_or_not)
        FEE_POP_STACK_UCHAR(blankcheck_or_not)
        FEE_POP_STACK_UCHAR(temp_proc)
    }

/* 1.search nonintegrated block */
    if( proc == FEE_SEARCH_CREATE_ACTION )
    {
        Fee_InfoDataBufferArray[0] = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_InfoDataBufferArray[1] = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        /* ReadOperation */
        Fee_FlsEnableDMA();
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, &Fee_InfoDataBufferArray[0], FEE_BLOCK_STATUS_SIZE); /* read InvalidStat */
        fee_fault = Fee_GetFlsFault();
        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            Fee_InfoDataBufferArray[0] = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        }

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE, &Fee_InfoDataBufferArray[1], FEE_BLOCK_STATUS_SIZE); /* read ValidStat */
        fee_fault = Fee_GetFlsFault();
        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            Fee_InfoDataBufferArray[1] = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        }
        Fee_FlsDisableDMA();

        if( Fee_InfoDataBufferArray[0] == FEE_BLOCK_INVALID_BLOCK ) /* read InvalidStat */
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                write_flag     = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */

                if( write_flag == FEE_NULL )
                {
                    /* One impossible case will be in here:                                 */
                    /************************************************************************/
                    /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
                    /*   Blank             XXXX             Not Blank           XXXX        */
                    /************************************************************************/

                    /* corrupt block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_CORRUPT_BLOCK;
                    /* Because we need to consider it as the max block virtually, so cannot do the real blank check in future. */
                    blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
                else
                {
                    /* invalid block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_INVALID_BLOCK;
                    blankcheck_or_not = FEE_BLANK_CHECK_UNDO;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
            }
            else
            {
                /* invalid block */
                /* Deviation from MISRA-C:2012 Rule-10.3
                Justification: The two variables have the same range. */
                /* PRQA S 4424 1*/
                temp_proc = FEE_SEARCH_CREATE_ACTION;
                valid_or_not = FEE_BLKIDX_INVALID_BLOCK;
                blankcheck_or_not = FEE_BLANK_CHECK_UNDO;
                /* => 2.search block index and update */
                proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
            }
        }
        else if( Fee_InfoDataBufferArray[1] == FEE_BLOCK_VALID_BLOCK ) /* read ValidStat */
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                write_flag     = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */

                if( write_flag == FEE_NULL )
                {
                    /* One impossible case will be in here:                                 */
                    /************************************************************************/
                    /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
                    /*   Blank             XXXX             Blank               Not Blank   */
                    /************************************************************************/

                    /* corrupt block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_CORRUPT_BLOCK;
                    /* Because we need to consider it as the max block virtually, so cannot do the real blank check in future. */
                    blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
                else
                {
                    /* valid block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_VALID_BLOCK;
                    blankcheck_or_not = FEE_BLANK_CHECK_UNDO;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
            }
            else
            {
                /* valid block */
                /* Deviation from MISRA-C:2012 Rule-10.3
                Justification: The two variables have the same range. */
                /* PRQA S 4424 1*/
                temp_proc = FEE_SEARCH_CREATE_ACTION;
                valid_or_not = FEE_BLKIDX_VALID_BLOCK;
                blankcheck_or_not = FEE_BLANK_CHECK_UNDO;
                /* => 2.search block index and update */
                proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
            }
        }
        else
        {
            /* => 1-a.blank check */
            proc = FEE_SEARCH_CREATE_BLANK_CHECK;
        }
    }

/* 1-a.blank check */
    if( proc == FEE_SEARCH_CREATE_BLANK_CHECK )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        invalid_status = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

        if( invalid_status != FEE_NULL )
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                write_flag     = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */

                if( write_flag == FEE_NULL )
                {
                    /* One impossible case will be in here:                                 */
                    /************************************************************************/
                    /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
                    /*   Blank             XXXX             Not Blank           XXXX        */
                    /************************************************************************/

                    /* corrupt block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_CORRUPT_BLOCK;
                    blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
                else
                {
                    /* invalid block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_INVALID_BLOCK;
                    blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
            }
            else
            {
                /* invalid block */
                /* Deviation from MISRA-C:2012 Rule-10.3
                Justification: The two variables have the same range. */
                /* PRQA S 4424 1*/
                temp_proc = FEE_SEARCH_CREATE_ACTION;
                valid_or_not = FEE_BLKIDX_INVALID_BLOCK;
                blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                /* => 2.search block index and update */
                proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
            }
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            valid_status   = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */

            if( valid_status != FEE_NULL )
            {
                if(STD_ON == Fee_GetDefinedThresholdPageSize())
                {
                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                    Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 1 */
                    write_flag     = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */

                    if( write_flag == FEE_NULL )
                    {
                        /* One impossible case will be in here:                                 */
                        /************************************************************************/
                        /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
                        /*   Blank             XXXX             Blank               Not Blank   */
                        /************************************************************************/

                        /* corrupt block */
                        /* Deviation from MISRA-C:2012 Rule-10.3
                        Justification: The two variables have the same range. */
                        /* PRQA S 4424 1*/
                        temp_proc = FEE_SEARCH_CREATE_ACTION;
                        valid_or_not = FEE_BLKIDX_CORRUPT_BLOCK;
                        blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                        /* => 2.search block index and update */
                        proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                    }
                    else
                    {
                        /* valid block */
                        /* Deviation from MISRA-C:2012 Rule-10.3
                        Justification: The two variables have the same range. */
                        /* PRQA S 4424 1*/
                        temp_proc = FEE_SEARCH_CREATE_ACTION;
                        valid_or_not = FEE_BLKIDX_VALID_BLOCK;
                        blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                        /* => 2.search block index and update */
                        proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                    }
                }
                else
                {
                    /* valid block */
                    /* Deviation from MISRA-C:2012 Rule-10.3
                    Justification: The two variables have the same range. */
                    /* PRQA S 4424 1*/
                    temp_proc = FEE_SEARCH_CREATE_ACTION;
                    valid_or_not = FEE_BLKIDX_VALID_BLOCK;
                    blankcheck_or_not = FEE_BLANK_CHECK_DONE;
                    /* => 2.search block index and update */
                    proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
                }
            }
            else
            {
                /* => 4.check empty area */
                FEE_SET_PROC(FEE_SEARCH_CREATE_CHECK_EMPTY_AREA)
            }
        }
    }
    
/* 2.search block index and update */
    if( proc == FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD )
    {
        /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
           Justification: Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          This cast is needed for handling with 32-bit type address. */
        /* PRQA S 310,488,3305 1 */
        retval = Fee_InitSearchBlockindexUpdate(&now_block_ptr,&page_no_current,&used_reserve_size,(Fee_SearchCreateBlockProcType*)&temp_proc,valid_or_not,blankcheck_or_not);

        switch(retval)
        {
        case FEE_OK:
            /* Deviation from MISRA-C:2012 Rule-10.5
               Justification: This is stack pop/push. It is necessary. */
            /* PRQA S 4342 1 */
            proc = (Fee_SearchCreateBlockProcType)temp_proc;
            break;
        case FEE_NG:
            /* HARDWARE_ERROR is reported in Fee_MainInit */
            /* retval is FEE_NG */
            /* => X.end of periodic processing */
            proc = FEE_SEARCH_CREATE_END;
            break;
        default: /* FEE_CONT */
            /* continue */
            break;
        }
    }

/* 3.write invalid flag */
    if( proc == FEE_SEARCH_CREATE_WRITE_INVALID_FLAG )
    {
        Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;
        /* invalid block */
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */
        /* => 3-a.check result of invalid write flag */
        FEE_SET_PROC(FEE_SEARCH_CREATE_WRITE_INVALID_FLAG_CHECK)
    }

/* 3-a.check result of write invalid flag */
    if( proc == FEE_SEARCH_CREATE_WRITE_INVALID_FLAG_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* get next search position */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            now_block_ptr        = (Fee_BlockManagementInfoType*)((uint8*)now_block_ptr + FEE_BLOCK_MANAGE_SIZE);

            /* => 1.search nonintegrated block */
            FEE_SET_PROC(FEE_SEARCH_CREATE_ACTION)

            retval = FEE_CONT;

            break;

        case MEMIF_JOB_FAILED:
            /* HARDWARE_ERROR is reported in Fee_MainInit */
            retval = FEE_NG;
            proc = FEE_SEARCH_CREATE_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            retval = FEE_CONT;
            break;
        }
    }

/* 4.check empty area */
    if( proc == FEE_SEARCH_CREATE_CHECK_EMPTY_AREA )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        write_flag     = Fee_FlsGetReadAddr((uint32)now_block_ptr); /* check WriteFlag */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        pageid_blkno   = Fee_FlsGetReadAddr((uint32)now_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE); /* check BNumAndPNum */

        if(( write_flag == FEE_NULL ) && ( pageid_blkno == FEE_NULL ))
        {
            /* One case will be in here:                                            */
            /************************************************************************/
            /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
            /*       Blank             Blank         Blank               Blank      */
            /************************************************************************/
            
            /* search end */
            /* no block to search */
            /* If block number is initial value, search completion */
            /* update empty address and empty size */
            blk_mgt_area_empty_addr_ptr = now_block_ptr;
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
                Justification: Cast between a pointer to object and an integral type.
                                Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic.
                                This deviation is due to an integer type cast to do pointer arithmetic. */
            /* PRQA S 306,310,488,3395,3305 1 */
            blk_page_area_empty_addr_ptr = (uint32*)((Fee_GetFlashSectorEraseFlagAddr(sector_no)) - (page_no_current * fee_cfg.FeeVirtualPageSize));
            Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);
            /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
               Justification: This implementation is adopted for avoiding more nesting.
               It is no problem because side effects cannot be caused. */
            /* PRQA S 3415 2 */
            if(( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_INITIALIZING) == FEE_MAIN_STATE_INITIALIZING )
                && ( STD_OFF == Fee_GetDefinedThresholdPageSize() ))
            {
                /* calculate immediate date reserve size */
                Fee_ImmDataReserveSize[Fee_CurrentConfigNo - (uint8)1] -= used_reserve_size;
            }
            retval = FEE_OK;
            proc = FEE_SEARCH_CREATE_END;
        }
        else if(( write_flag != FEE_NULL ) && ( pageid_blkno != FEE_NULL ))
        {
            /* One case will be in here:                                            */
            /************************************************************************/
            /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
            /*   Not Blank         Not Blank         Blank               Blank      */
            /************************************************************************/

            /* corrupt block */
            /* Deviation from MISRA-C:2012 Rule-10.3
                Justification: The two variables have the same range. */
            /* PRQA S 4424 1*/
            temp_proc = FEE_SEARCH_CREATE_ACTION;
            valid_or_not = FEE_BLKIDX_CORRUPT_BLOCK;
            blankcheck_or_not = FEE_BLANK_CHECK_UNDO;
            /* => 2.search block index and update */
            proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
        }
        else
        {
            /* Two cases will be in here:                                           */
            /************************************************************************/
            /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
            /*       Blank           NOT Blank         Blank               Blank    */
            /*     NOT Blank           Blank           Blank               Blank    */
            /************************************************************************/
            /* If do not recycle, treat here as empty area, then do write directly, */
            /* the write operation will always fail.                                */

            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                /* Deviation from MISRA-C:2012 Rule-10.3
                Justification: The two variables have the same range. */
                /* PRQA S 4424 1*/
                temp_proc = FEE_SEARCH_CREATE_ACTION;
                valid_or_not = FEE_BLKIDX_CORRUPT_BLOCK;
                blankcheck_or_not = FEE_BLANK_CHECK_UNDO;
                /* => 2.search block index and update */
                proc = FEE_SEARCH_CREATE_INIT_SEARCH_BINKUPD;
            }
            else
            {
                /* corrupt block is found */
                Fee_RecycleFlag = FEE_ON;

                /* get next search position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                now_block_ptr = (Fee_BlockManagementInfoType*)((uint8*)now_block_ptr + FEE_BLOCK_MANAGE_SIZE);

                proc = FEE_SEARCH_CREATE_ACTION;
            }
        }
    }

/* x.end of periodic processing */
    if( proc == FEE_SEARCH_CREATE_END )
    {
        FEE_PUSH_PROC(FEE_SEARCH_CREATE_START)
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The variables are only used after they are initialized by the former mainfunction. */
        /* PRQA S 2962 3*/
        FEE_PUSH_STACK_UCHAR(temp_proc)
        FEE_PUSH_STACK_UCHAR(blankcheck_or_not)
        FEE_PUSH_STACK_UCHAR(valid_or_not)
        FEE_PUSH_STACK_USHORT(page_no_current)
        FEE_PUSH_STACK_USHORT(used_reserve_size)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(now_block_ptr)
        FEE_PUSH_PROC(proc)

        retval = FEE_CONT;
    }

    return retval;
}

/** \brief Fee_OverWriteBlockFlag
**
** Write valid or invalid flag for all valid / invalid blocks
**
**
** \return     result
** \retval     FEE_OK                   All flags has been written
** \retval     FEE_NG                   Write error during write
** \retval     FEE_CONT                 continue
**
*/
static FUNC(uint8, FEE_CODE) Fee_OverWriteBlockFlag(void)
{
    VAR(Fee_OverwriteBlockFlagProcType, AUTOMATIC)              proc;                                /* position of the processing */
    VAR(uint8, AUTOMATIC)                                       retval;                              /* return value */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                      block_addr_index;                    /* index of blocks */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)    block_ptr;                           /* pointer to block mgt area */
    VAR(MemIf_JobResultType, AUTOMATIC)                         retjob;                              /* result of fls job */
    VAR(uint16, AUTOMATIC)                                      no_of_blocks;                        /* Number of defined blocks */
    VAR(uint16, AUTOMATIC)                                      cnt_of_blk_index;                    /* operation process of all blocks */
    VAR(uint32, AUTOMATIC)                                      block_addr_index_temp_valid_block;   /* index addr to valid block */
    VAR(uint8, AUTOMATIC)                                       find_flag;                           /* find_flag */
    VAR(uint8, AUTOMATIC)                                       cnt_max;                             /* max count for searching */
    VAR(uint32, AUTOMATIC)                                      invalid_status;                      /* check invalid status */
    VAR(uint32, AUTOMATIC)                                      valid_status;                        /* check valid status */

    retval                       = FEE_CONT;
    cnt_of_blk_index             = (uint16)FEE_ZERO;
    block_addr_index_temp_valid_block  = (uint32)FEE_ZERO;
    find_flag                    = FEE_FALSE;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_OverwriteBlockFlagProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_OVERWRITE_BLOCK_FLAG_START )
    {
        /* =>write flag */
        proc = FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG;
    }
    else
    {
        FEE_POP_STACK_USHORT(cnt_of_blk_index)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_POP_STACK_ULONG(block_addr_index_temp_valid_block)
    }

/* 1.write invalid flag */
    if( proc == FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG )
    {
        cnt_max = (uint8)0;
        no_of_blocks = Fee_GetNoOfBlocks();
        while( (cnt_of_blk_index < no_of_blocks) && (find_flag == FEE_FALSE) && (cnt_max < FEE_OVERWRITE_BLOCK_FLAG_MAX) )
        {
            if( FEE_ON == Fee_GetBlockBlankCheckOff() )
            {
                /* get a valid or invalid block to overwrite */
                block_addr_index = Fee_GetBlockAddrIndex(cnt_of_blk_index);
                
                /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
                   Justification: This implementation is adopted for avoiding more nesting.
                   It is no problem because side effects cannot be caused. */
                /* PRQA S 3415 2 */
                if((block_addr_index.BlkBlankCheck == FEE_BLANK_CHECK_UNDO) && 
                   ((block_addr_index.BlkStatus == FEE_BLKIDX_INVALID_BLOCK) || (block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK))
                  )
                {
                    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                       Justification: Cast between a pointer to object and an integral type. */
                    /* PRQA S 306 2 */
                    invalid_status = Fee_FlsGetReadAddr((uint32)block_addr_index.BlkAddr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */
                    valid_status = Fee_FlsGetReadAddr((uint32)block_addr_index.BlkAddr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */

                    if(( invalid_status != FEE_NULL ) && ( valid_status != FEE_NULL ))
                    {
                        block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
                    }
                    else if(( invalid_status == FEE_NULL ) && ( valid_status != FEE_NULL ))
                    {
                        block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;
                    }
                    else
                    {
                        block_addr_index.BlkStatus = FEE_BLKIDX_NEED_REFRESH;
                    }
                    block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                    Fee_SetBlockAddrIndex(cnt_of_blk_index,block_addr_index);
                }
            }

            /* get a valid or invalid block to overwrite */
            block_addr_index = Fee_GetBlockAddrIndex(cnt_of_blk_index);
            if((block_addr_index.BlkStatus == FEE_BLKIDX_INVALID_BLOCK) && (block_addr_index.BlkBlankCheck == FEE_BLANK_CHECK_DONE))
            {
                Fee_InfoDataBuffer           = FEE_BLOCK_FLAG_VALUE;
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                   Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306,488 1 */
                block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);
                /* invalid block */
                /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
                   Justification: Cast between a pointer to object and an integral type.
                                  Casting to different object pointer type. And this casting is safety by judgment. */
                /* PRQA S 306,310 1 */
                (void)Fee_FlsWrite((uint32)block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */
                /* => 2.check result of invalid write flag */
                FEE_SET_PROC(FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG_CHECK)
                find_flag = FEE_TRUE;
            }
            else if((block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK) && (block_addr_index.BlkBlankCheck == FEE_BLANK_CHECK_DONE))
            {
                if( block_addr_index_temp_valid_block < block_addr_index.BlkAddr )
                {
                    block_addr_index_temp_valid_block = block_addr_index.BlkAddr;
                }
            }
            else
            {
                /* do nothing when the index status is not valid or invalid */
            }

            cnt_of_blk_index++;
            cnt_max++;
        }

        if( (find_flag == FEE_FALSE) && ( cnt_of_blk_index == no_of_blocks ) )
        {
            if( block_addr_index_temp_valid_block != (uint32)FEE_ZERO )
            {
                /* => 3.write the lasted valid flag */
                proc = FEE_OVERWRITE_BLOCK_FLAG_WRITE_LAST_VALID;
            }
            else
            {
                /* there is no valid block, return directly */
                retval = FEE_OK;
                /* => X.end of periodic processing */
                proc = FEE_OVERWRITE_BLOCK_FLAG_END;
            }
        }

    }


/* 2.check result of write invalid flag */
    if( proc == FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* continue to write invalid blocks flag */
            /* 1.write invalid flag */
            FEE_SET_PROC(FEE_OVERWRITE_BLOCK_FLAG_WRITE_INVALID_FLAG)
            break;

        case MEMIF_JOB_FAILED:
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_OVERWRITE_BLOCK_FLAG_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 3.write the lasted valid flag */
    if( proc == FEE_OVERWRITE_BLOCK_FLAG_WRITE_LAST_VALID )
    {
        Fee_InfoDataBuffer           = FEE_BLOCK_FLAG_VALUE;
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index_temp_valid_block);
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write ValidStat */
        /* 4.check result of valid write flag */
        FEE_SET_PROC(FEE_OVERWRITE_BLOCK_FLAG_WRITE_LAST_VALID_CHECK)
    }
    
/* 4.check result of valid write flag */
    if( proc == FEE_OVERWRITE_BLOCK_FLAG_WRITE_LAST_VALID_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* write finish */
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_OVERWRITE_BLOCK_FLAG_END;
            break;

        case MEMIF_JOB_FAILED:
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_OVERWRITE_BLOCK_FLAG_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }
/* X.end of periodic processing  */
    if( proc == FEE_OVERWRITE_BLOCK_FLAG_END )
    {
        proc = FEE_OVERWRITE_BLOCK_FLAG_START;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_PUSH_STACK_ULONG(block_addr_index_temp_valid_block)
        FEE_PUSH_STACK_USHORT(cnt_of_blk_index)
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    return retval;
}


/** \brief Fee_ResetBlockIndex
**
** Reset address index of blocks
**
** \param      none
**
** \return     none
**
*/
FUNC(void, FEE_CODE) Fee_ResetBlockIndex(void)
{
    VAR(uint16, AUTOMATIC)                         no_of_blocks;                 /* Number of defined blocks */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)         block_addr_index;             /* index of blocks */
    VAR(uint16, AUTOMATIC)                         cnt;                          /* loop counter */

    no_of_blocks                   = Fee_GetNoOfBlocks();
    block_addr_index.BlkAddr       = (uint32)FEE_BLKIDX_NEED_REFRESH;
    block_addr_index.BlkStatus     = FEE_BLKIDX_NEED_REFRESH;
    block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_UNDO;
    for( cnt = (uint16)FEE_ZERO; cnt < no_of_blocks; cnt++ )
    {
        Fee_SetBlockAddrIndex(cnt, block_addr_index);
        Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, cnt, FEE_NEXT_BLOCK_IS_NOT_CORRUPT);
    }

    return;
}


/** \brief Fee_SearchValidBlock
**
** Use index to search valid block during recycle.
**
** \param[inout]     src_ptr            search position
**
** \return     result
** \retval     FEE_OK(0)                       block has been found
** \retval     FEE_NG(1)                       blank check failed
** \retval     FEE_BLOCK_NONE_SEARCH(3)        block search complete
** \retval     FEE_CONT(255)                   continue
**
*/
static FUNC(uint8, FEE_CODE) Fee_SearchValidBlock(
  P2VAR(Fee_BlockManagementInfoType*, AUTOMATIC, FEE_APPL_DATA) src_ptr)
{
    VAR(Fee_SearchValidProcType, AUTOMATIC)                    proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                      retval;                       /* return value */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                     block_addr_index;             /* index of blocks */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)   block_mng_area_ptr;           /* pointer to block management area */
    VAR(uint8, AUTOMATIC)                                      blank_check_flag;             /* current block is blank checked or not */

    retval             = FEE_CONT;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SearchValidProcType)
    
/* 0.entry of periodic processing */
    if( proc == FEE_SEARCH_VALID_START )
    {
        /* =>1.search valid block */
        proc = FEE_SEARCH_VALID_ACTION;
    }
    else
    {
        /* do nothing */
    }

/* 1.search valid block */
    if( proc == FEE_SEARCH_VALID_ACTION )
    {
        if( Fee_BlkIdxSearchBlkInRecycle >= Fee_GetNoOfBlocks())
        {
            Fee_BlkIdxSearchBlkInRecycle = (uint16)FEE_ZERO;
            /* block search complete */
            retval = FEE_BLOCK_NONE_SEARCH;
        }
        else
        {
            blank_check_flag = FEE_BLANK_CHECK_DONE;
            /* repeat until reaching the maximum frequency. */
            /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
               Justification: This implementation is adopted for avoiding more nesting.
               It is no problem because side effects cannot be caused. */
            /* PRQA S 3415 1 */
            while( (retval == FEE_CONT) && (blank_check_flag == FEE_BLANK_CHECK_DONE) && (Fee_BlkIdxSearchBlkInRecycle < Fee_GetNoOfBlocks()) )
            {
                block_addr_index = Fee_GetBlockAddrIndex(Fee_BlkIdxSearchBlkInRecycle);
                if( FEE_BLANK_CHECK_UNDO == block_addr_index.BlkBlankCheck )
                {
                    blank_check_flag = FEE_BLANK_CHECK_UNDO;
                    block_addr_index = Fee_BlockBlankCheck(Fee_BlkIdxSearchBlkInRecycle, FEE_RESTORE_INDEX_NO);

                }

                if ( ( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )||( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE ) )
                {
                    /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
                       Justification: Cast between a pointer to object and an integral type.
                                      Casting to different object pointer type. And this casting is safety by judgment.
                                      This deviation is due to doing pointer arithmetic
                                      This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
                    /* PRQA S 306,310,488,1840 1 */
                    block_mng_area_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);

                    /* this block is a valid block */
                    /* set Write Flag */
                    Fee_BlkMgtInfoBuffer.WriteFlag       = FEE_BLOCK_INITIAL_WRITEFLAG;
                    /* set block number */
                    /* Deviation from MISRA-C:2012 Rule-10.4
                       Justification: The formula has been tested. */
                    /* PRQA S 1860 1 */
                    Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = Fee_ConfigInfo[Fee_CurrentConfigNo - 1].Fee_BlkCfgPtr[Fee_BlkIdxSearchBlkInRecycle].FeeBlockNumber;
                    /* set Valid Block status */
                    Fee_BlkMgtInfoBuffer.ValidStat       = FEE_BLOCK_VALID_BLOCK;

                    retval = FEE_OK;

                    *src_ptr = block_mng_area_ptr;
                }

                Fee_BlkIdxSearchBlkInRecycle++;
            }
        }
    }


    if( retval == FEE_CONT )
    {
        FEE_PUSH_PROC(proc)
    }
    else
    {
        /* search complete, set stack to entry point */
        FEE_PUSH_PROC(FEE_SEARCH_VALID_START)
    }

    return retval;
}


/** \brief Fee_EraseSector
**
** Erase one logical sector.
**
** \param[in]        sector_no          target sector number
**
** \return     result
** \retval     FEE_OK(0)                erase job is successful
** \retval     FEE_NG(1)                erase job is failed
** \retval     FEE_CONT(255)            continue
**
*/
FUNC(uint8, FEE_CODE) Fee_EraseSector(
  VAR(uint8, AUTOMATIC) sector_no)
{
    VAR(Fee_EraseSectorProcType, AUTOMATIC)    proc;                           /* position of the processing */
    VAR(uint8, AUTOMATIC)                      retval;                         /* return value */
    VAR(uint32, AUTOMATIC)                     erase_flag_sector_start_addrss; /* physics sector start addrss of erase flag */
    VAR(uint32, AUTOMATIC)                     erase_flag_addrss;              /* erase flag address */
    VAR(uint32, AUTOMATIC)                     erase_length;                   /* length of erase */
    VAR(uint32, AUTOMATIC)                     sector_top_addr;                /* address of top erase sector */
    VAR(MemIf_JobResultType, AUTOMATIC)        retjob;                         /* result of fls job */

    retval = FEE_CONT;
    erase_flag_sector_start_addrss = (uint32)FEE_ZERO;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_EraseSectorProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_ERASE_SECTOR_START )
    {
        /* => 1.erase erase_flag physics sector */
        proc = FEE_ERASE_SECTOR_LAST_SECTOR;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_POP_STACK_ULONG(erase_flag_sector_start_addrss)     /* pop physics sector start addrss of erase flag */
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_POP_STACK_ULONG(erase_length)     /* pop erase length */
    }

/* 1.erase erase_flag physics sector */
    if( proc == FEE_ERASE_SECTOR_LAST_SECTOR )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488,3395 1 */
        erase_flag_addrss = (uint32)Fee_GetFlashSectorEraseFlagAddr(sector_no); /* get erase flag addrss from sector number */
        /* get physics sector start address of erase flag of sector number*/
        erase_flag_sector_start_addrss = Fee_FlsGetSecTopAddressFromAddress(erase_flag_addrss);
        erase_length = erase_flag_addrss - erase_flag_sector_start_addrss + (uint32)FEE_ERASE_COMPLETE_FLAG_SIZE; /* calculate length of physics sector length of erase flag */

        if( FEE_OFF == Fee_GetSectorBlankCheckOff() )
        {
            /* => 1-a.trigger erase  */
            FEE_SET_PROC(FEE_ERASE_SECTOR_TRIGGER_ERASE)
        }
        else
        {
            /* => 1-a.trigger erase  */
            proc = FEE_ERASE_SECTOR_TRIGGER_ERASE;
        }
    }

/* 1-a.trigger erase */
    if( proc == FEE_ERASE_SECTOR_TRIGGER_ERASE )
    {
        /* Add this proc because of PE test */
        /* ease erase_flag physics sector */
        (void)Fee_FlsErase( erase_flag_sector_start_addrss , erase_length );

        /* => 1-b.check result of erase erase_flag physics sector  */
        FEE_SET_PROC(FEE_ERASE_SECTOR_LAST_SECTOR_CHECK)
    }

/* 1-b.check result of erase erase_flag physics sector */
    if( proc == FEE_ERASE_SECTOR_LAST_SECTOR_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 2.erase sectors except erase_falg physics sector */
            proc = FEE_ERASE_SECTOR_REST_SECTOR;
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ERASE_SECTOR_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* 2.erase sectors except erase_falg physics sector */
    if( proc == FEE_ERASE_SECTOR_REST_SECTOR )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        sector_top_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no);        /* get address from sector number */
        erase_length = erase_flag_sector_start_addrss - sector_top_addr;     /* calculate length of erase */
        if( erase_length == (uint32)FEE_ZERO )
        {
            /* => 3.write erase complete flag */
            FEE_SET_PROC(FEE_ERASE_SECTOR_WRITE_FLAG)
        }
        else
        {
            /* ease physics sector except erase flag */
            (void)Fee_FlsErase( sector_top_addr, erase_length );

            /* => 2-a.check result of erasing sector */
            FEE_SET_PROC(FEE_ERASE_SECTOR_REST_SECTOR_CHECK)
        }
    }

/* 2-a.check result of erasing sector */
    if( proc == FEE_ERASE_SECTOR_REST_SECTOR_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 3.write erase complete flag */
            proc = FEE_ERASE_SECTOR_WRITE_FLAG;
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ERASE_SECTOR_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* 3.write erase complete flag */
    if( proc == FEE_ERASE_SECTOR_WRITE_FLAG )
    {
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
           Justification: 64bit is supported by the long long in ARM. */
        /* PRQA S 580 1 */
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_SET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic. */
        /* PRQA S 306,310,488,3395 1 */
        (void)Fee_FlsWrite((uint32)(Fee_GetFlashSectorEraseFlagAddr(sector_no)), (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_ERASE_COMPLETE_FLAG_SIZE);

        /* => 3-a.check result of writing erase complete flag */
        FEE_SET_PROC(FEE_ERASE_SECTOR_WRITE_FLAG_CHECK)
    }

/* 3-a.check result of writing erase complete flag */
    if( proc == FEE_ERASE_SECTOR_WRITE_FLAG_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* set disable sector to array of sector status */
            Fee_SetSectorStatus(sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_DISABLE);
            Fee_SetSectorStatusMirror(sector_no - FEE_SECTOR_STATUS_OFFSET, FEE_SECTOR_DISABLE);
            /* => X.end of periodic processing */
            proc = FEE_ERASE_SECTOR_END;
            retval = FEE_OK;
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ERASE_SECTOR_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* X.end of periodic processing */
    if( proc == FEE_ERASE_SECTOR_END )
    {
        /* => 0.entry of periodic processing */
        FEE_PUSH_PROC(FEE_ERASE_SECTOR_START)
    }
    else
    {
        retval = FEE_CONT;
        FEE_PUSH_PROC(proc)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 488 1 */
        FEE_PUSH_STACK_ULONG(erase_length)     /* evacuate erase length */
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 488 1 */
        FEE_PUSH_STACK_ULONG(erase_flag_sector_start_addrss)     /* evacuate physics sector start addrss of erase flag */
    }

    return retval;
}


/** \brief Fee_BlockBlankCheck
**
** blank check block management area
**
** \param[in]        blk_idx
** \param[in]        restore
**
** \return     Fee_BlockAddrIndexType
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This warning does not affect and other translation unit can refer in future. */
/* PRQA S 1505 1 */
FUNC(Fee_BlockAddrIndexType, FEE_CODE) Fee_BlockBlankCheck(
  VAR(uint16, AUTOMATIC) blk_idx,
  VAR(uint8, AUTOMATIC) restore)
{
    VAR(uint32, AUTOMATIC)                                      invalid_status;          /* check invalid status */
    VAR(uint32, AUTOMATIC)                                      valid_status;            /* check valid status */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                      block_addr_index;        /* index of blocks */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)    block_mng_area_ptr;      /* block management area */

    block_addr_index = Fee_GetBlockAddrIndex(blk_idx);
    /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
       Justification: Cast between a pointer to object and an integral type.
                      This deviation is due to doing pointer arithmetic. */
    /* PRQA S 306,488 1 */
    block_mng_area_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);

    if( STD_OFF == Fee_GetBlockBlankCheckOff() )
    {
        if(( FEE_BLKIDX_VALID_BLOCK == block_addr_index.BlkStatus ) || ( FEE_BLKIDX_INVALID_BLOCK == block_addr_index.BlkStatus ))
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 2 */
            invalid_status = Fee_FlsGetReadAddr((uint32)block_mng_area_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */
            valid_status = Fee_FlsGetReadAddr((uint32)block_mng_area_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */

            if(( invalid_status != FEE_NULL ) && ( valid_status != FEE_NULL ))
            {
                if( restore == FEE_RESTORE_INDEX_YES )
                {
                    /* restore the information to old one */
                    block_addr_index.BlkAddr   = Fee_BlockManagementInfoOldBlock.BlkAddr;
                    block_addr_index.BlkStatus = Fee_BlockManagementInfoOldBlock.BlkStatus;
                }
                else /* FEE_RESTORE_INDEX_NO */
                {
                    block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
                }
            }
            else if(( invalid_status == FEE_NULL ) && ( valid_status != FEE_NULL ))
            {
                block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;
            }
            else
            {
                /* restore the information to old one */
                block_addr_index.BlkAddr   = Fee_BlockManagementInfoOldBlock.BlkAddr;
                block_addr_index.BlkStatus = Fee_BlockManagementInfoOldBlock.BlkStatus;
            }
        }
        else /* FEE_BLKIDX_NEED_REFRESH or FEE_BLKIDX_NO_BLOCK_EXIST */
        {
            /* do nothing */
        }

        block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
        Fee_SetBlockAddrIndex(blk_idx, block_addr_index);
    }
    else
    {
        /* do nothing */
    }

    return block_addr_index;
}


/** \brief Fee_BlockBlankCheckAndRewrite
**
** blank check block management area
**
** \param[in]        blk_idx
**
** \return     result
** \retval     FEE_OK(0)                rewrite job is successful
** \retval     FEE_NG(1)                rewrite job is failed
** \retval     FEE_CONT(255)            continue
*/
FUNC(uint8, FEE_CODE) Fee_BlockBlankCheckAndRewrite(
  VAR(uint16, AUTOMATIC) blk_idx)
{
    VAR(Fee_BlockBlankCheckProcType, AUTOMATIC)                proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                      retval;                       /* return value */
    VAR(MemIf_JobResultType, AUTOMATIC)                        retjob;                       /* result of fls job */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)   block_ptr;                    /* pointer to block mgt area */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                     block_addr_index;             /* index of blocks */

    block_addr_index = Fee_GetBlockAddrIndex(blk_idx);

    retval             = FEE_CONT;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_BlockBlankCheckProcType)

/* 0.entry of periodic processing */
    if(proc == FEE_BLOCK_BLANKCHECKANDWRITE_START)
    {
        /* => 1.block blank check action */
        proc = FEE_BLOCK_BLANKCHECKANDWRITE_ACTION;
    }
    else
    {
        /*do nothing*/
    }

/* 1.block blank check action */
    if(proc == FEE_BLOCK_BLANKCHECKANDWRITE_ACTION)
    {
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The block_addr_index is only used after it is initialized by the former mainfunction. */
        /* PRQA S 2962 1 */
        if(FEE_BLANK_CHECK_UNDO == block_addr_index.BlkBlankCheck)
        {
            (void)Fee_BlockBlankCheck(blk_idx, FEE_RESTORE_INDEX_NO);

            /* => 2.rewrite block status of given block */
            FEE_SET_PROC(FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE)
        }
        else
        {
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_BLANKCHECKANDWRITE_END;
        }
    }

/* 2.rewrite block status of given block */
    if(proc == FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE)
    {
        Fee_InfoDataBuffer = FEE_BLOCK_FLAG_VALUE;
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);

        if(FEE_BLKIDX_VALID_BLOCK == block_addr_index.BlkStatus)
        {
            /* valid block */
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 306,310 1 */
            (void)Fee_FlsWrite((uint32)block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write ValidStat */
            /* => 2-a.set block blanck check status */
            FEE_SET_PROC(FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE_CHECK)
        }
        else if(FEE_BLKIDX_INVALID_BLOCK == block_addr_index.BlkStatus)
        {
            /* invalid block */
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 306,310 1 */
            (void)Fee_FlsWrite((uint32)block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */
            /* => 2-a.set block blanck check status */
            FEE_SET_PROC(FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE_CHECK)
        }
        else
        {
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_BLANKCHECKANDWRITE_END;
        }
    }

/* 2-a.set block blanck check status */
    if(proc == FEE_BLOCK_BLANKCHECKANDWRITE_REWRITE_CHECK)
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            retval = FEE_OK;
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_BLANKCHECKANDWRITE_END;
            break;

        case MEMIF_JOB_FAILED:
            retval = FEE_NG;
            /* => X.end of periodic processing */
            proc = FEE_BLOCK_BLANKCHECKANDWRITE_END;
            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* X.end of periodic processing */
    if(proc == FEE_BLOCK_BLANKCHECKANDWRITE_END)
    {
        /* => 0.entry of periodic processing */
        proc = FEE_BLOCK_BLANKCHECKANDWRITE_START;
    }
    else
    {
        /*do nothing*/
    }

    FEE_PUSH_PROC(proc)        /* evacuate processing */

    return retval;
}


/** \brief Fee_InitSearchBlockindexUpdate
**
** In intialization search function, update block index
**
** \param[out] now_block_ptr
** \param[out] page_no_current_ptr
** \param[out] used_reserve_size_ptr
** \param[out] temp_proc_ptr
** \param[in]  valid_or_not
** \param[in]  blankcheck_or_not
**
** \return     result
** \retval     FEE_NG(1)        block ID or block size is mismatch between work flash and configuration
** \retval     FEE_OK(0)        to search next block
** \retval     FEE_CONT(255)    to continue current block
**
*/
static FUNC(uint8, FEE_CODE) Fee_InitSearchBlockindexUpdate(
  P2VAR(Fee_BlockManagementInfoType*, AUTOMATIC, FEE_APPL_DATA) now_block_ptr,
  P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) page_no_current_ptr,
  P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) used_reserve_size_ptr,
  P2VAR(Fee_SearchCreateBlockProcType, AUTOMATIC, FEE_APPL_DATA) temp_proc_ptr,
  VAR(uint8, AUTOMATIC) valid_or_not,
  VAR(uint8, AUTOMATIC) blankcheck_or_not
 )
{
    VAR(Fee_InitSearchBlockindexUpdateProcType, AUTOMATIC)   proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                                    retval;                       /* return value */
    VAR(uint16, AUTOMATIC)                                   block_no;                     /* block no */
    VAR(uint16, AUTOMATIC)                                   block_size_from_workflash;    /* block size on flash */
    VAR(uint16, AUTOMATIC)                                   blk_idx;                      /* block number index */
    VAR(uint16, AUTOMATIC)                                   err_message;                  /* error message */
    VAR(Fee_ConfigType, AUTOMATIC)                           fee_cfg;                      /* fee configuration */
    VAR(Fee_BlockConfigType, AUTOMATIC)                      blk_cfg;                      /* block configuration*/
    VAR(Fee_BlockConfigType, AUTOMATIC)                      blk_cfg_on_flash;             /* block configuration*/
    VAR(uint32, AUTOMATIC)                                   write_flag;                   /* write flag */
    VAR(uint32, AUTOMATIC)                                   pageid_blkno;                 /* check pageid and block no */
    VAR(uint32, AUTOMATIC)                                   valid_status;                 /* check valid status */
    VAR(uint32, AUTOMATIC)                                   invalid_status;               /* check invalid status */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                   block_addr_index;             /* index of blocks */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                   block_addr_index2;            /* index of blocks */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                   block_addr_index3;            /* index of blocks */
    VAR(uint8, AUTOMATIC)                                    block_check_need;             /* it is necessary to check block or not */
    VAR(Fee_FaultType, AUTOMATIC)                            fee_fault;                    /* get fault information from FLS */
    VAR(Fee_BlockManagementInfoType,AUTOMATIC)               block_infor;                  /* get block information */
    VAR(uint16, AUTOMATIC)                                   pre_blk_idx;                  /* block number index */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                   pre_block_addr_index;         /* index of blocks */

    retval              = FEE_CONT;
    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is initialization. */
    /* PRQA S 2982 1 */
    err_message         = FEE_NULL;                             /* error message clear */
    fee_cfg             = Fee_GetCfg();
    block_check_need    = FEE_ON;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_InitSearchBlockindexUpdateProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_INIT_SEARCH_BLOCKINDEX_START )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        pageid_blkno = Fee_FlsGetReadAddr((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE); /* check BNumAndPNum */

        if(pageid_blkno == FEE_NULL)
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 3 */
            write_flag     = Fee_FlsGetReadAddr((uint32)(*now_block_ptr)); /* check WriteFlag */
            valid_status   = Fee_FlsGetReadAddr((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */
            invalid_status = Fee_FlsGetReadAddr((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

            if((write_flag == FEE_NULL) && (valid_status == FEE_NULL) && (invalid_status == FEE_NULL))
            {
                /* =>The calling source: 4.check empty area */
                *temp_proc_ptr = FEE_SEARCH_CREATE_CHECK_EMPTY_AREA;

                retval = FEE_OK;
                /* =>X.end of periodic processing  */
                proc = FEE_INIT_SEARCH_BLOCKINDEX_END;
            }
            else
            {
                if(STD_ON == Fee_GetDefinedThresholdPageSize())
                {
                    /* Basically, it is for this case:                                      */
                    /************************************************************************/
                    /* WriteStartFlag     BlockID&PageID    InvalidFlag         ValidFlag   */
                    /*     NOT Blank           Blank           Blank               Blank    */
                    /************************************************************************/
                    /* => 1.check block address index */
                    proc = FEE_INIT_SEARCH_BLOCKINDEX_GET_BLOCKNO_PAGENO;
                    Fee_ConsiderThisBlockAsMaxBlock = FEE_ON;
                }
                else
                {
                    Fee_RecycleFlag = FEE_ON;
                    
                    /* get next search position */
                    /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic. */
                    /* PRQA S 310,488,3305 1 */
                    (*now_block_ptr) = (Fee_BlockManagementInfoType*)((uint8*)(*now_block_ptr) + FEE_BLOCK_MANAGE_SIZE);
                    
                    retval = FEE_OK;
                    /* =>X.end of periodic processing  */
                    proc = FEE_INIT_SEARCH_BLOCKINDEX_END;
                }
            }
        }
        else
        {
            /* => 1.check block address index */
            proc = FEE_INIT_SEARCH_BLOCKINDEX_GET_BLOCKNO_PAGENO;
        }
    }
    else
    {
    }

/* 1.get block no and page no */
    if( proc == FEE_INIT_SEARCH_BLOCKINDEX_GET_BLOCKNO_PAGENO )
    {
        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if(fee_fault == FEE_FAULT_SED) /* 1bit ECC error, do recycle */
        {
            Fee_RecycleFlag = FEE_ON;
            if(valid_or_not == FEE_BLKIDX_CORRUPT_BLOCK)
            {
                if(STD_ON == Fee_GetDefinedThresholdPageSize())
                {
                    Fee_ConsiderThisBlockAsMaxBlock = FEE_ON;
                }
            }
            /* => 2.blank check and judge result */
            proc = FEE_INIT_SEARCH_BLOCKINDEX_BLANKCHECK;
        }
        else if(fee_fault == FEE_FAULT_DED) /* 2bit ECC error */
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                Fee_ConsiderThisBlockAsMaxBlock = FEE_ON;
                /* => 2.blank check and judge result */
                proc = FEE_INIT_SEARCH_BLOCKINDEX_BLANKCHECK;
            }
            else
            {
                if( Fee_GetDelayRecycleOperation() == FEE_ON )
                {
                    /* delay recycle operation is on, do not recycle */
                    Fee_RecycleImmediateFlag = FEE_ON;
                    /* get next search position */
                    /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic. */
                    /* PRQA S 310,488,3305 1 */
                    (*now_block_ptr) = (Fee_BlockManagementInfoType*)((uint8*)(*now_block_ptr) + FEE_BLOCK_MANAGE_SIZE);
                }
                else
                {
                    /* default : delay recycle operation is off, do recycle */
                    Fee_RecycleImmediateFlag = FEE_ON;

                    /* =>The calling source: X.end of periodic processing */
                    *temp_proc_ptr = FEE_SEARCH_CREATE_END;
                }

                retval = FEE_OK;
                /* =>X.end of periodic processing  */
                proc = FEE_INIT_SEARCH_BLOCKINDEX_END;
            }
        }
        else if(fee_fault == FEE_FAULT_NONE)
        {
            if(valid_or_not == FEE_BLKIDX_CORRUPT_BLOCK)
            {
                Fee_RecycleFlag = FEE_ON;
                if(STD_ON == Fee_GetDefinedThresholdPageSize())
                {
                    Fee_ConsiderThisBlockAsMaxBlock = FEE_ON;
                }
            }
            /* => 2.blank check and judge result */
            proc = FEE_INIT_SEARCH_BLOCKINDEX_BLANKCHECK;
        }
        else /* other error */
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                Fee_ConsiderThisBlockAsMaxBlock = FEE_ON;
                /* => 2.blank check and judge result */
                proc = FEE_INIT_SEARCH_BLOCKINDEX_BLANKCHECK;
            }
            else
            {
                Fee_RecycleFlag = FEE_ON;
                /* get next search position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                (*now_block_ptr) = (Fee_BlockManagementInfoType*)((uint8*)(*now_block_ptr) + FEE_BLOCK_MANAGE_SIZE);
                retval = FEE_OK;
                /* =>X.end of periodic processing  */
                proc = FEE_INIT_SEARCH_BLOCKINDEX_END;
            }
        }
    }

/* 2.blank check and judge result */
    if( proc == FEE_INIT_SEARCH_BLOCKINDEX_BLANKCHECK )
    {
        Fee_BlkSearchCntInInit++;

        /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
           Justification: This implementation is adopted for avoiding more nesting.
           It is no problem because side effects cannot be caused. */
        /* PRQA S 3415 1 */
        if((FEE_ON == Fee_ConsiderThisBlockAsMaxBlock) && (STD_ON == Fee_GetDefinedThresholdPageSize()))
        {
            block_no = Fee_GetBlockNoFromRealMaxsize(Fee_CurrentConfigNo);

            if(Fee_BlkSearchCntInInit == (uint16)1)
            {
                *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U); /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
            }
            else if(Fee_BlkSearchCntInInit == (uint16)2)
            {
                *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[0]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
            }
            else if(Fee_BlkSearchCntInInit == (uint16)3)
            {
                *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[1]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
            }
            else /* Fee_BlkSearchCntInInit is 4,5,6... */
            {
                *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[2]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
            }
            Fee_ConsiderThisBlockAsMaxBlock = FEE_OFF;
            valid_or_not = FEE_BLKIDX_NO_BLOCK_EXIST;
            blankcheck_or_not = FEE_BLANK_CHECK_UNDO;

            /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
            block_infor.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
            Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE - FEE_BLOCK_MANAGE_SIZE, &block_infor.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
            fee_fault = Fee_GetFlsFault();
            Fee_FlsDisableDMA();
            if((fee_fault == FEE_FAULT_SED) || (fee_fault == FEE_FAULT_NONE))
            {
                pre_blk_idx = Fee_BlockNumberToIndex(block_infor.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                pre_block_addr_index = Fee_GetBlockAddrIndex(pre_blk_idx);
                if((pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK) || (pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE))
                {
                    Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                }
            }
        }
        else
        {
            /* Block ID check & Block size check */
            block_no = (uint16)(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
            *page_no_current_ptr = (uint16)(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
        }

        if(Fee_BlkSearchCntInInit == (uint16)1)
        {
            Fee_BlkSearchPageNoInInit[0] = *page_no_current_ptr;
            /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6
               Justification: As a result of this expression, it will not exceed the essential type. */
            /* PRQA S 4491 1 */
            block_size_from_workflash    = (*page_no_current_ptr) * fee_cfg.FeeVirtualPageSize;
        }
        else if(Fee_BlkSearchCntInInit == (uint16)2)
        {
            Fee_BlkSearchPageNoInInit[1] = *page_no_current_ptr;
            /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6
               Justification: As a result of this expression, it will not exceed the essential type. */
            /* PRQA S 4491 1 */
            block_size_from_workflash    = (Fee_BlkSearchPageNoInInit[1] - Fee_BlkSearchPageNoInInit[0]) * fee_cfg.FeeVirtualPageSize;
        }
        else if(Fee_BlkSearchCntInInit == (uint16)3)
        {
            Fee_BlkSearchPageNoInInit[2] = *page_no_current_ptr;
            /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6
               Justification: As a result of this expression, it will not exceed the essential type. */
            /* PRQA S 4491 1 */
            block_size_from_workflash    = (Fee_BlkSearchPageNoInInit[2] - Fee_BlkSearchPageNoInInit[1]) * fee_cfg.FeeVirtualPageSize;
        }
        else
        {
            Fee_BlkSearchPageNoInInit[0] = Fee_BlkSearchPageNoInInit[1];
            Fee_BlkSearchPageNoInInit[1] = Fee_BlkSearchPageNoInInit[2];
            Fee_BlkSearchPageNoInInit[2] = *page_no_current_ptr;
            /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6
               Justification: As a result of this expression, it will not exceed the essential type. */
            /* PRQA S 4491 1 */
            block_size_from_workflash    = (Fee_BlkSearchPageNoInInit[2] - Fee_BlkSearchPageNoInInit[1]) * fee_cfg.FeeVirtualPageSize;
        }

        blk_idx = Fee_BlockNumberToIndex(block_no);
        if( blk_idx == (uint16)0xFFFF )
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                /* Just like Fee_ConsiderThisBlockAsMaxBlock */
                block_no = Fee_GetBlockNoFromRealMaxsize(Fee_CurrentConfigNo);
                blk_idx  = Fee_BlockNumberToIndex(block_no);
                if(Fee_BlkSearchCntInInit == (uint16)1)
                {
                    *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U); /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    Fee_BlkSearchPageNoInInit[0] = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U); /* >>2 means dividing fee_cfg.FeeVirtualPageSize */
                }
                else if(Fee_BlkSearchCntInInit == (uint16)2)
                {
                    *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[0]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    /* Fee_BlkSearchPageNoInInit[0] is not changed. */
                    Fee_BlkSearchPageNoInInit[1] = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[0]; /* >>2 means dividing fee_cfg.FeeVirtualPageSize */
                }
                else /* Fee_BlkSearchCntInInit is 3,4,5... */
                {
                    if(Fee_BlkSearchCntInInit == (uint16)3)
                    {
                        *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[1]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    }
                    else
                    {
                        *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[2]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    }
                    /*Fee_BlkSearchPageNoInInit[0] is not changed.*/
                    /*Fee_BlkSearchPageNoInInit[1] is not changed.*/
                    Fee_BlkSearchPageNoInInit[2] = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[1]; /* >>2 means dividing fee_cfg.FeeVirtualPageSize */
                }
                
                valid_or_not = FEE_BLKIDX_NO_BLOCK_EXIST;
                blankcheck_or_not = FEE_BLANK_CHECK_UNDO;

                /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                block_infor.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                Fee_FlsEnableDMA();
                /* ReadOperation */
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                Fee_FlsReadImmediateSync((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE - FEE_BLOCK_MANAGE_SIZE, &block_infor.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                fee_fault = Fee_GetFlsFault();
                Fee_FlsDisableDMA();
                if((fee_fault == FEE_FAULT_SED) || (fee_fault == FEE_FAULT_NONE))
                {
                    pre_blk_idx = Fee_BlockNumberToIndex(block_infor.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                    pre_block_addr_index = Fee_GetBlockAddrIndex(pre_blk_idx);
                    if((pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK) || (pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE))
                    {
                        Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                    }
                }
            }
            else
            {
                /* block no is not configured in user config*/
                err_message = FEE_EVENT_BLOCKID_UNMATCHED_ERROR_OCCURRED;
            }
        }
        else if(block_size_from_workflash != Fee_GetPageSizeAlignSize((Fee_GetBlkCfg(blk_idx)).FeeBlockSize))
        {
            if(STD_ON == Fee_GetDefinedThresholdPageSize())
            {
                /* Just like Fee_ConsiderThisBlockAsMaxBlock */
                block_no = Fee_GetBlockNoFromRealMaxsize(Fee_CurrentConfigNo);
                blk_idx  = Fee_BlockNumberToIndex(block_no);
                if(Fee_BlkSearchCntInInit == (uint16)1)
                {
                    *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U); /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    Fee_BlkSearchPageNoInInit[0] = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U); /* >>2 means dividing fee_cfg.FeeVirtualPageSize */
                }
                else if(Fee_BlkSearchCntInInit == (uint16)2)
                {
                    *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[0]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    /* Fee_BlkSearchPageNoInInit[0] is not changed. */
                    Fee_BlkSearchPageNoInInit[1] = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[0]; /* >>2 means dividing fee_cfg.FeeVirtualPageSize */
                }
                else /* Fee_BlkSearchCntInInit is 3,4,5... */
                {
                    if(Fee_BlkSearchCntInInit == (uint16)3)
                    {
                        *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[1]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    }
                    else
                    {
                        *page_no_current_ptr = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[2]; /* [>> 2U] means dividing fee_cfg.FeeVirtualPageSize */
                    }
                    /*Fee_BlkSearchPageNoInInit[0] is not changed.*/
                    /*Fee_BlkSearchPageNoInInit[1] is not changed.*/
                    Fee_BlkSearchPageNoInInit[2] = (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) + Fee_BlkSearchPageNoInInit[1]; /* >>2 means dividing fee_cfg.FeeVirtualPageSize */
                }
                valid_or_not = FEE_BLKIDX_NO_BLOCK_EXIST;
                blankcheck_or_not = FEE_BLANK_CHECK_UNDO;

                /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                block_infor.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                Fee_FlsEnableDMA();
                /* ReadOperation */
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
                /* PRQA S 306 1 */
                Fee_FlsReadImmediateSync((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE - FEE_BLOCK_MANAGE_SIZE, &block_infor.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                fee_fault = Fee_GetFlsFault();
                Fee_FlsDisableDMA();
                if((fee_fault == FEE_FAULT_SED) || (fee_fault == FEE_FAULT_NONE))
                {
                    pre_blk_idx = Fee_BlockNumberToIndex(block_infor.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                    pre_block_addr_index = Fee_GetBlockAddrIndex(pre_blk_idx);
                    if((pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK) || (pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE))
                    {
                        Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                    }
                }
            }
            else
            {
                /* block size is different between user config and work flash*/
                err_message = FEE_EVENT_BLOCKSIZE_UNMATCHED_ERROR_OCCURRED;

                /* For corrupted block, change the page number information. */
                if(valid_or_not == FEE_BLKIDX_CORRUPT_BLOCK)
                {
                    if(Fee_BlkSearchCntInInit == (uint16)1)
                    {
                        Fee_BlkSearchPageNoInInit[0] = (uint16)FEE_ZERO;
                    }
                    else if(Fee_BlkSearchCntInInit == (uint16)2)
                    {
                        Fee_BlkSearchPageNoInInit[1] = Fee_BlkSearchPageNoInInit[0];
                    }
                    else /* Fee_BlkSearchCntInInit is 3,4,5... */
                    {
                        Fee_BlkSearchPageNoInInit[2] = Fee_BlkSearchPageNoInInit[1];
                    }
                }
            }
        }
        else
        {
            err_message = (uint16)FEE_NULL;
        }

        if( FEE_NULL != err_message ) /* block ID unmatch or block size unmatch */
        {
            /* For confirming the corrupted block, the blank check here is necessary. */
        
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 4 */
            write_flag     = Fee_FlsGetReadAddr((uint32)(*now_block_ptr)); /* check WriteFlag */
            pageid_blkno   = Fee_FlsGetReadAddr((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE); /* check BNumAndPNum */
            valid_status   = Fee_FlsGetReadAddr((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */
            invalid_status = Fee_FlsGetReadAddr((uint32)(*now_block_ptr) + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

            if(err_message != FEE_EVENT_BLOCKID_UNMATCHED_ERROR_OCCURRED)
            {
                block_addr_index2 = Fee_GetBlockAddrIndex(blk_idx); 
                block_addr_index2.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
                Fee_SetBlockAddrIndex(blk_idx, block_addr_index2);
            }

            blankcheck_or_not = FEE_BLANK_CHECK_DONE;

            if((write_flag   == FEE_NULL) ||
                (pageid_blkno == FEE_NULL) ||
                ((invalid_status == FEE_NULL) && (valid_status == FEE_NULL)))
            {
                /* 13 cases are entered here. */

                if(err_message == FEE_EVENT_BLOCKSIZE_UNMATCHED_ERROR_OCCURRED)
                {
                    /* For corrupted block, change the page number information. */
                    if(Fee_BlkSearchCntInInit == (uint16)1)
                    {
                        Fee_BlkSearchPageNoInInit[0] = (uint16)FEE_ZERO;
                    }
                    else if(Fee_BlkSearchCntInInit == (uint16)2)
                    {
                        Fee_BlkSearchPageNoInInit[1] = Fee_BlkSearchPageNoInInit[0];
                    }
                    else /* Fee_BlkSearchCntInInit is 3,4,5... */
                    {
                        Fee_BlkSearchPageNoInInit[2] = Fee_BlkSearchPageNoInInit[1];
                    }
                }

                Fee_RecycleFlag = FEE_ON;

                /* get next search position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                    Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                    This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                (*now_block_ptr) = (Fee_BlockManagementInfoType*)((uint8*)(*now_block_ptr) + FEE_BLOCK_MANAGE_SIZE);
                block_check_need = FEE_OFF;
            }
            else
            {
                /* else only three cases: */
                /*         write_flag    pageid_blkno    invalid_status    valid_status */
                /* case1 : Not Blank     Not Blank       Blank             Not Blank    */
                /* case2 : Not Blank     Not Blank       Not Blank         Blank        */
                /* case3 : Not Blank     Not Blank       Not Blank         Not Blank    */
                /* besides, pageid_blkno of all the three cases is unmatch between config and work flash */

                if( Fee_GetUnmatchedBlockCheck() == FEE_ON )
                {
                    Fee_JobResult = MEMIF_JOB_FAILED;
                    Fee_ErrorCallout( err_message );
                    retval = FEE_NG;
                }
                else
                {
                    if(blk_idx != (uint16)0xFFFF)
                    {
                        if(block_size_from_workflash < Fee_GetPageSizeAlignSize((Fee_GetBlkCfg(blk_idx)).FeeBlockSize))
                        {
                            Fee_ConfigUnmatchFlag = FEE_ON;

                            blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);
                            /* Deviation from MISRA-C:2012 Rule-10.3
                                Justification: As a result of this expression, it will not exceed the essential type. */
                            /* PRQA S 4461 1 */
                            blk_cfg_on_flash.FeeBlockSize = block_size_from_workflash;
                            Fee_SetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx, blk_cfg_on_flash);
                        }
                        else
                        {
                            /* =>The calling source: 3.write invalid flag */
                            *temp_proc_ptr = FEE_SEARCH_CREATE_WRITE_INVALID_FLAG;
                        }
                    }
                    else
                    {
                        Fee_ConfigUnmatchFlag = FEE_ON;

                        /* get next search position */
                        /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic. */
                        /* PRQA S 310,488,3305 1 */
                        (*now_block_ptr) = (Fee_BlockManagementInfoType*)((uint8*)(*now_block_ptr) + FEE_BLOCK_MANAGE_SIZE);
                        block_check_need = FEE_OFF;
                    }
                }
            }
        }

        if( (retval != FEE_NG) && (FEE_SEARCH_CREATE_WRITE_INVALID_FLAG != (*temp_proc_ptr)) && ( block_check_need == FEE_ON ) )
        {
            if( valid_or_not == FEE_BLKIDX_VALID_BLOCK)
            {
                /* PRQA S 715 -- */
                /* update address index of blocks */
                block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;
                /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                   Justification: Cast between a pointer to object and an integral type.
                                  This deviation is due to doing pointer arithmetic. */
                /* PRQA S 306,488 1 */
                block_addr_index.BlkAddr = (uint32)(*now_block_ptr);
                block_addr_index.BlkBlankCheck = blankcheck_or_not;
            }
            else if( valid_or_not == FEE_BLKIDX_INVALID_BLOCK)
            {
                /* refresh BlkAddr */
                block_addr_index = Fee_GetBlockAddrIndex(blk_idx);
                Fee_BlockManagementInfoOldBlock.BlkAddr   = block_addr_index.BlkAddr;   /* save old information */
                Fee_BlockManagementInfoOldBlock.BlkStatus = block_addr_index.BlkStatus; /* save old information */
                block_addr_index3 = block_addr_index;
                 /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                    Justification: Cast between a pointer to object and an integral type.
                                   This deviation is due to doing pointer arithmetic. */
                /* PRQA S 306,488 2 */
                block_addr_index.BlkAddr = (uint32)(*now_block_ptr);
                block_addr_index3.BlkAddr = (uint32)(*now_block_ptr);
                block_addr_index3.BlkStatus = valid_or_not;
                Fee_SetBlockAddrIndex(blk_idx, block_addr_index3);
                /* refresh BlkAddr */
                if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                {
                    /* BlkStatus has already set to valid, but a newer invalid block is found. Do the following blank check. */
                    block_addr_index = Fee_BlockBlankCheck(blk_idx, FEE_RESTORE_INDEX_YES);
                }
                else
                {
                    /* update address index of blocks */
                    block_addr_index.BlkStatus = FEE_BLKIDX_INVALID_BLOCK;
                    block_addr_index.BlkBlankCheck = blankcheck_or_not;
                }
            }
            else /* FEE_BLKIDX_CORRUPT_BLOCK */
            {
                if(STD_OFF == Fee_GetDefinedThresholdPageSize())
                {
                    /* =>The calling source: 3.write invalid flag */
                    *temp_proc_ptr = FEE_SEARCH_CREATE_WRITE_INVALID_FLAG;
                }
            }

            if(FEE_SEARCH_CREATE_WRITE_INVALID_FLAG != (*temp_proc_ptr))
            {
                /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
                   Justification: The block_addr_index is only used after it is initialized by the former mainfunction. */
                /* PRQA S 2962 1*/
                if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
                {
                    blk_cfg = Fee_GetBlkCfg(blk_idx);
                    /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Dir-1.1
                       Justification: It is necessary that nesting of control structure exceeds 15 in the implementation. */
                    /* PRQA S 715 ++ */
                    if( blk_cfg.FeeImmediateData == TRUE )
                    {
                        *used_reserve_size_ptr += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                    }
                }
                if(valid_or_not != FEE_BLKIDX_NO_BLOCK_EXIST)
                {
                    /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
                      Justification: When in this branch,.block_addr_index always is initialized */
                    /* PRQA S 2962 1*/
                    Fee_SetBlockAddrIndex(blk_idx, block_addr_index);
                }
                /* get next search position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                   Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                  This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                (*now_block_ptr) = (Fee_BlockManagementInfoType*)((uint8*)(*now_block_ptr) + FEE_BLOCK_MANAGE_SIZE);
            }
        }

        if( retval != FEE_NG )
        {
            retval = FEE_OK;
        }
        proc = FEE_INIT_SEARCH_BLOCKINDEX_END;
    }

/* X.end of periodic processing  */
    if( proc == FEE_INIT_SEARCH_BLOCKINDEX_END )
    {
        proc = FEE_INIT_SEARCH_BLOCKINDEX_START;
    }
    else
    {
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    return retval;
}


/** \brief Fee_AdjustingWorkFlash
**
** When configuration is changed, adjusting work flash.
**
** \param[in]  src_sector_no_old_cfg   moving source sector number of old configuration
**                                     range: 1,2,3,...
**
** \return     result of operation
** \retval     FEE_OK                   success
** \retval     FEE_NG                   failed
** \retval     FEE_CONT                 continue
**
*/
static FUNC(uint8, FEE_CODE) Fee_AdjustingWorkFlash(
  VAR(uint8, AUTOMATIC) src_sector_no_old_cfg)
{
    VAR(Fee_AdjustingWorkFlashProcType, AUTOMATIC)               proc;                               /* position of the processing */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)     src_ptr;                            /* pointer to block of source */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)     dst_ptr;                            /* pointer to block of destination */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)     old_block_ptr;                      /* pointer to old block */
    VAR(Fee_ConfigType, AUTOMATIC)                               fee_cfg;                            /* fee configuration */
    VAR(Fee_BlockConfigType, AUTOMATIC)                          blk_cfg;                            /* block configuration array */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)                       block_addr_index;                   /* index of blocks */
    VAR(MemIf_JobResultType, AUTOMATIC)                          retjob;                             /* result of fls job */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)     blk_mgt_area_empty_addr_ptr;        /* pointer to empty address for block management area */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                          blk_page_area_empty_addr_ptr;       /* pointer to empty address for page area */
    VAR(uint16, AUTOMATIC)                                       blk_empty_size;                     /* empty size */
    VAR(uint16, AUTOMATIC)                                       cnt;                                /* loop counter */
    VAR(uint16, AUTOMATIC)                                       used_pages_size;                    /* size counter of used pages for calculating Fee_BlkPageAreaEmptyAddr and page number of Fee_BlkMgtInfoBuffer */
    VAR(uint16, AUTOMATIC)                                       used_reserve_size;                  /* size counter of used reserve space for calculating Fee_ImmDataReserveSize */
    VAR(uint32, AUTOMATIC)                                       flag_from_flash;                    /* temporary variable for storing the flag read from flash */
    VAR(uint16, AUTOMATIC)                                       blk_idx;                            /* block number index */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                           src_data_ptr;                       /* pointer to data of source */
    VAR(uint8, AUTOMATIC)                                        retval;                             /* return value */
    VAR(uint8, AUTOMATIC)                                        retval_sub_func;                    /* return value */
    VAR(uint8, AUTOMATIC)                                        dst_sector_no;                      /* recycling destination sector */
    VAR(uint8, AUTOMATIC)                                        src_sector_no;                      /* recycling source sector */
    VAR(uint8, AUTOMATIC)                                        erase_result;                       /* result of erase one sector */
    VAR(uint8, AUTOMATIC)                                        erase_sector_no;                    /* sector number for erasing */
    VAR(uint32, AUTOMATIC)                                       write_start_addr;                   /* the start address of writing */
    VAR(uint16, AUTOMATIC)                                       cnt_block_index;                    /* block number index */
    VAR(uint32, AUTOMATIC)                                       sector_start_addrss_of_new_config;  /* sector start addrss of valid sector in new configuration */
    VAR(uint32, AUTOMATIC)                                       sector_end_addrss_of_new_config;    /* sector end addrss of valid sector in new configuration */
    VAR(uint32, AUTOMATIC)                                       sector_start_addrss_of_old_config;  /* sector start addrss of valid sector in old configuration */
    VAR(uint32, AUTOMATIC)                                       sector_end_addrss_of_old_config;    /* sector end addrss of valid sector in old configuration */
    VAR(uint32, AUTOMATIC)                                       valid_status;                       /* check valid status */
    VAR(uint32, AUTOMATIC)                                       invalid_status;                     /* check invalid status */
    VAR(uint32, AUTOMATIC)                                       write_start_flag;                   /* check write start flag */
    VAR(uint32, AUTOMATIC)                                       bnum_pnum;                          /* check block number and page number */
    P2VAR(Fee_BlockManagementInfoType, AUTOMATIC, AUTOMATIC)     src_ptr_temp_ptr;                   /* pointer to block of source */
    VAR(Fee_FaultType, AUTOMATIC)                                fee_fault;                          /* get fault information from FLS */
    VAR(uint32, AUTOMATIC)                                       erase_target_addr;                  /* check block number and page number */
    VAR(uint32, AUTOMATIC)                                       erase_length;                       /* check block number and page number */
    VAR(uint16, AUTOMATIC)                                       front_pages_size;                   /* size of front block on old flash */
    VAR(uint16, AUTOMATIC)                                       current_pages_size;                 /* size of current block on old flash */
    /* Deviation from MISRA-C:2004 rule 18.4, MISRA-C:2012 Rule-19.2
       Justification: This union type is used for accessing to work flash memory. */
    /* PRQA S 759 1 */
    VAR(Fee_PscInfoType, AUTOMATIC)                              psc;                                /* old config PSC value */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                          data_ptr;                           /* block data buffer for last valid block */
    VAR(Fee_BlockManagementInfoType, AUTOMATIC)                  pre_block;                          /* the pre block of current block */
    VAR(uint16, AUTOMATIC)                                       pre_blk_idx;                        /* block number index */

    erase_sector_no   = (uint8)1;
    retval            = FEE_CONT;
    dst_sector_no     = FEE_NONE_SECTOR;
    src_ptr           = (Fee_BlockManagementInfoType*)FEE_NULL;
    dst_ptr           = (Fee_BlockManagementInfoType*)FEE_NULL;
    old_block_ptr     = (Fee_BlockManagementInfoType*)FEE_NULL;
    src_data_ptr      = (uint8*)FEE_NULL;
    used_pages_size   = (uint16)FEE_ZERO;
    used_reserve_size = (uint16)FEE_ZERO;
    retjob            = MEMIF_JOB_OK;
    cnt_block_index   = (uint16)FEE_ZERO;
    front_pages_size  = (uint16)FEE_ZERO;
    current_pages_size= (uint16)FEE_ZERO;
    src_sector_no     = src_sector_no_old_cfg;


    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_AdjustingWorkFlashProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_ADJUSTING_WORK_FLASH_START )
    {
        /* =>0-1.after OLD_CONSTRUCTION_MOVING, restart */
        proc = FEE_ADJUSTING_WORK_FLASH_RESTART_INIT_STACK;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 2 */
        FEE_POP_STACK_ULONG(erase_target_addr)
        FEE_POP_STACK_ULONG(erase_length)
        FEE_POP_STACK_UCHAR(src_sector_no)
        FEE_POP_STACK_UCHAR(erase_sector_no)
        /* Deviation from MISRA-C:2004 rule 12.8, 17.4, MISRA-C:2012 Rule-18.4, Rule-12.2
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          This deviation is due to doing pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          This deviation is due to a shift conversion for handling the uint64 variable. */
        /* PRQA S 488,2790 1 */
        FEE_POP_STACK_ULONG(sector_start_addrss_of_old_config)
        /* Deviation from MISRA-C:2004 rule 12.8, 17.4, MISRA-C:2012 Rule-18.4, Rule-12.2
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          This deviation is due to doing pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          This deviation is due to a shift conversion for handling the uint64 variable. */
        /* PRQA S 488,2790 1 */
        FEE_POP_STACK_ULONG(sector_end_addrss_of_old_config)
        FEE_POP_STACK_UCHAR(dst_sector_no)
        FEE_POP_STACK_USHORT(used_pages_size)
        FEE_POP_STACK_USHORT(used_reserve_size)
        /* If periodic processing is continued, pop related data of under processing. */
        FEE_POP_STACK_USHORT(blk_idx)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(src_data_ptr, uint8)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(dst_ptr, Fee_BlockManagementInfoType)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_POP_STACK_POINTER(src_ptr, Fee_BlockManagementInfoType)
        FEE_POP_STACK_USHORT(cnt_block_index)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 4 */
        FEE_POP_STACK_ULONG(write_start_flag)
        FEE_POP_STACK_ULONG(bnum_pnum)
        FEE_POP_STACK_ULONG(valid_status)
        FEE_POP_STACK_ULONG(invalid_status)
        FEE_POP_STACK_USHORT(front_pages_size)
        FEE_POP_STACK_USHORT(current_pages_size)
    }

/* 0-1.after OLD_CONSTRUCTION_MOVING, restart */
    if(proc == FEE_ADJUSTING_WORK_FLASH_RESTART_INIT_STACK)
    {
        erase_sector_no   = (uint8)1;
        retval              = FEE_CONT;
        dst_sector_no      = FEE_NONE_SECTOR;
        src_ptr           = (Fee_BlockManagementInfoType*)FEE_NULL;
        dst_ptr           = (Fee_BlockManagementInfoType*)FEE_NULL;
        old_block_ptr      = (Fee_BlockManagementInfoType*)FEE_NULL;
        src_data_ptr      = (uint8*)FEE_NULL;
        used_pages_size   = (uint16)FEE_ZERO;
        used_reserve_size = (uint16)FEE_ZERO;
        retjob              = MEMIF_JOB_OK;
        cnt_block_index   = (uint16)FEE_ZERO;
        front_pages_size  = (uint16)FEE_ZERO;
        current_pages_size= (uint16)FEE_ZERO;
        /* Note : When restart, src_sector_no must not be cleared. */

        /* =>0-2.after OLD_CONSTRUCTION_MOVING, restart */
        proc = FEE_ADJUSTING_WORK_FLASH_RESTART;
    }

/* 0-2.after OLD_CONSTRUCTION_MOVING, restart */
    if(proc == FEE_ADJUSTING_WORK_FLASH_RESTART)
    {
        Fee_EraseCountInAdjusting = (uint8)FEE_ZERO;

        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        sector_start_addrss_of_old_config = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR_OLD(src_sector_no);
        if(src_sector_no == Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NoOfSec)
        {
            sector_end_addrss_of_old_config = sector_start_addrss_of_old_config + Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize + Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_RemainSize - (uint32)1;
        }
        else
        {
            sector_end_addrss_of_old_config = sector_start_addrss_of_old_config + Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize - (uint32)1;
        }

        /* => 1.erase other sectors except the source sector */
        FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_ERASE_SECTOR)
    }

/* 1.erase other sectors except the source sector */
    if( proc == FEE_ADJUSTING_WORK_FLASH_ERASE_SECTOR )
    {
        if(erase_sector_no <= Fee_GetNoOfSec())
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306,488 1 */
            sector_start_addrss_of_new_config = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(erase_sector_no);
            if(erase_sector_no == Fee_GetNoOfSec())
            {
                sector_end_addrss_of_new_config = sector_start_addrss_of_new_config + Fee_GetSectorSize() + Fee_GetRemainSize() - (uint32)1;
            }
            else
            {
                sector_end_addrss_of_new_config = sector_start_addrss_of_new_config + Fee_GetSectorSize() - (uint32)1;
            }

            if((sector_start_addrss_of_new_config >= sector_end_addrss_of_old_config) ||
              (sector_end_addrss_of_new_config <= sector_start_addrss_of_old_config))
            {
                erase_result = Fee_EraseSector(erase_sector_no);
                Fee_EraseCountInAdjusting++;

                switch(erase_result)
                {
                case FEE_OK:
                    erase_sector_no++;
                    /* get next sector to erase */
                    /* => 1.erase other sectors except the source sector */
                    proc = FEE_ADJUSTING_WORK_FLASH_ERASE_SECTOR;
                    break;
                
                case FEE_NG:
                    /* => X.end of periodic processing */
                    proc = FEE_ADJUSTING_WORK_FLASH_END;
                    retval = FEE_NG;
                    break;
                
                default: /* FEE_CONT */
                    /* do nothing */
                    break;
                }
            }
            else
            {
                /* current sector is including valid blocks, do not erase, go get next sector */
                erase_sector_no++;
            }
        }
        else
        {
            if(Fee_EraseCountInAdjusting > (uint8)FEE_ZERO)
            {
                /* => 2.set source sector to moving */
                FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_SET_MOVING_SECTOR)
            }
            else
            {
                /* => 1-1.move data from source to destination via old construction when there only two sector and no sector to erase */
                FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING1_GET_ERASE_TARGET)
            }
        }
    }

/* 1-1.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING1_GET_ERASE_TARGET )
    {
        /* in old construction, erase the not valid sector */
        if(Fee_OldSectorStatusArray[2].FeeSectorAddress == Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr)
        {
            /* if valid sector is sector1, then sector2 is moving destination  */
            /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8
              Justification: Casting to different type for consistency. */
            /* PRQA S 4391 2 */
            erase_target_addr = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr + (uint32)(((uint16)Fee_OldSectorStatusArray[2].FeePsc1) * Fee_GetWflashLgSectorSize());
            erase_length = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecSize + Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_RemainSize;
            dst_sector_no = (uint8)2;
        }
        else
        {
            /* if valid sector is sector2, then sector1 is moving destination  */
            erase_target_addr = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_SecTopAddr;
            /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8
              Justification: Casting to different type for consistency. */
            /* PRQA S 4391 1 */
            erase_length = (uint32)(((uint16)(Fee_OldSectorStatusArray[2].FeePsc1)) * Fee_GetWflashLgSectorSize());
            dst_sector_no = (uint8)1;
        }
        
        (void)Fee_FlsErase(erase_target_addr, erase_length);
        
        /* => 1-2.move data from source to destination via old construction when there only two sector and no sector to erase */
        FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2_CHK_RET)
    }

/* 1-2.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2_CHK_RET )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 1-2-A.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2A_SET_EFLAG;
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* 1-2-A.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2A_SET_EFLAG )
    {
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
           Justification: 64bit is supported by the long long in ARM. */
        /* PRQA S 580 1 */
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_SET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic. */
        /* PRQA S 306,310,488,3395 1 */
        (void)Fee_FlsWrite((uint32)(erase_target_addr + erase_length - (uint32)FEE_ERASE_COMPLETE_FLAG_SIZE), (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_ERASE_COMPLETE_FLAG_SIZE);

        /* =>1-2-B.move data from source to destination via old construction when there only two sector and no sector to erase */
        FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2B_CHK_EFLAG)
    }

/* 1-2-B.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING2B_CHK_EFLAG )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* => 1-3.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING3_SET_MOVE;
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
            break;

        default: /* MEMIF_JOB_PENDING */
            /* do nothing */
            break;
        }
    }

/* 1-3.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING3_SET_MOVE )
    {
        /* in old construction, set src sector moving flag */
        retval_sub_func = Fee_SetOldSector(src_sector_no, FEE_SECTOR_MOVING);

        if( retval_sub_func == FEE_OK )
        {
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)(FEE_GET_FLASH_SECTOR_START_ADDR_OLD(src_sector_no) + FEE_TOP_BLOCK_OFFSET);
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            dst_ptr = (Fee_BlockManagementInfoType*)(FEE_GET_FLASH_SECTOR_START_ADDR_OLD(dst_sector_no) + FEE_TOP_BLOCK_OFFSET);
            /* => 1-4.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4_CHK_BLK;
        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 1-4.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4_CHK_BLK )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        write_start_flag = Fee_FlsGetReadAddr((uint32)(src_ptr)); /* check WriteFlag */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        bnum_pnum = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE);
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        valid_status = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        invalid_status = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

        if((write_start_flag != FEE_NULL) && (bnum_pnum != FEE_NULL)  && (valid_status != FEE_NULL) && (invalid_status == FEE_NULL))
        {
            /* valid block */

            Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_STATUS_SIZE);
            fee_fault = Fee_GetFlsFault();
            Fee_FlsDisableDMA();

            /* the address must be not blank, so here could not check ECC fault */
            fee_cfg = Fee_GetCfg();
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
                Justification: Cast between a pointer to object and an integral type.
                                This deviation is due to doing pointer arithmetic.
                                This deviation is due to an integer type cast to do pointer arithmetic.
                                This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                                The formula has been tested. */
            /* PRQA S 306,488,1840,1860 1 */
            src_data_ptr = Fee_CalPhysicalAddrFromPageNoOldConfig(src_sector_no, Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);

            current_pages_size = (Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum * fee_cfg.FeeVirtualPageSize) - front_pages_size;
            front_pages_size = current_pages_size;

            used_pages_size += current_pages_size;

            /* set block write flag */
            Fee_BlkMgtInfoBuffer.WriteFlag = (uint32)FEE_BLOCK_INITIAL_WRITEFLAG;
            /* set block number */
            Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum;
            /* set page number */
            /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8
                Justification: Casting to different type for consistency. */
            /* PRQA S 4391 1 */
            Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.PageNum = (uint16)(used_pages_size/fee_cfg.FeeVirtualPageSize);
            /* set Valid Block status */
            Fee_BlkMgtInfoBuffer.ValidStat   = FEE_BLOCK_VALID_BLOCK;

            /* => 1-5-0.memory copy */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4A_MEMORY_COPY;
        }
        else if((write_start_flag == FEE_NULL) && (bnum_pnum == FEE_NULL)  && (valid_status == FEE_NULL) && (invalid_status == FEE_NULL))
        {
            /* empty area */

            psc.PscBitField.Psc1 = Fee_OldSectorStatusArray[2].FeePsc1;
            psc.PscBitField.Psc2 = Fee_OldSectorStatusArray[2].FeePsc2;
            
            /* Deviation from MISRA-C:2004 rule 10.3, MISRA-C:2012 Rule-10.8, Rule-12.1
                Justification: This is the necessary algrithm. Casting to different type for consistency. */
            /* PRQA S 3395,4391 1 */
            psc.PscBitField.PscChecksum = (uint16)(psc.PscBitField.Psc1 + psc.PscBitField.Psc2 + (psc.PscBitField.Psc1 * psc.PscBitField.Psc2));
            
            Fee_InfoDataBuffer = psc.PscInfo;
            /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
                Justification: Cast between a pointer to object and an integral type.
                                This deviation is due to doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            write_start_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR_OLD(dst_sector_no) + FEE_PSC_OFFSET;
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
                Justification: Cast between a pointer to object and an integral type.
                                Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 306,310 1 */
            (void)Fee_FlsWrite(write_start_addr, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_PSC_SIZE);
            
            /* => 1-6.move data from source to destination via old construction when there only two sector and no sector to erase */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING6_CHK_PSC)
        }
        else
        {
            /* invalid block or corrupt block */
            /* update current position */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
            /* => 1-4.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4_CHK_BLK;
        }
    }

/* 1-5-0.memory copy */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4A_MEMORY_COPY )
    {
        /* copy last valid block to buffer */
        data_ptr  = Fee_GetDataBufferRecycle();
        blk_idx   = Fee_BlockNumberToIndex((uint16)Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
        blk_cfg   = Fee_GetBlkCfg(blk_idx);
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
        Justification: Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 310 1*/
        retval_sub_func = Fee_MemCpy1((uint8*)data_ptr, src_data_ptr, (uint16)Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize));
        if( retval_sub_func == FEE_OK )
        {
            /* => 1-5.write block */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING5_WRT_BLK;
        }
        else
        {
            /* continue */
            /* 1-5-0.memory copy */
        }
    }

/* 1-5.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING5_WRT_BLK )
    {
        data_ptr  = Fee_GetDataBufferRecycle();
        /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
           Justification: Casting to different object pointer type. And this casting is safety by judgment.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 310 1 */
        retval_sub_func = Fee_WriteBlock(dst_sector_no, dst_ptr, (uint8*)data_ptr, FEE_ADJUSTING_USE_OLD_STRUCT);

        if( retval_sub_func == FEE_OK )
        {
            /* update current position */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 2 */
            dst_ptr = (Fee_BlockManagementInfoType*)((uint8*)dst_ptr + FEE_BLOCK_MANAGE_SIZE);
            src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
            
            /* => 1-4.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING4_CHK_BLK;
        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 1-6.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING6_CHK_PSC )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* 1-7.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING7_SET_ENABLE;
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;

            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }

    }

/* 1-7.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING7_SET_ENABLE )
    {
        retval_sub_func = Fee_SetOldSector(dst_sector_no, FEE_SECTOR_ENABLE);

        if( retval_sub_func == FEE_OK )
        {
            /* => 1-8.move data from source to destination via old construction when there only two sector and no sector to erase */
            proc = FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING8_SET_GARBAGE;
        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 1-8.move data from source to destination via old construction when there only two sector and no sector to erase */
    if( proc == FEE_ADJUSTING_WORK_FLASH_OLD_CONSTRUCTION_MOVING8_SET_GARBAGE )
    {
        retval_sub_func = Fee_SetOldSector(src_sector_no, FEE_SECTOR_GARBAGE);

        if( retval_sub_func == FEE_OK )
        {
            src_sector_no = dst_sector_no;
            proc = FEE_ADJUSTING_WORK_FLASH_RESTART_INIT_STACK;
        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 2.set source sector to moving */
    if( proc == FEE_ADJUSTING_WORK_FLASH_SET_MOVING_SECTOR )
    {
        retval_sub_func = Fee_SetOldSector(src_sector_no, FEE_SECTOR_MOVING);

        if( retval_sub_func == FEE_OK )
        {
            /* => 3.get destination sector */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_DST_SECTOR;
        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 3.get destination sector */
    if( proc == FEE_ADJUSTING_WORK_FLASH_GET_DST_SECTOR )
    {
        /* reset address index of blocks */
        Fee_ResetBlockIndex();

        dst_sector_no = Fee_GetDisableSector(sector_start_addrss_of_old_config, sector_end_addrss_of_old_config);

        if( dst_sector_no == FEE_NONE_SECTOR )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)(FEE_GET_FLASH_SECTOR_START_ADDR_OLD(src_sector_no) + FEE_TOP_BLOCK_OFFSET);
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly. */
            /* PRQA S 306,310,488,1840,3305 1 */
            dst_ptr = (Fee_BlockManagementInfoType*)(FEE_GET_FLASH_SECTOR_START_ADDR(dst_sector_no) + FEE_TOP_BLOCK_OFFSET);

            Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH;
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;

            /* => 4-1.get write start flag blank or not */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG;
        }
    }

/* 4-1.get write start flag blank or not */
    if( proc == FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            write_start_flag = Fee_FlsGetReadAddr((uint32)(src_ptr)); /* check WriteFlag */

            /* => 4-2.get blocknumber and page number blank or not */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_GET_BNUMANDPNUM)
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr, &Fee_InfoDataBuffer, FEE_BLOCK_WRITEFLAG_SIZE);
            fee_fault = Fee_GetFlsFault();
            if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
            {
                Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            }
            Fee_FlsDisableDMA();
            write_start_flag = Fee_InfoDataBuffer;
            /* => 4-2.get blocknumber and page number blank or not */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_BNUMANDPNUM;
        }
    }

/* 4-2.get blocknumber and page number blank or not */
    if( proc == FEE_ADJUSTING_WORK_FLASH_GET_BNUMANDPNUM )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        bnum_pnum = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE);

        /* => 4-3.get valid flag blank or not */
        FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_GET_VALIDFLAG)
    }

/* 4-3.get valid flag blank or not */
    if( proc == FEE_ADJUSTING_WORK_FLASH_GET_VALIDFLAG )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            valid_status = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE); /* check ValidStat */

            /* => 4-4.get invalid flag blank or not */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_GET_INVALIDFLG)
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE + FEE_BLOCK_STATUS_SIZE, &Fee_InfoDataBuffer, FEE_BLOCK_STATUS_SIZE);
            fee_fault = Fee_GetFlsFault();
            if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
            {
                Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            }
            valid_status = Fee_InfoDataBuffer;
            /* => 4-4.get invalid flag blank or not */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_INVALIDFLG;
        }
    }

/* 4-4.get invalid flag blank or not */
    if( proc == FEE_ADJUSTING_WORK_FLASH_GET_INVALIDFLG )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            invalid_status = Fee_FlsGetReadAddr((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* check InvalidStat */

            /* => 4-4-a. save block infor to variable  */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_SAVE_BLOCK_INFOR)
        }
        else
        {
            Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)src_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, &Fee_InfoDataBuffer, FEE_BLOCK_STATUS_SIZE);
            fee_fault = Fee_GetFlsFault();
            if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
            {
                Fee_InfoDataBuffer = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            }
            Fee_FlsDisableDMA();
            invalid_status = Fee_InfoDataBuffer;

            /* => 4-4-a. save block infor to variable  */
            proc = FEE_ADJUSTING_WORK_SAVE_BLOCK_INFOR;
        }
    }

/* 4-4-a. save block infor to variable */
    if(proc == FEE_ADJUSTING_WORK_SAVE_BLOCK_INFOR)
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            if( write_start_flag == FEE_NULL )
            {
                Fee_LastBlockIsFound = (uint8)FEE_ON; /* write_start_flag is blank */
            }
            else
            {
                Fee_LastBlockIsFound = (uint8)FEE_OFF; /* write_start_flag is not blank */
            }
        }
        else
        {
            if( write_start_flag != FEE_BLOCK_FLAG_VALUE )
            {
                Fee_LastBlockIsFound = (uint8)FEE_ON; /* write_start_flag is blank */
            }
            else
            {
                Fee_LastBlockIsFound = (uint8)FEE_OFF; /* write_start_flag is not blank */
            }
        }

        if(Fee_BlockInforDuringSearchWorkFlashCnt == 0U)
        {
            Fee_BlockInforDuringSearchWorkFlash[0].write_start_flag = write_start_flag;
            Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum = bnum_pnum;
            Fee_BlockInforDuringSearchWorkFlash[0].valid_status = valid_status;
            Fee_BlockInforDuringSearchWorkFlash[0].invalid_status = invalid_status;

            /* Save first one, then search the second one directly */

            /* update current position */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);

            /* => 4-1.get write start flag blank or not */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG;
        }
        else if(Fee_BlockInforDuringSearchWorkFlashCnt == 1U)
        {
            Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag = write_start_flag;
            Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum = bnum_pnum;
            Fee_BlockInforDuringSearchWorkFlash[1].valid_status = valid_status;
            Fee_BlockInforDuringSearchWorkFlash[1].invalid_status = invalid_status;

            /* => 4-5.search enable block from source sector  */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_ENABLE_DATA;
        }
        else /* Fee_BlockInforDuringSearchWorkFlashCnt == 2,3... */
        {
            Fee_BlockInforDuringSearchWorkFlash[0] = Fee_BlockInforDuringSearchWorkFlash[1];
            Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag = write_start_flag;
            Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum = bnum_pnum;
            Fee_BlockInforDuringSearchWorkFlash[1].valid_status = valid_status;
            Fee_BlockInforDuringSearchWorkFlash[1].invalid_status = invalid_status;

            /* => 4-5.search enable block from source sector  */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_ENABLE_DATA;
        }
        Fee_BlockInforDuringSearchWorkFlashCnt++;
    }

/* 4-5.search enable block from source sector */
    if( proc == FEE_ADJUSTING_WORK_FLASH_GET_ENABLE_DATA )
    {
        src_ptr_temp_ptr = src_ptr;
        retval_sub_func = Fee_SearchValidBlockOldConfig(&src_ptr,
            Fee_BlockInforDuringSearchWorkFlash[0].write_start_flag,
            Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum,
            Fee_BlockInforDuringSearchWorkFlash[0].valid_status,
            Fee_BlockInforDuringSearchWorkFlash[0].invalid_status,
            src_sector_no);
        if(
        ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
        (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
        (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
        (FEE_NULL == Fee_BlockInforDuringSearchWorkFlash[1].invalid_status)) ||
        ((FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].write_start_flag) &&
        (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].bnum_pnum) &&
        (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].valid_status) &&
        (FEE_NULL != Fee_BlockInforDuringSearchWorkFlash[1].invalid_status))
        )
        {
            /* when next block is valid block and invalid block do nothing */
        }
        else
        {
            pre_block.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
            Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync(Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum, &pre_block.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
            fee_fault = Fee_GetFlsFault();
            Fee_FlsDisableDMA();
            if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
            {
                /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                pre_blk_idx = Fee_BlockNumberToIndex(pre_block.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
            }
        }

        if( src_ptr_temp_ptr != src_ptr)
        {
            /* => 4-1.get write start flag blank or not */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG)
        }

        switch(retval_sub_func)
        {
        case FEE_BLOCK_NONE_SEARCH:
            /* block search complete */
            /* clear empty address */
            Fee_SetBlkMgtAreaEmptyAddr((Fee_BlockManagementInfoType*)FEE_NULL);
            Fee_SetBlkPageAreaEmptyAddr((uint32*)FEE_NULL);
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;
            /* => 8.set PSC(physical sector count) */
            proc = FEE_ADJUSTING_WORK_FLASH_SET_PSC;
            break;
        case FEE_OK:
            /* => 4-6.get block no and page no*/
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_GET_BLOCKNO_PAGENO)
            break;
        case FEE_NG:
            Fee_BlockInforDuringSearchWorkFlashCnt = (uint8)FEE_ZERO;
            Fee_LastBlockIsFound = (uint8)FEE_OFF;
            Fee_JobResult = MEMIF_JOB_FAILED;
            Fee_ErrorCallout( FEE_EVENT_HARDWARE_ERROR_OCCURRED );
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
            break;

        default:/* FEE_CONT */

            /* continue */
            break;
        }
    }

/* 4-6. get block no and page no*/
    if(proc == FEE_ADJUSTING_WORK_FLASH_GET_BLOCKNO_PAGENO)
    {
        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync(Fee_BlockInforDuringSearchWorkFlash[0].bnum_pnum, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_STATUS_SIZE);
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            if(Fee_LastBlockIsFound == (uint8)FEE_OFF)
            {
                /* update current position */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
            }

            /* => 4-1.get write start flag blank or not */
            proc = FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG;
        }
        else
        {
            /* block exist */
            fee_cfg = Fee_GetCfg();
            /* Deviation from MISRA-C:2004 rule 10.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.4, Rule-10.4
               Justification: Cast between a pointer to object and an integral type.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic.
                              This deviation is due to converting signed and non-negative value to an unsigned type implicitly.
                              The formula has been tested. */
            /* PRQA S 306,488,1840,1860 1 */
            src_data_ptr = Fee_CalPhysicalAddrFromPageNoOldConfig(src_sector_no, Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
            flag_from_flash = (uint32)Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum;
            blk_idx = Fee_BlockNumberToIndex((uint16)flag_from_flash);
            
            blk_cfg = Fee_GetBlkCfg(blk_idx);
            used_pages_size += Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize);
            
            if( (Fee_PeriInfo.Fee_MainState & FEE_MAIN_STATE_INITIALIZING) == FEE_MAIN_STATE_INITIALIZING )
            {
                if( blk_cfg.FeeImmediateData == TRUE )
                {
                    used_reserve_size += (Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize) + (uint16)FEE_BLOCK_MANAGE_SIZE);
                }
            }
            
            Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.PageNum = (uint16)(used_pages_size/fee_cfg.FeeVirtualPageSize);
            /* => 5-0.copy src data to buffer for last valid block */
            proc = FEE_ADJUSTING_WORK_COPY_TO_BUFFER_FOR_LAST_VALID_BLOCK;
        }
    }

/* 5-0.copy src data to buffer for last valid block */
    if( proc == FEE_ADJUSTING_WORK_COPY_TO_BUFFER_FOR_LAST_VALID_BLOCK )
    {
        fee_cfg = Fee_GetCfg();
        blk_idx = Fee_BlockNumberToIndex((uint16)Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
        /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
           MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5
            Justification: Cast between a pointer to object and an integral type.
            This deviation is due to doing pointer arithmetic.
            This deviation is due to an integer type cast to do pointer arithmetic. 
            It is no problem because side effects cannot be caused */
        /* PRQA S 3395,3415 7 */
        if(
            (
             (Fee_LastBlockIsFound == (uint8)FEE_ON) ||
             (Fee_GetIsNextBlockCorrupt(Fee_CurrentConfigNo, blk_idx) == FEE_NEXT_BLOCK_IS_CORRUPT)
            ) &&
            (((Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum * fee_cfg.FeeVirtualPageSize + FEE_ERASE_COMPLETE_FLAG_SIZE) % FEE_CHECK_BYTES_ALIGN) != (uint8)0) 
          )
        {
            /* copy last valid block to buffer */
            data_ptr     = Fee_GetDataBufferRecycle();
            blk_cfg      = Fee_GetBlkCfg(blk_idx);
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
            Justification: Casting to different object pointer type. And this casting is safety by judgment. */
            /* PRQA S 310 1*/
            retval_sub_func = Fee_MemCpy1((uint8*)data_ptr, src_data_ptr, (uint16)Fee_GetPageSizeAlignSize(blk_cfg.FeeBlockSize));
            if( retval_sub_func == FEE_OK )
            {
                /* => 5.write block */
                proc = FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK;
                Fee_UseFlashOrBuffer = FEE_USE_RAM_TO_FLASH; /* set for UseIndex pattern */
            }
            else
            {
                /* continue */
                /* 5-0.copy src data to buffer for last valid block */
            }
        }
        else
        {
            /* no need to copy last valid block to buffer */
            /* => 5.write block */
            proc = FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK;
            Fee_UseFlashOrBuffer = FEE_USE_FLASH_TO_FLASH; /* set for UseIndex pattern */
        }
    }

/* 5.write block */
    if( proc == FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK )
    {
        if(Fee_UseFlashOrBuffer == FEE_USE_FLASH_TO_FLASH)
        {
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            Implementation often uses pointer access by array-subscripting.*/
            /* PRQA S 310 1 */
            retval_sub_func = Fee_WriteBlock(dst_sector_no, dst_ptr, (uint8*)src_data_ptr, FEE_ADJUSTING_USE_NEW_STRUCT);
        }
        else
        {
            data_ptr     = Fee_GetDataBufferRecycle();
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            Implementation often uses pointer access by array-subscripting.*/
            /* PRQA S 310 1 */
            retval_sub_func = Fee_WriteBlock(dst_sector_no, dst_ptr, (uint8*)data_ptr, FEE_ADJUSTING_USE_NEW_STRUCT);
        }

        if( retval_sub_func == FEE_OK )
        {
            block_addr_index = Fee_GetBlockAddrIndex(blk_idx);
            if( block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK )
            {
                /* old block exist */
                /* => 7.invalidate old block */
                proc =  FEE_ADJUSTING_WORK_FLASH_WRITE_DISABLE;
            }
            else
            {
                /* => 6.update index after block copy */
                proc = FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK_UPDATE_INDEX;
            }
        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 6.update index after block copy */
    if( proc == FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK_UPDATE_INDEX )
    {
        /* update address index of blocks */
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        block_addr_index.BlkAddr       = (uint32)dst_ptr;
        block_addr_index.BlkStatus     = FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE;
        block_addr_index.BlkBlankCheck = FEE_BLANK_CHECK_DONE;
        Fee_SetBlockAddrIndex(blk_idx, block_addr_index);

        /* update current position */
        /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
           Justification: Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 310,488,3305 1 */
        dst_ptr = (Fee_BlockManagementInfoType*)((uint8*)dst_ptr + FEE_BLOCK_MANAGE_SIZE);
        if(Fee_LastBlockIsFound == (uint8)FEE_OFF)
        {
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
            Justification: Casting to different object pointer type. And this casting is safety by judgment.
                            This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            src_ptr = (Fee_BlockManagementInfoType*)((uint8*)src_ptr + FEE_BLOCK_MANAGE_SIZE);
        }

        /* => 4-1.get write start flag blank or not */
        proc = FEE_ADJUSTING_WORK_FLASH_GET_WRITESTARTFLAG;
    }

/* 7.invalidate old block */
    if( proc == FEE_ADJUSTING_WORK_FLASH_WRITE_DISABLE )
    {
        Fee_InfoDataBuffer = FEE_BLOCK_INVALID_BLOCK;
        block_addr_index = Fee_GetBlockAddrIndex(blk_idx);
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        old_block_ptr = (Fee_BlockManagementInfoType*)(block_addr_index.BlkAddr);
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite((uint32)old_block_ptr + FEE_BLOCK_WRITEFLAG_SIZE + FEE_BLOCK_BLKNUMPAGENUM_SIZE, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_BLOCK_STATUS_SIZE); /* write InvalidStat */

        /* => 7-a.check result of invalidating old block */
        FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_WRITE_DISABLE_CHECK)
    }

/* 7-a.check result of invalidating old block */
    if( proc == FEE_ADJUSTING_WORK_FLASH_WRITE_DISABLE_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* 6.update index after block copy */
            proc = FEE_ADJUSTING_WORK_FLASH_WRITE_BLOCK_UPDATE_INDEX;

            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;

            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 8.set PSC(physical sector count) */
    if( proc == FEE_ADJUSTING_WORK_FLASH_SET_PSC )
    {
        Fee_InfoDataBuffer = Fee_CalculatePSC();
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        write_start_addr = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(dst_sector_no) + FEE_PSC_OFFSET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment. */
        /* PRQA S 306,310 1 */
        (void)Fee_FlsWrite(write_start_addr, (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_PSC_SIZE);

        /* => 8-a.check result of writing */
        FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_SET_PSC_CHECK)
    }

/* 8-a.check result of writing */
    if( proc == FEE_ADJUSTING_WORK_FLASH_SET_PSC_CHECK )
    {
        retjob = Fee_FlsGetJobResult();    /* get result of operation */

        switch(retjob)
        {
        case MEMIF_JOB_OK:
            /* 9.set enable sector */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_SET_ENABLE_SECTOR)
            break;

        case MEMIF_JOB_FAILED:
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;

            break;

        default: /* MEMIF_JOB_PENDING */
            break;
        }
    }

/* 9.set enable sector */
    if( proc == FEE_ADJUSTING_WORK_FLASH_SET_ENABLE_SECTOR )
    {
        retval_sub_func = Fee_SetSector(dst_sector_no, FEE_SECTOR_ENABLE);

        if( retval_sub_func == FEE_OK )
        {
            /* update empty address and empty size */
            blk_mgt_area_empty_addr_ptr = dst_ptr;
            Fee_SetBlkMgtAreaEmptyAddr(blk_mgt_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-12.1
               Justification: Cast between a pointer to object and an integral type.
                              Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic.
                              This deviation is due to an integer type cast to do pointer arithmetic. */
            /* PRQA S 306,310,488,3395,3305 1 */
            blk_page_area_empty_addr_ptr = (uint32*)((Fee_GetFlashSectorEraseFlagAddr(dst_sector_no)) - used_pages_size);
            Fee_SetBlkPageAreaEmptyAddr(blk_page_area_empty_addr_ptr);
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            blk_empty_size = (uint16)((uint32)blk_page_area_empty_addr_ptr - (uint32)blk_mgt_area_empty_addr_ptr);
            Fee_SetBlkEmptySize(blk_empty_size);

            erase_sector_no   = (uint8)1;
            /* => 10.erasing sector source */
            FEE_SET_PROC(FEE_ADJUSTING_WORK_FLASH_ERASING_SECTORSRC)

        }
        else if( retval_sub_func == FEE_NG )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_NG;
        }
        else
        {
            /* continue */
        }
    }

/* 10.erasing sector source */
    if( proc == FEE_ADJUSTING_WORK_FLASH_ERASING_SECTORSRC )
    {
        if(erase_sector_no <= Fee_GetNoOfSec())
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
               Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306,488 1 */
            sector_start_addrss_of_new_config = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(erase_sector_no);
            if(erase_sector_no == Fee_GetNoOfSec())
            {
                sector_end_addrss_of_new_config = sector_start_addrss_of_new_config + Fee_GetSectorSize() + Fee_GetRemainSize() - (uint32)1;
            }
            else
            {
                sector_end_addrss_of_new_config = sector_start_addrss_of_new_config + Fee_GetSectorSize() - (uint32)1;
            }

            if((sector_start_addrss_of_new_config < sector_end_addrss_of_old_config) &&
              (sector_end_addrss_of_new_config > sector_start_addrss_of_old_config))
            {
                erase_result = Fee_EraseSector(erase_sector_no);
                
                switch(erase_result)
                {
                case FEE_OK:
                    erase_sector_no++;
                    /* get next sector to erase */
                    /* => 10.erasing sector source */
                    proc = FEE_ADJUSTING_WORK_FLASH_ERASING_SECTORSRC;
                    break;
                
                case FEE_NG:
                    /* => X.end of periodic processing */
                    proc = FEE_ADJUSTING_WORK_FLASH_END;
                    retval = FEE_NG;
                    break;
                
                default: /* FEE_CONT */
                    /* do nothing */
                    break;
                }
            }
            else
            {
                /* current sector is including valid blocks, do not erase, go get next sector */
                erase_sector_no++;
            }
        }
        else
        {
            /* => 11.change block index status */
            proc = FEE_ADJUSTING_WORK_FLASH_CHANGE_BLK_IDX_STATUS;
            retval = FEE_OK;
        }
    }

/* 11. change block index status */
    if( proc == FEE_ADJUSTING_WORK_FLASH_CHANGE_BLK_IDX_STATUS )
    {
        /* if recycle is successful, save index from temporary array to normal array */
        cnt = 0;
        while( (cnt_block_index < Fee_GetNoOfBlocks()) && (cnt < FEE_CPY_BLK_INDEX_MAX) )
        {
            block_addr_index = Fee_GetBlockAddrIndex(cnt_block_index);
            if(block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE)
            {
                block_addr_index.BlkStatus = FEE_BLKIDX_VALID_BLOCK;
                Fee_SetBlockAddrIndex(cnt_block_index, block_addr_index);
                Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, cnt_block_index, FEE_NEXT_BLOCK_IS_NOT_CORRUPT);
            }

            cnt_block_index++;
            cnt++;
        }

        if( cnt_block_index >= Fee_GetNoOfBlocks() )
        {
            /* => X.end of periodic processing */
            proc = FEE_ADJUSTING_WORK_FLASH_END;
            retval = FEE_OK;
        }
        else
        {
            /* do not change proc, continue copy index */
        }
    }


/* X.end of periodic processing */
    if( proc == FEE_ADJUSTING_WORK_FLASH_END )
    {
        proc = FEE_ADJUSTING_WORK_FLASH_START;
    }
    else
    {
        FEE_PUSH_STACK_USHORT(current_pages_size)
        FEE_PUSH_STACK_USHORT(front_pages_size)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 4 */
        FEE_PUSH_STACK_ULONG(invalid_status)
        FEE_PUSH_STACK_ULONG(valid_status)
        FEE_PUSH_STACK_ULONG(bnum_pnum)
        FEE_PUSH_STACK_ULONG(write_start_flag)
        FEE_PUSH_STACK_USHORT(cnt_block_index)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(src_ptr)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(dst_ptr)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_POINTER(src_data_ptr)
        FEE_PUSH_STACK_USHORT(blk_idx)
        FEE_PUSH_STACK_USHORT(used_reserve_size)
        FEE_PUSH_STACK_USHORT(used_pages_size)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_UCHAR(dst_sector_no)
        /* Deviation from MISRA-C:2004 rule 12.8, 17.4, MISRA-C:2012 Rule-18.4, Rule-12.2
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          This deviation is due to doing pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          This deviation is due to a shift conversion for handling the uint64 variable. */
        /* PRQA S 488,2790 1 */
        FEE_PUSH_STACK_ULONG(sector_end_addrss_of_old_config)
        /* Deviation from MISRA-C:2004 rule 12.8, 17.4, MISRA-C:2012 Rule-18.4, Rule-12.2
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          This deviation is due to doing pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          This deviation is due to a shift conversion for handling the uint64 variable. */
        /* PRQA S 488,2790 1 */
        FEE_PUSH_STACK_ULONG(sector_start_addrss_of_old_config)
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_UCHAR(erase_sector_no)    
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 306,488 1 */
        FEE_PUSH_STACK_UCHAR(src_sector_no)
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 2 */
        FEE_PUSH_STACK_ULONG(erase_length)
        FEE_PUSH_STACK_ULONG(erase_target_addr)
    }

    FEE_PUSH_PROC(proc)                /* evacuate processing */

    if( proc != FEE_ADJUSTING_WORK_FLASH_START )
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_SetOldSector
**
** Set sector of old configuration.
**
** \param[in]  sector_no  sector number
** \param[in]  status     sector status
**
** \return     result of processing
** \retval     FEE_OK     success
** \retval     FEE_NG     failed
** \retval     FEE_CONT   continue
**
*/
static FUNC(uint8, FEE_CODE) Fee_SetOldSector(
  VAR(uint8, AUTOMATIC) sector_no,
  VAR(uint8, AUTOMATIC) status)
{
    VAR(Fee_SetOldSectorToMovingProcType, AUTOMATIC)  proc;              /* position of the processing */
    VAR(uint8, AUTOMATIC)                             retval;            /* return value */
    P2VAR(uint8, AUTOMATIC, AUTOMATIC)                write_addr_ptr;    /* pointer to write address */
    VAR(uint8, AUTOMATIC)                             write_end_pos;     /* end position of writing */
    VAR(uint8, AUTOMATIC)                             write_pos;         /* position of writing */
    VAR(uint32, AUTOMATIC)                            flag_from_flash;   /* temporary variable for storing the flag read from flash */
    retval = FEE_OK;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SetOldSectorToMovingProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_SET_OLD_SECTOR_TO_MOVING_START )
    {
        if( status == FEE_SECTOR_MOVING )
        {
            /* moving sector */
            /* Deviation from MISRA-C:2012 Rule-10.1
               Justification: This is the algrithm. */
            /* PRQA S 4544 1 */
            write_end_pos = (uint8)(FEE_SECTOR_ONE_STATUS_SIZE << 1);
            write_pos      = (uint8)FEE_ZERO;
        }
        else
        {
            /* enable or garbage sector */
            write_end_pos = (uint8)(FEE_SECTOR_ONE_STATUS_SIZE * ((status - FEE_SECTOR_ENABLE) + (uint8)1));
            write_pos      = (uint8)(FEE_SECTOR_ONE_STATUS_SIZE * (status - FEE_SECTOR_ENABLE ));
        }

        /* =>1.set sector status */
        proc = FEE_SET_OLD_SECTOR_TO_MOVING_SET;
    }
    else
    {
        FEE_POP_STACK_UCHAR(write_pos)
        FEE_POP_STACK_UCHAR(write_end_pos)
    }

/* 1.set sector status */
    if( proc == FEE_SET_OLD_SECTOR_TO_MOVING_SET )
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,488 1 */
        write_addr_ptr = FEE_GET_FLASH_SECTOR_START_ADDR_OLD(sector_no);
        /* Deviation from MISRA-C:2004 rule 1.1, MISRA-C:2012 Rule-1.1
           Justification: 64bit is supported by the long long in ARM. */
        /* PRQA S 580 1 */
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_SET;
        /* Deviation from MISRA-C:2004 rule 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic. */
        /* PRQA S 306,310,488 1 */
        (void)Fee_FlsWrite((uint32)(write_addr_ptr + write_pos), (uint8*)(&Fee_InfoDataBuffer), (uint32)FEE_SECTOR_ONE_STATUS_SIZE);

        /* =>2.check completion of writing sector status */
        FEE_SET_PROC(FEE_SET_OLD_SECTOR_TO_MOVING_SET_FINAL)
    }

/* 2.check completion of writing sector status */
    if( proc == FEE_SET_OLD_SECTOR_TO_MOVING_SET_FINAL )
    {
        write_pos += (uint8)FEE_SECTOR_ONE_STATUS_SIZE;
        if( write_pos >= write_end_pos )
        {
            /* =>3.check result of writing sector status  */
            FEE_SET_PROC(FEE_SET_OLD_SECTOR_TO_MOVING_CHECK)
        }
        else
        {
            /* =>1.set sector status */
            FEE_SET_PROC(FEE_SET_OLD_SECTOR_TO_MOVING_SET)
        }
    }

/* 3.check result of writing sector status    */
    if( proc == FEE_SET_OLD_SECTOR_TO_MOVING_CHECK )
    {
        if( Fee_FlsGetJobResult() == MEMIF_JOB_OK )
        {
            retval = FEE_OK;
        }
        else
        {
            if( status == FEE_SECTOR_GARBAGE )
            {
                /* Deviation from MISRA-C:2004 rule 10.5, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-10.8
                   Justification: Cast between a pointer to object and an integral type.
                                  This deviation is due to doing pointer arithmetic.
                                  The result type of shift conversion must be explicit. */
                /* PRQA S 306,488,4399 1 */
                write_addr_ptr = FEE_GET_FLASH_SECTOR_START_ADDR_OLD(sector_no) + (uint32)(FEE_SECTOR_ONE_STATUS_SIZE << 1U);
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 11.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3
                   Justification: Casting to different object pointer type. And this casting is safety by judgment. */
                /* PRQA S 306,310 1 */
                flag_from_flash = Fee_FlsGetReadAddr((uint32)write_addr_ptr);

                if( flag_from_flash != FEE_NULL )
                {
                    retval = FEE_OK;
                }
                else
                {
                    retval = FEE_NG;
                }
            }
            else
            {
                retval = FEE_NG;
            }
        }
        /* =>X.end of periodic processing */
        proc = FEE_SET_OLD_SECTOR_TO_MOVING_END;
    }

/* X.end of periodic processing */
    if( proc == FEE_SET_OLD_SECTOR_TO_MOVING_END )
    {
        /* =>0.entry of periodic processing */
        proc = FEE_SET_OLD_SECTOR_TO_MOVING_START;
    }
    else
    {
        FEE_PUSH_STACK_UCHAR(write_end_pos)
        FEE_PUSH_STACK_UCHAR(write_pos)
    }

    FEE_PUSH_PROC(proc)

    if( proc != FEE_SET_OLD_SECTOR_TO_MOVING_START )
    {
        retval = FEE_CONT;
    }

    return retval;
}


/** \brief Fee_SearchValidBlockOldConfig
**
** Search valid block one by one on work flash.
**
** src_ptr is only incremented in this function.
** Use other four parameters for block information.
** Current block infor is included in the other four parameters.
** src_ptr is always pointed to the next block.
** In this function, please only do src_ptr+=16.
**
** \param[inout]     src_ptr            search position
**
** \return     result
** \retval     FEE_OK(0)                       block has been found
** \retval     FEE_NG(1)                       read failure
** \retval     FEE_BLOCK_NONE_SEARCH(3)        block search complete
** \retval     FEE_CONT(255)                   continue to get next block
**
*/
static FUNC(uint8, FEE_CODE) Fee_SearchValidBlockOldConfig(
  P2VAR(Fee_BlockManagementInfoType*, AUTOMATIC, FEE_APPL_DATA) src_ptr,
  VAR(uint32, AUTOMATIC) write_start_flag,
  VAR(uint32,AUTOMATIC) bnum_pnum,
  VAR(uint32,AUTOMATIC) valid_status,
  VAR(uint32,AUTOMATIC) invalid_status,
  VAR(uint8,AUTOMATIC) src_sector_no)
{
    VAR(Fee_SearchValidOldProcType, AUTOMATIC)   proc;                         /* position of the processing */
    VAR(uint8, AUTOMATIC)                        retval;                       /* return value */
    VAR(uint16, AUTOMATIC)                       block_no;                     /* block number */
    VAR(uint16, AUTOMATIC)                       blk_idx;                      /* block number index */
    VAR(uint16, AUTOMATIC)                       page_no_current;              /* current page number */
    VAR(uint16, AUTOMATIC)                       page_no_current_page_cnt_recalculate;  /* if size not match, consider the pre block is max, then re-calculate the current block: current - max - prepre */
    VAR(uint16, AUTOMATIC)                       block_size_from_workflash;    /* block size from work flash */
    VAR(Fee_ConfigType, AUTOMATIC)               fee_cfg;                      /* fee configuration */
    VAR(uint8, AUTOMATIC)                        branch_flag;                  /* branch flag */
    VAR(Fee_FaultType, AUTOMATIC)                fee_fault;                    /* get fault information from FLS */
    VAR(Fee_BlockConfigType, AUTOMATIC)          blk_cfg_on_flash;             /* block configuration*/
    VAR(Fee_BlockManagementInfoType, AUTOMATIC)  pre_pre_block;                /* the pre-pre block of current block */
    VAR(uint16, AUTOMATIC)                       pre_pre_blk_idx;              /* block number index */
    VAR(Fee_BlockAddrIndexType, AUTOMATIC)       pre_pre_block_addr_index;     /* index of blocks */

    retval             = FEE_CONT;
    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is initialization. */
    /* PRQA S 2982 1 */
    page_no_current    = (uint16)FEE_ZERO;
    fee_cfg            = Fee_GetCfg();

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_SearchValidOldProcType)

/* 0.entry of periodic processing */
    if( proc == FEE_SEARCH_VALID_OLD_START )
    {
        /* =>1.search valid block */
        proc = FEE_SEARCH_VALID_OLD_PRE_GET_BLOCKNO_PAGENO;
    }

/* 1.search valid block */
    if( proc == FEE_SEARCH_VALID_OLD_PRE_GET_BLOCKNO_PAGENO )
    {
        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            if( write_start_flag == FEE_NULL )
            {
                branch_flag = (uint8)1;
            }
            else
            {
                branch_flag = (uint8)0;
            }
        }
        else
        {
            if( write_start_flag != FEE_BLOCK_FLAG_VALUE )
            {
                branch_flag = (uint8)1;
            }
            else
            {
                branch_flag = (uint8)0;
            }
        }

        if( branch_flag == (uint8)1 )
        {
            /* block search complete */
            retval = FEE_BLOCK_NONE_SEARCH;
            /* => X.end of periodic processing */
            proc = FEE_SEARCH_VALID_OLD_END;
        }
        else
        {
            if( bnum_pnum != FEE_NULL )
            {
                /* 2.get old block page no */
                proc = FEE_SEARCH_VALID_OLD_GET_BLOCKNO_PAGENO;
            }
            else
            {
                /* update current src position to find next block */
                /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
                   Justification: Casting to different object pointer type. And this casting is safety by judgment.
                                  This deviation is due to doing pointer arithmetic. */
                /* PRQA S 310,488,3305 1 */
                *src_ptr = (Fee_BlockManagementInfoType*)((uint8*)*src_ptr + FEE_BLOCK_MANAGE_SIZE);
                retval = FEE_CONT;
                /* => X.end of periodic processing */
                proc = FEE_SEARCH_VALID_OLD_END;
            }
        }
    }

/* 2.get block no and page no */
    if(proc == FEE_SEARCH_VALID_OLD_GET_BLOCKNO_PAGENO)
    {
        Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync(bnum_pnum, &Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            /* update current src position to find next block */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            *src_ptr = (Fee_BlockManagementInfoType*)((uint8*)*src_ptr + FEE_BLOCK_MANAGE_SIZE);
            retval = FEE_CONT;
            /* => X.end of periodic processing */
            proc = FEE_SEARCH_VALID_OLD_END;
        }
        else
        {
            /* => 3.search action */
            proc = FEE_SEARCH_VALID_OLD_ACTION;
        }
    }

/* 3.search action */
    if(proc == FEE_SEARCH_VALID_OLD_ACTION)
    {
        block_no = (uint16)(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
        blk_idx = Fee_BlockNumberToIndex(block_no);
        page_no_current = (uint16)(Fee_BlkMgtInfoForReadBlockNoPageNo.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
        block_size_from_workflash = (page_no_current - Fee_PageNoFront) * fee_cfg.FeeVirtualPageSize;
        Fee_PageNoFront = page_no_current;

        if( STD_OFF == Fee_GetBlockBlankCheckOff() )
        {
            if( (valid_status != FEE_NULL) && (invalid_status == FEE_NULL) )
            {
                branch_flag = (uint8)1;
            }
            else
            {
                branch_flag = (uint8)0;
            }
        }
        else
        {
            if( (valid_status == FEE_BLOCK_FLAG_VALUE) && (invalid_status != FEE_BLOCK_FLAG_VALUE) )
            {
                branch_flag = (uint8)1;
            }
            else
            {
                branch_flag = (uint8)0;
            }
        }
        
        if( branch_flag == (uint8)1 )
        {
            /* this block is a valid block */
            if( blk_idx != (uint16)0xFFFF ) /* block is configured or not */
            {
                if(STD_OFF == Fee_GetDefinedThresholdPageSize())
                {
                    if(block_size_from_workflash <= Fee_GetPageSizeAlignSize((Fee_GetBlkCfg(blk_idx)).FeeBlockSize))
                    {
                        blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);
                        /* Deviation from MISRA-C:2012 Rule-10.3
                        Justification: As a result of this expression, it will not exceed the essential type. */
                        /* PRQA S 4461 1 */
                        blk_cfg_on_flash.FeeBlockSize = block_size_from_workflash;
                        Fee_SetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx, blk_cfg_on_flash);

                        /* set Write Flag */
                        Fee_BlkMgtInfoBuffer.WriteFlag   = FEE_BLOCK_INITIAL_WRITEFLAG;
                        /* set block number */
                        Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = (uint16)block_no;
                        /* set Valid Block status */
                        Fee_BlkMgtInfoBuffer.ValidStat   = FEE_BLOCK_VALID_BLOCK;
            
                        retval = FEE_OK;
                    }
                }
                else
                {
                    if(block_size_from_workflash == Fee_GetPageSizeAlignSize((Fee_GetBlkCfg(blk_idx)).FeeBlockSize))
                    {
                        blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);
                        /* Deviation from MISRA-C:2012 Rule-10.3
                        Justification: As a result of this expression, it will not exceed the essential type. */
                        /* PRQA S 4461 1 */
                        blk_cfg_on_flash.FeeBlockSize = block_size_from_workflash;
                        Fee_SetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx, blk_cfg_on_flash);

                        /* set Write Flag */
                        Fee_BlkMgtInfoBuffer.WriteFlag   = FEE_BLOCK_INITIAL_WRITEFLAG;
                        /* set block number */
                        Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = (uint16)block_no;
                        /* set Valid Block status */
                        Fee_BlkMgtInfoBuffer.ValidStat   = FEE_BLOCK_VALID_BLOCK;
            
                        retval = FEE_OK;
                    }
                    else
                    {
                        /* calculate the sum size of pages for page number : sum = (already existed page size) + (new write target page size) */
                        /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
                            Justification: Cast between a pointer to object and an integral type.
                            This deviation is due to doing pointer arithmetic.
                            This deviation is due to an integer type cast to do pointer arithmetic. */
                        /* PRQA S 306,488 1 */
                        if((write_start_flag - (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(src_sector_no)) == FEE_SECOND_BLOCK_OFFSET)
                        {
                            /*For example, block2 is OK, block1 is Corrupt.*/
                            page_no_current_page_cnt_recalculate = page_no_current - (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U);
                            if((page_no_current_page_cnt_recalculate * fee_cfg.FeeVirtualPageSize) == Fee_GetPageSizeAlignSize((Fee_GetBlkCfg(blk_idx)).FeeBlockSize))
                            {
                                blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);
                                /* Deviation from MISRA-C:2012 Rule-10.3
                                Justification: As a result of this expression, it will not exceed the essential type. */
                                /* PRQA S 4461 1 */
                                blk_cfg_on_flash.FeeBlockSize = page_no_current_page_cnt_recalculate * fee_cfg.FeeVirtualPageSize;
                                Fee_SetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx, blk_cfg_on_flash);

                                /* set Write Flag */
                                Fee_BlkMgtInfoBuffer.WriteFlag   = FEE_BLOCK_INITIAL_WRITEFLAG;
                                /* set block number */
                                Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = (uint16)block_no;
                                /* set Valid Block status */
                                Fee_BlkMgtInfoBuffer.ValidStat   = FEE_BLOCK_VALID_BLOCK;

                                retval = FEE_OK;
                            }
                        }
                        /* calculate the sum size of pages for page number : sum = (already existed page size) + (new write target page size) */
                        /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
                            Justification: Cast between a pointer to object and an integral type.
                            This deviation is due to doing pointer arithmetic.
                            This deviation is due to an integer type cast to do pointer arithmetic. */
                        /* PRQA S 306,488,3395 1 */
                        if((write_start_flag - (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(src_sector_no)) >= FEE_THIRD_BLOCK_OFFSET)
                        {
                            /*For example, block3 is OK, block2 is Corrupt, block1 is OK.*/
                            pre_pre_block.BlkNumAndPageNum.BNumAndPNum = FEE_BLOCK_INITIAL_VALUE; /* clear value */
                            Fee_FlsEnableDMA();
                            /* ReadOperation */
                            /* Deviation from MISRA-C:2004 rule 11.3, 12.1, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-12.1
                                Justification: Cast between a pointer to object and an integral type.
                                 This deviation is due to doing pointer arithmetic.
                                 This deviation is due to an integer type cast to do pointer arithmetic. */
                            /* PRQA S 306,3395 1 */
                            Fee_FlsReadImmediateSync(bnum_pnum - FEE_BLOCK_MANAGE_SIZE*2U, &pre_pre_block.BlkNumAndPageNum.BNumAndPNum, FEE_BLOCK_BLKNUMPAGENUM_SIZE); /* read BNumAndPNum */
                            fee_fault = Fee_GetFlsFault();
                            Fee_FlsDisableDMA();
                            if((fee_fault == FEE_FAULT_NONE) || (fee_fault == FEE_FAULT_SED))
                            {
                                page_no_current_page_cnt_recalculate = page_no_current - (uint16)(Fee_GetBlockRealMaxsize(Fee_CurrentConfigNo) >> 2U) - (uint16)(pre_pre_block.BlkNumAndPageNum.BNumAndPNumBitField.PageNum);
                                if((page_no_current_page_cnt_recalculate * fee_cfg.FeeVirtualPageSize) == Fee_GetPageSizeAlignSize((Fee_GetBlkCfg(blk_idx)).FeeBlockSize))
                                {
                                    blk_cfg_on_flash = Fee_GetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx);
                                    /* Deviation from MISRA-C:2012 Rule-10.3
                                    Justification: As a result of this expression, it will not exceed the essential type. */
                                    /* PRQA S 4461 1 */
                                    blk_cfg_on_flash.FeeBlockSize = page_no_current_page_cnt_recalculate * fee_cfg.FeeVirtualPageSize;
                                    Fee_SetBlkCfgOnFlash(Fee_CurrentConfigNo, blk_idx, blk_cfg_on_flash);

                                    /* set Write Flag */
                                    Fee_BlkMgtInfoBuffer.WriteFlag   = FEE_BLOCK_INITIAL_WRITEFLAG;
                                    /* set block number */
                                    Fee_BlkMgtInfoBuffer.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum = (uint16)block_no;
                                    /* set Valid Block status */
                                    Fee_BlkMgtInfoBuffer.ValidStat   = FEE_BLOCK_VALID_BLOCK;
                        
                                    retval = FEE_OK;
                                }

                                /* Change previous block's Fee_IsNextBlockCorrupt to FEE_NEXT_BLOCK_IS_CORRUPT */
                                pre_pre_blk_idx = Fee_BlockNumberToIndex(pre_pre_block.BlkNumAndPageNum.BNumAndPNumBitField.BlkNum);
                                pre_pre_block_addr_index = Fee_GetBlockAddrIndex(pre_pre_blk_idx);
                                if((pre_pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK) || (pre_pre_block_addr_index.BlkStatus == FEE_BLKIDX_VALID_BLOCK_IN_RECYCLE))
                                {
                                    Fee_SetIsNextBlockCorrupt(Fee_CurrentConfigNo, pre_pre_blk_idx, FEE_NEXT_BLOCK_IS_CORRUPT);
                                }
                            }
                        }
                    }
                }
            }
        }

        /* if no valid block find, update src_ptr to next position */
        /* if valid block find, return src_ptr */
        if( retval == FEE_CONT )
        {
            /* update current src position to find next block */
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4
               Justification: Casting to different object pointer type. And this casting is safety by judgment.
                              This deviation is due to doing pointer arithmetic. */
            /* PRQA S 310,488,3305 1 */
            *src_ptr = (Fee_BlockManagementInfoType*)((uint8*)*src_ptr + FEE_BLOCK_MANAGE_SIZE);
        }

        /* => X.end of periodic processing */
        proc = FEE_SEARCH_VALID_OLD_END;
    }

/* X.end of periodic processing  */
    if( proc == FEE_SEARCH_VALID_OLD_END )
    {
        /* => 0.entry of periodic processing */
        proc = FEE_SEARCH_VALID_OLD_START;
    }

    FEE_PUSH_PROC(proc)        /* evacuate processing */

    return retval;
}



/** \brief Fee_CalculatePSC
**
** Calculate PSC.
**
** \param    none
**
** \return   PSC = (x,y,checksum)
**
*/
static FUNC(uint32, FEE_CODE) Fee_CalculatePSC(void)
{
    /* Deviation from MISRA-C:2004 rule 18.4, MISRA-C:2012 Rule-19.2
       Justification: This union type is used for accessing to work flash memory. */
    /* PRQA S 759 1 */
    VAR(Fee_PscInfoType, AUTOMATIC) psc;

    psc.PscBitField.Psc1 = Fee_GetNormalSectorCount();
    psc.PscBitField.Psc2 = Fee_GetLastSectorCount();

    /* Deviation from MISRA-C:2012 Rule-12.1
       Justification: This is the necessary algrithm. */
    /* PRQA S 3395 1 */
    psc.PscBitField.PscChecksum = (uint16)Fee_GetNormalSectorCount() + (uint16)Fee_GetLastSectorCount() + (uint16)Fee_GetNormalSectorCount() * (uint16)Fee_GetLastSectorCount();

    return psc.PscInfo;
}

/** \brief Fee_CheckOldConfigAndCompare
**
** check old Config and compare with new config.
**
** \param[out] uint8* configdifference  
**             FEE_CONFIG_IS_DIFFERENT  
**             FEE_CONFIG_IS_SAME
**
** \return     uint8
**             FEE_OK     check old config and compare finish
**             FEE_NG     blank check failure
**             FEE_CONT   check old config and compare continue
**
*/
/* Deviation from MISRA-C:2012 Rule-8.8
   Justification: The declaration is in the head of this file. */
/* PRQA S 3224 3 */
static FUNC(uint8, FEE_CODE) Fee_CheckOldConfigAndCompare(
  P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) config_difference_ptr)
{
    VAR(Fee_CheckOldConfigAndCompareProcType, AUTOMATIC)      proc;                          /* processsing */
    VAR(uint8, AUTOMATIC)                                     retval;                        /* return value */
    VAR(uint32, AUTOMATIC)                                    current_address;               /* current address */
    VAR(uint8, AUTOMATIC)                                     cnt;                           /* loop count */
    VAR(uint8, AUTOMATIC)                                     erase_sector_number;           /* erase sector number */
    VAR(uint8, AUTOMATIC)                                     loop_max;                      /* max count for loop */

    erase_sector_number = 0;
    cnt = 0;
    retval = FEE_CONT;
    *config_difference_ptr = FEE_CONFIG_IS_SAME;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_CheckOldConfigAndCompareProcType)                 /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_CHK_OLD_CONFIG_AND_COMPARE_START )
    {
        current_address = Fee_GetSecTopAddr();
        /* => 1.caculate sector status */
        proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_CALC;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 1 */
        FEE_POP_STACK_ULONG(current_address)
        FEE_POP_STACK_UCHAR(erase_sector_number)
    }
/*1.caculate sector status */
    if( proc == FEE_CHK_OLD_CONFIG_AND_COMPARE_CALC )
    {
        if( FEE_OFF == Fee_GetSectorBlankCheckOff() )
        {
            loop_max = FEE_CHECK_OLD_CONFIG_AND_COMPARE_MAX;
        }
        else
        {
            loop_max = FEE_CHECK_OLD_CONFIG_AND_COMPARE_MAX_FOR_BC_OFF;
        }

        /*read head information of sector */
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Dir-4.1
           Justification: Loop is decided by performance. */
        /* PRQA S 2877 1 */
        while( (current_address < Fee_GetSecEndAddr()) && (cnt < loop_max) )
        {
            retval = Fee_CaculateOldSectorStatus(current_address);
            switch(retval)
            {
                case FEE_CONT:
                    /* do nothing*/
                    break;
                case FEE_OK:
                    current_address += Fee_GetWflashLgSectorSize();
                    break;
                default:
                    break;
            }
            /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
               Justification: The value is needed to be updated at each time. */
            /* PRQA S 2984 1 */
            cnt++;
        }

        if( current_address >= Fee_GetSecEndAddr())
        {
            if( FEE_OFF == Fee_GetSectorBlankCheckOff() )
            {
                /* => 2.look for effective sector */
                FEE_SET_PROC(FEE_CHK_OLD_CONFIG_AND_COMPARE_FIND_EFFECTIVE)
            }
            else
            {
                /* => 2.look for effective sector */
                proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_FIND_EFFECTIVE;
            }
        }
    }

/* 2.look for effective sector */
    if( proc == FEE_CHK_OLD_CONFIG_AND_COMPARE_FIND_EFFECTIVE )
    {
        if(Fee_OldSectorStatusArray[0].FeeSectorStatus != FEE_NONE_SECTOR )
        {
            Fee_OldSectorStatusArray[2].FeeSectorStatus     = Fee_OldSectorStatusArray[0].FeeSectorStatus;
            Fee_OldSectorStatusArray[2].FeeSectorAddress    = Fee_OldSectorStatusArray[0].FeeSectorAddress;
            Fee_OldSectorStatusArray[2].FeePsc1             = Fee_OldSectorStatusArray[0].FeePsc1;
            Fee_OldSectorStatusArray[2].FeePsc2             = Fee_OldSectorStatusArray[0].FeePsc2;
            Fee_OldSectorStatusArray[2].FeeOldLogicalNumber = Fee_OldSectorStatusArray[0].FeeOldLogicalNumber;
            Fee_OldSectorStatusArray[2].FeePscChecksum      = Fee_OldSectorStatusArray[0].FeePscChecksum;
            /* => 3.compare psc of new and old */
            proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_COMPARE;
        }
        else if((Fee_OldSectorStatusArray[0].FeeSectorStatus == FEE_NONE_SECTOR) && (Fee_OldSectorStatusArray[1].FeeSectorStatus != FEE_NONE_SECTOR))
        {
            Fee_OldSectorStatusArray[2].FeeSectorStatus     = Fee_OldSectorStatusArray[1].FeeSectorStatus;
            Fee_OldSectorStatusArray[2].FeeSectorAddress    = Fee_OldSectorStatusArray[1].FeeSectorAddress;
            Fee_OldSectorStatusArray[2].FeePsc1             = Fee_OldSectorStatusArray[1].FeePsc1;
            Fee_OldSectorStatusArray[2].FeePsc2             = Fee_OldSectorStatusArray[1].FeePsc2;
            Fee_OldSectorStatusArray[2].FeeOldLogicalNumber = Fee_OldSectorStatusArray[1].FeeOldLogicalNumber;
            Fee_OldSectorStatusArray[2].FeePscChecksum      = Fee_OldSectorStatusArray[1].FeePscChecksum;
            /* => 3.compare psc of new and old */
            proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_COMPARE;
        }
        else
        {
            Fee_OldSectorStatusArray[2].FeeSectorStatus = FEE_NONE_SECTOR;
            if( FEE_ON == Fee_GetInitiallyEraseEmptySectors() )
            {
                /* => 4.erase all sectors */
                proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_ERASE_ALL;
            }
            else
            {
                retval = FEE_OK;
                *config_difference_ptr = FEE_CONFIG_IS_SAME;
                /* => X.end of periodic processing */
                proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_END;
            }
        }
    }


/* 3.compare psc of new and old */
    if( proc == FEE_CHK_OLD_CONFIG_AND_COMPARE_COMPARE )
    {
        /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
           Justification: This implementation is adopted for avoiding more nesting.
           It is no problem because side effects cannot be caused. */
        /* PRQA S 3415 4 */
        if( (Fee_OldSectorStatusArray[2].FeeSectorStatus != FEE_NONE_SECTOR) && 
            (Fee_OldSectorStatusArray[2].FeePsc1 ==  Fee_GetNormalSectorCount()) &&
            (Fee_OldSectorStatusArray[2].FeePsc2 == Fee_GetLastSectorCount()) &&
            (Fee_OldSectorStatusArray[2].FeePscChecksum == Fee_GetPSCChecksum())
           )
        {
            *config_difference_ptr = FEE_CONFIG_IS_SAME;
        }
        else
        {
            *config_difference_ptr = FEE_CONFIG_IS_DIFFERENT;
        }
        retval = FEE_OK;
        /* => X.end of periodic processing */
        proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_END;
    }

/* 4.erase all sectors */
    if(proc == FEE_CHK_OLD_CONFIG_AND_COMPARE_ERASE_ALL )
    {
        /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Dir-4.1
           Justification: Loop is decided by performance. */
        /* PRQA S 2877 1 */
        while((erase_sector_number < Fee_GetNoOfSec()) && (cnt < FEE_CHECK_OLD_CONFIG_AND_COMPARE_MAX))
        {
           retval = Fee_EraseSector(erase_sector_number + FEE_SECTOR_STATUS_OFFSET);

            switch(retval)
            {
                case FEE_OK:
                    erase_sector_number++;
                    retval = FEE_CONT;
                    break;

                case FEE_NG:
                    retval = FEE_NG;
                    /* => X.end of periodic processing */
                    proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_END;
                    break;

                default: /* FEE_CONT */
                    /* do nothing */
                    break;
            }
            /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
               Justification: The value is needed to be updated at each time. */
            /* PRQA S 2984 1 */
            cnt++;
        }

        if(erase_sector_number >= Fee_GetNoOfSec())
        {
            retval = FEE_OK;
            *config_difference_ptr = FEE_CONFIG_IS_SAME;
            /* => X.end of periodic processing */
            proc = FEE_CHK_OLD_CONFIG_AND_COMPARE_END;
        }
    }

/* X.end of periodic processing  */
    if( proc == FEE_CHK_OLD_CONFIG_AND_COMPARE_END )
    {
        FEE_PUSH_PROC(FEE_CHK_OLD_CONFIG_AND_COMPARE_START)
    }
    else
    {
        retval = FEE_CONT;
        FEE_PUSH_STACK_UCHAR(erase_sector_number)
        /* Deviation from MISRA-C:2004 rule 12.8, 17.4, MISRA-C:2012 Rule-18.4, Rule-12.2
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          This deviation is due to doing pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          This deviation is due to a shift conversion for handling the uint64 variable. */
        /* PRQA S 488,2790 1 */
        FEE_PUSH_STACK_ULONG(current_address)
        FEE_PUSH_PROC(proc)
    }

    return retval;
}

/** \brief Fee_CaculateOldSectorStatus
**
** get sector status from Flash.
**
** \param[in] currentAddress 
** \param[out] physicalSectorCounter 
**
** \return     uint8
**             FEE_CONT  continue
**             FEE_OK    complete
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7, Rule-8.8
   Justification: This warning does not affect and other translation unit can refer in future.
                  The declaration is in the head of this file. */
/* PRQA S 1505,3224 2 */
static FUNC(uint8, FEE_CODE) Fee_CaculateOldSectorStatus(
 VAR(uint32,FEE_CODE) current_address )
{
    VAR(Fee_CaculateOldSectorStatusProcType, AUTOMATIC)    proc;                          /* position of the processing */
    VAR(uint8, AUTOMATIC)                                  retval;                        /* return value */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                    status_ptr;                    /* pointer to sector status */
    VAR(uint32, AUTOMATIC)                                 status_flag1;                  /* blank check for status flag */
    VAR(uint32, AUTOMATIC)                                 status_flag2;                  /* blank check for status flag */
    VAR(uint32, AUTOMATIC)                                 status_flag3;                  /* blank check for status flag */
    /* Deviation from MISRA-C:2004 rule 18.4, MISRA-C:2012 Rule-19.2
       Justification: This union type is used for accessing to work flash memory. */
    /* PRQA S 759 1 */
    VAR(Fee_PscInfoType, AUTOMATIC)                        psc_info;                      /* blank check for psc */
    VAR(uint32, AUTOMATIC)                                 erase_flag;                    /* blank check for erase flag */
    VAR(uint8, AUTOMATIC)                                  valid_or_moving_status;        /* valid or moving status*/
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                    sector_status_ptr1;            /* pointer to sector status */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                    sector_status_ptr2;            /* pointer to sector status */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                    sector_status_ptr3;            /* pointer to sector status */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                    sector_psc_ptr;                /* pointer to psc */
    P2VAR(uint32, AUTOMATIC, AUTOMATIC)                    sector_erase_complete_flag_ptr;/* pointer to erase complete flag ptr */
    VAR(Fee_FaultType, AUTOMATIC)                          fee_fault;                     /* get fault information from FLS */

    valid_or_moving_status = FEE_SECTOR_NOSTATUS;
    /* Deviation from MISRA-C:2012 Rule-2.2
       Justification: This is initialization. */
    /* PRQA S 2982 1 */
    retval = FEE_CONT;

    /* Deviation from MISRA-C:2012 Rule-10.5
       Justification: This is stack pop/push. It is necessary. */
    /* PRQA S 4342 1 */
    FEE_POP_PROC(proc, Fee_CaculateOldSectorStatusProcType)                /* get position of the processing */

/* 0.entry of periodic processing */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_START )
    {
        /* Deviation from MISRA-C:2004 rule 10.3, 11.3, 11.4, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-11.3, Rule-18.4, Rule-10.8
           Justification: Cast between a pointer to object and an integral type.
                          Casting to different object pointer type. And this casting is safety by judgment.
                          This deviation is due to doing pointer arithmetic.
                          Casting to different type for consistency. */
        /* PRQA S 306,310,488,4391 1 */
        status_ptr = (uint32*)(current_address); /* get sector top address */
        sector_status_ptr1 = status_ptr; /* get flag1 address */
        status_ptr++;
        sector_status_ptr2 = status_ptr; /* get flag2 address */
        status_ptr++;
        sector_status_ptr3 = status_ptr; /* get flag3 address */
        status_ptr++;
        status_ptr++;
        sector_psc_ptr = status_ptr; /* get psc info */

        /* => 1.get flag1 */
        proc = FEE_CACULATE_OLD_SECTOR_STATUS_FLAG1;
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.*/
        /* PRQA S 306,488 5 */
        FEE_POP_STACK_POINTER(sector_erase_complete_flag_ptr, uint32)
        FEE_POP_STACK_POINTER(sector_status_ptr1, uint32)
        FEE_POP_STACK_POINTER(sector_status_ptr2, uint32)
        FEE_POP_STACK_POINTER(sector_status_ptr3, uint32)
        FEE_POP_STACK_POINTER(sector_psc_ptr, uint32)
        
        FEE_POP_STACK_UCHAR(valid_or_moving_status)

        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting. */
        /* PRQA S 488 3 */
        FEE_POP_STACK_ULONG(status_flag1)
        FEE_POP_STACK_ULONG(status_flag2)
        FEE_POP_STACK_ULONG(status_flag3)
    }

/* 1.get flag1  */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_FLAG1 )
    {
        /* get flag1 */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        status_flag1 = Fee_FlsGetReadAddr((uint32)sector_status_ptr1);

        /* => 2.get flag2 */
        proc = FEE_CACULATE_OLD_SECTOR_STATUS_FLAG2;
    }
    
/* 2.get flag2 */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_FLAG2 )
    {
        /* get flag2 */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        status_flag2 = Fee_FlsGetReadAddr((uint32)sector_status_ptr2);

        /* => 3.get flag3 */
        proc = FEE_CACULATE_OLD_SECTOR_STATUS_FLAG3;
    }
    
/* 3.get flag3 */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_FLAG3 )
    {
        /* get flag3 */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        status_flag3 = Fee_FlsGetReadAddr((uint32)sector_status_ptr3);

        /* =>4.judge sector status */
        proc = FEE_CACULATE_OLD_SECTOR_STATUS_JUDGE;
    }

/* 4.judge sector status */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_JUDGE )
    {
        /* Deviation from MISRA-C:2004 rule 9.1, MISRA-C:2012 Rule-9.1
           Justification: The status_flag1, status_flag2 and status_flag3 are only used after they are initialized by the former mainfunction. */
        /* PRQA S 2962 2*/
        if((status_flag1 != FEE_NULL) && (status_flag2 == FEE_NULL) && (status_flag3 == FEE_NULL))
        {
            /* valid sector */
            valid_or_moving_status = FEE_SECTOR_ENABLE;
            /* =>5.check PSC */
            proc = FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_PSC;
        }
        else if((status_flag1 != FEE_NULL) && (status_flag2 != FEE_NULL) && (status_flag3 == FEE_NULL))
        {
            /* moving sector */
            valid_or_moving_status = FEE_SECTOR_MOVING;
            /* =>5.check PSC */
            proc = FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_PSC;
        }
        else
        {
            /* => X.end of periodic processing */
            proc = FEE_CACULATE_OLD_SECTOR_STATUS_END;
        }
    }

/* 5.check PSC */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_PSC )
    {
        /* check PSC */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        psc_info.PscInfo = Fee_FlsGetReadAddr((uint32)sector_psc_ptr);

        if( psc_info.PscInfo != FEE_NULL)
        {
            Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
            Fee_FlsEnableDMA();
            /* ReadOperation */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
                Justification: Cast between a pointer to object and an integral type. */
            /* PRQA S 306 1 */
            Fee_FlsReadImmediateSync((uint32)sector_psc_ptr, &Fee_InfoDataBuffer, FEE_PSC_SIZE);
            fee_fault = Fee_GetFlsFault();
            Fee_FlsDisableDMA();

            if(((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED)) ||
                (Fee_InfoDataBuffer == (uint32)FEE_NULL))
            {
                /* => X.end of periodic processing */
                proc = FEE_CACULATE_OLD_SECTOR_STATUS_END;
            }
            else
            {
                psc_info.PscInfo = Fee_InfoDataBuffer;
                /* Deviation from MISRA-C:2004 rule 10.1, 10.3, MISRA-C:2012 Rule-10.7, Rule-12.1
                    Justification: This implmentation is needed for the algrithm. */
                /* PRQA S 1891,3395 1 */
                if( psc_info.PscBitField.PscChecksum == (psc_info.PscBitField.Psc1+psc_info.PscBitField.Psc2 + psc_info.PscBitField.Psc1 * psc_info.PscBitField.Psc2) )
                {
                    /* Deviation from MISRA-C:2004 rule 10.1, 10.3, MISRA-C:2012 Rule-10.7, Rule-12.1
                        Justification: This implmentation is needed for the algrithm. */
                    /* PRQA S 1891,3395,3397 1 */
                    if( current_address > Fee_GetSecEndAddr() - psc_info.PscBitField.Psc2 * Fee_GetWflashLgSectorSize() - Fee_GetSectorSizeLessThan800() )
                    {
                        /* => X.end of periodic processing */
                        proc = FEE_CACULATE_OLD_SECTOR_STATUS_END;
                    }
                    /* Deviation from MISRA-C:2004 rule 10.1, 10.3, MISRA-C:2012 Rule-10.7, Rule-12.1
                        Justification: This implmentation is needed for the algrithm. */
                    /* PRQA S 1891,3395 1 */
                    else if( current_address == ( Fee_GetSecEndAddr() - psc_info.PscBitField.Psc2 * Fee_GetWflashLgSectorSize() - Fee_GetSectorSizeLessThan800() ) )
                    {
                        Fee_SetConfigInfoOld(psc_info.PscBitField.Psc1, psc_info.PscBitField.Psc2, psc_info.PscBitField.PscChecksum);
                        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-10.4
                            Justification: Cast between a pointer to object and an integral type.
                                            This implmentation is needed for doing a signed cast. */
                        /* PRQA S 306,1840 1 */
                        sector_erase_complete_flag_ptr =  (uint32*)(Fee_GetSecEndAddr() - FEE_ERASE_COMPLETE_FLAG_SIZE);

                        /* => 6.check erase flag */
                        FEE_SET_PROC(FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_ERASE_FLAG)
                    }
                    else
                    {
                        Fee_SetConfigInfoOld(psc_info.PscBitField.Psc1,psc_info.PscBitField.Psc2, psc_info.PscBitField.PscChecksum);
                        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 10.1, 10.3, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-10.4, Rule-10.7, , Rule-12.1
                            Justification: Cast between a pointer to object and an integral type.
                                            This implmentation is needed for doing a signed cast. */
                        /* PRQA S 306,1840,1891,3395 1 */
                        sector_erase_complete_flag_ptr = (uint32*)(current_address + psc_info.PscBitField.Psc1 * Fee_GetWflashLgSectorSize() - FEE_ERASE_COMPLETE_FLAG_SIZE);

                        /* => 6.check erase flag */
                        FEE_SET_PROC(FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_ERASE_FLAG)
                    }
                }
                else
                {
                    /* => X.end of periodic processing */
                    proc = FEE_CACULATE_OLD_SECTOR_STATUS_END;
                }
            }
        }
        else
        {
            /* => X.end of periodic processing */
            proc = FEE_CACULATE_OLD_SECTOR_STATUS_END;
        }
    }

/* 6.check erase flag */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_CHECK_ERASE_FLAG )
    {
        Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
        Fee_FlsEnableDMA();
        /* ReadOperation */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        Fee_FlsReadImmediateSync((uint32)sector_erase_complete_flag_ptr, &Fee_InfoDataBuffer, FEE_ERASE_COMPLETE_FLAG_SIZE);
        fee_fault = Fee_GetFlsFault();
        Fee_FlsDisableDMA();

        if((fee_fault != FEE_FAULT_NONE) && (fee_fault != FEE_FAULT_SED))
        {
            Fee_InfoDataBuffer = FEE_SECTOR_STATUS_DATA_INIT; /* clear value */
        }

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306 1 */
        erase_flag = Fee_FlsGetReadAddr((uint32)sector_erase_complete_flag_ptr);

        /* ReadOperation */
        if( ( erase_flag != FEE_NULL ) && ( Fee_InfoDataBuffer == FEE_SECTOR_STATUS_DATA_SET ) )
        {
            if( valid_or_moving_status == FEE_SECTOR_MOVING )
            {
                Fee_OldSectorStatusArray[1].FeeSectorStatus     = FEE_SECTOR_MOVING;
                Fee_OldSectorStatusArray[1].FeeSectorAddress    = current_address;                      
                Fee_OldSectorStatusArray[1].FeePsc1             = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NormalSectorCount;
                Fee_OldSectorStatusArray[1].FeePsc2             = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_LastSectorCount;  
                Fee_OldSectorStatusArray[1].FeePscChecksum      = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_PSCCheckSum;
                /* Deviation from MISRA-C:2004 rule 10.1, 10.3, MISRA-C:2012 Rule-10.7, Rule-12.1, Rule-10.3
                    Justification: This implmentation is needed for the algrithm. */
                /* PRQA S 1891,3395,4461 1 */
                Fee_OldSectorStatusArray[1].FeeOldLogicalNumber = (current_address - Fee_GetSecTopAddr())/(Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NormalSectorCount * Fee_GetWflashLgSectorSize()) + (uint8)1;
            }
            else
            {
                Fee_OldSectorStatusArray[0].FeeSectorStatus     = FEE_SECTOR_ENABLE;
                Fee_OldSectorStatusArray[0].FeeSectorAddress    = current_address;                      
                Fee_OldSectorStatusArray[0].FeePsc1             = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NormalSectorCount;
                Fee_OldSectorStatusArray[0].FeePsc2             = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_LastSectorCount; 
                Fee_OldSectorStatusArray[0].FeePscChecksum      = Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_PSCCheckSum;
                /* Deviation from MISRA-C:2004 rule 10.1, 10.3, MISRA-C:2012 Rule-10.7, Rule-12.1, Rule-10.3
                    Justification: This implmentation is needed for the algrithm. */
                /* PRQA S 1891,3395,4461 1 */
                Fee_OldSectorStatusArray[0].FeeOldLogicalNumber = (current_address - Fee_GetSecTopAddr())/(Fee_ConfigInfoOld[Fee_CurrentConfigNo - (uint8)1].Fee_NormalSectorCount * Fee_GetWflashLgSectorSize()) + (uint8)1;
            } 
        }

        /* => X.end of periodic processing */
        proc = FEE_CACULATE_OLD_SECTOR_STATUS_END;
    }

/* X.end of periodic processing  */
    if( proc == FEE_CACULATE_OLD_SECTOR_STATUS_END )
    {
        retval = FEE_OK;
        FEE_PUSH_PROC(FEE_CACULATE_OLD_SECTOR_STATUS_START)
    }
    else
    {
        retval = FEE_CONT;
        /* Deviation from MISRA-C:2004 rule 17.4, 9.1, MISRA-C:2012 Rule-18.4, Rule-9.1
           Justification: This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          The status_flag3,status_flag2 are only used after they are initialized by the former mainfunction. */
        /* PRQA S 488,2962 3 */
        FEE_PUSH_STACK_ULONG(status_flag3)
        FEE_PUSH_STACK_ULONG(status_flag2)
        FEE_PUSH_STACK_ULONG(status_flag1)
        
        FEE_PUSH_STACK_UCHAR(valid_or_moving_status)

        /* Deviation from MISRA-C:2004 rule 11.3, 17.4, 9.1, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4, Rule-9.1
           Justification: Cast between a pointer to object and an integral type.
                          This deviation is due to doing pointer arithmetic.
                          This deviation is due to an integer type cast to do pointer arithmetic.
                          Implementation often uses pointer access by array-subscripting.
                          The sector_erase_complete_flag_ptr is only used after it is initialized by the former mainfunction. */
        /* PRQA S 306,488,2962 5 */
        FEE_PUSH_STACK_POINTER(sector_psc_ptr)
        FEE_PUSH_STACK_POINTER(sector_status_ptr3)
        FEE_PUSH_STACK_POINTER(sector_status_ptr2)
        FEE_PUSH_STACK_POINTER(sector_status_ptr1)
        FEE_PUSH_STACK_POINTER(sector_erase_complete_flag_ptr)
        FEE_PUSH_PROC(proc)
    }

    return retval;
}

/** \brief Fee_GetDisableSector
**
** Get disable sector.when there is difference in new and old config.
**
** \param[in]    sector start addrss of valid sector in new configuration
** \param[in]    sector end addrss of valid sector in new configuration
**
** \return     sector number or error information
** \retval     1-FEE_NUMBER_OF_SECTORS    sector number
** \retval     FEE_NONE_SECTOR        none sector
**
*/
/* Deviation from MISRA-C:2004 rule 8.10, MISRA-C:2012 Rule-8.7
   Justification: This interface is intentionally external scope so that other
                  translation unit can refer in future. */
/* PRQA S 1505 1 */
FUNC(uint8, FEE_CODE) Fee_GetDisableSector(
  VAR(uint32,AUTOMATIC) sector_start_addrss_of_old_config,
  VAR(uint32,AUTOMATIC) sector_end_addrss_of_old_config)
{
    VAR(uint8, AUTOMATIC) disable_sector;                       /* variable for disable sector */
    VAR(uint8, AUTOMATIC) sector_no;                            /* sector no */
    VAR(uint32, AUTOMATIC) sector_start_addrss_of_new_config;   /* sector start addrss of valid sector in new configuration */
    VAR(uint32, AUTOMATIC) sector_end_addrss_of_new_config;     /* sector end addrss of valid sector in new configuration */

    disable_sector = FEE_NONE_SECTOR;

    for( sector_no = (uint8)FEE_ZERO + (uint8)1; sector_no <= Fee_GetNoOfSec(); sector_no++ )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4
           Justification: Cast between a pointer to object and an integral type. */
        /* PRQA S 306,488 1 */
        sector_start_addrss_of_new_config = (uint32)FEE_GET_FLASH_SECTOR_START_ADDR(sector_no);
        if(sector_no == Fee_GetNoOfSec())
        {
            sector_end_addrss_of_new_config = sector_start_addrss_of_new_config + Fee_GetSectorSize() + Fee_GetRemainSize() - (uint32)1;
        }
        else
        {
            sector_end_addrss_of_new_config = sector_start_addrss_of_new_config + Fee_GetSectorSize() - (uint32)1;
        }
        if((sector_start_addrss_of_new_config >= sector_end_addrss_of_old_config) ||
          (sector_end_addrss_of_new_config <= sector_start_addrss_of_old_config))
        {
            if( Fee_GetSectorStatus(sector_no - (uint8)1) == FEE_SECTOR_DISABLE )
            {
                disable_sector = sector_no;
                /* Deviation from MISRA-C:2004 rule 13.6, MISRA-C:2012 Rule-14.2
                   Justification: This implementation is adopted for algrithm. */
                /* PRQA S 2469 1 */
                sector_no = Fee_GetNoOfSec() + (uint8)1;
            }
        }
    }

    return disable_sector;
}


#define FEE_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include "Fee_MemMap.h"

