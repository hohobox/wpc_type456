/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains the implementation of the AUTOSAR module Fls.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Fls.h>                /* Fls Flash Driver header file */
#include <Fls_LibInterface.h>   /* Library interface header file */

/*==================[macros]================================================*/

/*------------------[AUTOSAR vendor identification check]-------------------*/

#if (!defined FLS_VENDOR_ID) /* configuration check */
#error FLS_VENDOR_ID must be defined
#endif /* if (!defined FLS_VENDOR_ID) */

#if (FLS_VENDOR_ID != 66U) /* vendor check */
#error FLS_VENDOR_ID has wrong vendor id
#endif /* if (FLS_VENDOR_ID != 66U) */


/*------------------[AUTOSAR AR version number check]------------------------*/
#if !FLS_AR_VERSION_CHECK( 4, \
                           2, \
                           2)
#error AUTOSAR AR version number mismatch
#endif

/*------------------[AUTOSAR SW version number check]------------------------*/
#if !FLS_SW_VERSION_CHECK( 1, \
                           17, \
                           0) /* To avoid checking patch version, 3rd parameter is 0. */
#error AUTOSAR SW version number mismatch
#endif

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/** \brief Fls_Init
 **
 ** Initializes the flash driver and saves the configuration pointer locally.
 **
 ** \param[in]  ConfigPtr   Pointer to flash driver configuration set
 **
 ** \return     none
 */
FUNC(void, FLS_CODE) Fls_Init
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
)
{
    Fls_InitLib(ConfigPtr);
}

/** \brief Fls_Erase
 **
 ** Setup of a flash erase job to be processed when calling the MainFunction().
 ** The function Fls_Erase shall copy the given parameters to FLS module internal
 ** variables, initiate an erase job, set the FLS module status to MEMIF_BUSY,
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] Length           Number of bytes to erase
 **
 ** \return    erase command has been accepted/not been accepted
 ** \retval    E_NOT_OK         erase command has not been accepted
 **            E_OK             erase command has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_Erase
(
    Fls_AddressType TargetAddress,
    Fls_LengthType  Length
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_EraseLib(TargetAddress, Length);

#if defined( FLS_ERASE_CALLOUT_FUNCTION_USE ) && ( FLS_ERASE_CALLOUT_FUNCTION_USE == STD_ON )
    if( Ret == E_OK )
    {
        /* if erase callout function is configured and erase command has been accepted, calls erase callback function */
        FLS_ERASE_CALLOUT_FUNCTION(TargetAddress);
    }
#endif /* #if defined( FLS_ERASE_CALLOUT_FUNCTION_USE ) && ( FLS_ERASE_CALLOUT_FUNCTION_USE == STD_ON ) */

    return Ret;
}

/** \brief Fls_Write
 **
 ** Setup of a flash write job to be processed when calling the MainFunction().
 ** The function Fls_Write shall copy the given parameters to Fls module internal
 ** variables, initiate a write job, set the FLS module status to MEMIF_BUSY,
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK.
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] SourceAddressPtr Pointer to source data buffer
 ** \param[in] Length           Number of bytes to write
 **
 ** \return    write command has been accepted/not been accepted
 ** \retval    E_NOT_OK         write command has not been accepted
 **            E_OK             write command has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_Write
(
    Fls_AddressType TargetAddress,
    P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr,
    Fls_LengthType Length
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_WriteLib(TargetAddress, SourceAddressPtr, Length);

    return Ret;
}

#if ( FLS_CANCEL_API == STD_ON )

/** \brief Fls_Cancel
 **
 ** Cancels an ongoing flash job immediately(read/write/erase/compare/blank check).
 ** Reset internal job processing variables and set driver state to IDLE.
 ** If configured, this function call the error notification function.
 **
 ** \return     none
 */ 
FUNC(void, FLS_CODE) Fls_Cancel(void)
{
    Fls_CancelLib();
}

#endif /* if( FLS_CANCEL_API == STD_ON ) */

#if ( FLS_GET_STATUS_API == STD_ON )

/** \brief Fls_GetStatus
 **
 ** Returns the status of the flash driver.
 **
 ** \return  The driver state
 ** \retval  MEMIF_IDLE      driver is currently idle
 **          MEMIF_UNINIT    driver is not yet initialized
 **          MEMIF_BUSY      driver is busy
 **
 */
FUNC(MemIf_StatusType, FLS_CODE) Fls_GetStatus(void)
{
    MemIf_StatusType    Ret;    /* return value */

    Ret = Fls_GetStatusLib();

    return Ret;
}

#endif /* if( FLS_GET_STATUS_API == STD_ON ) */

#if ( FLS_GET_JOB_RESULT_API == STD_ON )

/** \brief Fls_GetJobResult
 **
 ** Returns the last job result of the flash driver.
 **
 ** \return  The result of the last job
 ** \retval  MEMIF_BLOCK_INCONSISTENT  last compare job indicated differences
 **          MEMIF_JOB_CANCELED        last job canceled
 **          MEMIF_JOB_FAILED          last job failed due to hardware error
 **          MEMIF_JOB_OK              last job successfully completed
 **          MEMIF_JOB_PENDING         a new job is pending
 **
*/
FUNC(MemIf_JobResultType, FLS_CODE) Fls_GetJobResult(void)
{
    MemIf_JobResultType     Ret;    /* return value */

    Ret = Fls_GetJobResultLib();

    return Ret;
}

#endif /* if( FLS_GET_JOB_RESULT_API == STD_ON ) */

/** \brief Fls_Read
 **
 ** Setup of a flash read job to be processed when calling the MainFunction().
 ** The function Fls_Read shall copy the given parameters to FLS module internal
 ** variables, initiate a read job, set the FLS module status to MEMIF_BUSY,
 ** set the FLS module job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in]  SourceAddress    Source address in flash memory
 ** \param[out] TargetAddressPtr Pointer to target data buffer
 ** \param[in]  Length           Number of bytes to read
 **
 ** \return    read command has been accepted/not been accepted
 ** \retval    E_NOT_OK         read command has not been accepted
 **            E_OK             read command has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_Read
(
    Fls_AddressType SourceAddress,
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    Fls_LengthType Length
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_ReadLib(SourceAddress, TargetAddressPtr, Length, FLS_FALSE);

    return Ret;
}

#if ( FLS_COMPARE_API == STD_ON )

/** \brief Fls_Compare
 **
 ** Setup of a flash compare job to be processed when calling the MainFunction().
 ** The function Fls_Compare shall copy the given parameters to Fls module internal
 ** variables, initiate a compare job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] SourceAddress    Source address in flash memory
 ** \param[in] TargetAddressPtr Pointer to target data buffer
 ** \param[in] Length           Number of bytes to compare
 **
 ** \return    compare command has been accepted/not been accepted
 ** \retval    E_NOT_OK         compare command has not been accepted
 **            E_OK             compare command has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_Compare
(
    Fls_AddressType SourceAddress,
    P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) TargetAddressPtr,
    Fls_LengthType Length
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_CompareLib(SourceAddress, TargetAddressPtr, Length);

    return Ret;
}

#endif /* if( FLS_COMPARE_API == STD_ON ) */

#if ( FLS_SET_MODE_API == STD_ON )

/** \brief Fls_SetMode
 **
 ** Sets the mode for the flash access to SLOW or FAST as given by the parameter.
 **
 ** \param[in]  Mode    mode to be switched to (SLOW, FAST)
 **
 ** \return     none
 */
FUNC(void, FLS_CODE) Fls_SetMode
(
    MemIf_ModeType Mode
)
{
    Fls_SetModeLib(Mode);
}

#endif /* if( FLS_SET_MODE_API == STD_ON ) */

#if ( FLS_VERSION_INFO_API == STD_ON )

/** \brief Fls_GetVersionInfo
 **
 ** This service returns the version information of this module.
 **
 ** \param[out]  VersioninfoPtr  Pointer to where to store the version
 **                              information of this module (Module Id,
 **                              Vendor Id, Vendor specific version numbers).
 **
 ** \return     none
 */
FUNC(void, FLS_CODE) Fls_GetVersionInfo
(
    P2VAR(Std_VersionInfoType, AUTOMATIC, FLS_APPL_DATA) VersioninfoPtr
)
{
    Fls_GetVersionInfoLib(VersioninfoPtr);
    if( VersioninfoPtr != NULL_PTR )
    {
        /* Return the patch version information */
        VersioninfoPtr->sw_patch_version = FLS_SW_PATCH_VERSION;
    }
}

#endif /* if( FLS_VERSION_INFO_API == STD_ON ) */

/** \brief Fls_MainFunction
 **
 ** This function shall perform the processing of the flash read, write, erase,
 ** compare and blank check jobs. When a job has been initiated, the FLS module's 
 ** environment shall call the function Fls_MainFunction cyclically until the job
 ** is finished. 
 ** This function calls each internal functions by FLS module's state.
 **
 ** Fls049: The Fls_Cancel() function shall not be called during a running
 ** Fls_MainFunction() function.
 ** Therefore the main function does not consider any disturbence during
 ** runtime.
 **
 ** \return     none
 */
FUNC(void, FLS_CODE) Fls_MainFunction(void)
{
    Fls_MainFunctionLib();
}

#if ( FLS_BLANK_CHECK_API == STD_ON )

/** \brief Fls_BlankCheck
 **
 ** Setup of a flash blank check job to be processed when calling the MainFunction().
 ** The function Fls_BlankCheck shall copy the given parameters to Fls module internal
 ** variables, initiate a blank check job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] Length           Number of bytes to be checked blank
 **
 ** \return    blank check command has been accepted/not been accepted
 ** \retval    E_NOT_OK         blank check command has not been accepted
 **            E_OK             blank check command has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_BlankCheck
(
    Fls_AddressType TargetAddress,
    Fls_LengthType Length
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_BlankCheckLib(TargetAddress, Length);

    return Ret;
}

#endif /* if( FLS_BLANK_CHECK_API == STD_ON ) */

#if ( FLS_READ_IMMEDIATE_API == STD_ON )

/** \brief Fls_ReadImmediate
 **
 ** Setup of a flash read immediate job to be processed when calling the MainFunction().
 ** The function Fls_ReadImmediate shall copy the given parameters to Fls module internal
 ** variables, initiate a read immediate job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in]  SourceAddress    Source address in flash memory
 ** \param[out] TargetAddressPtr Pointer to read buffer
 ** \param[in]  Length           Number of bytes to read
 **
 ** \return    read immediate command has been accepted/not been accepted
 ** \retval    E_NOT_OK         read immediate command has not been accepted
 **            E_OK             read immediate command has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_ReadImmediate
(
    Fls_AddressType SourceAddress,
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    Fls_LengthType Length
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_ReadLib(SourceAddress, TargetAddressPtr, Length, FLS_TRUE);

    return Ret;
}

#endif /* if( FLS_READ_IMMEDIATE_API == STD_ON ) */

#if ( FLS_SUSPEND_RESUME_API == STD_ON )

/** \brief Fls_Suspend
 **
 ** This function suspends in progress Fls operation, erase or write.
 **
 ** \return    suspend has been accepted/not been accepted
 ** \retval    E_NOT_OK         a Write or an Erase was in progress and could not be
 **                             suspended because another operation was already suspended
 **                             or no Write or Erase operation was in progress
 **            E_OK             a Write or an Erase was in progress and coud be suspended
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_Suspend(void)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_SuspendLib();

    return Ret;
}

/** \brief Fls_Resume
 **
 ** This function resumes a suspended Fls operation, erase or write.
 ** Only the operation previously suspended can be resumed.
 **
 ** \return    resume has been accepted/not been accepted
 ** \retval    E_NOT_OK         no operation was suspended or the suspended operation
 **                             cannot be resumed because there is a Fls operation
 **                             in progress already
 **            E_OK             an operation was suspended and could be resumed
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_Resume(void)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_ResumeLib();

    return Ret;
}

#endif /* if( FLS_SUSPEND_RESUME_API == STD_ON ) */

#if ( FLS_SET_CYCLE_MODE_API == STD_ON )

/** \brief Fls_SetCycleMode
 **
 ** This function determines whether the flash driver checks timeout or not.
 **
 ** \param[in] Mode             mode to be switched to (SLOW, FAST)
 **
 ** \return    setting mode has been accepted/not been accepted
 ** \retval    E_NOT_OK         setting mode has not been accepted
 **            E_OK             setting mode has been accepted
 **
 */
FUNC(Std_ReturnType, FLS_CODE) Fls_SetCycleMode
(
    MemIf_ModeType Mode
)
{
    Std_ReturnType  Ret;    /* return value */

    Ret = Fls_SetCycleModeLib(Mode);

    return Ret;
}

#endif /* if( FLS_SET_CYCLE_MODE_API == STD_ON ) */

#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
