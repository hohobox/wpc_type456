#if !defined( FLS_H )
#define FLS_H

/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains or includes all external identifiers of
 ** the AUTOSAR module Fls.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Std_Types.h>          /* AUTOSAR standard types */
#include <MemIf_Types.h>        /* AUTOSAR standard types */
#include <Fls_TypesLib.h>       /* module specific types */
#include <Fls_TypesDerLib.h>    /* derivative specific types */
#include <Fls_Version.h>        /* this module's version declaration */
#include <Os.h>                 /* AUTOSAR OS declaration */
#include <Fls_Irq.h>            /* this module's ISR declaration */
#include <Fls_Cfg.h>            /* Generated module specific configuration */

/*==================[macros]================================================*/

/* Fls_GetStatusSub() return values */
#define FLS_STATUS_IDLE       ((FLS_UCHAR)0)    /* idle */

/*==================[type definitions]======================================*/

#ifndef FLS_TYPEDEF_UCHAR
#define FLS_TYPEDEF_UCHAR
typedef uint8   FLS_UCHAR;
#endif /* end of FLS_TYPEDEF_UCHAR */

#ifndef FLS_TYPEDEF_ULONG
#define FLS_TYPEDEF_ULONG
typedef uint32  FLS_ULONG;
#endif /* end of FLS_TYPEDEF_ULONG */

/*==================[external function declarations]========================*/

#define FLS_START_SEC_CODE
#include <Fls_MemMap.h>

/** \brief Fls_Init
 **
 ** Initializes the flash driver and saves the configuration pointer locally.
 **
 ** \param[in]  ConfigPtr   Pointer to flash driver configuration set
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_Init
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
);

/** \brief Fls_Erase
 **
 ** Setup of a flash erase job to be processed when calling the MainFunction().
 ** The function Fls_Erase shall copy the given parameters to FLS module internal
 ** variables, initiate an erase job, set the FLS module status to MEMIF_BUSY,
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] Length           Number of bytes to erase
 **
 ** \return    erase command has been accepted/not been accepted
 ** \retval    E_NOT_OK         erase command has not been accepted
 **            E_OK             erase command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_Erase
(
    Fls_AddressType TargetAddress,
    Fls_LengthType Length
);

/** \brief Fls_Write
 **
 ** Setup of a flash write job to be processed when calling the MainFunction().
 ** The function Fls_Write shall copy the given parameters to Fls module internal
 ** variables, initiate a write job, set the FLS module status to MEMIF_BUSY,
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK.
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] SourceAddressPtr Pointer to source data buffer
 ** \param[in] Length           Number of bytes to write
 **
 ** \return    write command has been accepted/not been accepted
 ** \retval    E_NOT_OK         write command has not been accepted
 **            E_OK             write command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_Write
(
    Fls_AddressType TargetAddress,
    P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr,
    Fls_LengthType Length
);

/** \brief Fls_Cancel
 **
 ** Cancels an ongoing flash job immediately(read/write/erase/compare/blank check).
 ** Reset internal job processing variables and set driver state to IDLE.
 ** If configured, this function call the error notification function.
 **
 ** \return     none
 */ 
extern FUNC(void, FLS_CODE) Fls_Cancel(void);

/** \brief Fls_GetStatus
 **
 ** Returns the status of the flash driver.
 **
 ** \return  The driver state
 ** \retval  MEMIF_IDLE      driver is currently idle
 **          MEMIF_UNINIT    driver is not yet initialized
 **          MEMIF_BUSY      driver is busy
 **
 */
extern FUNC(MemIf_StatusType, FLS_CODE) Fls_GetStatus(void);

/** \brief Fls_GetJobResult
 **
 ** Returns the last job result of the flash driver.
 **
 ** \return  The result of the last job
 ** \retval  MEMIF_BLOCK_INCONSISTENT  last compare job indicated differences
 **          MEMIF_JOB_CANCELED        last job canceled
 **          MEMIF_JOB_FAILED          last job failed due to hardware error
 **          MEMIF_JOB_OK              last job successfully completed
 **          MEMIF_JOB_PENDING         a new job is pending
 **
*/
extern FUNC(MemIf_JobResultType, FLS_CODE) Fls_GetJobResult(void);

#if defined( FLS_DECLARATION_MAINFUNCTION )

/** \brief Fls_MainFunction
 **
 ** This function shall perform the processing of the flash read, write, 
 ** erase and compare jobs. When a job has been initiated, the FLS module's 
 ** environment shall call the function Fls_MainFunction cyclically until the job
 ** is finished. 
 ** This function calls each internal functions by FLS module's state.
 **
 ** Fls049: The Fls_Cancel() function shall not be called during a running
 ** Fls_MainFunction() function.
 ** Therefore the main function does not consider any disturbence during
 ** runtime.
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_MainFunction(void);

#endif /* if defined( FLS_DECLARATION_MAINFUNCTION ) */

/** \brief Fls_Read
 **
 ** Setup of a flash read job to be processed when calling the MainFunction().
 ** The function Fls_Read shall copy the given parameters to FLS module internal
 ** variables, initiate a read job, set the FLS module status to MEMIF_BUSY,
 ** set the FLS module job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in]  SourceAddress    Source address in flash memory
 ** \param[out] TargetAddressPtr Pointer to target data buffer
 ** \param[in]  Length           Number of bytes to read
 **
 ** \return    read command has been accepted/not been accepted
 ** \retval    E_NOT_OK         read command has not been accepted
 **            E_OK             read command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_Read
(
    Fls_AddressType SourceAddress,
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    Fls_LengthType Length
);

/** \brief Fls_Compare
 **
 ** Setup of a flash compare job to be processed when calling the MainFunction().
 ** The function Fls_Compare shall copy the given parameters to Fls module internal
 ** variables, initiate a compare job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] SourceAddress    Source address in flash memory
 ** \param[in] TargetAddressPtr Pointer to target data buffer
 ** \param[in] Length           Number of bytes to compare
 **
 ** \return    compare command has been accepted/not been accepted
 ** \retval    E_NOT_OK         compare command has not been accepted
 **            E_OK             compare command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_Compare
(
    Fls_AddressType SourceAddress,
    P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) TargetAddressPtr,
    Fls_LengthType Length
);

/** \brief Fls_SetMode
 **
 ** Sets the mode for the flash access to SLOW or FAST as given by the parameter.
 **
 ** \param[in]  Mode    mode to be switched to (SLOW, FAST)
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_SetMode
(
    MemIf_ModeType Mode
);

/** \brief Fls_GetVersionInfo
 **
 ** This service returns the version information of this module.
 **
 ** \param[out]  VersioninfoPtr  Pointer to where to store the version
 **                              information of this module (Module Id,
 **                              Vendor Id, Vendor specific version numbers).
 **
 ** \return     none
 */
extern FUNC(void, FLS_CODE) Fls_GetVersionInfo
(
    P2VAR(Std_VersionInfoType, AUTOMATIC, FLS_APPL_DATA) VersioninfoPtr
);

/** \brief Fls_GetStatusSub
 **
 ** The function informs whether the flash memory processing is ongoing.
 **
 ** \return     the flash memory processing is ongoing/not ongoing
 ** \retval     FLS_STATUS_IDLE              not ongoing (idle)
 ** \retval     other than FLS_STATUS_IDLE   ongoing (busy)
 **
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_GetStatusSub
(
    void
);

/** \brief Fls_BlankCheck
 **
 ** Setup of a flash blank check job to be processed when calling the MainFunction().
 ** The function Fls_BlankCheck shall copy the given parameters to Fls module internal
 ** variables, initiate a blank check job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in] TargetAddress    Target address in flash memory
 ** \param[in] Length           Number of bytes to be checked blank
 **
 ** \return    blank check command has been accepted/not been accepted
 ** \retval    E_NOT_OK         blank check command has not been accepted
 **            E_OK             blank check command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_BlankCheck
(
    Fls_AddressType TargetAddress,
    Fls_LengthType Length
);

/** \brief Fls_ReadImmediate
 **
 ** Setup of a flash read immediate job to be processed when calling the MainFunction().
 ** The function Fls_ReadImmediate shall copy the given parameters to Fls module internal
 ** variables, initiate a read immediate job, set the status to MEMIF_BUSY, 
 ** set the job result to MEMIF_JOB_PENDING and return with E_OK. 
 **
 ** \param[in]  SourceAddress    Source address in flash memory
 ** \param[out] TargetAddressPtr Pointer to read buffer
 ** \param[in]  Length           Number of bytes to read
 **
 ** \return    read immediate command has been accepted/not been accepted
 ** \retval    E_NOT_OK         read immediate command has not been accepted
 **            E_OK             read immediate command has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_ReadImmediate
(
    Fls_AddressType SourceAddress,
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    Fls_LengthType Length
);

/** \brief Fls_Suspend
 **
 ** This function suspends in progress Fls operation, erase or write.
 **
 ** \return    suspend has been accepted/not been accepted
 ** \retval    E_NOT_OK         a Write or an Erase was in progress and could not be
 **                             suspended because another operation was already suspended
 **                             or no Write or Erase operation was in progress
 **            E_OK             a Write or an Erase was in progress and coud be suspended
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_Suspend(void);

/** \brief Fls_Resume
 **
 ** This function resumes a suspended Fls operation, erase or write.
 ** Only the operation previously suspended can be resumed.
 **
 ** \return    resume has been accepted/not been accepted
 ** \retval    E_NOT_OK         no operation was suspended or the suspended operation
 **                             cannot be resumed because there is a Fls operation
 **                             in progress already
 **            E_OK             an operation was suspended and could be resumed
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_Resume(void);

/** \brief Fls_SetCycleMode
 **
 ** This function determines whether the flash driver checks timeout or not.
 **
 ** \param[in] Mode             mode to be switched to (SLOW, FAST)
 **
 ** \return    setting mode has been accepted/not been accepted
 ** \retval    E_NOT_OK         setting mode has not been accepted
 **            E_OK             setting mode has been accepted
 **
 */
extern FUNC(Std_ReturnType, FLS_CODE) Fls_SetCycleMode
(
    MemIf_ModeType Mode
);

#define FLS_STOP_SEC_CODE
#include <Fls_MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* if !defined( FLS_H ) */
/*==================[end of file]===========================================*/
