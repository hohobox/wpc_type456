/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains the implementation of Fls sub module internal functions.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*========*/
/* Header */
/*========*/
#include <Fls_LibInterface.h>   /* Library interface header file */
#include <Fls_InternalLib.h>    /* Module internal API */        


/*=================*/
/* Const variables */
/*=================*/


/*==================*/
/* Global variables */
/*==================*/
#define FLS_START_SEC_VAR_NO_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>
P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA)          Fls_ParamAddr;            /* address of writing */
volatile P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) Fls_NowAddr;              /* current address of writing or erasing */
P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA)          Fls_NowData;              /* data address */
VAR(FLS_ULONG, FLS_VAR_NO_INIT)                     Fls_ParamLength;          /* length of writing or erasing */
VAR(FLS_ULONG, FLS_VAR_NO_INIT)                     Fls_DataSize;             /* remain size of writing */
VAR(FLS_UCHAR, FLS_VAR_NO_INIT)                     Fls_StateSub;             /* state of HAL */
VAR(FLS_UCHAR, FLS_VAR_NO_INIT)                     Fls_StateSubMirror;       /* mirror of Fls_StateSub for fail-safe */
VAR(FLS_UCHAR, FLS_VAR_NO_INIT)                     Fls_JobresultSub;         /* job result */
P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA)          Fls_SuspendedParamAddr;   /* address of writing */
volatile P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) Fls_SuspendedNowAddr;     /* current address of writing or erasing */
P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA)          Fls_SuspendedNowData;     /* data address */
VAR(FLS_ULONG, FLS_VAR_NO_INIT)                     Fls_SuspendedParamLength; /* length of writing or erasing */
VAR(FLS_ULONG, FLS_VAR_NO_INIT)                     Fls_SuspendedDataSize;    /* remain size of writing */
VAR(FLS_UCHAR, FLS_VAR_NO_INIT)                     Fls_SuspendedStateSub;    /* state of HAL */
VAR(FLS_UCHAR, FLS_VAR_NO_INIT)                     Fls_SuspendedResultSub;   /* suspended job result */
VAR(FLS_UCHAR, FLS_VAR_NO_INIT)                     Fls_SuspendingEraseFlag;  /* suspending erase of flash macro */

static VAR(Fls_WriteRegistersPatternType, FLS_VAR_NO_INIT)  Fls_WriteRegistersPatternInPrivilege; /* pattern of write registers in privilege */
static VAR(FLS_UCHAR, FLS_VAR_NO_INIT)              Fls_InInterrupt;          /* in interrupt (FLS_TRUE_SUB) or not (FLS_FALSE_SUB) */
static VAR(Fls_DmacDescriptorType, FLS_VAR_NO_INIT) Fls_DmacDescriptor;       /* DMAC descriptor */
#define FLS_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>


/*==================*/
/* Global variables */
/*==================*/
#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>
static FUNC(void, FLS_CODE) Fls_WriteRegistersInPrivilege
(
 void
);
#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>


/*==================*/
/* functions        */
/*==================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/** \brief Fls_GetMasterId
**
** Request for the bus master identifier.
**
** \return     the bus master identifier
**
*/
FUNC(FLS_UCHAR, FLS_CODE) Fls_GetMasterId
(
 void
)
{
    return (FLS_UCHAR)( ( FLS_REG_CPUSS_IDENTITY & FLS_CPUSS_IDENTITY_MS_R_MASK ) >> FLS_SHIFT_8BITS );
}


/** \brief Fls_GetAddrForRead
**
** Request for getting read address in flash memory (for FLS).
**
** \param[in]  addr       start address to read
** \param[in]  length     length in byte
**
** \return     read address if not blank, or NULL_PTR if blank
**
*/
FUNC_P2VAR(void, AUTOMATIC, FLS_CODE) Fls_GetAddrForRead
(
 P2VAR(void, AUTOMATIC, FLS_APPL_DATA) addr,
 FLS_ULONG length
)
{
    FLS_ULONG retval;                   /* return value */
#if !defined( FLS_IO_DEFINE )
    P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) laddr;

    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for calculation of address. */
    /* PRQA S 306 1 */
    laddr = (FLS_ULONG *)((FLS_ULONG)addr & 0xFFFFFFFCUL);

    /* blank check */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for specifying an address as
       an integral value for call of function. */
    /* PRQA S 306 1 */
    retval = Fls_InvokeFMAPI( FLS_FMAPI_BLANK_CHECK_SYNC, (FLS_ULONG)laddr, length );
    
    switch(retval)
    {
    case FLS_FMAPI_STATUS_SUCCESS:
    case FLS_FMAPI_STATUS_FLASH_NOT_ERASED:
        /* Performed blank check normally */
        break;
    case FLS_FMAPI_STATUS_ACTIVE_ERASE:
    case FLS_FMAPI_STATUS_EMB_ACTIVE:
        /* Blank check failed due to flash macro error */
        Fls_Fault = FLS_FAULT_MACROERROR;
        break;
    default:
        /* Blank check failed due to unexpected error */
        Fls_Fault = FLS_FAULT_OTHERERROR;
        break;
    }
#else
    (void)length;
    retval = FLS_FMAPI_STATUS_FLASH_NOT_ERASED;
#endif /* if !defined( FLS_IO_DEFINE ) */

    /* return read address if not blank or FLS_NULL if blank */
    return ( ( retval != FLS_FMAPI_STATUS_SUCCESS )? addr: NULL_PTR );
}


/** \brief Fls_GetReadAddr
**
** Request for getting read address in flash memory (for CY FEE).
**
** \param[in]  addr       start address to read
** \param[in]  length     length in byte
**
** \return     read address if not blank, or NULL_PTR if blank
**
*/
FUNC_P2VAR(void, AUTOMATIC, FLS_CODE) Fls_GetReadAddr
(
 P2VAR(void, AUTOMATIC, FLS_APPL_DATA) addr,
 FLS_ULONG length
)
{
    FLS_ULONG retval;                   /* return value */
#if !defined( FLS_IO_DEFINE )
    FLS_ULONG    RetryFlag = FLS_TRUE;
    P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) laddr;

    /* Reset fault information */
    Fls_Fault = FLS_FAULT_NONE;
    
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for calculation of address. */
    /* PRQA S 306 1 */
    laddr = (FLS_ULONG *)((FLS_ULONG)addr & 0xFFFFFFFCUL);

    /* blank check */
    do
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for specifying an address as
           an integral value for call of function. */
        /* PRQA S 306 1 */
        retval = Fls_InvokeFMAPI( FLS_FMAPI_BLANK_CHECK_SYNC, (FLS_ULONG)laddr, length );
        
        switch(retval)
        {
        case FLS_FMAPI_STATUS_SUCCESS:
        case FLS_FMAPI_STATUS_FLASH_NOT_ERASED:
            /* Performed blank check normally */
            RetryFlag = FLS_FALSE;
            break;
        case FLS_FMAPI_STATUS_ACTIVE_ERASE:
        case FLS_FMAPI_STATUS_EMB_ACTIVE:
            /* Retry blank check */
            break;
        default:
            /* Blank check failed */
            RetryFlag = FLS_FALSE;
            Fls_Fault = FLS_FAULT_OTHERERROR;
            break;
        }
        
        /* clear the watchdog timer */
        Fls_WdgClear();
    }while( RetryFlag == FLS_TRUE );
#else
    (void)length;
    retval = FLS_FMAPI_STATUS_FLASH_NOT_ERASED;
#endif /* if !defined( FLS_IO_DEFINE ) */

    /* return read address if not blank or FLS_NULL if blank */
    return ( ( retval != FLS_FMAPI_STATUS_SUCCESS )? addr: NULL_PTR );
}


/** \brief Fls_ClearReadError
**
** Request for clearing read error.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_ClearReadError
(
 void
)
{
    /* clear fault information */
    Fls_Fault = FLS_FAULT_NONE;
    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_READERROR ); /* clear read error */

    return;
}


/** \brief Fls_GetReadError
**
** Request for acquiring read error except for Fault.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_GetReadError
(
 void
)
{
    if( ( (*Fls_FlashStatusAddr) & FLS_FLASHC_CM_STATUS_R_MASK ) == FLS_FLASHC_CM_STATUS_ERROR )
    {
        /* set fault information */
        Fls_Fault = FLS_FAULT_MACROERROR;
        Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_READERROR ); /* clear read error */
    }

    return;
}


/** \brief Fls_EnableDMA
**
** Enable DMA.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_EnableDMA
(
 void
)
{
#if !defined( FLS_IO_DEFINE )
    if( Fls_UseDmaForRead == STD_ON )
    {
        /* Set DMAC DESCR registers */
        Fls_DmacDescriptor.DescrCtl  = FLS_DMAC_DESCR_CTL_VALUE;    /* DMAC_DESCR_CTL */
        Fls_DmacDescriptor.DescrNext = FLS_DMAC_DESCR_NEXT_VALUE;   /* DMAC_DESCR_NEXT */
        Fls_DisableDMA();
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 2 */
        /* Initialize DMA channel */
        FLS_REG_DMAC_CH_INTR_MASK(Fls_DmaChannel) = ( FLS_REG_DMAC_CH_INTR_MASK(Fls_DmaChannel) & FLS_DMAC_CH_INTR_MASK_W_MASK ) |
                                                      FLS_DMAC_CH_INTR_MASK_CLEAR;
    }
#endif /* if !defined( FLS_IO_DEFINE ) */
    return;
}


/** \brief Fls_DisableDMA
**
** Disable DMA.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_DisableDMA
(
 void
)
{
#if !defined( FLS_IO_DEFINE )
    if( Fls_UseDmaForRead == STD_ON )
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 5 */
        /* Disable DMA channel */
        FLS_REG_DMAC_CH_CTL(Fls_DmaChannel)       = ( FLS_REG_DMAC_CH_CTL(Fls_DmaChannel) & FLS_DMAC_CH_CTL_W_MASK ) | 
                                                      FLS_DMAC_CH_CTL_DISABLED;
        FLS_REG_DMAC_CH_CURR(Fls_DmaChannel)      = (FLS_ULONG)FLS_NULL;
        FLS_REG_DMAC_CH_INTR_MASK(Fls_DmaChannel) = ( FLS_REG_DMAC_CH_INTR_MASK(Fls_DmaChannel) & FLS_DMAC_CH_INTR_MASK_W_MASK ) |
                                                      FLS_DMAC_CH_INTR_MASK_CLEAR;
    }
#endif /* if !defined( FLS_IO_DEFINE ) */
    return;
}


/** \brief Fls_ReadFlash
**
** Read data from specified address.
**
** \param[in]  dst        address where reading to
** \param[in]  src        address where reading from
** \param[in]  length     length in byte
**
** \return     none
**
*/
/* Deviation from MISRA-C:2012 Dir-4.3.
   Justification: This function contains a inline assembler code. */
/* PRQA S 3006 1 */
FUNC(void, FLS_CODE) Fls_ReadFlash
(
 P2CONST(void, AUTOMATIC, FLS_APPL_DATA) dst,
 P2CONST(void, AUTOMATIC, FLS_APPL_DATA) src,
 FLS_ULONG length
)
{
#if !defined( FLS_IO_DEFINE )
    FLS_ULONG intr_factor;      /* interrupt factor for DMA reading */
    volatile FLS_ULONG counter; /* counter of delay loop for writing */

    if( Fls_UseDmaForRead == STD_ON )
    {
        /* Set DMA */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for setting addresses as integral values
           in DMAC descriptor. */
        /* PRQA S 306 2 */
        Fls_DmacDescriptor.DescrSrc   = (FLS_ULONG)src;             /* DMAC_DESCR_SRC */
        Fls_DmacDescriptor.DescrDst   = (FLS_ULONG)dst;             /* DMAC_DESCR_DST */
        Fls_DmacDescriptor.DescrXSize = length - 1UL;               /* DMAC_DESCR_X_SIZE */
        /* Deviation from MISRA-C:2004 rule 16.10, 8.1, MISRA-C:2012 Dir-4.2, Rule-1.2, Rule-17.3, Rule-17.7.
           Justification: This is a inline assembler code. */
        /* PRQA S 3200,3335,1006 1 */
        __asm("DSB");

        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 45 */
        /* Set current descriptor */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for setting addresses as integral values
           in DMAC_CH register . */
        /* PRQA S 306 1 */
        FLS_REG_DMAC_CH_CURR(Fls_DmaChannel) = (FLS_ULONG)&Fls_DmacDescriptor;    /* DMAC_CH_CURR */

        /* Enable DMA channel */
        FLS_REG_DMAC_CH_CTL(Fls_DmaChannel) = ( FLS_REG_DMAC_CH_CTL(Fls_DmaChannel) & FLS_DMAC_CH_CTL_W_MASK ) | 
                                                FLS_DMAC_CH_CTL_ENABLED;
        FLS_REG_DMAC_CH_CTL(Fls_DmaChannel);

        FLS_REG_DMAC_CH_INTR(Fls_DmaChannel) = FLS_DMAC_CH_INTR_CLEAR;

        /* SW Trigger */
        FLS_REG_DMAC_CH_TR_CMD(Fls_DmaChannel) = FLS_DMAC_CH_TR_CMD_ACTIVATE;

        /* wait for DMA completion */
        counter = FLS_COUNT_MAX_SUB;
        do
        {
            intr_factor = FLS_REG_DMAC_CH_INTR(Fls_DmaChannel);
            counter--;
            /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
               Justification: This implementation is adopted for avoiding more nesting.
               It is no problem because side effects cannot be caused. */
            /* PRQA S 3415 1 */
        }while( ( ( intr_factor & FLS_DMAC_CH_INTR_R_MASK ) == (FLS_ULONG)FLS_NULL ) && ( counter > 0UL ) );
        Fls_GetReadError();
        if( Fls_Fault == FLS_FAULT_NONE )
        {
            if( ( intr_factor & FLS_DMAC_CH_INTR_COMPLETION ) != (FLS_ULONG)FLS_NULL )
            {
            }
            else if( ( intr_factor & FLS_DMAC_CH_INTR_SRC_BUS_ERROR ) != (FLS_ULONG)FLS_NULL )
            {
                Fls_Fault = FLS_FAULT_BUSERROR;
            }
            else
            {
                Fls_Fault = FLS_FAULT_OTHERERROR;
            }
        }

        FLS_REG_DMAC_CH_INTR(Fls_DmaChannel) = FLS_DMAC_CH_INTR_CLEAR;
    }
#else
    {
        while( length > (FLS_ULONG)FLS_ZERO )
        {
            *(((FLS_UCHAR *)dst)++) = *(((FLS_UCHAR *)src)++);
            length--;
        }
    }
#endif /* if !defined( FLS_IO_DEFINE ) */

    return;
}


/** \brief Fls_WriteFlashStart
**
** Start writing flash memory.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_WriteFlashStart
(
 void
)
{
#if !defined( FLS_IO_DEFINE )
    FLS_ULONG fmapi_result;     /* result of Flash manament API */
    FLS_ULONG addr;             /* current address of writing */
    FLS_ULONG data;             /* data to be written */
    P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) ldataaddr; /* address of data to be written (1byte) */
    P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) lnowdata;  /* data address (1byte) */

    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_ENABLE_WRITE ); /* enable writing to flash memory */

    if( Fls_IpcLocked == FLS_TRUE )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
           Justification: This cast is needed for specifying addresses as
           integral values for call of function. */
        /* PRQA S 303 1 */
        addr = (FLS_ULONG)Fls_NowAddr;
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for calculation of address. */
        /* PRQA S 306 1 */
        if( ( (FLS_ULONG)Fls_NowData & (FLS_ULONG)( sizeof(FLS_ULONG) - 1UL ) ) == 0UL )
        {
            data = *Fls_NowData;
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
               Justification: This cast is needed for handling with 8-bit type address. */
            /* PRQA S 310 2 */
            lnowdata  = (FLS_UCHAR *)Fls_NowData;
            ldataaddr = (FLS_UCHAR *)&data;
            ldataaddr[0] = lnowdata[0];
            ldataaddr[1] = lnowdata[1];
            ldataaddr[2] = lnowdata[2];
            ldataaddr[3] = lnowdata[3];
        }

        Fls_NowAddr++;
        Fls_NowData++;
        Fls_DataSize -= sizeof(FLS_ULONG);

        Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );  /* invalidate cache and buffer */

        /* start writing */
        if( Fls_UseNonBlockingWrite == STD_OFF )
        {
            fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_PROGRAM_ROW_BLOCKING, addr, data );
        }
        else
        {
            fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_PROGRAM_ROW_NONBLOCKING, addr, data );
        }
        switch( fmapi_result )
        {
        case FLS_FMAPI_STATUS_SUCCESS:
            if( ( Fls_UseInterrupts == STD_OFF ) || ( Fls_UseNonBlockingWrite == STD_ON ) )
            {
                Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_DISABLE_INTERRUPT_WRITE ); /* disable interruption */
            }
            else
            {
                Fls_InInterrupt = FLS_FALSE_SUB;
                Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_ENABLE_INTERRUPT_WRITE ); /* enable interruption */
            }
            break;
        case FLS_FMAPI_STATUS_ACTIVE_ERASE:
        case FLS_FMAPI_STATUS_EMB_ACTIVE:
            Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
            break;
        default:
            Fls_JobresultSub = FLS_JOB_FAILED_UNWRITABLE;
            break;
        }
    }
    else
    {
        Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
    }
#else
    *Fls_NowAddr = *Fls_NowData;
    Fls_NowAddr++;
    Fls_NowData++;
    Fls_DataSize -= sizeof(FLS_ULONG);
#endif /* if !defined( FLS_IO_DEFINE ) */

    return;
}


/** \brief Fls_WriteFlashPolling
**
** Poll for write completion. 
** When complete it, write next data if it is necessary.
**
** \return     result of polling
** \retval     FLS_OK         success
** \retval     FLS_NG         failed
** \retval     FLS_CONT       continue
** 
*/
FUNC(FLS_UCHAR, FLS_CODE) Fls_WriteFlashPolling
(
 void
)
{
    FLS_UCHAR retval;           /* return value */
    FLS_ULONG fmapi_result;     /* result of Flash manament API */
    FLS_ULONG addr;             /* current address of writing */
    FLS_ULONG data;             /* data to be written */
    P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) ldataaddr; /* address of data to be written (1byte) */
    P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) lnowdata;  /* data address (1byte) */

    retval = Fls_PollingFlash();

    if( retval == FLS_HAL_WRITE )
    {
        retval = FLS_CONT;
    }
    else if( retval == FLS_HAL_MAX )
    {
        retval = FLS_NG;
        Fls_JobresultSub = FLS_JOB_FAILED;
    }
    else
    {
        if( Fls_UseNonBlockingWrite == STD_ON )
        {
#if !defined( FLS_IO_DEFINE )
            /* Dummy read from Work FLASH is required if embedded operation was done in non-blocking mode. */
            *(Fls_NowAddr - 1);
#endif /* if !defined( FLS_IO_DEFINE ) */
        }
        if( Fls_DataSize == (FLS_ULONG)FLS_ZERO )
        {
            /* write completion */
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );    /* invalidate cache and buffer */
            retval = FLS_OK;
            Fls_JobresultSub = FLS_JOB_OK;
        }
        else
        {
            retval = FLS_CONT;

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
               Justification: This cast is needed for specifying addresses as
               integral values for call of function. */
            /* PRQA S 303 1 */
            addr = (FLS_ULONG)Fls_NowAddr;
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
               Justification: This cast is needed for calculation of address. */
            /* PRQA S 306 1 */
            if( ( (FLS_ULONG)Fls_NowData & (FLS_ULONG)( sizeof(FLS_ULONG) - 1UL ) ) == 0UL )
            {
                data = *Fls_NowData;
            }
            else
            {
                /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
                   Justification: This cast is needed for handling with 8-bit type address. */
                /* PRQA S 310 2 */
                lnowdata  = (FLS_UCHAR *)Fls_NowData;
                ldataaddr = (FLS_UCHAR *)&data;
                ldataaddr[0] = lnowdata[0];
                ldataaddr[1] = lnowdata[1];
                ldataaddr[2] = lnowdata[2];
                ldataaddr[3] = lnowdata[3];
            }

            Fls_NowAddr++;
            Fls_NowData++;
            Fls_DataSize -= sizeof(FLS_ULONG);

#if !defined( FLS_IO_DEFINE )
            /* start writing */
            if( Fls_UseNonBlockingWrite == STD_OFF )
            {
                fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_PROGRAM_ROW_BLOCKING, addr, data );
            }
            else
            {
                fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_PROGRAM_ROW_NONBLOCKING, addr, data );
            }
            switch( fmapi_result )
            {
            case FLS_FMAPI_STATUS_SUCCESS:
                break;
            case FLS_FMAPI_STATUS_ACTIVE_ERASE:
            case FLS_FMAPI_STATUS_EMB_ACTIVE:
                Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
                break;
            default:
                retval = FLS_NG;
                Fls_JobresultSub = FLS_JOB_FAILED_UNWRITABLE;
                break;
            }
#else
            (void)addr;
            (void)data;
            *(Fls_NowAddr - 1) = *(Fls_NowData - 1);
#endif /* if !defined( FLS_IO_DEFINE ) */
        }
    }

    return retval;
}


/** \brief Fls_WriteFlashFinal
**
** End writing flash memory.
**
** \return     none
** 
*/
FUNC(void, FLS_CODE) Fls_WriteFlashFinal
(
 void
)
{
    /* initialize internal variable */
    Fls_NowData      = (FLS_ULONG *)FLS_NULL;
    Fls_NowAddr      = (volatile FLS_ULONG *)FLS_NULL;
    Fls_DataSize     = (FLS_ULONG)FLS_NULL;
    Fls_ParamLength  = (FLS_ULONG)FLS_NULL;
    Fls_ParamAddr    = (FLS_UCHAR *)FLS_NULL;

    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_DISABLE_INTERRUPT_WRITE ); /* disable interruption */
    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );        /* invalidate cache and buffer */
    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_DISABLE_WRITE );           /* disable writing to flash memory */

    return;
}


/** \brief Fls_EraseFlashStart
**
** Start erasing specified sector in flash memory.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_EraseFlashStart
(
 void
)
{
#if !defined( FLS_IO_DEFINE )
    FLS_ULONG         fmapi_result; /* result of Flash manament API */
    Fls_MemoryMapType sector_info;  /* sector information */

    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_ENABLE_WRITE ); /* enable writing to flash memory */

    if( Fls_IpcLocked == FLS_TRUE )
    {
        Fls_GetCurrentSectorInfo(&sector_info);

        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
           Justification: This cast is needed for handling integral values as
           addresses for device access. */
        /* PRQA S 303 1 */
        Fls_NowAddr = (volatile FLS_ULONG *)sector_info.physical;
        Fls_DataSize = sector_info.size;

        Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );  /* invalidate cache and buffer */

        /* start erasing */
        if( Fls_UseInterrupts == STD_OFF )
        {
            fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_ERASE_SECTOR_NOINTR, sector_info.physical, (FLS_ULONG)FLS_NULL );
        }
        else
        {
            Fls_InInterrupt = FLS_FALSE_SUB;
            (void)Fls_InvokeFMAPI( FLS_FMAPI_CONFIGURE_FM_INTERRUPT_CLEAR, (FLS_ULONG)FLS_NULL, (FLS_ULONG)FLS_NULL );
            fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_ERASE_SECTOR_INTR, sector_info.physical, (FLS_ULONG)FLS_NULL );
        }
        switch( fmapi_result )
        {
        case FLS_FMAPI_STATUS_SUCCESS:
            break;
        case FLS_FMAPI_STATUS_ACTIVE_ERASE:
        case FLS_FMAPI_STATUS_EMB_ACTIVE:
            Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
            break;
        default:
            Fls_JobresultSub = FLS_JOB_FAILED_UNWRITABLE;
            break;
        }
    }
    else
    {
        Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
    }
#else
    {
        Fls_MemoryMapType sector_info;  /* sector information */
        FLS_ULONG         counter;      /* counter */

        Fls_GetCurrentSectorInfo(&sector_info);
        Fls_NowAddr = (volatile FLS_ULONG *)sector_info.physical;
        Fls_DataSize = sector_info.size;
        counter = sector_info.size;
        while( counter > (FLS_ULONG)FLS_ZERO )
        {
            *Fls_NowAddr++ = 0xFFFFFFFFUL;
            counter -= sizeof(FLS_ULONG);
        }
    }
#endif /* if !defined( FLS_IO_DEFINE ) */

    return;
}


/** \brief Fls_EraseFlashPolling
**
** Poll for erase completion. 
** When complete it, erase next sector if it is necessary.
**
** \return     result of polling
** \retval     FLS_OK         success 
** \retval     FLS_NG         failed
** \retval     FLS_CONT       continue
** 
*/
FUNC(FLS_UCHAR, FLS_CODE) Fls_EraseFlashPolling
(
 void
)
{
    FLS_UCHAR         retval;       /* return value */
    FLS_ULONG         fmapi_result; /* result of Flash manament API */
    Fls_MemoryMapType sector_info;  /* sector information */

    retval = Fls_PollingFlash();

    if( retval == FLS_HAL_ERASE )
    {
        retval = FLS_CONT;
    }
    else if( retval == FLS_HAL_MAX )
    {
        retval = FLS_NG;
        Fls_JobresultSub = FLS_JOB_FAILED;
    }
    else
    {
#if !defined( FLS_IO_DEFINE )
        /* Dummy read from Work FLASH is required if embedded operation was done in non-blocking mode. */
        *Fls_NowAddr;
#endif /* if !defined( FLS_IO_DEFINE ) */

        Fls_ParamLength -= Fls_DataSize;

        if( Fls_ParamLength == (FLS_ULONG)FLS_ZERO )
        {
            /* erase completion */
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );    /* invalidate cache and buffer */
            retval = FLS_OK;
            Fls_JobresultSub = FLS_JOB_OK;
        }
        else
        {
            retval = FLS_CONT;

            Fls_IncrementCurrentSector();
            Fls_GetCurrentSectorInfo(&sector_info);

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
               Justification: This cast is needed for handling integral values as
               addresses for device access. */
            /* PRQA S 303 1 */
            Fls_NowAddr = (volatile FLS_ULONG *)sector_info.physical;
            Fls_DataSize = sector_info.size;

            /* start erasing */
#if !defined( FLS_IO_DEFINE )
            if( Fls_UseInterrupts == STD_OFF )
            {
                fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_ERASE_SECTOR_NOINTR, sector_info.physical, (FLS_ULONG)FLS_NULL );
            }
            else
            {
                fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_ERASE_SECTOR_INTR, sector_info.physical, (FLS_ULONG)FLS_NULL );
            }
            switch( fmapi_result )
            {
            case FLS_FMAPI_STATUS_SUCCESS:
                break;
            case FLS_FMAPI_STATUS_ACTIVE_ERASE:
            case FLS_FMAPI_STATUS_EMB_ACTIVE:
                Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
                break;
            default:
                retval = FLS_NG;
                Fls_JobresultSub = FLS_JOB_FAILED_UNWRITABLE;
                break;
            }
#else
            {
                FLS_ULONG   counter; /* counter */

                counter = sector_info.size;
                while( counter > (FLS_ULONG)FLS_ZERO )
                {
                    *Fls_NowAddr++ = 0xFFFFFFFFUL;
                    counter -= sizeof(FLS_ULONG);
                }
            }
#endif /* if !defined( FLS_IO_DEFINE ) */
        }
    }

    return retval;
}


/** \brief Fls_EraseFlashFinal
**
** End erasing flash memory.
**
** \return     none
** 
*/
FUNC(void, FLS_CODE) Fls_EraseFlashFinal
(
 void
)
{
    /* initialize internal variable */
    Fls_NowAddr      = (volatile FLS_ULONG *)FLS_NULL;
    Fls_DataSize     = (FLS_ULONG)FLS_NULL;
    Fls_ParamLength  = (FLS_ULONG)FLS_NULL;

    if( Fls_UseInterrupts == STD_ON )
    {
        /* clear interrupt mask of FM_CTL_ECT */
        (void)Fls_InvokeFMAPI( FLS_FMAPI_CONFIGURE_FM_INTERRUPT_MCLEAR, (FLS_ULONG)FLS_NULL, (FLS_ULONG)FLS_NULL );
    }
    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );    /* invalidate cache and buffer */
    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_DISABLE_WRITE );       /* disable writing to flash memory */

    return;
}


/** \brief Fls_BlankCheckFlashStart
**
** Start brank checking specified sector in flash memory.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_BlankCheckFlashStart
(
 void
)
{
    FLS_ULONG         fmapi_result; /* result of Flash manament API */

#if !defined( FLS_IO_DEFINE )
    /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
       Justification: This implementation is adopted for avoiding more nesting.
       It is no problem because side effects cannot be caused. */
    /* PRQA S 3415 1 */
    if( ( Fls_UseSafetyMechanism == STD_OFF ) || ( Fls_IpcLock() == FLS_TRUE ) )
    {
        Fls_IpcLocked = FLS_TRUE;
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
           Justification: This cast is needed for specifying an address as
           an integral value for call of function. */
        /* PRQA S 303 1 */
        fmapi_result = Fls_InvokeFMAPI( FLS_FMAPI_BLANK_CHECK_ASYNC, (FLS_ULONG)Fls_NowAddr, Fls_DataSize );
        switch( fmapi_result )
        {
        case FLS_FMAPI_STATUS_SUCCESS:
            break;
        case FLS_FMAPI_STATUS_ACTIVE_ERASE:
        case FLS_FMAPI_STATUS_EMB_ACTIVE:
            Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
            break;
        default:
            Fls_JobresultSub = FLS_JOB_FAILED_UNWRITABLE;
            break;
        }
    }
    else
    {
        Fls_JobresultSub = FLS_JOB_FAILED_NOTACQUIRE;
    }
#endif /* if !defined( FLS_IO_DEFINE ) */

    return;
}


/** \brief Fls_BlankCheckFlashPolling
**
** Poll for blank check completion. 
** When complete it, blank check next area if it is necessary.
**
** \return     result of polling
** \retval     FLS_OK         success 
** \retval     FLS_NG         failed
** \retval     FLS_CONT       continue
** 
*/
FUNC(FLS_UCHAR, FLS_CODE) Fls_BlankCheckFlashPolling
(
 void
)
{
    FLS_UCHAR   retval;         /* return value */

    retval = Fls_PollingFlash();

    if( retval == FLS_HAL_BLANKCHECK )
    {
        retval = FLS_CONT;
    }
    else if( retval == FLS_HAL_MAX )
    {
        /* completion unsuccessfully */
        retval = FLS_NG;
        Fls_JobresultSub = FLS_JOB_FAILED;
    }
    else
    {
        /* completion successfully */
        retval = FLS_OK;
        Fls_JobresultSub = FLS_JOB_OK;
    }

    return retval;
}


/** \brief Fls_BlankCheckFlashFinal
**
** End checking blank flash memory.
**
** \return     none
** 
*/
FUNC(void, FLS_CODE) Fls_BlankCheckFlashFinal
(
 void
)
{
    /* initialize internal variable */
    Fls_NowAddr      = (volatile FLS_ULONG *)FLS_NULL;
    Fls_ParamLength  = (FLS_ULONG)FLS_NULL;
    Fls_ParamAddr    = (FLS_UCHAR *)FLS_NULL;
    if( Fls_UseSafetyMechanism == STD_ON )
    {
        Fls_IpcRelease( FLS_EMBEDDED_NONE, FLS_FALSE );
    }
    Fls_IpcLocked = FLS_FALSE;

    return;
}


/** \brief Fls_CancelSubSub
**
** Cancel the processing under operation.
** Initialize internal variable used in writing and erasing.
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_CancelSubSub
(
 void
)
{
    /* Initialize internal variable. */
    Fls_DataSize    = (FLS_ULONG)FLS_NULL;
    Fls_ParamLength = (FLS_ULONG)FLS_NULL;
    Fls_ParamAddr   = (FLS_UCHAR *)FLS_NULL;

    /* Initialize internal variable. */
    Fls_NowAddr = (volatile FLS_ULONG *)FLS_NULL;
    Fls_NowData = (FLS_ULONG *)FLS_NULL;

    if( Fls_UseInterrupts == STD_ON )
    {
        if( Fls_StateSub == FLS_HAL_WRITE )
        {
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_DISABLE_INTERRUPT_WRITE ); /* disable interruption */
        }
        else
        {
            if( Fls_StateSub == FLS_HAL_ERASE )
            {
                /* clear interrupt mask of FM_CTL_ECT */
               (void)Fls_InvokeFMAPI( FLS_FMAPI_CONFIGURE_FM_INTERRUPT_MCLEAR, (FLS_ULONG)FLS_NULL, (FLS_ULONG)FLS_NULL );
            }
        }
    }

    Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_INVALIDATE_CACHE );        /* invalidate cache and buffer */

    FLS_STATESUB_SET(FLS_HAL_NOP)             /* set state */

    /* call Fls_GetStatusSub because to disable writing to flash memory */
    (void)Fls_GetStatusSub();
    
    return;
}


/** \brief Fls_PollingFlash
**
** Poll for write completion or erase completion status check.
**
** \return     result of polling
** \retval     FLS_HAL_NOP              No-operation(completion)
** \retval     FLS_HAL_WRITE_WAIT       waiting for writing
** \retval     FLS_HAL_WRITE            writing
** \retval     FLS_HAL_ERASE_WAIT       waiting for erasing
** \retval     FLS_HAL_ERASE            erasing
** \retval     FLS_HAL_BLANKCHECK_WAIT  waiting for checking blank
** \retval     FLS_HAL_BLANKCHECK       checking blank
** \retval     FLS_HAL_MAX              timing limit exceeded
** \retval     FLS_FMC_ACT              FMC active in no-operation
**
*/
FUNC(FLS_UCHAR, FLS_CODE) Fls_PollingFlash
(
 void
)
{
    FLS_UCHAR retval;           /* return value */
#if !defined( FLS_IO_DEFINE )
    FLS_ULONG fmapi_result;     /* result of Flash manament API */

    if( Fls_InInterrupt == FLS_TRUE_SUB )
    {
        if( Fls_StateSub == FLS_HAL_WRITE )
        {
            /* comes here when async serivice (program) has finished */
            fmapi_result = Fls_GetResultFMAPI();
            if( fmapi_result == FLS_FMAPI_STATUS_SUCCESS )
            {
                retval = FLS_HAL_NOP;       /* completion successfully */
            }
            else
            {
                retval = FLS_HAL_MAX;       /* completion unsuccessfully */
            }
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_IPC ); /* clear interruption of IPC */
        }
        else
        {
            /* comes here when async serivice (erase) has finished */
            /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
               Justification: This cast is needed for doing pointer arithmetic. */
            /* PRQA S 488 1 */
            if( ( FLS_REG_FM_CTL_ECT_STATUS & FLS_FM_CTL_ECT_STATUS_HANG_MASK ) == FLS_FM_CTL_ECT_STATUS_NOHANG )
            {
                retval = FLS_HAL_NOP;       /* completion successfully */
            }
            else
            {
                retval = FLS_HAL_MAX;       /* completion unsuccessfully */
            }
            /* clear interrupt of FM_CTL_ECT */
            (void)Fls_InvokeFMAPI( FLS_FMAPI_CONFIGURE_FM_INTERRUPT_CLEAR, (FLS_ULONG)FLS_NULL, (FLS_ULONG)FLS_NULL );
        }
    }
    else if( ( ( Fls_StateSub == FLS_HAL_WRITE ) && ( Fls_UseNonBlockingWrite == STD_OFF ) ) || ( Fls_StateSub == FLS_HAL_BLANKCHECK ) )
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 1 */
        if( ( FLS_REG_IPC_INTR_STRUCT_INTR(FLS_FMAPI_SLAVE_IPC_INTR) & FLS_IPC_INTR_STRUCT_INTR_R_MASK(FLS_FMAPI_IPC) ) == FLS_IPC_INTR_STRUCT_INTR_RELEASE(FLS_FMAPI_IPC) )
        {
            /* comes here when async serivice (program/blank check) has finished */
            fmapi_result = Fls_GetResultFMAPI();
            if( fmapi_result == FLS_FMAPI_STATUS_SUCCESS )
            {
                retval = FLS_HAL_NOP;       /* completion successfully */
            }
            else
            {
                retval = FLS_HAL_MAX;       /* completion unsuccessfully */
            }
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_IPC ); /* clear interruption of IPC */
        }
        else
        {
            retval = Fls_StateSub;          /* current state of HAL */
        }
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 1 */
        fmapi_result = FLS_REG_FM_CTL_ECT_STATUS;
        if( ( fmapi_result & FLS_FM_CTL_ECT_STATUS_BUSY_MASK ) == FLS_FM_CTL_ECT_STATUS_NOTBUSY )
        {
            /* comes here when async serivice (program or erase) has finished */
            if( ( fmapi_result & FLS_FM_CTL_ECT_STATUS_HANG_MASK ) == FLS_FM_CTL_ECT_STATUS_NOHANG )
            {
                retval = FLS_HAL_NOP;       /* completion successfully */
            }
            else
            {
                retval = FLS_HAL_MAX;       /* completion unsuccessfully */
            }
            Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_IPC ); /* clear interruption of IPC */
        }
        else
        {
            /* comes here when async serivice (program or erase) is running */
            if( Fls_StateSub == FLS_HAL_NOP )
            {
                retval = FLS_FMC_ACT;        /* FMC active in no-operation */
            }
            else
            {
                retval = Fls_StateSub;          /* current state of HAL */
            }
        }
    }
#else
    retval = FLS_HAL_NOP;
#endif /* if !defined( FLS_IO_DEFINE ) */
    
    return retval;
}


/** \brief Fls_Isr_Ipc_Sub
**
** ISR process in HAL unit of flash processing (IPC_INTR).
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_Isr_Ipc_Sub
(
 void
)
{
    Fls_InInterrupt = FLS_TRUE_SUB;

    if( Fls_StateSub == FLS_HAL_WRITE )
    {
        (void)Fls_WriteFlashPolling();
    }
    else
    {
        Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_IPC ); /* clear interruption of IPC */
    }

    Fls_InInterrupt = FLS_FALSE_SUB;

    return;
}


/** \brief Fls_Isr_Flash_Sub
**
** ISR process in HAL unit of flash processing (FM_CTL_ECT).
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_Isr_Flash_Sub
(
 void
)
{
    Fls_InInterrupt = FLS_TRUE_SUB;

    if( Fls_StateSub == FLS_HAL_ERASE )
    {
        (void)Fls_EraseFlashPolling();
    }
    else
    {
        (void)Fls_InvokeFMAPI( FLS_FMAPI_CONFIGURE_FM_INTERRUPT_CLEAR, (FLS_ULONG)FLS_NULL, (FLS_ULONG)FLS_NULL );
    }

    Fls_InInterrupt = FLS_FALSE_SUB;

    return;
}


/** \brief Fls_Fault_Handling_Sub
**
** Fault handling process in HAL unit (FAULT, FLASHC).
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_Fault_Handling_Sub
(
 void
)
{
    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
       Justification: This cast is needed for doing pointer arithmetic. */
    /* PRQA S 488 3 */
    if( ( FLS_REG_FAULT_STRUCT_STATUS & FLS_FAULT_STRUCT_STATUS_R_MASK1 ) != (FLS_ULONG)FLS_NULL )
    {
        switch( FLS_REG_FAULT_STRUCT_STATUS & FLS_FAULT_STRUCT_STATUS_R_MASK2 )
        {
        case FLS_FAULT_STRUCT_STATUS_WORK_BUS_ERROR:
            /* set fault information */
            Fls_Fault = FLS_FAULT_BUSERROR;
            break;
        case FLS_FAULT_STRUCT_STATUS_WORK_C_ECC:
            /* set fault information */
            Fls_Fault = FLS_FAULT_SED;
            break;
        case FLS_FAULT_STRUCT_STATUS_WORK_NC_ECC:
            /* set fault information */
            Fls_Fault = FLS_FAULT_DED;
            break;
        default:
            /* set fault information */
            Fls_Fault = FLS_FAULT_OTHERERROR;
            break;
        }
    }

    /* user will clear valid of fault status */

    return;
}


/** \brief Fls_WritePrivilegedRegisters
**
** Access routine to registers for writing in privileged mode.
**
** \param[in]  pattern    pattern of writing to registers
**
** \return     none
**
*/
FUNC(void, FLS_CODE) Fls_WritePrivilegedRegisters
(
 Fls_WriteRegistersPatternType pattern
)
{
    Fls_WriteRegistersPatternInPrivilege = pattern;

    Fls_WriteRegistersInPrivilege(); /* calls Fls_WriteRegistersInPrivilege directly */

    return;
}


/** \brief Fls_WriteRegistersInPrivilege
**
** Access to registers for writing in privileged mode.
**
** \return     none
**
*/
static FUNC(void, FLS_CODE) Fls_WriteRegistersInPrivilege
(
 void
)
{
#if !defined( FLS_IO_DEFINE )
    switch(Fls_WriteRegistersPatternInPrivilege)
    {
    case FLS_WRITE_REG_PATN_ENABLE_WRITE:
        /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
           Justification: This implementation is adopted for avoiding more nesting.
           It is no problem because side effects cannot be caused. */
        /* PRQA S 3415 1 */
        if( ( Fls_UseSafetyMechanism == STD_OFF ) || ( Fls_IpcLock() == FLS_TRUE ) )
        {
            if( Fls_WFSafetyWMask != 0xFFFFFFFFUL )
            {
                /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
                   Justification: This cast is needed for doing pointer arithmetic. */
                /* PRQA S 488 3 */
                FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY = ( FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY & Fls_WFSafetyWMask ) |
                                                         FLS_FM_CTL_ECT_WORK_FLASH_SAFETY_WE_ON;
                FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY;
            }
            Fls_IpcLocked = FLS_TRUE;
        }
        break;
    case FLS_WRITE_REG_PATN_DISABLE_WRITE:
        if( ( Fls_UseSafetyMechanism == STD_OFF ) || ( Fls_IpcLocked == FLS_TRUE ) )
        {
            if( Fls_WFSafetyWMask != 0xFFFFFFFFUL )
            {
                /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
                   Justification: This cast is needed for doing pointer arithmetic. */
                /* PRQA S 488 3 */
                FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY = ( FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY & Fls_WFSafetyWMask ) |
                                                         FLS_FM_CTL_ECT_WORK_FLASH_SAFETY_WE_OFF;
                FLS_REG_FM_CTL_ECT_WORK_FLASH_SAFETY;
            }
            if( Fls_UseSafetyMechanism == STD_ON )
            {
                Fls_IpcRelease( FLS_EMBEDDED_WORK, FLS_FALSE );
            }
            Fls_IpcLocked = FLS_FALSE;
        }
        break;
    case FLS_WRITE_REG_PATN_DISABLE_INTERRUPT_WRITE:
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 4 */
        FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_FMAPI_SLAVE_IPC_INTR) = ( FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_FMAPI_SLAVE_IPC_INTR) &
                                                                        FLS_IPC_INTR_STRUCT_INTR_MASK_W_MASK(FLS_FMAPI_IPC) ) |
                                                                        FLS_IPC_INTR_STRUCT_INTR_MASK_DISABLE;
        FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_FMAPI_SLAVE_IPC_INTR);
        break;
    case FLS_WRITE_REG_PATN_ENABLE_INTERRUPT_WRITE:
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 4 */
        FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_FMAPI_SLAVE_IPC_INTR) = ( FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_FMAPI_SLAVE_IPC_INTR) &
                                                                        FLS_IPC_INTR_STRUCT_INTR_MASK_W_MASK(FLS_FMAPI_IPC) ) |
                                                                        FLS_IPC_INTR_STRUCT_INTR_MASK_ENABLE(FLS_FMAPI_IPC);
        FLS_REG_IPC_INTR_STRUCT_INTR_MASK(FLS_FMAPI_SLAVE_IPC_INTR);
        break;
    case FLS_WRITE_REG_PATN_CLEAR_IPC:
        /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
           Justification: This cast is needed for doing pointer arithmetic. */
        /* PRQA S 488 2 */
        FLS_REG_IPC_INTR_STRUCT_INTR(FLS_FMAPI_SLAVE_IPC_INTR) = FLS_IPC_INTR_STRUCT_INTR_CLEAR(FLS_FMAPI_IPC);
        FLS_REG_IPC_INTR_STRUCT_INTR(FLS_FMAPI_SLAVE_IPC_INTR);
        break;
    case FLS_WRITE_REG_PATN_INVALIDATE_CACHE:
        if( Fls_HsmPresent == STD_OFF )
        {
            /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
               Justification: This cast is needed for doing pointer arithmetic. */
            /* PRQA S 488 3 */
            FLS_REG_FLASHC_FLASH_CMD = ( FLS_REG_FLASHC_FLASH_CMD & FLS_FLASHC_FLASH_CMD_W_MASK ) |
                                         FLS_FLASHC_FLASH_CMD_INVALID;
            FLS_REG_FLASHC_FLASH_CMD;
        }
        else
        {
            if( Fls_IpcLocked == FLS_TRUE )
            {
                Fls_IpcNotify(FLS_INVOKE_HSM_INVALIDATE_CACHE);
            }
        }
        break;
    case FLS_WRITE_REG_PATN_CLEAR_READERROR:
        *Fls_FlashStatusAddr = ( (*Fls_FlashStatusAddr) & FLS_FLASHC_CM_STATUS_W_MASK ) |
                                 FLS_FLASHC_CM_STATUS_CLEAR;
        *Fls_FlashStatusAddr;
        break;
    case FLS_WRITE_REG_PATN_REFRESH_REGISTERS:
    case FLS_WRITE_REG_PATN_INITIALIZE_REGISTERS:
        if( Fls_HsmPresent == STD_OFF )
        {
            if( Fls_FlashCtlWMask != 0xFFFFFFFFUL )
            {
                /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
                   Justification: This cast is needed for doing pointer arithmetic. */
                /* PRQA S 488 2 */
                FLS_REG_FLASHC_FLASH_CTL = ( FLS_REG_FLASHC_FLASH_CTL & Fls_FlashCtlWMask ) | Fls_FlashCtlValue;
                FLS_REG_FLASHC_FLASH_CTL;
            }
        }
        if( Fls_FaultStructMask1WMask != 0xFFFFFFFFUL )
        {
            /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
               Justification: This cast is needed for doing pointer arithmetic. */
            /* PRQA S 488 3 */
            FLS_REG_FAULT_STRUCT_MASK1 = ( FLS_REG_FAULT_STRUCT_MASK1 & Fls_FaultStructMask1WMask ) |
                                           Fls_FaultStructMask1Value;
            FLS_REG_FAULT_STRUCT_MASK1;
        }
        if( Fls_UseSafetyMechanism == STD_ON )
        {
            Fls_IpcIntrMask();
        }
        break;
    default:
        break;
    }
#endif /* if !defined( FLS_IO_DEFINE ) */
    return;
}

/** \brief Fls_CheckRegisters
 **
 ** Checks registers written by HSM.
 **
 ** \return    check result
 ** \retval    FLS_FALSE        failed
 **            FLS_TRUE         success
 */
FUNC(uint8, FLS_CODE) Fls_CheckRegisters
(
 void
)
{
    uint8   Ret;            /* return value */

    /* set FLS_TRUE for return value  */
    Ret = FLS_TRUE;

    if( Fls_FlashCtlWMask != 0xFFFFFFFFUL )
    {
        if( ( FLS_REG_FLASHC_FLASH_CTL & Fls_FlashCtlRMask ) != Fls_FlashCtlValue )
        {
            /* set FLS_FALSE for return value  */
            Ret = FLS_FALSE;
        }
    }

    return Ret;
}

/** \brief Fls_InvokeFMAPI
**
** Invoke FLASH Management API.
**
** \param[in]  opcode     opcode
** \param[in]  argument1  1st argumen1
** \param[in]  argument2  2nd argumen1
**
** \return     result of request
** \retval     FLS_FMAPI_STATUS_SUCCESS             complete successfully
** \retval     other than FLS_FMAPI_STATUS_SUCCESS  failed
**
*/
/* Deviation from MISRA-C:2012 Dir-4.3.
   Justification: This function contains a inline assembler code. */
/* PRQA S 3006 1 */
FUNC(FLS_ULONG, FLS_CODE) Fls_InvokeFMAPI
(
 FLS_UCHAR opcode,
 FLS_ULONG argument1,
 FLS_ULONG argument2
)
{
    FLS_ULONG fmapi_result;             /* result of Flash manament API */
#if !defined( FLS_IO_DEFINE )
    FLS_UCHAR sync;                     /* whether service is sync (FLS_TRUE_SUB) or async (FLS_FALSE_SUB) */
    FLS_UCHAR blocking;                 /* whether API is blocking (FLS_TRUE_SUB) or non-blocking (FLS_FALSE_SUB) */
    FLS_ULONG ipc_data;                 /* IPC data */
    volatile FLS_ULONG counter;         /* counter of delay loop for writing */

    fmapi_result = FLS_FMAPI_STATUS_SUCCESS;
    blocking = FLS_TRUE_SUB;
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for setting an address as an integral value
       in a register for FLASH Management API invocation. */
    /* PRQA S 306 1 */
    ipc_data = (FLS_ULONG)(&Fls_IpcContext[0]);

    switch(opcode)
    {
    case FLS_FMAPI_PROGRAM_ROW_BLOCKING:
        sync = FLS_FALSE_SUB;
        Fls_WriteData = argument2;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_PROGRAM_ROW << FLS_SHIFT_24BITS) | ((FLS_ULONG)FLS_FMAPI_SKIP_BLANKCHECK << FLS_SHIFT_16BITS) |
                            ((FLS_ULONG)FLS_FMAPI_BLOCKING << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = (0UL << FLS_SHIFT_16BITS) | ((FLS_ULONG)FLS_FMAPI_DATALOCATION_SRAM << FLS_SHIFT_8BITS) |
                            ((FLS_ULONG)FLS_FMAPI_PROGRAM_32BITS);
        Fls_IpcContext[2] = argument1;
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
           Justification: This cast is needed for setting an address as an integral value
           in a register for FLASH Management API invocation. */
        /* PRQA S 303 1 */
        Fls_IpcContext[3] = (FLS_ULONG)(&Fls_WriteData);
        break;
    case FLS_FMAPI_PROGRAM_ROW_NONBLOCKING:
        sync = FLS_FALSE_SUB;
        blocking = FLS_FALSE_SUB;
        Fls_WriteData = argument2;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_PROGRAM_ROW << FLS_SHIFT_24BITS) | ((FLS_ULONG)FLS_FMAPI_SKIP_BLANKCHECK << FLS_SHIFT_16BITS) |
                            ((FLS_ULONG)FLS_FMAPI_NONBLOCKING << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = ((FLS_ULONG)FLS_FMAPI_NO_INTR_MASK << FLS_SHIFT_24BITS) | (0UL << FLS_SHIFT_16BITS) |
                            ((FLS_ULONG)FLS_FMAPI_DATALOCATION_SRAM << FLS_SHIFT_8BITS) | ((FLS_ULONG)FLS_FMAPI_PROGRAM_32BITS);
        Fls_IpcContext[2] = argument1;
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
           Justification: This cast is needed for setting an address as an integral value
           in a register for FLASH Management API invocation. */
        /* PRQA S 303 1 */
        Fls_IpcContext[3] = (FLS_ULONG)(&Fls_WriteData);
        break;
    case FLS_FMAPI_CONFIGURE_FM_INTERRUPT_CLEAR:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_CONFIGURE_FM_INTERRUPT << FLS_SHIFT_24BITS) |
                            ((FLS_ULONG)FLS_FMAPI_CLEAR_INTERRUPT << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = 0UL;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_CONFIGURE_FM_INTERRUPT_MSET:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_CONFIGURE_FM_INTERRUPT << FLS_SHIFT_24BITS) |
                            ((FLS_ULONG)FLS_FMAPI_SET_INTERRUPT_MASK << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = 0UL;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_CONFIGURE_FM_INTERRUPT_MCLEAR:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_CONFIGURE_FM_INTERRUPT << FLS_SHIFT_24BITS) |
                            ((FLS_ULONG)FLS_FMAPI_CLEAR_INTERRUPT_MASK << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = 0UL;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_ERASE_SECTOR_NOINTR:
        sync = FLS_FALSE_SUB;
        blocking = FLS_FALSE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_ERASE_SECTOR << FLS_SHIFT_24BITS) | ((FLS_ULONG)FLS_FMAPI_NO_INTR_MASK << FLS_SHIFT_16BITS) |
                            ((FLS_ULONG)FLS_FMAPI_NONBLOCKING << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = argument1;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_ERASE_SECTOR_INTR:
        sync = FLS_FALSE_SUB;
        blocking = FLS_FALSE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_ERASE_SECTOR << FLS_SHIFT_24BITS) | ((FLS_ULONG)FLS_FMAPI_INTR_MASK << FLS_SHIFT_16BITS) |
                            ((FLS_ULONG)FLS_FMAPI_NONBLOCKING << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = argument1;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_ERASE_SUSPEND:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_ERASE_SUSPEND << FLS_SHIFT_24BITS) | (FLS_ULONG)FLS_FMAPI_ALLINDATA;
        Fls_IpcContext[1] = 0UL;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_ERASE_RESUME:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_ERASE_RESUME << FLS_SHIFT_24BITS) | ((FLS_ULONG)FLS_FMAPI_NONBLOCKING << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = 0UL;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_BLANK_CHECK_SYNC:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = (FLS_ULONG)FLS_FMAPI_BLANK_CHECK << FLS_SHIFT_24BITS;
        Fls_IpcContext[1] = argument1;
        Fls_IpcContext[2] = (argument2 >> 2U) - 1UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_BLANK_CHECK_ASYNC:
        sync = FLS_FALSE_SUB;
        Fls_IpcContext[0] = (FLS_ULONG)FLS_FMAPI_BLANK_CHECK << FLS_SHIFT_24BITS;
        Fls_IpcContext[1] = argument1;
        Fls_IpcContext[2] = (argument2 >> 2U) - 1UL;
        Fls_IpcContext[3] = 0UL;
        break;
    case FLS_FMAPI_SILICON_ID_SROMFW_VERSION:
        sync = FLS_TRUE_SUB;
        Fls_IpcContext[0] = ((FLS_ULONG)FLS_FMAPI_SILICON_ID << FLS_SHIFT_24BITS) | ((FLS_ULONG)FLS_FMAPI_SROMFW_VERSION << FLS_SHIFT_8BITS);
        Fls_IpcContext[1] = 0UL;
        Fls_IpcContext[2] = 0UL;
        Fls_IpcContext[3] = 0UL;
        break;
    default:
        sync = FLS_FALSE_SUB;
        ipc_data = 0UL;
        break;
    }

    if( ipc_data != 0UL )
    {
        /* Deviation from MISRA-C:2004 rule 16.10, 8.1, MISRA-C:2012 Dir-4.2, Rule-1.2, Rule-17.3, Rule-17.7.
           Justification: This is a inline assembler code. */
        /* PRQA S 3200,3335,1006 1 */
        __asm("DSB");

        if( Fls_SystemcallCalloutFunction != NULL_PTR )
        {
            if( E_OK == Fls_SystemcallCalloutFunction( &Fls_IpcContext[0] ) )
            {
                fmapi_result = Fls_IpcContext[0];
            }
            else
            {
                fmapi_result = FLS_FMAPI_STATUS_IPC_BUSY;
            }
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
               Justification: This cast is needed for doing pointer arithmetic. */
            /* PRQA S 488 8 */
            if( ( FLS_REG_IPC_STRUCT_ACQUIRE(FLS_FMAPI_IPC) & FLS_IPC_STRUCT_ACQUIRE_R_MASK ) == FLS_IPC_STRUCT_ACQUIRE_SUCCESS )
            {
                Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_IPC ); /* clear interruption of IPC */
                FLS_REG_IPC_STRUCT_DATA0(FLS_FMAPI_IPC)  = ipc_data;
                FLS_REG_IPC_STRUCT_DATA0(FLS_FMAPI_IPC);
                FLS_REG_IPC_STRUCT_NOTIFY(FLS_FMAPI_IPC) = ( FLS_REG_IPC_STRUCT_NOTIFY(FLS_FMAPI_IPC) & FLS_IPC_STRUCT_NOTIFY_W_MASK(FLS_FMAPI_MASTER_IPC_INTR) ) |
                                                             FLS_IPC_STRUCT_NOTIFY_VALUE(FLS_FMAPI_MASTER_IPC_INTR);
                FLS_REG_IPC_STRUCT_NOTIFY(FLS_FMAPI_IPC);
                if( ( sync == FLS_TRUE_SUB ) || ( blocking == FLS_FALSE_SUB ) )
                {
                    counter = FLS_COUNT_MAX_SUB;
                    /* Deviation from MISRA-C:2004 rule 17.4, MISRA-C:2012 Rule-18.4.
                       Justification: This cast is needed for doing pointer arithmetic. */
                    /* PRQA S 488 5 */
                    /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
                       Justification: This implementation is adopted for avoiding more nesting.
                       It is no problem because side effects cannot be caused. */
                    /* PRQA S 3415 1 */
                    while( ( ( FLS_REG_IPC_INTR_STRUCT_INTR(FLS_FMAPI_SLAVE_IPC_INTR) & FLS_IPC_INTR_STRUCT_INTR_R_MASK(FLS_FMAPI_IPC) ) == FLS_IPC_INTR_STRUCT_INTR_NOTRELEASE ) &&
                           ( counter > 0UL ) )
                    {
                        counter--;
                    }
                    if( counter > 0UL )
                    {
                        fmapi_result = Fls_IpcContext[0];
                        Fls_WritePrivilegedRegisters( FLS_WRITE_REG_PATN_CLEAR_IPC ); /* clear interruption of IPC */
                    }
                    else
                    {
                        fmapi_result = FLS_FMAPI_STATUS_IPC_BUSY;
                    }
                }
            }
            else
            {
                fmapi_result = FLS_FMAPI_STATUS_IPC_BUSY;
            }
        }
    }
#else
    (void)opcode;
    (void)argument1;
    (void)argument2;
    fmapi_result = FLS_FMAPI_STATUS_SUCCESS;
#endif /* if !defined( FLS_IO_DEFINE ) */

    return fmapi_result;
}

/** \brief Fls_GetResultFMAPI
**
** Get result of FLASH Management API.
**
** \return     result of request
** \retval     FLS_FMAPI_STATUS_SUCCESS             complete successfully
** \retval     other than FLS_FMAPI_STATUS_SUCCESS  failed
**
*/
FUNC(FLS_ULONG, FLS_CODE) Fls_GetResultFMAPI
(
 void
)
{
    return Fls_IpcContext[0];
}

#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[end of file]===========================================*/
