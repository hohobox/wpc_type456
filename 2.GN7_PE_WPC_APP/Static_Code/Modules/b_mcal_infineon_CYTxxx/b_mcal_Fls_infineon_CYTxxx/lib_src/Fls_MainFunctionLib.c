/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains the implementation of the AUTOSAR module Fls
 ** function Fls_MainFunction.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Fls_LibInterface.h>   /* Library interface header file */
#include <Fls_InternalLib.h>    /* Module internal API */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/** \brief Fls_MainCompare
 **
 ** This internal function verifies that data at Fls_JobRequest.FlashAddress is
 ** equal to Fls_JobRequest.RamAddress. If Fls_JobRequest.Length exceeds
 ** ConfigPtr->MaxRead(Normal/Fast)Mode only
 ** ConfigPtr->MaxRead(Normal/Fast)Mode will be compared at once.
 **
 ** From Spec V2.1: If a compare job yields differences, the job result will be
 ** set to MEMIF_BLOCK_INCONSISTENT.
 **
 ** If the complete data is compared, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainCompare
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
);

/** \brief Fls_MainErase
 **
 ** This internal function erases all flash blocks described by Fls_JobRequest.FlashAddress
 ** and Fls_JobRequest.Length.
 **
 ** If all affected blocks are erased, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainErase
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
);

/** \brief Fls_MainRead
 **
 ** This internal function copys data from Fls_JobRequest.FlashAddress to the
 ** Fls_JobRequest.RamAddress. If Fls_JobRequest.Length exceeds
 ** ConfigPtr->MaxRead(Normal/Fast)Mode only
 ** ConfigPtr->MaxRead(Normal/Fast)Mode will be copied at once.
 **
 ** If the complete data is read, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainRead
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
);

/** \brief Fls_MainWrite
 **
 ** This internal function writes data from Fls_JobRequest.RamAddress to the
 ** Fls_JobRequest.FlashAddress and up to Fls_JobRequest.CurrentLength at once.
 **
 ** If the complete data is written, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainWrite
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
);

/** \brief Fls_MainFinish
 **
 ** This function is called from Fls_MainFunction, or internal functions
 ** of Fls_MainFunction.
 ** This function performs the initialization of global variables and 
 ** calls the End/Error notification function.
 **  
 ** \param[in] ConfigPtr        Configuration address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainFinish
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
);

/** \brief Fls_MainEraseVerify
 **
 ** The function verifies that the area given by Fls_JobRequest.LogFlashAddress
 ** with length Fls_JobRequest.Length is erased. If not, the erase job will be
 ** aborted, the DET error FLS_E_VERIFY_ERASE_FAILED will be generated.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainEraseVerify
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
);

/** \brief Fls_MainWriteVerify
 **
 ** The function verifies that the area given by Fls_JobRequest.LogFlashAddress
 ** with length Fls_JobRequest.Length are identical to Fls_JobRequest.RamAddress
 ** with identical length.
 ** If not, the write job will be aborted, the DET error 
 ** FLS_E_VERIFY_WRITE_FAILED will be generated.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainWriteVerify
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
);

#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

#define FLS_START_SEC_VAR_NO_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/* data to be written that is passed to FLASH Management API */
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9.
   Justification: An area of this variable must be maintained even out of a function scope. */
/* PRQA S 3218 1 */
static VAR(Fls_WriteDataType, FLS_VAR_NO_INIT) Fls_FlashWData;      /* data in Flash for verify operation */
static VAR(uint8, FLS_VAR_NO_INIT)             Fls_FlashData;       /* data (1byte) in Flash for compare/read operation */
static VAR(Fls_MultiReadType, FLS_VAR_NO_INIT) Fls_FlashMultiData;  /* data (multi) in Flash for compare/read operation */

#define FLS_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[external function definitions]=========================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/** \brief Fls_MainFunctionLib
 **
 ** This function shall perform the processing of the flash read, write, erase,
 ** compare and blank check jobs. When a job has been initiated, the FLS module's 
 ** environment shall call the function Fls_MainFunction cyclically until the job
 ** is finished. 
 ** This function calls each internal functions by FLS module's state.
 **
 ** \return     none
 */
FUNC(void, FLS_CODE) Fls_MainFunctionLib(void)
{
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST)      ConfigPtr;  /* Configuration address */
    P2CONST(Fls_MemoryMapType, AUTOMATIC, FLS_APPL_CONST)   MemoryMap;  /* Memory map address    */
    Fls_PhysicalAddressType PhysicalAddress;    /* physical address for write/erase operation */
    Fls_PhysicalLengthType  LengthToSectorEnd;  /* calculated length to sector end */
    Fls_LengthType          MaxReadCurrentMode; /* max number of bytes to blank check */
    uint8                   Ret;                /* return value of main routine of flash driver engine */

    /* initialize internal value */
    ConfigPtr = Fls_ConfigPtr;
    MemoryMap = Fls_MemoryMapPtr;

    /* Fls117: check that driver is not yet initialized -> FLS_E_UNINIT */
    if( Fls_DriverState == MEMIF_UNINIT )
    {
        /* report DET error */
        (void)Fls_ReportError( FLS_MODULE_ID,
                               FLS_INSTANCE_ID,
                               FLS_ID_MAINFUNCTION,
                               FLS_E_UNINIT );
    }
    else
    {
        /* enter exclusive area */
        Fls_EnterCritiSec();

        /* refresh external data */
        /* Deviation from MISRA-C:2004 rule 11.5, MISRA-C:2012 Rule-11.8.
           Justification: This implementation is intentional code because of
           refreshing variables. */
        /* PRQA S 311 2 */
        *((const Fls_ConfigType *volatile *)&Fls_ConfigPtr) = Fls_ConfigPtr;
        *((const Fls_MemoryMapType *volatile *)&Fls_MemoryMapPtr) = Fls_MemoryMapPtr;

        if( Fls_JobRequest.CurrentJob >= FLS_SUSPEND_RESUME )
        {
            /* exit exclusive area */
            Fls_ExitCritiSec();
        }
        /* check that driver is BUSY */
        else if( Fls_DriverState == MEMIF_BUSY )
        {
            /* exit exclusive area */
            Fls_ExitCritiSec();

            /* check timeout */
            if( ( Fls_JobRequest.Fls_MainFunctionTime <= FLS_MAX_TIME_ZERO ) && ( Fls_CycleMode == MEMIF_MODE_SLOW ) )
            {
                /* check the state of FlsSub  */
                Ret = Fls_GetStatusSub();
                if( Ret != FLS_STATUS_IDLE )
                {
                    Fls_ResetSub();
                }
                Fls_JobResult = MEMIF_JOB_FAILED;
                /* report DET error */
                (void)Fls_ReportError( FLS_MODULE_ID,
                                       FLS_INSTANCE_ID,
                                       FLS_ID_MAINFUNCTION,
                                       FLS_E_TIMEOUT );
                /* call Fls_MainFinish() to finish a job */
                Fls_MainFinish(ConfigPtr);
            }
            else
            {
                /* call main routine of flash driver engine in order to refresh */
                if( ( Fls_JobRequest.CurrentJob != FLS_WRITE ) && ( Fls_JobRequest.CurrentJob != FLS_ERASE ) && ( Fls_JobRequest.CurrentJob != FLS_ERASE_VERIFY ) &&
                    ( Fls_JobRequest.CurrentJob != FLS_WRITE_PREVER ) && ( Fls_JobRequest.CurrentJob != FLS_BLANKCHECK ) ){
                    /* if FLS_WRITE, FLS_ERASE, FLS_ERASE_VERIFY, FLS_WRITE_PREVER or FLS_BLANKCHECK, call the routine later in process of write job, erase job or verify job */
                    Fls_MainFunctionSub(ConfigPtr);
                }

                /* decrement Fls_MainFunctionTime every calling Mainfunction */
                Fls_JobRequest.Fls_MainFunctionTime -= ConfigPtr->CallCycle;

                if( ( ( ConfigPtr->VerificationFlag & FLS_BEFORE_WRITE_VERIFICATION ) != FLS_BEFORE_WRITE_VERIFICATION ) && ( Fls_JobRequest.CurrentJob == FLS_WRITE_PREVER_WAIT ) )
                {
                    Fls_JobRequest.CurrentJob = FLS_WRITE_WAIT;
                }

                MaxReadCurrentMode = ( Fls_Mode == MEMIF_MODE_SLOW ) ? ( ConfigPtr->MaxReadNormalMode ) : ( ConfigPtr->MaxReadFastMode );

                /* Deviation from MISRA-C:2004 rule 10.1, 10.2, MISRA-C:2012 Rule-10.4.
                   Justification: This implmentation is needed for comparing a signed type with
                   enum to check if previous MainFunction waited for finish of sector erase. */
                /* PRQA S 1880 1 */
                if( Fls_JobRequest.CurrentJob >= FLS_WAIT_SECTOR_ERASE )
                {
                    /* check the state of FlsSub  */
                    Ret = Fls_GetStatusSub();
                    if( Ret == FLS_STATUS_IDLE )
                    {
                        /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.1, Rule-10.3.
                           Justification: This implemetation is because speed of subtraction
                           would outweigh the benefit of ISO compliance with leading to
                           the overhead for using switch-case. */
                        /* PRQA S 4432,4521 2 */
                        Fls_JobRequest.CurrentJob -= FLS_WAIT_SECTOR_ERASE;
                        Fls_JobRequest.Fls_RetryTime = 0U;

                        /* calculate physical address and length to sector end */
                        Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                                        MemoryMap,
                                                        Fls_JobRequest.LogFlashAddress,
                                                        &PhysicalAddress,
                                                        &LengthToSectorEnd);

                        switch( Fls_JobRequest.CurrentJob )
                        {
                        /* if a write job is pending */
                        case FLS_WRITE:
                            /* call write routine of flash driver engine */
                            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
                               Justification: This cast is needed for specifying
                               integral values as addresses for device access. */
                            /* PRQA S 306 2 */
                            (void)Fls_WriteSub((FLS_UCHAR *)PhysicalAddress, 
                                                (FLS_UCHAR *)Fls_JobRequest.RamAddress, 
                                                Fls_JobRequest.CurrentLength);
                            break;
                        /* if an erase job is pending */
                        case FLS_ERASE:
                            /* call erase routine of flash driver engine */
                            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
                               Justification: This cast is needed for specifying
                               an integral value as an address for device access. */
                            /* PRQA S 306 1 */
                            (void)Fls_EraseSub((FLS_UCHAR *)PhysicalAddress, 
                                                Fls_JobRequest.CurrentLength);
                            break;
                        /* if a compare job is pending */
                        case FLS_COMPARE:
                            Fls_MainCompare(ConfigPtr, MemoryMap);
                            break;

                        /* if a read job is pending */
                        case FLS_READ:
                            Fls_MainRead(ConfigPtr, MemoryMap);
                            break;

                        /* if previous verify in a write job is pending */
                        case FLS_WRITE_PREVER:
                        /* if a blank check is pending */
                        case FLS_BLANKCHECK:
                            /* Fls371: only verify as much data as configured for one read cycle in the given mode */
                            Fls_JobRequest.CurrentLength = (( Fls_JobRequest.CurrentLength ) < ( MaxReadCurrentMode )) ?
                                                             ( Fls_JobRequest.CurrentLength ) : ( MaxReadCurrentMode );

                            /* call blank check routine of flash driver engine */
                            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
                               Justification: This cast is needed for specifying
                               an integral value as an address for device access. */
                            /* PRQA S 306 1 */
                            (void)Fls_BlankCheckSub((FLS_UCHAR *)PhysicalAddress, 
                                                     Fls_JobRequest.CurrentLength);
                            break;

                        default:
                            /* do nothing */
                            break;
                        }
                    }
                }
                else
                {
                    switch( Fls_JobRequest.CurrentJob )
                    {
                    /* Fls037: if a write job is pending */
                    case FLS_WRITE:
                        Fls_MainWrite(ConfigPtr, MemoryMap);
                        /* For performance improvement, below */
                        if( Fls_JobRequest.CurrentJob == FLS_WRITE_VERIFY )
                        {
                            if( ( ConfigPtr->VerificationFlag & FLS_WRITE_VERIFICATION ) != FLS_WRITE_VERIFICATION )
                            {
                                /* call Fls_MainFinish() and finish a write job */
                                Fls_MainFinish(ConfigPtr);
                            }
                        }
                        break;

                    /* Fls037: if an erase job is pending */
                    case FLS_ERASE:
                        Fls_MainErase(ConfigPtr);
                        /* For performance improvement, below */
                        if( Fls_JobRequest.CurrentJob == FLS_ERASE_VERIFY )
                        {
                            if( ( ConfigPtr->VerificationFlag & FLS_ERASE_VERIFICATION ) == FLS_ERASE_VERIFICATION )
                            {
                                /* calculate physical address */
                                Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                                                MemoryMap,
                                                                Fls_JobRequest.LogFlashAddress,
                                                                &PhysicalAddress,
                                                                &LengthToSectorEnd);

                                /* Fls371: only verify as much data as configured for one read cycle in the given mode */
                                Fls_JobRequest.CurrentLength = (( LengthToSectorEnd ) < ( MaxReadCurrentMode )) ?
                                                                 ( LengthToSectorEnd ) : ( MaxReadCurrentMode );

                                /* call blank check routine of flash driver engine */
                                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
                                   Justification: This cast is needed for specifying
                                   an integral value as an address for device access. */
                                /* PRQA S 306 1 */
                                (void)Fls_BlankCheckSub((FLS_UCHAR *)PhysicalAddress, 
                                                         Fls_JobRequest.CurrentLength);
                            }
                            else
                            {
                                /* call Fls_MainFinish() and finish an erase job */
                                Fls_MainFinish(ConfigPtr);
                            }
                        }
                        break;

                    /* Fls037: if a read job is pending */
                    case FLS_READ:
                        Fls_MainRead(ConfigPtr, MemoryMap);
                        break;

                    /* Fls037: if a compare job is pending */
                    case FLS_COMPARE:
                        Fls_MainCompare(ConfigPtr, MemoryMap);
                        break;

                    /* if verify in an erase job is pending */
                    case FLS_ERASE_VERIFY:
                        Fls_MainEraseVerify(ConfigPtr, MemoryMap);
                        break;

                    /* if previous verify in a write job is pending */
                    case FLS_WRITE_PREVER:
                        Fls_MainEraseVerify(ConfigPtr, MemoryMap);
                        break;

                    /* if verify in a write job is pending */
                    case FLS_WRITE_VERIFY:
                        Fls_MainWriteVerify(ConfigPtr, MemoryMap);
                        break;

                    /* if a blank check job is pending */
                    case FLS_BLANKCHECK:
                        Fls_MainEraseVerify(ConfigPtr, MemoryMap);
                        break;

                    default:
                        /* do nothing */
                        break;
                    }
                }
            }
        }
        /* Fls038: may also be called cyclically if no job is currently pending   */
        /* Fls039: if no job is pending, return without any action (only refresh) */
        else
        {
            /* refresh Fls_DriverState */
            Fls_DriverState = MEMIF_IDLE;

            /* call main routine of flash driver engine */
            Fls_MainFunctionSub(ConfigPtr);

            /* exit exclusive area */
            Fls_ExitCritiSec();
        }
    }


    return;
}


/*==================[internal function definitions]=========================*/

/** \brief Fls_MainCompare
 **
 ** This internal function verifies that data at Fls_JobRequest.FlashAddress is
 ** equal to Fls_JobRequest.RamAddress. If Fls_JobRequest.Length exceeds
 ** ConfigPtr->MaxRead(Normal/Fast)Mode only
 ** ConfigPtr->MaxRead(Normal/Fast)Mode will be compared at once.
 **
 ** From Spec V2.1: If a compare job yields differences, the job result will be
 ** set to MEMIF_BLOCK_INCONSISTENT.
 **
 ** If the complete data is compared, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainCompare
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
)
{
    Fls_LengthType                                         CurrentCompareLength; /* length of data to be compared on this call */
    Fls_LengthType                                         LoopCounter;          /* loop counter value */
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)                 RamAddressPtr;        /* pointer for compare operation in RAM (1byte) */
    FAR P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)             FlashAddressPtr;      /* pointer for compare operation in Flash (1byte) */
    P2VAR(Fls_MultiReadType, AUTOMATIC, FLS_APPL_DATA)     RamAddressMPtr;       /* pointer for compare operation in RAM (multi) */
    FAR P2VAR(Fls_MultiReadType, AUTOMATIC, FLS_APPL_DATA) FlashAddressMPtr;     /* pointer for compare operation in Flash (multi) */
    Fls_PhysicalAddressType                                PhysicalAddress;      /* physical address for compare operation */
    Fls_PhysicalLengthType                                 LengthToSectorEnd;    /* calculated length to sector end */
    uint8                                                  MultiCompareFlag;     /* flag of enabling multiple compare */
    Fls_LengthType                                         ReadSize;             /* length of processed data */
    Fls_LengthType                                         AuxBufferReadSize;    /* processed or read data in auxiliary buffer */

    /* initialize internal value */
    LoopCounter = 0UL;
    ReadSize = 0UL;

    /* calculate physical address and length to sector end */
    Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                    MemoryMap,
                                    Fls_JobRequest.LogFlashAddress,
                                    &PhysicalAddress,
                                    &LengthToSectorEnd);

    /* determine whether multiple compare can be done because the memory access instruction requires word-aligned address */
    if( ( ( (uint32)PhysicalAddress & (uint32)( sizeof(uint32) - 1UL ) ) == 0UL ) && ( ( (uint32)Fls_JobRequest.RamAddress & (uint32)( sizeof(uint32) - 1UL ) ) == 0UL ) )
    {
        MultiCompareFlag = FLS_TRUE;
    }
    else
    {
        MultiCompareFlag = FLS_FALSE;
    }

    /* RamPtr is in Ram and can therefore be a near pointer */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for handling integral values as addresses
       for device access. */
    /* PRQA S 306 2 */
    RamAddressPtr = (uint8 *)Fls_JobRequest.RamAddress;
    FlashAddressPtr = (FAR uint8 *)PhysicalAddress;

    if( MultiCompareFlag == FLS_TRUE )
    {
        /* RamPtr is in Ram and can therefore be a near pointer */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for handling integral values as
           addresses for device access. */
        /* PRQA S 306 2 */
        RamAddressMPtr = (Fls_MultiReadType *)Fls_JobRequest.RamAddress;
        FlashAddressMPtr = (FAR Fls_MultiReadType *)PhysicalAddress;
    }

    /* Fls040: only compare as much data as configured for one compare cycle in the given mode */
    if( Fls_Mode == MEMIF_MODE_SLOW )
    {
        CurrentCompareLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadNormalMode )) ?
                                ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadNormalMode );
    }
    else
    {
        CurrentCompareLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadFastMode )) ?
                                ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadFastMode );
    }

    /* only compare to the next sector end */
    CurrentCompareLength = (( CurrentCompareLength ) < ( LengthToSectorEnd )) ?
                            ( CurrentCompareLength ) : ( LengthToSectorEnd );

    Fls_EnableDMA();

    /* clear read error */
    Fls_ClearReadError();

    if( Fls_UseDmaForRead == STD_ON )
    {
        AuxBufferReadSize = (( CurrentCompareLength ) < ( Fls_AuxiliaryBufferSize )) ?
                             ( CurrentCompareLength ) : ( Fls_AuxiliaryBufferSize );
        Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[0], AuxBufferReadSize );
        AuxBufferReadSize = 0UL;
    }

    if( MultiCompareFlag == FLS_TRUE )
    {
        /* Fls241: compare the contents of an area of flash memory */
        /*         with that of an application data buffer         */
        /* Fls243: compare CurrentCompareLength asynchronously     */
        while( LoopCounter < ( CurrentCompareLength >> FLS_SHIFT_R_VALUE ) )
        {
            /* read from flash */
            if( Fls_UseDmaForRead == STD_ON )
            {
                Fls_FlashMultiData = Fls_AuxiliaryBuffer[AuxBufferReadSize];
            }
            else
            {
                Fls_FlashMultiData = FlashAddressMPtr[LoopCounter];
                Fls_GetReadError();
            }
            if( Fls_Fault != FLS_FAULT_NONE )
            {
                if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
                {
                    Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                    Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                    CurrentCompareLength = 0UL;
                    LoopCounter = CurrentCompareLength;
                }
                else
                {
                    /* report Fault */
                    Fls_ReportFault( Fls_JobRequest.CurrentJob,
                                     FLS_MODULE_ID,
                                     FLS_INSTANCE_ID,
                                     FLS_ID_MAINFUNCTION,
                                     Fls_Fault );
                    if( Fls_Fault == FLS_FAULT_SED )
                    {
                    }
                    else if( Fls_Fault == FLS_FAULT_DED )
                    {
                        /* change to wrong data on purpose */
                        Fls_FlashMultiData = FLS_ERASED_E_VALUE;
                    }
                    else
                    {
                        /* Fls154: on hardware failure
                                    - set job result to MEMIF_JOB_FAILED
                                    - call DEM with FLS_E_COMPARE_FAILED
                        */
                        Fls_JobResult = MEMIF_JOB_FAILED;
                        LoopCounter = CurrentCompareLength;
                    }
                }
                /* set no fault */
                Fls_Fault = FLS_FAULT_NONE;
            }

            if( LoopCounter < CurrentCompareLength )
            {
                if( RamAddressMPtr[LoopCounter] != Fls_FlashMultiData )
                {
                    /* from Spec V2.1 Fls200: on differences while comparing, 
                        the job result will be set to MEMIF_BLOCK_INCONSISTENT */
                    Fls_JobResult = MEMIF_BLOCK_INCONSISTENT;
                    LoopCounter = CurrentCompareLength;
                }
                else
                {
                    Fls_JobRequest.Fls_RetryTime = 0U;
                    LoopCounter++;
                    if( Fls_UseDmaForRead == STD_ON )
                    {
                        ReadSize += 4UL;
                        AuxBufferReadSize++;
                        if( ( AuxBufferReadSize << FLS_SHIFT_R_VALUE ) >= Fls_AuxiliaryBufferSize )
                        {
                            AuxBufferReadSize = (( CurrentCompareLength - ReadSize ) < ( Fls_AuxiliaryBufferSize )) ?
                                                 ( CurrentCompareLength - ReadSize ) : ( Fls_AuxiliaryBufferSize );
                            if( AuxBufferReadSize > 0UL )
                            {
                                Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[ReadSize], AuxBufferReadSize );
                                AuxBufferReadSize = 0UL;
                            }
                        }
                    }
                }
            }
            
            /* clear the watchdog timer */
            Fls_WdgClear();
        }
        
        if( Fls_UseDmaForRead == STD_ON )
        {
            AuxBufferReadSize <<= FLS_SHIFT_R_VALUE;
        }
        LoopCounter <<= FLS_SHIFT_R_VALUE;
    }

    /* Fls241: compare the contents of an area of flash memory */
    /*         with that of an application data buffer         */
    /* Fls243: compare CurrentCompareLength asynchronously     */
    while( LoopCounter < CurrentCompareLength )
    {
        /* read from flash */
        if( Fls_UseDmaForRead == STD_ON )
        {
            /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4.
               Justification: This cast is needed for handling with 8-bit type address and doing pointer arithmetic. */
            /* PRQA S 310,488 1 */
            Fls_FlashData = *((uint8 *)Fls_AuxiliaryBuffer + AuxBufferReadSize);
        }
        else
        {
            Fls_FlashData = FlashAddressPtr[LoopCounter];
            Fls_GetReadError();
        }
        if( Fls_Fault != FLS_FAULT_NONE )
        {
            if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
            {
                Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                CurrentCompareLength = 0UL;
                LoopCounter = CurrentCompareLength;
            }
            else
            {
                /* report Fault */
                Fls_ReportFault( Fls_JobRequest.CurrentJob,
                                 FLS_MODULE_ID,
                                 FLS_INSTANCE_ID,
                                 FLS_ID_MAINFUNCTION,
                                 Fls_Fault );
                if( Fls_Fault == FLS_FAULT_SED )
                {
                }
                else if( Fls_Fault == FLS_FAULT_DED )
                {
                    /* change to wrong data on purpose */
                    Fls_FlashData = 0xFFU;
                }
                else
                {
                    /* Fls154: on hardware failure
                                - set job result to MEMIF_JOB_FAILED
                                - call DEM with FLS_E_COMPARE_FAILED
                    */
                    Fls_JobResult = MEMIF_JOB_FAILED;
                    LoopCounter = CurrentCompareLength;
                }
            }
            /* set no fault */
            Fls_Fault = FLS_FAULT_NONE;
        }

        if( LoopCounter < CurrentCompareLength )
        {
            if( RamAddressPtr[LoopCounter] != Fls_FlashData )
            {
                /* from Spec V2.1 Fls200: on differences while comparing, 
                    the job result will be set to MEMIF_BLOCK_INCONSISTENT */
                Fls_JobResult = MEMIF_BLOCK_INCONSISTENT;
                LoopCounter = CurrentCompareLength;
            }
            else
            {
                Fls_JobRequest.Fls_RetryTime = 0U;
                LoopCounter++;
                if( Fls_UseDmaForRead == STD_ON )
                {
                    ReadSize++;
                    AuxBufferReadSize++;
                    if( AuxBufferReadSize >= Fls_AuxiliaryBufferSize )
                    {
                        AuxBufferReadSize = (( CurrentCompareLength - ReadSize ) < ( Fls_AuxiliaryBufferSize )) ?
                                             ( CurrentCompareLength - ReadSize ) : ( Fls_AuxiliaryBufferSize );
                        if( AuxBufferReadSize > 0UL )
                        {
                            Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[ReadSize], AuxBufferReadSize );
                            AuxBufferReadSize = 0UL;
                        }
                    }
                }
            }
        }
        
        /* clear the watchdog timer */
        Fls_WdgClear();
    }

    Fls_DisableDMA();

    /* update Fls_JobRequest */
    Fls_JobRequest.Length          -= CurrentCompareLength;
    Fls_JobRequest.RamAddress      += CurrentCompareLength;
    Fls_JobRequest.LogFlashAddress += CurrentCompareLength;

    /* call Fls_MainFinish after the compare is finished successfully */
    /* also finish if error is detected */
    if(( Fls_JobRequest.Length == 0UL ) || ( Fls_JobResult != MEMIF_JOB_PENDING ))
    {
        if( Fls_JobResult != MEMIF_JOB_FAILED )
        {
            /* no hardware failure detected */
            Fls_ReportErrorStatusCompareFailed( FLS_EVENT_STATUS_PASSED );
        }

        /* call Fls_MainFinish() and finish a compare job */
        Fls_MainFinish(ConfigPtr);
    }

    return;
}

/** \brief Fls_MainErase
 **
 ** This internal function erases all flash blocks described by Fls_JobRequest.FlashAddress
 ** and Fls_JobRequest.Length.
 **
 ** If all affected blocks are erased, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainErase
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
)
{
    uint8                   Ret;               /* return value of main routine of flash driver engine */

    /* Fls220: call main routine of flash driver engine asynchronously */
    Fls_MainFunctionSub(ConfigPtr);

    /* check the jobresult of FlsSub */
    Ret = Fls_GetJobResultSub();

    /* clear the watchdog timer */
    Fls_WdgClear();

    if( Ret == FLS_JOB_FAILED_NOTACQUIRE )
    {
        if( Fls_JobRequest.Fls_RetryTime > FLS_MAX_TIME_RETRY_ACQUIRE )
        {
            Ret = FLS_JOB_TIMEOUT;
        }
    }
    else
    {
        if( Fls_GetStatusSub() == FLS_STATUS_BUSY )
        {
            Ret = FLS_JOB_PENDING;
        }
    }

    switch(Ret)
    {
    case FLS_JOB_PENDING:
        Fls_JobRequest.Fls_RetryTime = 0U;
        break;
    case FLS_JOB_OK:
        Fls_ReportErrorStatusEraseFailed( FLS_EVENT_STATUS_PASSED );

        /* update Fls_JobRequest */
        Fls_JobRequest.CurrentJob       = FLS_ERASE_VERIFY;
        Fls_JobRequest.Length           = Fls_JobRequest.ResetLength;
        Fls_JobRequest.LogFlashAddress += Fls_JobRequest.CurrentLength;
        Fls_JobRequest.LogFlashAddress -= Fls_JobRequest.ResetLength;
        Fls_JobRequest.Fls_RetryTime    = 0U;
        break;
    case FLS_JOB_TIMEOUT:
        /* report DET error */
        (void)Fls_ReportError( FLS_MODULE_ID,
                               FLS_INSTANCE_ID,
                               FLS_ID_MAINFUNCTION,
                               FLS_E_TIMEOUT );

        /* Fls104: set MEMIF_JOB_FAILED for Fls_JobResult */
        Fls_JobResult = MEMIF_JOB_FAILED;

        /* call Fls_MainFinish() and finish an erase job */
        Fls_MainFinish(ConfigPtr);
        break;
    case FLS_JOB_FAILED:
    case FLS_JOB_FAILED_UNWRITABLE:
        /* Fls104: DET must also be reported on failed */
        Fls_ReportErrorStatusEraseFailed( FLS_EVENT_STATUS_FAILED );

        /* Fls104: set MEMIF_JOB_FAILED for Fls_JobResult */
        Fls_JobResult = MEMIF_JOB_FAILED;

        /* call Fls_MainFinish() and finish an erase job */
        Fls_MainFinish(ConfigPtr);
        break;
    case FLS_JOB_FAILED_NOTACQUIRE:
        Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
        Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
        break;
    default:
        break;
    }
    return;
}

/** \brief Fls_MainRead
 **
 ** This internal function copys data from Fls_JobRequest.FlashAddress to the
 ** Fls_JobRequest.RamAddress. If Fls_JobRequest.Length exceeds
 ** ConfigPtr->MaxRead(Normal/Fast)Mode only
 ** ConfigPtr->MaxRead(Normal/Fast)Mode will be copied at once.
 **
 ** If the complete data is read, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainRead
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
)
{
    Fls_LengthType                                         CurrentReadLength; /* length of data to be read on this call */
    Fls_LengthType                                         LoopCounter;       /* loop counter value */
    P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)                 RamAddressPtr;     /* pointer for read operation in RAM (1byte) */
    FAR P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)             FlashAddressPtr;   /* pointer for read operation in Flash (1byte) */
    P2VAR(Fls_MultiReadType, AUTOMATIC, FLS_APPL_DATA)     RamAddressMPtr;    /* pointer for read operation in RAM (multi) */
    FAR P2VAR(Fls_MultiReadType, AUTOMATIC, FLS_APPL_DATA) FlashAddressMPtr;  /* pointer for read operation in Flash (multi) */
    Fls_PhysicalAddressType                                PhysicalAddress;   /* physical address for read operation */
    Fls_PhysicalLengthType                                 LengthToSectorEnd; /* calculated length to sector end */
    uint8                                                  MultiReadFlag;     /* flag of enabling multiple read */
    Fls_LengthType                                         ReadSize;          /* length of processed data */
    Fls_LengthType                                         AuxBufferReadSize; /* processed or read data in auxiliary buffer */

    /* initialize internal value */
    LoopCounter = 0UL;
    ReadSize = 0UL;

    /* calculate physical address and length to sector end */
    Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                    MemoryMap,
                                    Fls_JobRequest.LogFlashAddress,
                                    &PhysicalAddress,
                                    &LengthToSectorEnd);

    /* determine whether multiple read can be done because the memory access instruction requires word-aligned address */
    if( ( ( (uint32)PhysicalAddress & (uint32)( sizeof(uint32) - 1UL ) ) == 0UL ) && ( ( (uint32)Fls_JobRequest.RamAddress & (uint32)( sizeof(uint32) - 1UL ) ) == 0UL ) )
    {
        MultiReadFlag = FLS_TRUE;
    }
    else
    {
        MultiReadFlag = FLS_FALSE;
    }

    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for handling integral values as addresses
       for device access. */
    /* PRQA S 306 2 */
    RamAddressPtr = (uint8 *)Fls_JobRequest.RamAddress;
    FlashAddressPtr = (FAR uint8 *)PhysicalAddress;

    if( MultiReadFlag == FLS_TRUE )
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for handling integral values as
           addresses for device access. */
        /* PRQA S 306 2 */
        RamAddressMPtr = (Fls_MultiReadType *)Fls_JobRequest.RamAddress;
        FlashAddressMPtr = (FAR Fls_MultiReadType *)PhysicalAddress;
    }

    /* Fls040: only read as much data as configured for one read cycle in the given mode */
    if( Fls_Mode == MEMIF_MODE_SLOW )
    {
        CurrentReadLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadNormalMode )) ?
                             ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadNormalMode );
    }
    else
    {
        CurrentReadLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadFastMode )) ?
                             ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadFastMode );
    }

    /* only read to the next sector end */
    CurrentReadLength = (( CurrentReadLength ) < ( LengthToSectorEnd )) ?
                         ( CurrentReadLength ) : ( LengthToSectorEnd );

    Fls_EnableDMA();

    /* clear read error */
    Fls_ClearReadError();

    if( Fls_JobRequest.ReadWithoutBlankCheck == FLS_FALSE )
    {
        if( MultiReadFlag == FLS_TRUE )
        {
            /* Fls236: read from flash memory                           */
            /* Fls238: read CurrentReadLength from flash asynchronously */
            while( LoopCounter < ( CurrentReadLength >> FLS_SHIFT_R_VALUE ) )
            {
                /* read address if not blank, or FLS_NULL if blank */
                if( Fls_GetAddrForRead(&FlashAddressMPtr[LoopCounter], sizeof(Fls_MultiReadType)) == NULL_PTR )
                {
                    Fls_FlashMultiData = FLS_ERASED_E_VALUE;
                }
                else
                {
                    if( ( Fls_Fault != FLS_FAULT_MACROERROR ) && ( Fls_Fault != FLS_FAULT_OTHERERROR ) )
                    {
                        /* read from flash */
                        if( Fls_UseDmaForRead == STD_ON )
                        {
                            Fls_ReadFlash( &Fls_FlashMultiData, &FlashAddressMPtr[LoopCounter], sizeof(Fls_MultiReadType) );
                        }
                        else
                        {
                            Fls_FlashMultiData = FlashAddressMPtr[LoopCounter];
                            Fls_GetReadError();
                        }
                    }
                    if( Fls_Fault != FLS_FAULT_NONE )
                    {
                        if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
                        {
                            Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                            Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                            CurrentReadLength = 0UL;
                            LoopCounter = CurrentReadLength;
                        }
                        else
                        {
                            /* report Fault */
                            Fls_ReportFault( Fls_JobRequest.CurrentJob,
                                             FLS_MODULE_ID,
                                             FLS_INSTANCE_ID,
                                             FLS_ID_MAINFUNCTION,
                                             Fls_Fault );
                            if( Fls_Fault == FLS_FAULT_SED )
                            {
                            }
                            else if( Fls_Fault == FLS_FAULT_DED )
                            {
                                /* change to wrong data on purpose */
                                Fls_FlashMultiData = FLS_ERASED_E_VALUE;
                            }
                            else
                            {
                                /* Fls106: on hardware failure
                                        - set job result to MEMIF_JOB_FAILED
                                        - call DEM with FLS_E_READ_FAILED
                                */
                                Fls_JobResult = MEMIF_JOB_FAILED;
                                LoopCounter = CurrentReadLength;
                            }
                        }
                        /* set no fault */
                        Fls_Fault = FLS_FAULT_NONE;
                    }
                }

                if( LoopCounter < CurrentReadLength )
                {
                    RamAddressMPtr[LoopCounter] = Fls_FlashMultiData;
                    
                    Fls_JobRequest.Fls_RetryTime = 0U;
                    LoopCounter++;
                }
                
                /* clear the watchdog timer */
                Fls_WdgClear();
            }
            
            LoopCounter <<= FLS_SHIFT_R_VALUE;
        }

        /* Fls236: read from flash memory                           */
        /* Fls238: read CurrentReadLength from flash asynchronously */
        while( LoopCounter < CurrentReadLength )
        {
            /* read address if not blank, or FLS_NULL if blank */
            if( Fls_GetAddrForRead(&FlashAddressPtr[LoopCounter], sizeof(Fls_MultiReadType)) == NULL_PTR )
            {
                /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
                   Justification: This cast is needed for calculation of address. */
                /* PRQA S 306 1 */
                if( ( ( (uint32)&FlashAddressPtr[LoopCounter] & (uint32)( sizeof(uint32) - 1UL ) ) == 0UL ) && ( ( LoopCounter + 3UL ) < CurrentReadLength ) )
                {
                    RamAddressPtr[LoopCounter]     = 0xFFU;
                    RamAddressPtr[LoopCounter+1UL] = 0xFFU;
                    RamAddressPtr[LoopCounter+2UL] = 0xFFU;
                    LoopCounter += 3UL;
                }
                Fls_FlashData = 0xFFU;
            }
            else
            {
                if( ( Fls_Fault != FLS_FAULT_MACROERROR ) && ( Fls_Fault != FLS_FAULT_OTHERERROR ) )
                {
                    /* read from flash */
                    if( Fls_UseDmaForRead == STD_ON )
                    {
                        Fls_ReadFlash( &Fls_FlashData, &FlashAddressPtr[LoopCounter], sizeof(uint8) );
                    }
                    else
                    {
                        Fls_FlashData = FlashAddressPtr[LoopCounter];
                        Fls_GetReadError();
                    }
                }
                if( Fls_Fault != FLS_FAULT_NONE )
                {
                    if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
                    {
                        Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                        Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                        CurrentReadLength = 0UL;
                        LoopCounter = CurrentReadLength;
                    }
                    else
                    {
                        /* report Fault */
                        Fls_ReportFault( Fls_JobRequest.CurrentJob,
                                         FLS_MODULE_ID,
                                         FLS_INSTANCE_ID,
                                         FLS_ID_MAINFUNCTION,
                                         Fls_Fault );
                        if( Fls_Fault == FLS_FAULT_SED )
                        {
                        }
                        else if( Fls_Fault == FLS_FAULT_DED )
                        {
                            /* change to wrong data on purpose */
                            Fls_FlashData = 0xFFU;
                        }
                        else
                        {
                            /* Fls106: on hardware failure
                                    - set job result to MEMIF_JOB_FAILED
                                    - call DEM with FLS_E_READ_FAILED
                            */
                            Fls_JobResult = MEMIF_JOB_FAILED;
                            LoopCounter = CurrentReadLength;
                        }
                    }
                    /* set no fault */
                    Fls_Fault = FLS_FAULT_NONE;
                }
            }

            if( LoopCounter < CurrentReadLength )
            {
                RamAddressPtr[LoopCounter] = Fls_FlashData;
                
                Fls_JobRequest.Fls_RetryTime = 0U;
                LoopCounter++;
            }
            
            /* clear the watchdog timer */
            Fls_WdgClear();
        }
    }
    else
    {
        if( Fls_ReadImmediateDirect == STD_ON )
        {
            /* Fls236: read from flash memory                           */
            /* Fls238: read CurrentReadLength from flash asynchronously */
            /* read from flash */
            Fls_ReadFlash( RamAddressPtr, FlashAddressPtr, CurrentReadLength );
            MultiReadFlag = FLS_FALSE;
        }
        else
        {
            if( Fls_UseDmaForRead == STD_ON )
            {
                AuxBufferReadSize = (( CurrentReadLength ) < ( Fls_AuxiliaryBufferSize )) ?
                                     ( CurrentReadLength ) : ( Fls_AuxiliaryBufferSize );
                Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[0], AuxBufferReadSize );
                AuxBufferReadSize = 0UL;
            }
        }

        if( MultiReadFlag == FLS_TRUE )
        {
            /* Fls236: read from flash memory                           */
            /* Fls238: read CurrentReadLength from flash asynchronously */
            while( LoopCounter < ( CurrentReadLength >> FLS_SHIFT_R_VALUE ) )
            {
                /* read from flash */
                if( Fls_UseDmaForRead == STD_ON )
                {
                    Fls_FlashMultiData = Fls_AuxiliaryBuffer[AuxBufferReadSize];
                }
                else
                {
                    Fls_FlashMultiData = FlashAddressMPtr[LoopCounter];
                    Fls_GetReadError();
                }
                if( Fls_Fault != FLS_FAULT_NONE )
                {
                    if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
                    {
                        Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                        Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                        CurrentReadLength = 0UL;
                        LoopCounter = CurrentReadLength;
                    }
                    else
                    {
                        /* report Fault */
                        Fls_ReportFault( Fls_JobRequest.CurrentJob,
                                         FLS_MODULE_ID,
                                         FLS_INSTANCE_ID,
                                         FLS_ID_MAINFUNCTION,
                                         Fls_Fault );
                        if( Fls_Fault == FLS_FAULT_SED )
                        {
                        }
                        else if( Fls_Fault == FLS_FAULT_DED )
                        {
                            /* change to wrong data on purpose */
                            Fls_FlashMultiData = FLS_ERASED_E_VALUE;
                        }
                        else
                        {
                            /* Fls106: on hardware failure
                                    - set job result to MEMIF_JOB_FAILED
                                    - call DEM with FLS_E_READ_FAILED
                            */
                            Fls_JobResult = MEMIF_JOB_FAILED;
                            LoopCounter = CurrentReadLength;
                        }
                    }
                    /* set no fault */
                    Fls_Fault = FLS_FAULT_NONE;
                }

                if( LoopCounter < CurrentReadLength )
                {
                    RamAddressMPtr[LoopCounter] = Fls_FlashMultiData;

                    Fls_JobRequest.Fls_RetryTime = 0U;
                    LoopCounter++;
                    if( Fls_UseDmaForRead == STD_ON )
                    {
                        ReadSize += 4UL;
                        AuxBufferReadSize++;
                        if( ( AuxBufferReadSize << FLS_SHIFT_R_VALUE ) >= Fls_AuxiliaryBufferSize )
                        {
                            AuxBufferReadSize = (( CurrentReadLength - ReadSize ) < ( Fls_AuxiliaryBufferSize )) ?
                                                 ( CurrentReadLength - ReadSize ) : ( Fls_AuxiliaryBufferSize );
                            if( AuxBufferReadSize > 0UL )
                            {
                                Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[ReadSize], AuxBufferReadSize );
                                AuxBufferReadSize = 0UL;
                            }
                        }
                    }
                }
                
                /* clear the watchdog timer */
                Fls_WdgClear();
            }
            
            if( Fls_UseDmaForRead == STD_ON )
            {
                AuxBufferReadSize <<= FLS_SHIFT_R_VALUE;
            }
            LoopCounter <<= FLS_SHIFT_R_VALUE;
        }

        /* Fls236: read from flash memory                           */
        /* Fls238: read CurrentReadLength from flash asynchronously */
        while( LoopCounter < CurrentReadLength )
        {
            if( Fls_ReadImmediateDirect == STD_OFF )
            {
                /* read from flash */
                if( Fls_UseDmaForRead == STD_ON )
                {
                    /* Deviation from MISRA-C:2004 rule 11.4, 17.4, MISRA-C:2012 Rule-11.3, Rule-18.4.
                       Justification: This cast is needed for handling with 8-bit type address and doing pointer arithmetic. */
                    /* PRQA S 310,488 1 */
                    Fls_FlashData = *((uint8 *)Fls_AuxiliaryBuffer + AuxBufferReadSize);
                }
                else
                {
                    Fls_FlashData = FlashAddressPtr[LoopCounter];
                    Fls_GetReadError();
                }
            }
            if( Fls_Fault != FLS_FAULT_NONE )
            {
                if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
                {
                    Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                    Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                    CurrentReadLength = 0UL;
                    LoopCounter = CurrentReadLength;
                }
                else
                {
                    /* report Fault */
                    Fls_ReportFault( Fls_JobRequest.CurrentJob,
                                     FLS_MODULE_ID,
                                     FLS_INSTANCE_ID,
                                     FLS_ID_MAINFUNCTION,
                                     Fls_Fault );
                    if( Fls_Fault == FLS_FAULT_SED )
                    {
                    }
                    else if( Fls_Fault == FLS_FAULT_DED )
                    {
                        /* change to wrong data on purpose */
                        Fls_FlashData = 0xFFU;
                    }
                    else
                    {
                        /* Fls106: on hardware failure
                                - set job result to MEMIF_JOB_FAILED
                                - call DEM with FLS_E_READ_FAILED
                        */
                        Fls_JobResult = MEMIF_JOB_FAILED;
                        LoopCounter = CurrentReadLength;
                    }
                }
                /* set no fault */
                Fls_Fault = FLS_FAULT_NONE;
            }

            if( Fls_ReadImmediateDirect == STD_ON )
            {
                LoopCounter = CurrentReadLength;
                Fls_JobRequest.Fls_RetryTime = 0U;
            }
            else 
            {
                if( LoopCounter < CurrentReadLength )
                {
                    RamAddressPtr[LoopCounter] = Fls_FlashData;
                    
                    Fls_JobRequest.Fls_RetryTime = 0U;
                    LoopCounter++;
                    if( Fls_UseDmaForRead == STD_ON )
                    {
                        ReadSize++;
                        AuxBufferReadSize++;
                        if( AuxBufferReadSize >= Fls_AuxiliaryBufferSize )
                        {
                            AuxBufferReadSize = (( CurrentReadLength - ReadSize ) < ( Fls_AuxiliaryBufferSize )) ?
                                                 ( CurrentReadLength - ReadSize ) : ( Fls_AuxiliaryBufferSize );
                            if( AuxBufferReadSize > 0UL )
                            {
                                Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[ReadSize], AuxBufferReadSize );
                                AuxBufferReadSize = 0UL;
                            }
                        }
                    }
                }
            }

            /* clear the watchdog timer */
            Fls_WdgClear();
        }
    }

    Fls_DisableDMA();

    /* update Fls_JobRequest */
    Fls_JobRequest.Length          -= CurrentReadLength;
    Fls_JobRequest.RamAddress      += CurrentReadLength;
    Fls_JobRequest.LogFlashAddress += CurrentReadLength;

    /* call Fls_MainFinish after the read is failed */
    /* also finish if error is detected */
    /* call Fls_MainFinish after the read is finished successfully */
    if(( Fls_JobRequest.Length == 0UL ) || ( Fls_JobResult != MEMIF_JOB_PENDING ))
    {
        if( Fls_JobResult != MEMIF_JOB_FAILED )
        {
            /* no hardware failure detected */
            Fls_ReportErrorStatusReadFailed( FLS_EVENT_STATUS_PASSED );
        }

        /* call Fls_MainFinish() and finish a read job */
        Fls_MainFinish(ConfigPtr);
    }

    return;
}

/** \brief Fls_MainWrite
 **
 ** This internal function writes data from Fls_JobRequest.RamAddress to the
 ** Fls_JobRequest.FlashAddress and up to Fls_JobRequest.CurrentLength at once.
 **
 ** If the complete data is written, the job status and driver status will be
 ** adjusted and this function calles Fls_MainFinish() function.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainWrite
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
)
{
    uint8                   Ret;                /* return value of main routine of flash driver engine */
    Fls_PhysicalAddressType PhysicalAddress;    /* physical address for write operation */
    Fls_PhysicalLengthType  LengthToSectorEnd;  /* calculated length to sector end */

    /* Fls225: call main routine of flash driver engine asynchronously */
    Fls_MainFunctionSub(ConfigPtr);

    /* check the state of FlsSub  */
    Ret = Fls_GetJobResultSub();

    /* clear the watchdog timer */
    Fls_WdgClear();

    if( Ret == FLS_JOB_FAILED_NOTACQUIRE )
    {
        if( Fls_JobRequest.Fls_RetryTime > FLS_MAX_TIME_RETRY_ACQUIRE )
        {
            Ret = FLS_JOB_TIMEOUT;
        }
    }
    else
    {
        if( Fls_GetStatusSub() == FLS_STATUS_BUSY )
        {
            Ret = FLS_JOB_PENDING;
        }
    }

    switch(Ret)
    {
    case FLS_JOB_PENDING:
        Fls_JobRequest.Fls_RetryTime = 0U;
        break;
    case FLS_JOB_OK:
        Fls_JobRequest.Length          -= Fls_JobRequest.CurrentLength;
        Fls_JobRequest.LogFlashAddress += Fls_JobRequest.CurrentLength;
        Fls_JobRequest.RamAddress      += Fls_JobRequest.CurrentLength;
        Fls_JobRequest.Fls_RetryTime    = 0U;

        if( Fls_JobRequest.Length == 0UL )
        {
            Fls_ReportErrorStatusWriteFailed( FLS_EVENT_STATUS_PASSED );

            /* update Fls_JobRequest */
            Fls_JobRequest.CurrentJob       = FLS_WRITE_VERIFY;
            Fls_JobRequest.Length           = Fls_JobRequest.ResetLength;
            Fls_JobRequest.LogFlashAddress -= Fls_JobRequest.ResetLength;
            Fls_JobRequest.RamAddress      -= Fls_JobRequest.ResetLength;
        }
        else
        {
            /* calculate physical address and length to sector end */
            Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                            MemoryMap,
                                            Fls_JobRequest.LogFlashAddress,
                                            &PhysicalAddress,
                                            &LengthToSectorEnd);

            Fls_JobRequest.CurrentLength = (( Fls_JobRequest.Length ) > ( LengthToSectorEnd )) ?
                                ( LengthToSectorEnd ) : ( Fls_JobRequest.Length );

            /* call write routine of flash driver engine */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
               Justification: This cast is needed for specifying
               integral values as addresses for device access. */
            /* PRQA S 306 2 */
            (void)Fls_WriteSub((FLS_UCHAR *)PhysicalAddress, 
                                (FLS_UCHAR *)Fls_JobRequest.RamAddress, 
                                Fls_JobRequest.CurrentLength);
        }
        break;
    case FLS_JOB_TIMEOUT:
        /* report DET error */
        (void)Fls_ReportError( FLS_MODULE_ID,
                               FLS_INSTANCE_ID,
                               FLS_ID_MAINFUNCTION,
                               FLS_E_TIMEOUT );

        Fls_JobResult = MEMIF_JOB_FAILED;

        /* call Fls_MainFinish() and finish a write job */
        Fls_MainFinish(ConfigPtr);
        break;
    case FLS_JOB_FAILED:
    case FLS_JOB_FAILED_UNWRITABLE:
        /* Fls105: on hardware failure
        - set job result to MEMIF_JOB_FAILED
        - call DET with FLS_E_WRITE_FAILED
        */
        Fls_ReportErrorStatusWriteFailed( FLS_EVENT_STATUS_FAILED );
        Fls_JobResult = MEMIF_JOB_FAILED;

        /* call Fls_MainFinish() and finish a write job */
        Fls_MainFinish(ConfigPtr);
        break;
    case FLS_JOB_FAILED_NOTACQUIRE:
        Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
        Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
        break;
    default:
        break;
    }

    return;
}

/** \brief Fls_MainFinish
 **
 ** This function is called from Fls_MainFunction, or internal functions
 ** of Fls_MainFunction.
 ** This function performs the initialization of global variables and 
 ** calls the End/Error notification function.
 **  
 ** \param[in] ConfigPtr        Configuration address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainFinish
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
)
{
    /* enter exclusive area */
    Fls_EnterCritiSec();

    /* after the job has been finished successfully, 
            Fls345: set job result to MEMIF_JOB_OK if it is currently MEMIF_JOB_PENDING 
            Fls346: set the driver state to MEMIF_IDLE and call the job end notification 
                    function if configured 
    */
    Fls_JobRequest.CurrentJob = FLS_IDLE;         /* clear Fls_JobRequest.CurrentJob */
    Fls_DriverState           = MEMIF_IDLE;       /* clear Fls_DriverState */
    Fls_JobRequest.Fls_MainFunctionTime = FLS_MAX_TIME_INIT;  /* clear Fls_MainFunctionTime */

    /* check the Fls_JobResult */
    if( Fls_JobResult == MEMIF_JOB_PENDING )
    {
        Fls_JobResult = MEMIF_JOB_OK;

        Fls_ExitCritiSec();

        /* Fls167: if configured call job end callback, 
                called job end callback function */
        if( ConfigPtr->JobEndNotifFctPtr != NULL_PTR )
        {
            ConfigPtr->JobEndNotifFctPtr();
        }
    }
    else
    {
        Fls_ExitCritiSec();

        /* if HW error occured, call Fls_CancelSub and Fls_GetStatusSub 
            in order to disable writing to flash memory and issue the reset command. */
        Fls_CancelSub();
        (void)Fls_GetStatusSub();

        /* Fls347: when the module has finished a job with a negative result */
        /* Fls348: when the module has canceled an ongoing job */
        /* Fls349: when the module has finished a compare job and the memory blocks differ */

        /* if configured call job error callback, 
                called job error callback function */
        if(ConfigPtr->JobErrorNotifFctPtr != NULL_PTR)
        {
            ConfigPtr->JobErrorNotifFctPtr();
        }
    }
    return;
}

/** \brief Fls_ConvertLogicalFlashAddress
 **
 ** The function calculates the physical flash address and the length to the sector end
 ** from the given logical flash address.
 **
 ** \param[in]  ConfigPtr            Configuration address
 ** \param[in]  MemoryMap            Memory map address
 ** \param[in]  LogicalAddress       Logical flash address
 ** \param[out] PhysicalAddressPtr   Pointer to store physical address
 ** \param[out] LengthToSectorEndPtr Pointer to store length to sector end
 **
 ** \return     none
 */
FUNC(void, FLS_CODE) Fls_ConvertLogicalFlashAddress
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap,
    Fls_AddressType LogicalAddress,
    P2VAR(Fls_PhysicalAddressType, AUTOMATIC, FLS_APPL_DATA) PhysicalAddressPtr,
    P2VAR(Fls_PhysicalLengthType, AUTOMATIC, FLS_APPL_DATA) LengthToSectorEndPtr
)
{
    uint16  MemoryMapCounter;       /* memory map conuter */
    uint16  SectorCounter;          /* sector counter */
    uint32  CurrentSecLogAddr;      /* current sector logical address */

    /* initialize internal value */
    MemoryMapCounter = 0U;
    SectorCounter = 0U;
    CurrentSecLogAddr = MemoryMap[MemoryMapCounter].logical;

    /* query the correct sector of the logical address */
    while( SectorCounter < ConfigPtr->NumberOfSectors )
    {
        if( LogicalAddress < ( CurrentSecLogAddr + ( MemoryMap[MemoryMapCounter].size * MemoryMap[MemoryMapCounter].number ) ) )
        {
            /* calculate physical address */
            ( *PhysicalAddressPtr ) = ( (Fls_PhysicalAddressType)LogicalAddress - CurrentSecLogAddr ) + MemoryMap[MemoryMapCounter].physical;

            /* calculate length to sector end */
            ( *LengthToSectorEndPtr ) = MemoryMap[MemoryMapCounter].size - ( ( *PhysicalAddressPtr ) & ( MemoryMap[MemoryMapCounter].size - 1UL ) );

            /* escape loop */
            SectorCounter = ConfigPtr->NumberOfSectors;
        }
        else
        {
            SectorCounter += MemoryMap[MemoryMapCounter].number;
            MemoryMapCounter++;
            CurrentSecLogAddr = MemoryMap[MemoryMapCounter].logical;
        }
    }

    return;
}

/** \brief Fls_MainEraseVerify
 **
 ** The function verifies that the area given by Fls_JobRequest.LogFlashAddress
 ** with length Fls_JobRequest.Length is erased. If not, the erase job will be
 ** aborted, the DET error FLS_E_VERIFY_ERASE_FAILED will be generated.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainEraseVerify
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
)
{
    uint8                   Ret;                  /* return value of main routine of flash driver engine */
    Fls_PhysicalAddressType PhysicalAddress;      /* physical address for write operation */
    Fls_PhysicalLengthType  LengthToSectorEnd;    /* calculated length to sector end */
    Fls_LengthType          CurrentVerifyLength;  /* length of data to be verified */

    /* Fls220: call main routine of flash driver engine asynchronously */
    Fls_MainFunctionSub(ConfigPtr);

    /* check the jobresult of FlsSub */
    Ret = Fls_GetJobResultSub();

    /* clear the watchdog timer */
    Fls_WdgClear();

    if( ( Ret == FLS_JOB_FAILED_NOTACQUIRE ) && ( Fls_JobRequest.Fls_RetryTime > FLS_MAX_TIME_RETRY_ACQUIRE ) )
    {
        Ret = FLS_JOB_TIMEOUT;
    }

    switch(Ret)
    {
    case FLS_JOB_PENDING:
        Fls_JobRequest.Fls_RetryTime = 0U;
        break;
    case FLS_JOB_OK:
        Fls_JobRequest.LogFlashAddress += Fls_JobRequest.CurrentLength;
        Fls_JobRequest.Length          -= Fls_JobRequest.CurrentLength;
        Fls_JobRequest.Fls_RetryTime    = 0U;
        if( Fls_JobRequest.Length == 0UL )
        {
            if( Fls_JobRequest.CurrentJob == FLS_WRITE_PREVER )
            {
                /* update Fls_JobRequest */
                Fls_JobRequest.CurrentJob = FLS_WRITE_WAIT;
                Fls_JobRequest.Length           = Fls_JobRequest.ResetLength;
                Fls_JobRequest.LogFlashAddress -= Fls_JobRequest.ResetLength;

                /* calculate physical address and length to sector end */
                Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                                MemoryMap,
                                                Fls_JobRequest.LogFlashAddress,
                                                &PhysicalAddress,
                                                &LengthToSectorEnd);
                Fls_JobRequest.CurrentLength = (( Fls_JobRequest.Length ) > ( LengthToSectorEnd )) ?
                                                ( LengthToSectorEnd ) : ( Fls_JobRequest.Length );
            }
            else
            {
                /* call Fls_MainFinish() and finish an erase job */
                Fls_MainFinish(ConfigPtr);
            }
        }
        else
        {
            /* calculate physical address and length to sector end */
            Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                            MemoryMap,
                                            Fls_JobRequest.LogFlashAddress,
                                            &PhysicalAddress,
                                            &LengthToSectorEnd);

            /* Fls371: only verify as much data as configured for one read cycle in the given mode */
            if( Fls_Mode == MEMIF_MODE_SLOW )
            {
                CurrentVerifyLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadNormalMode )) ?
                                        ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadNormalMode );
            }
            else
            {
                CurrentVerifyLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadFastMode )) ?
                                        ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadFastMode );
            }

            Fls_JobRequest.CurrentLength = (( CurrentVerifyLength ) < ( LengthToSectorEnd )) ?
                                             ( CurrentVerifyLength ) : ( LengthToSectorEnd );

            /* call blank check routine of flash driver engine */
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
               Justification: This cast is needed for specifying
               an integral value as an address for device access. */
            /* PRQA S 306 1 */
            (void)Fls_BlankCheckSub((FLS_UCHAR *)PhysicalAddress, 
                                     Fls_JobRequest.CurrentLength);
        }
        break;
    case FLS_JOB_TIMEOUT:
        /* set MEMIF_JOB_FAILED for Fls_JobResult */
        Fls_JobResult = MEMIF_JOB_FAILED;

        /* report DET error */
        (void)Fls_ReportError( FLS_MODULE_ID,
                               FLS_INSTANCE_ID,
                               FLS_ID_MAINFUNCTION,
                               FLS_E_TIMEOUT );

        Fls_MainFinish(ConfigPtr);
        break;
    case FLS_JOB_FAILED:
    case FLS_JOB_FAILED_UNWRITABLE:
        /* set MEMIF_JOB_FAILED for Fls_JobResult */
        Fls_JobResult = MEMIF_JOB_FAILED;

        /* Support of configuration for not reporting to error callout */
        /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
           Justification: This implementation is adopted for avoiding more nesting.
           It is no problem because side effects cannot be caused. */
        /* PRQA S 3415 2 */
        if( ( Fls_ReportErrorIfNotBlank == TRUE ) || ( Fls_JobRequest.CurrentJob != FLS_BLANKCHECK ) ||
            ( ( Fls_GetResultFMAPI() & FLS_BLANKCHECK_ERROR_MASK ) != FLS_FMAPI_STATUS_FLASH_NOT_ERASED ) )
        {
            /* report DET error */
            (void)Fls_ReportError( FLS_MODULE_ID,
                                   FLS_INSTANCE_ID,
                                   FLS_ID_MAINFUNCTION,
                                   FLS_E_VERIFY_ERASE_FAILED );
        }

        Fls_MainFinish(ConfigPtr);
        break;
    case FLS_JOB_FAILED_NOTACQUIRE:
        Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
        Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
        break;
    default:
        break;
    }

    return;
}

/** \brief Fls_MainWriteVerify
 **
 ** The function verifies that the area given by Fls_JobRequest.LogFlashAddress
 ** with length Fls_JobRequest.Length are identical to Fls_JobRequest.RamAddress
 ** with identical length.
 ** If not, the write job will be aborted, the DET error 
 ** FLS_E_VERIFY_WRITE_FAILED will be generated.
 **
 ** \param[in] ConfigPtr        Configuration address
 ** \param[in] MemoryMap        Memory map address
 **
 ** \return     none
 */
static FUNC(void, FLS_CODE) Fls_MainWriteVerify
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr,
    P2CONST(Fls_MemoryMapType, FLS_CONST, FLS_APPL_CONST) MemoryMap
)
{
    FAR P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)             FlashAddressPtr;   /* pointer to Flash Address (32bit) */
    FAR P2VAR(Fls_WriteDataType, AUTOMATIC, FLS_APPL_DATA) RamAddressPtr;     /* pointer to data (32bit) */
    FAR P2VAR(Fls_WriteDataType, AUTOMATIC, FLS_APPL_DATA) FlashAddressMPtr;  /* pointer for compare operation in Flash (32bit) */
    Fls_LengthType                                         LoopCounter ;      /* loop counter value */
    Fls_LengthType                                         VerifyLength;      /* length for verifing in called once */
    Fls_PhysicalAddressType                                PhysicalAddress;   /* physical address for compare operation */
    Fls_PhysicalLengthType                                 LengthToSectorEnd; /* calculated length to sector end */
    uint8                                                  VerifyFailedFlag;  /* flag of write verify failed check */
    Fls_WriteDataType                                      RamData;           /* data for verifing operation in RAM */
    FAR P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)             RamAddressCPtr;    /* pointer to data (8bit) */
    FAR P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)             RamDataCPtr;       /* pointer to data (8bit) */
    uint8                                                  MultiVerifyFlag;   /* flag of enabling multiple verify */
    Fls_LengthType                                         ReadSize;          /* length of processed data */
    Fls_LengthType                                         AuxBufferReadSize; /* processed or read data in auxiliary buffer */

    /* Fls056: after successful write and if DET is ON, verify written data
        - on failure set job result to MEMIF_JOB_FAILED and
        - call DET -> FLS_E_VERIFY_WRITE_FAILED
        - and return
    */

    /* initialize internal value */
    VerifyFailedFlag = FLS_FALSE;
    LoopCounter = 0UL;
    ReadSize = 0UL;

    /* calculate physical address and length to sector end */
    Fls_ConvertLogicalFlashAddress( ConfigPtr,
                                    MemoryMap,
                                    Fls_JobRequest.LogFlashAddress,
                                    &PhysicalAddress,
                                    &LengthToSectorEnd);

    /* determine whether multiple verification can be done because the memory access instruction requires word-aligned address */
    if( ( (uint32)Fls_JobRequest.RamAddress & (uint32)( sizeof(uint32) - 1UL ) ) == 0UL )
    {
        MultiVerifyFlag = FLS_TRUE;
    }
    else
    {
        MultiVerifyFlag = FLS_FALSE;
    }

    /* set pointer for Flash and RAM */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: This cast is needed for handling integral values as
       addresses for device access. */
    /* PRQA S 306 3 */
    FlashAddressPtr = (FAR uint8 *)PhysicalAddress;
    RamAddressPtr   = (FAR Fls_WriteDataType *)Fls_JobRequest.RamAddress;
    FlashAddressMPtr = (FAR Fls_WriteDataType *)PhysicalAddress;

    /* Fls040: only read as much data as configured for one read cycle in the given mode */
    if( Fls_Mode == MEMIF_MODE_SLOW )
    {
        VerifyLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadNormalMode )) ?
                        ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadNormalMode );
    }
    else
    {
        VerifyLength = (( Fls_JobRequest.Length ) < ( ConfigPtr->MaxReadFastMode )) ?
                        ( Fls_JobRequest.Length ) : ( ConfigPtr->MaxReadFastMode );
    }

    /* only read to the next sector end */
    VerifyLength = (( VerifyLength ) < ( LengthToSectorEnd )) ?
                    ( VerifyLength ) : ( LengthToSectorEnd );

    Fls_EnableDMA();

    /* clear read error */
    Fls_ClearReadError();

    if( Fls_UseDmaForRead == STD_ON )
    {
        AuxBufferReadSize = (( VerifyLength ) < ( Fls_AuxiliaryBufferSize )) ?
                             ( VerifyLength ) : ( Fls_AuxiliaryBufferSize );
        Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[0], AuxBufferReadSize );
        AuxBufferReadSize = 0UL;
    }

    while( LoopCounter < ( VerifyLength >> FLS_SHIFT_W_VALUE ) )
    {
        /* read from flash */
        if( Fls_UseDmaForRead == STD_ON )
        {
            Fls_FlashWData = Fls_AuxiliaryBuffer[AuxBufferReadSize];
        }
        else
        {
            Fls_FlashWData = FlashAddressMPtr[LoopCounter];
            Fls_GetReadError();
        }
        if( MultiVerifyFlag == FLS_TRUE )
        {
            RamData = RamAddressPtr[LoopCounter];
        }
        else
        {
            /* Deviation from MISRA-C:2004 rule 11.4, MISRA-C:2012 Rule-11.3.
               Justification: This cast is needed for handling with 8-bit type address. */
            /* PRQA S 310 2 */
            RamAddressCPtr = (uint8 *)(&RamAddressPtr[LoopCounter]);
            RamDataCPtr    = (uint8 *)(&RamData);
            RamDataCPtr[0] = RamAddressCPtr[0];
            RamDataCPtr[1] = RamAddressCPtr[1];
            RamDataCPtr[2] = RamAddressCPtr[2];
            RamDataCPtr[3] = RamAddressCPtr[3];
        }

        /* read error check and compare that the value of FlashAddressPtr and RamAddressPtr */
        if( ( Fls_Fault != FLS_FAULT_NONE ) || ( Fls_FlashWData != RamData ) )
        {
            if( ( Fls_Fault == FLS_FAULT_MACROERROR ) && ( Fls_JobRequest.Fls_RetryTime <= FLS_MAX_TIME_RETRY_ACQUIRE ) )
            {
                Fls_JobRequest.Fls_MainFunctionTime += ConfigPtr->CallCycle;
                Fls_JobRequest.Fls_RetryTime += (uint16)ConfigPtr->CallCycle;
                VerifyLength = 0UL;
            }
            else
            {
                /* if verify failed */
                Fls_JobResult = MEMIF_JOB_FAILED;

                /* VerifyFailedFlag is ON */
                VerifyFailedFlag = FLS_TRUE;

                if( Fls_Fault != FLS_FAULT_MACROERROR )
                {
                    /* report DET error */
                    (void)Fls_ReportError( FLS_MODULE_ID,
                                           FLS_INSTANCE_ID,
                                           FLS_ID_MAINFUNCTION,
                                           FLS_E_VERIFY_WRITE_FAILED );
                }
                else
                {
                    /* report DET error */
                    (void)Fls_ReportError( FLS_MODULE_ID,
                                           FLS_INSTANCE_ID,
                                           FLS_ID_MAINFUNCTION,
                                           FLS_E_TIMEOUT );
                }
                Fls_MainFinish(ConfigPtr);
            }

            LoopCounter = ( VerifyLength >> FLS_SHIFT_W_VALUE );
        }
        else
        {
            /* update the verify area  */
            Fls_JobRequest.Fls_RetryTime = 0U;
            LoopCounter++;
            if( Fls_UseDmaForRead == STD_ON )
            {
                ReadSize += 4UL;
                AuxBufferReadSize++;
                if( ( AuxBufferReadSize << FLS_SHIFT_W_VALUE ) >= Fls_AuxiliaryBufferSize )
                {
                    AuxBufferReadSize = (( VerifyLength - ReadSize ) < ( Fls_AuxiliaryBufferSize )) ?
                                         ( VerifyLength - ReadSize ) : ( Fls_AuxiliaryBufferSize );
                    if( AuxBufferReadSize > 0UL )
                    {
                        Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], &FlashAddressPtr[ReadSize], AuxBufferReadSize );
                        AuxBufferReadSize = 0UL;
                    }
                }
            }
        }
        
        /* clear the watchdog timer */
        Fls_WdgClear();
    }

    Fls_DisableDMA();

    if( VerifyFailedFlag == FLS_FALSE )
    {
        /* update Fls_JobRequest */
        Fls_JobRequest.Length          -= VerifyLength;
        Fls_JobRequest.LogFlashAddress += VerifyLength;
        Fls_JobRequest.RamAddress      += VerifyLength;
        
        /* if write verify job finish, call Fls_MainFinish() */
        if( Fls_JobRequest.Length == 0UL )
        {
            /* call Fls_MainFinish() and finish a write job */
            Fls_MainFinish(ConfigPtr);
        }
    }
    
    return;
}


#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[end of file]===========================================*/
