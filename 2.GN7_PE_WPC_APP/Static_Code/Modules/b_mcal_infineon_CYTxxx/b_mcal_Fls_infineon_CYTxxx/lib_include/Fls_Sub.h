/** \brief AUTOSAR Fls Flash Driver
 **
 ** Fls sub module interface header
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef FLS_SUB_H
#define FLS_SUB_H


/*============*/
/* Data types */
/*============*/
#ifndef FLS_TYPEDEF_UCHAR
#define FLS_TYPEDEF_UCHAR
typedef uint8   FLS_UCHAR;
#endif /* end of FLS_TYPEDEF_UCHAR */

#ifndef FLS_TYPEDEF_USHORT
#define FLS_TYPEDEF_USHORT
typedef uint16  FLS_USHORT;
#endif /* end of FLS_TYPEDEF_USHORT */

#ifndef FLS_TYPEDEF_ULONG
#define FLS_TYPEDEF_ULONG
typedef uint32  FLS_ULONG;
#endif /* end of FLS_TYPEDEF_ULONG */

#ifndef FLS_TYPEDEF_ULONGLONG
#define FLS_TYPEDEF_ULONGLONG
typedef uint64  FLS_ULONGLONG;
#endif /* end of FLS_TYPEDEF_ULONGLONG */

#ifndef FLS_TYPEDEF_SCHAR
#define FLS_TYPEDEF_SCHAR
typedef sint8   FLS_SCHAR;
#endif /* end of FLS_TYPEDEF_SCHAR */

#ifndef FLS_TYPEDEF_SSHORT
#define FLS_TYPEDEF_SSHORT
typedef sint16  FLS_SSHORT;
#endif /* end of FLS_TYPEDEF_SSHORT */

#ifndef FLS_TYPEDEF_SLONG
#define FLS_TYPEDEF_SLONG
typedef sint32  FLS_SLONG;
#endif /* end of FLS_TYPEDEF_SLONG */

#ifndef FLS_TYPEDEF_SLONGLONG
#define FLS_TYPEDEF_SLONGLONG
typedef sint64  FLS_SLONGLONG;
#endif /* end of FLS_TYPEDEF_SLONGLONG */

/* Type of job performed on next mainfunction call */
typedef enum fls_writeregisterspattern
{
    FLS_WRITE_REG_PATN_ENABLE_WRITE = 1,        /* enable writing to flash memory */
    FLS_WRITE_REG_PATN_DISABLE_WRITE,           /* disable writing to flash memory */
    FLS_WRITE_REG_PATN_DISABLE_INTERRUPT_WRITE, /* disable interruption for writing */
    FLS_WRITE_REG_PATN_ENABLE_INTERRUPT_WRITE,  /* enable interruption for writing */
    FLS_WRITE_REG_PATN_CLEAR_IPC,               /* clear interruption of IPC */
    FLS_WRITE_REG_PATN_INVALIDATE_CACHE,        /* invalidate cache and buffer */
    FLS_WRITE_REG_PATN_CLEAR_READERROR,         /* clear read error */
    FLS_WRITE_REG_PATN_REFRESH_REGISTERS,       /* refresh registers */
    FLS_WRITE_REG_PATN_INITIALIZE_REGISTERS     /* initialize registers */
} Fls_WriteRegistersPatternType;

/* Type of DMAC descriptor */
typedef struct fls_dmacdescriptor
{
    uint32 DescrCtl;    /* Descriptor control */
    uint32 DescrSrc;    /* Descriptor source */
    uint32 DescrDst;    /* Descriptor destination */
    uint32 DescrXSize;  /* Descriptor X loop size */
    uint32 DescrNext;   /* Descriptor next pointer */
} Fls_DmacDescriptorType;

/*============*/
/* Macros     */
/*============*/
/* for Fls_StateSub */
#define FLS_HAL_NOP               ((FLS_UCHAR)0)    /* no-operation */
#define FLS_HAL_WRITE_WAIT        ((FLS_UCHAR)1)    /* waiting for writing */
#define FLS_HAL_WRITE             ((FLS_UCHAR)2)    /* writing */
#define FLS_HAL_ERASE_WAIT        ((FLS_UCHAR)3)    /* waiting for erasing */
#define FLS_HAL_ERASE             ((FLS_UCHAR)4)    /* erasing */
#define FLS_HAL_BLANKCHECK_WAIT   ((FLS_UCHAR)5)    /* waiting for checking blank */
#define FLS_HAL_BLANKCHECK        ((FLS_UCHAR)6)    /* checking blank */

#define FLS_HAL_MAX               ((FLS_UCHAR)7)    /* time over */
#define FLS_FMC_ACT               ((FLS_UCHAR)8)    /* FMC active in No-operation */

/* request return values */
#define FLS_REQUEST_ACCEPT        ((FLS_UCHAR)0)    /* accept request  */
#define FLS_REQUEST_DECLINE       ((FLS_UCHAR)1)    /* decline request */
#define FLS_PARAMETER_ERROR       ((FLS_UCHAR)2)    /* parameter error */

/* Fls_GetStatusSub() return values */
#define FLS_STATUS_IDLE           ((FLS_UCHAR)0)    /* idle */
#define FLS_STATUS_WAIT_IDLE      ((FLS_UCHAR)1)    /* waiting for idle */
#define FLS_STATUS_BUSY           ((FLS_UCHAR)2)    /* busy */

/* polling return values */
#define FLS_OK                    ((FLS_UCHAR)0)    /* OK */
#define FLS_NG                    ((FLS_UCHAR)1)    /* NG */
#define FLS_CONT                  ((FLS_UCHAR)255)  /* continue */

/* Fls_JobresultSub() return values */
#define FLS_JOB_OK                ((FLS_UCHAR)0)    /* success */
#define FLS_JOB_PENDING           ((FLS_UCHAR)1)    /* pending */
#define FLS_JOB_CANCELLED         ((FLS_UCHAR)2)    /* cancelled */
#define FLS_JOB_FAILED            ((FLS_UCHAR)3)    /* failed */
#define FLS_JOB_TIMEOUT           ((FLS_UCHAR)4)    /* timeout */
#define FLS_JOB_FAILED_UNWRITABLE ((FLS_UCHAR)5)    /* failed (unwritable) */
#define FLS_JOB_FAILED_NOTACQUIRE ((FLS_UCHAR)6)    /* unable to set the flash memory writable */

/* common value */
#ifndef FLS_TRUE_SUB
#define FLS_TRUE_SUB                        (1U)    /* true  */
#endif
#ifndef FLS_FALSE_SUB
#define FLS_FALSE_SUB                       (0U)    /* false */
#endif
#define FLS_NULL                            (0)     /* zero(NULL)  */

#define FLS_ZERO                            (0)     /* zero */

/* macro for bit operation */
#define FLS_SHIFT_2BITS                     (2U)
#define FLS_SHIFT_8BITS                     (8U)
#define FLS_SHIFT_16BITS                    (16U)
#define FLS_SHIFT_24BITS                    (24U)

/* macro for counting up to max */
#if !defined( FLS_USE_VCAST )
#define FLS_COUNT_MAX_SUB                   ( ( Fls_CoreKind == FLS_CM0P ) ? ( 20000000UL ) : ( ( Fls_CoreKind == FLS_CM4 ) ? ( 40000000UL ) : ( 70000000UL ) ) )
#else
#define FLS_COUNT_MAX_SUB                   (0x0000000FUL)
#endif /* if !defined( FLS_USE_VCAST ) */

/* state set macro */
#define FLS_STATESUB_SET(state)     \
{                                   \
    Fls_StateSub = (state);         \
    Fls_StateSubMirror = (state);   \
}


/*============*/
/* Header     */
/*============*/
#include "Fls_MpuSub.h"                 /* include MPU configuration header */
#include "Fls_CfgSub.h"                 /* include user configuration */


/*=================*/
/* Const variables */
/*=================*/


/*==================*/
/* Global variables */
/*==================*/

#define FLS_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include <Fls_MemMap.h>

extern    volatile P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) Fls_NowAddr;              /* current address of writing or erasing */
extern             P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) Fls_NowData;              /* data address */
extern             P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) Fls_ParamAddr;            /* address of writing */
extern             VAR(FLS_ULONG, FLS_VAR_NO_INIT)            Fls_ParamLength;          /* length of writing or erasing */
extern             VAR(FLS_ULONG, FLS_VAR_NO_INIT)            Fls_DataSize;             /* remain size of writing */
extern             VAR(FLS_UCHAR, FLS_VAR_NO_INIT)            Fls_StateSub;             /* state of HAL */
extern             VAR(FLS_UCHAR, FLS_VAR_NO_INIT)            Fls_StateSubMirror;       /* mirror of Fls_StateSub for fail-safe */
extern             VAR(FLS_UCHAR, FLS_VAR_NO_INIT)            Fls_JobresultSub;         /* job result */
extern             P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) Fls_SuspendedParamAddr;   /* address of writing */
extern    volatile P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) Fls_SuspendedNowAddr;     /* current address of writing or erasing */
extern             P2VAR(FLS_ULONG, AUTOMATIC, FLS_APPL_DATA) Fls_SuspendedNowData;     /* data address */
extern             VAR(FLS_ULONG, FLS_VAR_NO_INIT)            Fls_SuspendedParamLength; /* length of writing or erasing */
extern             VAR(FLS_ULONG, FLS_VAR_NO_INIT)            Fls_SuspendedDataSize;    /* remain size of writing */
extern             VAR(FLS_UCHAR, FLS_VAR_NO_INIT)            Fls_SuspendedStateSub;    /* state of HAL */
extern             VAR(FLS_UCHAR, FLS_VAR_NO_INIT)            Fls_SuspendedResultSub;   /* suspended job result */
extern             VAR(FLS_UCHAR, FLS_VAR_NO_INIT)            Fls_SuspendingEraseFlag;  /* suspending erase of flash macro */

#define FLS_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include <Fls_MemMap.h>

/*==================*/
/* Functions        */
/*==================*/

#define FLS_START_SEC_CODE
#include <Fls_MemMap.h>

/** \brief Fls_GetMasterId
**
** Request for the bus master identifier.
**
** \return     the bus master identifier
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_GetMasterId
(
 void
);

/** \brief Fls_GetAddrForRead
**
** Request for getting read address in flash memory (for FLS).
**
** \param[in]  addr       start address to read
** \param[in]  length     length in byte
**
** \return     read address if not blank, or NULL_PTR if blank
**
*/
extern FUNC_P2VAR(void, AUTOMATIC, FLS_CODE) Fls_GetAddrForRead
(
 P2VAR(void, AUTOMATIC, FLS_APPL_DATA) addr,
 FLS_ULONG length
);

/** \brief Fls_GetReadAddr
**
** Request for getting read address in flash memory (for CY FEE).
**
** \param[in]  addr       start address to read
** \param[in]  length     length in byte
**
** \return     read address if not blank, or NULL_PTR if blank
**
*/
extern FUNC_P2VAR(void, AUTOMATIC, FLS_CODE) Fls_GetReadAddr
(
 P2VAR(void, AUTOMATIC, FLS_APPL_DATA) addr,
 FLS_ULONG length
);

/** \brief Fls_ClearReadError
**
** Request for clearing read error.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_ClearReadError
(
 void
);

/** \brief Fls_GetReadError
**
** Request for acquiring read error except for Fault.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_GetReadError
(
 void
);

/** \brief Fls_WriteSub
**
** Request for writing in flash memory.
**
** \param[in]  addr       start address to write
** \param[in]  data       data address
** \param[in]  length     length in byte
**
** \return     result of request
** \retval     FLS_REQUEST_ACCEPT     accept request
** \retval     FLS_REQUEST_DECLINE    decline request
** \retval     FLS_PARAMETER_ERROR    parameter error
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_WriteSub
(
 P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) addr,
 P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) data,
 FLS_ULONG length
);

/** \brief Fls_EnableDMA
**
** Enable DMA.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_EnableDMA
(
 void
);

/** \brief Fls_DisableDMA
**
** Disable DMA.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_DisableDMA
(
 void
);

/** \brief Fls_ReadFlash
**
** Read data from specified address.
**
** \param[in]  dst        address where reading to
** \param[in]  src        address where reading from
** \param[in]  length     length in byte
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_ReadFlash
(
 P2CONST(void, AUTOMATIC, FLS_APPL_DATA) dst,
 P2CONST(void, AUTOMATIC, FLS_APPL_DATA) src,
 FLS_ULONG length
);

/** \brief Fls_WriteFlashStart
**
** Start writing flash memory.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_WriteFlashStart
(
 void
);

/** \brief Fls_WriteFlashPolling
**
** Poll for write completion. 
** When complete it, write next data if it is necessary.
**
** \return     result of polling
** \retval     FLS_OK         success
** \retval     FLS_NG         failed
** \retval     FLS_CONT       continue
** 
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_WriteFlashPolling
(
 void
);

/** \brief Fls_WriteFlashFinal
**
** End writing flash memory.
**
** \return     none
** 
*/
extern FUNC(void, FLS_CODE) Fls_WriteFlashFinal
(
 void
);

/** \brief Fls_EraseSub
**
** Request for erasing sector in flash memory.
**
** \param[in]  addr       start address to erase
** \param[in]  length     length in byte
**
** \return     result of request
** \retval     FLS_REQUEST_ACCEPT     accept request
** \retval     FLS_REQUEST_DECLINE    decline request
** \retval     FLS_PARAMETER_ERROR    parameter error 
** \retval     FLS_ACCESS_SIZE_ERROR  access size error
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_EraseSub
(
 P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) addr,
 FLS_ULONG length
);

/** \brief Fls_EraseFlashStart
**
** Start erasing specified sector in flash memory.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_EraseFlashStart
(
 void
);

/** \brief Fls_EraseFlashPolling
**
** Poll for erase completion. 
** When complete it, erase next sector if it is necessary.
**
** \return     result of polling
** \retval     FLS_OK         success 
** \retval     FLS_NG         failed
** \retval     FLS_CONT       continue
** 
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_EraseFlashPolling
(
 void
);

/** \brief Fls_EraseFlashFinal
**
** End erasing flash memory.
**
** \return     none
** 
*/
extern FUNC(void, FLS_CODE) Fls_EraseFlashFinal
(
 void
);

/** \brief Fls_MainFunctionSub
**
** Periodic execution of HAL.
**
** \param[in] ConfigPtr        Configuration address
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_MainFunctionSub
(
 P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
);

/** \brief Fls_GetStatusSub
**
** Get status of HAL.
**
** \return     status of HAL
** \retval     FLS_STATUS_IDLE        idle
** \retval     FLS_STATUS_WAIT_IDLE   waiting for idle
** \retval     FLS_STATUS_BUSY        busy
**
*/
/* Deviation from MISRA-C:2004 rule 8.8, MISRA-C:2012 Rule-8.5.
   Justification: This declaration is intentionally done in more than one file
   in order to be accessible from outside. */
/* PRQA S 3451 1 */
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_GetStatusSub
(
 void
);

/** \brief Fls_InitSub
**
** Initialize register and internal variable.
** Flash memory is not erased.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_InitSub
(
 void
);

/** \brief Fls_CancelSub
**
** Cancel periodic processing and initialize internal variable.
** Flash memory is not erased.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_CancelSub
(
 void
);

/** \brief Fls_CancelSubSub
**
** Cancel the processing under operation.
** Initialize internal variable used in writing and erasing.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_CancelSubSub
(
 void
);

/** \brief Fls_GetJobResultSub
**
** Get job result of HAL.
**
** \return     job result
** \retval     FLS_JOB_OK                 success
** \retval     FLS_JOB_PENDING            pending
** \retval     FLS_JOB_CANCELLED          cancelled
** \retval     FLS_JOB_FAILED             failed
** \retval     FLS_JOB_TIMEOUT            timeout
** \retval     FLS_JOB_FAILED_UNWRITABLE  failed (unwritable)
** \retval     FLS_JOB_FAILED_NOTACQUIRE  unable to set the flash memory writable
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_GetJobResultSub
(
 void
);

/** \brief Fls_PollingFlash
**
** Poll for write completion or erase completion status check.
**
** \return     result of polling
** \retval     FLS_HAL_NOP              No-operation(completion)
** \retval     FLS_HAL_WRITE_WAIT       waiting for writing
** \retval     FLS_HAL_WRITE            writing
** \retval     FLS_HAL_ERASE_WAIT       waiting for erasing
** \retval     FLS_HAL_ERASE            erasing
** \retval     FLS_HAL_BLANKCHECK_WAIT  waiting for checking blank
** \retval     FLS_HAL_BLANKCHECK       checking blank
** \retval     FLS_HAL_MAX              timing limit exceeded
** \retval     FLS_FMC_ACT              FMC active in no-operation
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_PollingFlash
(
 void
);

/** \brief Fls_ResetSub
**
** Issue a reset command to the flash memory.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_ResetSub
(
 void
);

/** \brief Fls_BlankCheckSub
**
** This function in HAL unit requests blank check to flash memory.
**
** \param[in]  addr       start address to check blank
** \param[in]  length     length in byte
**
** \return     result of request
** \retval     FLS_REQUEST_ACCEPT     accept request
** \retval     FLS_REQUEST_DECLINE    decline request
** \retval     FLS_PARAMETER_ERROR    parameter error
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_BlankCheckSub
(
 P2VAR(FLS_UCHAR, AUTOMATIC, FLS_APPL_DATA) addr,
 FLS_ULONG length
);

/** \brief Fls_BlankCheckFlashStart
**
** Start brank checking specified sector in flash memory.
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_BlankCheckFlashStart
(
 void
);

/** \brief Fls_BlankCheckFlashPolling
**
** Poll for blank check completion. 
** When complete it, blank check next area if it is necessary.
**
** \return     result of polling
** \retval     FLS_OK         success 
** \retval     FLS_NG         failed
** \retval     FLS_CONT       continue
** 
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_BlankCheckFlashPolling
(
 void
);

/** \brief Fls_BlankCheckFlashFinal
**
** End checking blank flash memory.
**
** \return     none
** 
*/
extern FUNC(void, FLS_CODE) Fls_BlankCheckFlashFinal
(
 void
);

/** \brief Fls_SuspendSub
**
** This function in HAL unit requests suspend to flash memory.
**
** \return     result of request
** \retval     FLS_REQUEST_ACCEPT     accept request
** \retval     FLS_REQUEST_DECLINE    decline request
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_SuspendSub
(
 void
);

/** \brief Fls_ResumeSub
**
** This function in HAL unit requests resume for suspended process to flash memory.
**
** \return     result of request
** \retval     FLS_REQUEST_ACCEPT     accept request
** \retval     FLS_REQUEST_DECLINE    decline request
**
*/
extern FUNC(FLS_UCHAR, FLS_CODE) Fls_ResumeSub
(
 void
);

/** \brief Fls_Isr_Ipc_Sub
**
** ISR process in HAL unit of flash processing (IPC_INTR).
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_Isr_Ipc_Sub
(
 void
);

/** \brief Fls_Isr_Flash_Sub
**
** ISR process in HAL unit of flash processing (FM_CTL_ECT).
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_Isr_Flash_Sub
(
 void
);

/** \brief Fls_Fault_Handling_Sub
**
** Fault handling process in HAL unit (FAULT, FLASHC).
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_Fault_Handling_Sub
(
 void
);

/** \brief Fls_WritePrivilegedRegisters
**
** Access routine to registers for writing in privileged mode.
**
** \param[in]  pattern    pattern of writing to registers
**
** \return     none
**
*/
extern FUNC(void, FLS_CODE) Fls_WritePrivilegedRegisters
(
 Fls_WriteRegistersPatternType pattern
);

/** \brief Fls_CheckRegisters
 **
 ** Checks registers written by HSM.
 **
 ** \return    check result
 ** \retval    FLS_FALSE        failed
 **            FLS_TRUE         success
 */
extern FUNC(uint8, FLS_CODE) Fls_CheckRegisters
(
 void
);

/** \brief Fls_InvokeFMAPI
**
** Invoke FLASH Management API.
**
** \param[in]  opcode     opcode
** \param[in]  argument1  1st argumen1
** \param[in]  argument2  2nd argumen1
**
** \return     result of request
** \retval     FLS_FMAPI_STATUS_SUCCESS             complete successfully
** \retval     other than FLS_FMAPI_STATUS_SUCCESS  failed
**
*/
extern FUNC(FLS_ULONG, FLS_CODE) Fls_InvokeFMAPI
(
 FLS_UCHAR opcode,
 FLS_ULONG argument1,
 FLS_ULONG argument2
);

/** \brief Fls_GetResultFMAPI
**
** Get result of FLASH Management API.
**
** \return     result of request
** \retval     FLS_FMAPI_STATUS_SUCCESS             complete successfully
** \retval     other than FLS_FMAPI_STATUS_SUCCESS  failed
**
*/
extern FUNC(FLS_ULONG, FLS_CODE) Fls_GetResultFMAPI
(
 void
);

#define FLS_STOP_SEC_CODE
#include <Fls_MemMap.h>

#endif /* !FLS_SUB_H */

/*==================[end of file]===========================================*/
