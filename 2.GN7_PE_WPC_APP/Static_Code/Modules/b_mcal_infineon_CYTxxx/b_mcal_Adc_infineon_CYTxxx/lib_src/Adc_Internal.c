/** \brief AUTOSAR Adc Driver
 **
 ** This file contains the implementation of the AUTOSAR module Adc function
 ** for processing internal functionality.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Adc_Data.h>     /* Module data declaration */
#include <Adc_Internal.h> /* Module internal declaration */
#include <Adc_Regs.h>     /* Module register types */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ADC_START_SEC_CODE_ASIL_B
#include <Adc_MemMap.h>

/** \brief Adc_CheckTriggersAndResetStream
 **
 ** Checks if triggers have to be disabled or re-triggered (one-shot vs.
 ** continuous/streaming mode) and resets the stream indices depending on
 ** the group configuration (i.e. linear vs. circular streaming buffer).
 **
 ** PRECONDITIONS:
 **   - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 ** \param [in] GroupStatus      Current status for the specified ADC channel group.
 **
 */
static FUNC(void, ADC_CODE) Adc_CheckTriggersAndResetStream
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(Adc_StatusType, AUTOMATIC) GroupStatus
);

/** \brief Adc_DeInitHw_Channel
 **
 ** De-initializes all channels as configured.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 ** 
 ** \param [in] GroupConfigPtr   Pointer to config for group.
 */
static FUNC(void, ADC_CODE) Adc_DeInitHw_Channel
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_InitHw_Channel
 **
 ** Initializes all channels as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] ConfigPtr        Pointer to configuration setting.
 ** \param [in] GroupConfigPtr   Pointer to config for group.
 */
static FUNC(void, ADC_CODE) Adc_InitHw_Channel
(
  P2CONST(Adc_ConfigType,      AUTOMATIC, ADC_APPL_CONST) ConfigPtr,
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_DeInitHw_Group
 **
 ** De-initializes all groups as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **
 ** \param [in] ConfigPtr         Pointer to config for Adc module.
 **
 */
static FUNC(void, ADC_CODE) Adc_DeInitHw_Group
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
);

/** \brief Adc_GetStreamStatus
 **
 ** Returns the status of the stream.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                       Status of the stream: ADC_COMPLETED or ADC_STREAM_COMPLETED.
 **                               ADC_COMPLETED          : some results
 **                               ADC_STREAM_COMPLETED   : filled
 **
 ** \param [in] GroupConfigPtr    Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(Adc_StatusType, ADC_CODE) Adc_GetStreamStatus
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_InitHw_Group
 **
 ** Initializes all groups as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **
 ** \param [in] ConfigPtr   Pointer to config for Adc module.
 **
 */
static FUNC(void, ADC_CODE) Adc_InitHw_Group
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
);

/** \brief Adc_IsInterruptPending
 **
 ** Checks the interrupt cause for the given group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                        Returns the status of the interrupt flag.
 **                                ADC_INT_DONE    : Interrupt flag is set.
 **                                ADC_INT_NO      : Interrupt flag is not set.
 **                                ADC_INT_ERROR   : Interrupt flag is set of error.
 **
 ** \param [in] GroupConfigPtr     Pointer to config for group.
 ** \param [in] ChannelConfigPtr   Pointer to config for channel.
 */
static FUNC(uint8, ADC_CODE) Adc_IsInterruptPending
(
  P2CONST(Adc_GroupConfigType,   AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) ChannelConfigPtr
);

/** \brief Adc_ReactionAfterGroupConversionDone
 **
 ** Continues the group conversion again or stops it according to group setting.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReactionAfterGroupConversionDone
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_ReadGroupFromRegister
 **
 ** Reads the result registers and returns the values.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 ** \param [in] ChannelOffset   Offset between the channel results to be written into ResultPtr.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReadGroupFromRegister
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  ResultPtr,
  VAR(Adc_StreamNumSampleType, AUTOMATIC)                 ChannelOffset
);

/** \brief Adc_ReadGroupFromRegisterForIsr
 **
 ** Reads the result registers and returns the values.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 ** \param [in] ChannelOffset   Offset between the channel results to be written into ResultPtr.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReadGroupFromRegisterForIsr
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  ResultPtr,
  VAR(Adc_StreamNumSampleType, AUTOMATIC)                 ChannelOffset
);

/** \brief Adc_ReadGroupFromResultBuffer
 **
 ** Reads the result buffer and returns the values.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReadGroupFromResultBuffer
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  ResultPtr
);

/** \brief Adc_PushStream
 **
 ** Reads out the current results from the result registers and appends them to the stream.
 ** But, if DMA is used, this function doesn't read out the RESULT registers.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(void, ADC_CODE) Adc_PushStream
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_PushStreamForIsr
 **
 ** Reads out the current results from the result registers and appends them to the stream.
 ** But, if DMA is used, this function doesn't read out the RESULT registers.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(void, ADC_CODE) Adc_PushStreamForIsr
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_GetStreamCurrentPointer
 **
 ** Returns the pointer to the current (newest) entry to the stream.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 ** 
 ** \return                     Current stream pointer.
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC_P2VAR(Adc_ValueGroupType, ADC_APPL_DATA, ADC_CODE) Adc_GetStreamCurrentPointer
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_GetStreamValidSamples
 **
 ** Returns the number of valid samples of the stream of the given group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                     Number of valid samples of the given stream.
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(Adc_StreamNumSampleType, ADC_CODE) Adc_GetStreamValidSamples
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_StartDmaInternal
 **
 ** Start a DMA channel.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in]  GroupConfigPtr  Pointer to configuration for a group.
 **
 */
static FUNC(void, ADC_CODE) Adc_StartDmaInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
);

/** \brief Adc_ClearInterrupt
 **
 ** Clear the interrupt cause for the given group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 ** \param [in] GroupConfigPtr     Pointer to config for group.
 ** \param [in] ChannelConfigPtr   Pointer to config for channel.
 */
static FUNC(void, ADC_CODE) Adc_ClearInterrupt
(
  P2CONST(Adc_GroupConfigType,   AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) ChannelConfigPtr
);

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

#define ADC_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/** This data stores the target power state. */
static VAR(Adc_PowerStateType, ADC_VAR_NO_INIT) Adc_TargetPowerState;

#define ADC_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[external function definitions]=========================*/

#define ADC_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/** \brief Adc_DeInitHw
 **
 ** De-initializes all HW units as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **
 ** \param [in] ConfigPtr   Pointer to configuration setting.
 **
 */
FUNC(void, ADC_CODE) Adc_DeInitHw
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
)
{
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) curHwUnitConfigPtr;
  uint8  curHwUnitIndex; /* Loop variable for HW units */

  /* De-initialize groups each HW unit. */
  Adc_DeInitHw_Group(ConfigPtr);

  /* Iterate over all HW units. */
  for (curHwUnitIndex = 0U;
       curHwUnitIndex < ConfigPtr->HwUnitConfigsNumber;
       curHwUnitIndex++)
  {
    /* Get the configuration of the current HW unit. */
    curHwUnitConfigPtr = Adc_GetHwUnitConfigInternal(curHwUnitIndex);

    /* Reset configuration registers when deinitialize the Hw unit. */
    Adc_DeInitConfigurationRegisters(curHwUnitConfigPtr);
    
    /* Setup generic input trigger select register. */
    Adc_SetupGenericInputTriggerSelect(
      curHwUnitConfigPtr->HwUnitId,  /* Numeric ID for the HwUnit */
      ADC_DEFAULT_MMIO_SAR_TR_IN_SEL /* ESAR:EPASS_MMIO:SAR_TR_IN_SEL */
    );

    /* Setup generic output trigger select register. */
    Adc_SetupSarTrOutSel(curHwUnitConfigPtr->HwUnitId, ADC_OUT0_SEL, 0U);
    Adc_SetupSarTrOutSel(curHwUnitConfigPtr->HwUnitId, ADC_OUT1_SEL, 1U);

  } /* End of HW unit loop */
  
  /* Set PASS control register to default value. */
  Adc_SetupPassControl(0U);
}

/** \brief Adc_GetGroupStatusInternal
 **
 ** Returns the status of current group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                      Return status of group described by the given GroupConfigPtr.
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
FUNC(Adc_StatusType, ADC_CODE) Adc_GetGroupStatusInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  Adc_StatusType  result;
  uint8           interruptCase;
  CONSTP2VAR(Adc_StatusType, AUTOMATIC, ADC_APPL_DATA) groupStatusPtr = GroupConfigPtr->GroupStatusPtr;

  if (GroupConfigPtr->InterruptMode == TRUE)
  {
    /* In case of Interrupt mode */
    result = *groupStatusPtr;
  }
  else
  {
    /* In case of Polling mode (I.e. only single access mode) */
    if (*groupStatusPtr == ADC_IDLE)
    {
      /* In case of idle status */
      result = ADC_IDLE;
    }
    else
    {
      /* In case of not idle status */
      /* It is necessary to identify the status from hardware */
      /* (i.e. busy, stream-completed or error).               */
      P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) lastChannelConfigPtr =
        Adc_GetChannelConfig(GroupConfigPtr->LastLogicalChannelConfigIndex);

      /* Check the interrupt cause. */
      interruptCase = Adc_IsInterruptPending(GroupConfigPtr, lastChannelConfigPtr);

      if (interruptCase == ADC_INT_DONE)
      {
        /* If interrupt occurred, set to ADC_STREAM_COMPLETED. */
        result = ADC_STREAM_COMPLETED;
      }
      else if (interruptCase == ADC_INT_NO)
      {
        /* If interrupt not occurred, set to ADC_BUSY. */
        result = ADC_BUSY;
      }
      else
      {
        /* If interrupt of error occurred, set to ADC_ERROR. */
        result = ADC_ERROR;
      }
    }
  }

  return result;
}

/** \brief Adc_GetStreamLastPointerInternal
 **
 ** Returns the number of valid samples per channel, stored in the result buffer.
 ** Reads a pointer, pointing to a position in the group result buffer. With the
 ** pointer position, the results of all group channels of the last completed
 ** conversion round can be accessed.
 ** With the pointer and the return value, all valid group conversion results can
 ** be accessed (the user has to take the layout of the result buffer into account).
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'PtrToSamplePtr' must be a valid buffer pointer.
 **
 ** \return                       Number of valid samples per channel.
 ** \param [in] GroupConfigPtr    Pointer to channel group config.
 ** \param [in] GroupStatus       Channel group status.
 ** \param [out] PtrToSamplePtr   Pointer to result buffer pointer.
 **
 */
FUNC(Adc_StreamNumSampleType, ADC_CODE) Adc_GetStreamLastPointerInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(Adc_StatusType, AUTOMATIC) GroupStatus,
  P2VAR(P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA), AUTOMATIC, ADC_APPL_DATA) PtrToSamplePtr
)
{
  Adc_StreamNumSampleType result;

  if (GroupConfigPtr->InterruptMode == FALSE)
  {
    /* In case of Polling mode */
    /* Try to add the latest sample, if already finished.
       This step is required in single access mode when interrupt
       is disabled (i.e. no ISR - which would store completed samples
       in the stream - is called). */
    Adc_PushStream(GroupConfigPtr);
  }

  /* Get available sample number. */
  result = Adc_GetStreamValidSamples(GroupConfigPtr);

  /* Get last stored buffer position. */
  *PtrToSamplePtr = Adc_GetStreamCurrentPointer(GroupConfigPtr);

  /* Check triggers and reset stream if necessary. */
  Adc_CheckTriggersAndResetStream(GroupConfigPtr, GroupStatus);

  return result;
}

/** \brief Adc_InitHw
 **
 ** Initializes all HW units as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **
 ** \param [in] ConfigPtr   A pointer to ADC driver configuration.
 **
 */
FUNC(void, ADC_CODE) Adc_InitHw
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
)
{
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) curHwUnitConfigPtr;
  uint8  curHwUnitIndex; /* Loop variable for HW units */

  /* Setup PASS control register. */
  Adc_SetupPassControl(ConfigPtr->PassControlSetting);

  /* Iterate over all HW units. */
  for (curHwUnitIndex = 0U;
       curHwUnitIndex < ConfigPtr->HwUnitConfigsNumber;
       curHwUnitIndex++)
  {
    /* Get the configuration of the current HW unit. */
    curHwUnitConfigPtr = &(ConfigPtr->HwUnitConfigPtr[curHwUnitIndex]);

    /* Set configuration registers when initialize the Hw unit. */
    Adc_InitConfigurationRegisters(curHwUnitConfigPtr);
    
    /* Setup generic input trigger select register. */
    Adc_SetupGenericInputTriggerSelect(
      curHwUnitConfigPtr->HwUnitId,             /* Numeric ID for the HwUnit */
      curHwUnitConfigPtr->TriggerInputSelection /* ESAR:EPASS_MMIO:SAR_TR_IN_SEL */
    );
    
  } /* End of HW unit loop */

  /* Initialize groups each HW unit. */
  Adc_InitHw_Group(ConfigPtr);
}

/** \brief Adc_InitResultBuffer
 **
 ** Initializes the group to run with the given result buffer. The stream is also
 ** reset to the beginning.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'BufferPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [in] BufferPtr       Pointer to the result buffer.
 **
 */
FUNC(void, ADC_CODE) Adc_InitResultBuffer
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  BufferPtr
)
{
  P2VAR(Adc_StreamInfoType, AUTOMATIC, ADC_APPL_DATA) streamInfoPtr;

  /* Get the stream info. */
  streamInfoPtr = GroupConfigPtr->StreamInfoPtr;

  /* Set the buffer in the stream info to the given buffer. */
  /* Reset stream index values.                             */
  streamInfoPtr->BufferBasePtr     = BufferPtr;
  streamInfoPtr->LastPushedIndex   = -1;
  streamInfoPtr->ValidElementCount = 0U;
}

/** \brief Adc_IsAllTriggerEnabled
 **
 ** Returns that whether there is any group is on running.
 **
 ** \return  TRUE : At least one channel group is on-going.
 **          FALSE: All of channel groups are not on-going.
 **
 */
FUNC(boolean, ADC_CODE) Adc_IsAllTriggerEnabled(void)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) curGroupConfigPtr;
  uint8          curGroupId;
  Adc_StatusType curGroupStatus;
  boolean        result = FALSE;
  uint8          groupNumber;
  
  /* Get the number of configured groups. */
  groupNumber = Adc_GetGroupCount();

  /* Determine if any group is not in state ADC_IDLE or ADC_STREAM_COMPLETED. */
  for (curGroupId = 0U; curGroupId < groupNumber; curGroupId++)
  {
    curGroupConfigPtr = Adc_GetGroupConfigInternal(curGroupId);

    /* Get the status of the current group. */
    curGroupStatus = Adc_GetGroupStatusInternal(curGroupConfigPtr);

    /* Check groups are either in ADC_IDLE or ADC_STREAM_COMPLETED. */
    if (curGroupStatus != ADC_IDLE)
    {
      /* In case of ADC_STREAM_COMPLETED, check ADC groups which are implicitly stopped. */
      if ((curGroupStatus == ADC_STREAM_COMPLETED) &&
          (((curGroupConfigPtr->TriggerSource == ADC_TRIGG_SRC_SW) &&
             (curGroupConfigPtr->GroupConvMode == ADC_CONV_MODE_ONESHOT)) ||
            ((curGroupConfigPtr->GroupAccessMode  == ADC_ACCESS_MODE_STREAMING) &&
             (curGroupConfigPtr->StreamBufferMode == ADC_STREAM_BUFFER_LINEAR))))
      {
        /* Not action */
      }
      else
      {
        /* In case of not stopped */
        result = TRUE;
        break;
      }
    }
  }

  return result;
}

/** \brief Adc_IsrGroupConversionFinished
 **
 ** Internal function called by ISRs to handle the finished group conversions
 ** or the finished DMA transfer of conversion data or DMA error.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
FUNC(void, ADC_CODE) Adc_IsrGroupConversionFinished
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curLastChannelConfigPtr;
  uint8  interruptCase;

  /* Get the channel config of the last channel. */
  curLastChannelConfigPtr
    = Adc_GetChannelConfig(GroupConfigPtr->LastLogicalChannelConfigIndex);

  /* Enter critical section. */
  Adc_EnterCriticalSection();

  /* Check the interrupt cause for the given group. */
  interruptCase = Adc_IsInterruptPending(GroupConfigPtr, curLastChannelConfigPtr);

  /* Clear interrupt cause */
  Adc_ClearInterrupt(GroupConfigPtr, curLastChannelConfigPtr);

  /* Check if the interrupt occurred. */
  if (interruptCase != ADC_INT_NO)
  {
    /* In case of error or ADC complete */
    if (interruptCase == ADC_INT_DONE)
    {
      /* In case of ADC complete (and DMA transfer success) */
      /* Push the converted values into the stream. */
      Adc_PushStreamForIsr(GroupConfigPtr);

      /* Continue the group conversion again or stop it according to group setting. */
      Adc_ReactionAfterGroupConversionDone(GroupConfigPtr);
    }
    else
    {
      /* In case of error (only using DMA) */
      /* Disable ADC channel group.        */
      Adc_SetChannelEnable(GroupConfigPtr, FALSE);

      /* Set ADC_ERROR to Group Status. */
      *(GroupConfigPtr->GroupStatusPtr) = ADC_ERROR;
    }

    /* Exit critical section. */
    Adc_ExitCriticalSection();

    /* Invoke the notification callback if configured. */
    if (((*(GroupConfigPtr->NotificationEnableSettingPtr)) == TRUE) &&
        (GroupConfigPtr->NotificationPtr != NULL_PTR))
    {
      (GroupConfigPtr->NotificationPtr)();
    }
  }
  else
  {
    /* Exit critical section. */
    Adc_ExitCriticalSection();
  }
}

/** \brief Adc_ReadGroupInternal
 **
 ** Reads the result registers or the result buffer, returns the values
 ** and performs the required state transition.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [in] GroupStatus     Current status for the specified ADC channel group.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 **
 */
FUNC(void, ADC_CODE) Adc_ReadGroupInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST)  GroupConfigPtr,
  VAR(Adc_StatusType, AUTOMATIC)                           GroupStatus,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)   ResultPtr
)
{
  if (GroupConfigPtr->InterruptMode == TRUE)
  {
    /* In case of Interrupt mode               */
    /* Read the result from the result buffer. */
    Adc_ReadGroupFromResultBuffer(GroupConfigPtr, ResultPtr);
  }
  else
  {
    /* In case of Polling mode */
    if (GroupConfigPtr->UseDma == TRUE)
    {
      /* In case of using DMA                    */
      /* Read the result from the result buffer. */
      Adc_ReadGroupFromResultBuffer(GroupConfigPtr, ResultPtr);

      /* Clear the interrupt flag for the Dma channel. */
      Adc_ClearChannelInterruptDmaByBaseAddr(GroupConfigPtr->DmaChannelConfigPtr->RegisterBase);
    }
    else
    {
      /* In case of not using DMA           */
      /* Read the result from the resister. */
      Adc_ReadGroupFromRegister(GroupConfigPtr, ResultPtr, 1U);
    }
  }

  /* Check triggers and reset stream if necessary */
  Adc_CheckTriggersAndResetStream(GroupConfigPtr, GroupStatus);
}

/** \brief Adc_SetGroupNotification
 **
 ** Enables/disables the group notification. 
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr  The configuration pointer of the group that is affected by
 **                              the operation.
 ** \param [in] EnableSetting   TRUE : Enable notification.
 **                             FALSE: Disable notification.
 **
 */
FUNC(void, ADC_CODE) Adc_SetGroupNotification
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(boolean, AUTOMATIC) EnableSetting
)
{
  /* Remember the enable setting. */
  (*(GroupConfigPtr->NotificationEnableSettingPtr)) = EnableSetting;
}

/** \brief Adc_IsSwTriggerEnabled
 **
 ** Checks whether the request for starting the channel group conversion
 ** can be accepted.
 ** TRUE is returned if it is accepted. Otherwise FALSE is returned.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                      TRUE : The request is accepted.
 **                              FALSE: The request is NOT accepted.
 **
 ** \param [in] GroupConfigPtr   The configuration pointer of the group that is affected by the operation.
 **
 */
FUNC(boolean, ADC_CODE) Adc_IsSwTriggerEnabled
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  Adc_StatusType groupStatus;
  boolean result = FALSE;

  /* Get current status. */
  groupStatus = Adc_GetGroupStatusInternal(GroupConfigPtr);

  /* Check whether the SW trigger is enabled. */
  if (groupStatus == ADC_IDLE)
  {
    result = TRUE;
  }
  else if (groupStatus == ADC_STREAM_COMPLETED)
  {
    if ((GroupConfigPtr->GroupConvMode == ADC_CONV_MODE_ONESHOT) ||
        ((GroupConfigPtr->GroupAccessMode == ADC_ACCESS_MODE_STREAMING) &&
         (GroupConfigPtr->StreamBufferMode == ADC_STREAM_BUFFER_LINEAR)))
    {
      if (GroupConfigPtr->InterruptMode == FALSE)
      {
        /* In case of Polling mode    */
        /* Disable the channel group. */
        Adc_SetChannelEnable(GroupConfigPtr, FALSE);
        
        /* Clear the interrupt flag for the channel group. */
        Adc_ClearChannelInterrupt(GroupConfigPtr->LastLogicalChannelConfigIndex);
      }
      result = TRUE;
    }
  }
  else
  {
    /* No action here */
  }
  return result;
}

/** \brief Adc_IsHwTriggerEnabled
 **
 ** Checks whether the request for enabling HW trigger in the channel group
 ** can be accepted.
 ** TRUE is returned if it is accepted. Otherwise FALSE is returned.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                      TRUE : The request is accepted.
 **                              FALSE: The request is NOT accepted.
 **
 ** \param [in] GroupConfigPtr   The configuration pointer of the group that is affected by the operation.
 **
 */
FUNC(boolean, ADC_CODE) Adc_IsHwTriggerEnabled
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  Adc_StatusType groupStatus;
  boolean result;

  /* Get current status. */
  groupStatus = Adc_GetGroupStatusInternal(GroupConfigPtr);

  /* Check whether the HW trigger is enabled. */
  if (groupStatus == ADC_IDLE)
  {
    result = TRUE;
  }
  else
  {
    result = FALSE;
  }
  return result;
}

/** \brief Adc_SetChannelEnable
 **
 ** This function is intended to enable/disable ADC channels and start/stop DMA for the group if used DMA.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 ** \param [in] EnableSetting    Represent that the channel is enabled or disabled.
 **
 */
FUNC(void, ADC_CODE) Adc_SetChannelEnable
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(boolean, AUTOMATIC) EnabledSetting
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) firstChannelConfigPtr;
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) lastChannelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) firstEsarChStructRegPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) lastEsarChStructRegPtr;
  volatile P2VAR(Adc_DwChStructType,   AUTOMATIC, REGSPACE) dmaChStructRegPtr;

  /* Get the channel config of the first channel. */
  firstChannelConfigPtr
    = Adc_GetChannelConfig(GroupConfigPtr->FirstLogicalChannelConfigIndex);

  /* Get the channel config of the last channel. */
  lastChannelConfigPtr
    = Adc_GetChannelConfig(GroupConfigPtr->LastLogicalChannelConfigIndex);

  /* Get a pointer to ESAR:CH_STRUCT registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  firstEsarChStructRegPtr
    = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))
        firstChannelConfigPtr->RegisterBase;

  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  lastEsarChStructRegPtr
    = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))
        lastChannelConfigPtr->RegisterBase;

  /* Check whether EnabledSetting is 'true'? */
  if (EnabledSetting == TRUE)
  {
    /* Check whether DMA is used. */
    if (GroupConfigPtr->UseDma == FALSE)
    {
      /* Check whether interrupt is enabled. */
      if (GroupConfigPtr->InterruptMode == TRUE)
      {
        /* Enable interrupt for the specified ADC channel. */
        Adc_SetIntrMaskRegister(lastEsarChStructRegPtr,
                                GroupConfigPtr->InterruptMaskValue);
      }
    }
    else
    {
      /* Enable DMA. */
      Adc_StartDmaInternal(GroupConfigPtr);

      /* Check whether generic output trigger is used. */
      if (GroupConfigPtr->DmaChannelConfigPtr->SarTrOutNum != ADC_INVALID_SEL)
      {
        /* Set Generic output trigger. */
        Adc_SetupSarTrOutSel(
          GroupConfigPtr->HwUnitConfigPtr->HwUnitId,
          GroupConfigPtr->DmaChannelConfigPtr->SarTrOutNum,
          (uint8)(lastChannelConfigPtr->LogicalChannelId + ADC_OUTSEL_START_OF_RANGVIO));
      }

      /* Check whether interrupt is enabled. */
      if (GroupConfigPtr->InterruptMode == TRUE)
      {
        /* Get a pointer to DMA channel registers. */
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
           Justification: The hardware address is provided as integral type by configuration. 
                          However, the hardware access must be handled by using pointer. */
        /* PRQA S 303 2 */
        dmaChStructRegPtr = 
          (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))
            GroupConfigPtr->DmaChannelConfigPtr->RegisterBase;

        /* Enable interrupt for the specified DMA channel. */
        Adc_DmaSetChannelInterruptMask(dmaChStructRegPtr, EnabledSetting);
      }
    }

    /* Enable all channels in the group. */
    Adc_EnableGroupChannelsRegister(firstEsarChStructRegPtr,
                                    lastEsarChStructRegPtr,
                                    EnabledSetting);
  }
  /* EnabledSetting is 'false'? */
  else
  {
    /* Disable all channels in the group. */
    Adc_EnableGroupChannelsRegister(firstEsarChStructRegPtr,
                                    lastEsarChStructRegPtr,
                                    EnabledSetting);

    if (GroupConfigPtr->UseDma == FALSE)
    {
      /* Check whether interrupt is enabled. */
      if (GroupConfigPtr->InterruptMode == TRUE)
      {
        /* Disable interrupt for the specified ADC channel. */
        Adc_SetIntrMaskRegister(lastEsarChStructRegPtr, 0U);
      }
    }
    else
    {
      /* Get a pointer to DMA channel registers. */
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
         Justification: The hardware address is provided as integral type by configuration. 
                        However, the hardware access must be handled by using pointer. */
      /* PRQA S 303 2 */
      dmaChStructRegPtr = 
        (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))
          GroupConfigPtr->DmaChannelConfigPtr->RegisterBase;

      /* Disable DMA. */
      Adc_DmaStopChannelRegister(dmaChStructRegPtr);

      /* Check whether interrupt is enabled. */
      if (GroupConfigPtr->InterruptMode == TRUE)
      {
        /* Disable interrupt for the specified DMA channel. */
        Adc_DmaSetChannelInterruptMask(dmaChStructRegPtr, EnabledSetting);
      }
    }
  }
  /* Read back for DW */
  Adc_DmaRegisterReadCtl(GroupConfigPtr);
  /* Read back for ADC */
  Adc_AdcRegisterReadTrCtl(GroupConfigPtr);
}

/** \brief Adc_SetSwTrigger
 **
 ** Triggers the SW trigger group described by GroupConfigPtr.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
FUNC(void, ADC_CODE) Adc_SetSwTrigger
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) firstChannelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) firstEsarChStructRegPtr;

  /* Get the channel config of the first channel. */
  firstChannelConfigPtr
    = Adc_GetChannelConfig(GroupConfigPtr->FirstLogicalChannelConfigIndex);

  /* Get a pointer to ESAR:CH_STRUCT registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  firstEsarChStructRegPtr
    = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))firstChannelConfigPtr->RegisterBase;

  /* Set the trigger flag which actually triggers one conversion. */
  Adc_SetTriggerFlag(firstEsarChStructRegPtr);
}

/** \brief Adc_GetTargetPowerStateInternal
 **
 ** Gets the target power state.
 **
 ** \return Target power state.
 **
 */
FUNC(Adc_PowerStateType, ADC_CODE) Adc_GetTargetPowerStateInternal(void)
{
  /* Return the target power state. */
  return Adc_TargetPowerState;
}

/** \brief Adc_SetTargetPowerStateInternal
 **
 ** Sets the target power state.
 **
 ** PRECONDITIONS:
 **  - 'PowerState' must be a valid value.
 **
 ** \param [in] PowerState   Target power state.
 **
 */
FUNC(void, ADC_CODE) Adc_SetTargetPowerStateInternal
(
  VAR(Adc_PowerStateType, AUTOMATIC) PowerState
)
{
  /* Set the target power state. */
  Adc_TargetPowerState = PowerState;
}

/** \brief Adc_GetCurrentPowerStateInternal
 **
 ** Gets the current power state.
 **
 ** \return Current power state.
 **
 */
FUNC(Adc_PowerStateType, ADC_CODE) Adc_GetCurrentPowerStateInternal(void)
{
  Adc_PowerStateType currentPowerState;
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) adcConfigPtr = Adc_GetConfig();

  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr
    = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE))adcConfigPtr->HwUnitConfigPtr->RegisterBase;

  /* Check the status of power enable. */
  if (Adc_GetEnablePower(curEsarRegPtr) == TRUE)
  {
    currentPowerState = ADC_FULL_POWER;
  }
  else
  {
    currentPowerState = ADC_OFF_POWER;
  }

  return currentPowerState;
}

/** \brief Adc_SetCurrentPowerStateInternal
 **
 ** Sets the current power state.
 **
 */
FUNC(void, ADC_CODE) Adc_SetCurrentPowerStateInternal(void)
{
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) adcConfigPtr = Adc_GetConfig();
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr;
  uint8 hwUnitId;
  boolean enableFlag;

  /* Check the target power state. */
  if (Adc_TargetPowerState == ADC_FULL_POWER)
  {
    enableFlag = TRUE;
  }
  else
  {
    enableFlag = FALSE;
  }

  /* Iterate over all Hw units. */
  for (hwUnitId = 0U; hwUnitId < adcConfigPtr->HwUnitConfigsNumber; hwUnitId++)
  {
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    curEsarRegPtr
      = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE))adcConfigPtr->HwUnitConfigPtr[hwUnitId].RegisterBase;

    /* Set state of enable power. */
    Adc_SetEnablePower(
      curEsarRegPtr,
      &(adcConfigPtr->HwUnitConfigPtr[hwUnitId]),
      enableFlag
    );
  }
}

/** \brief Adc_ChangeSamplingTimeInternal
 **
 ** Changes sampling time for an ADC channel.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'PhysicalChannel' must be a valid channel.
 **  - 'SamplingTime' must be a valid setting value.
 **
 ** \return                     E_OK    : sampling time changed
 **                             E_NOT_OK: request rejected
 **
 ** \param [in] GroupConfigPtr  A pointer to config for a group.
 ** \param [in] PhysicalChannel An ADC physical channel that its sampling time is changed.
 ** \param [in] SamplingTime    Sampling time that it is set for the specified ADC channel.
 **
 */
FUNC(Std_ReturnType, ADC_CODE) Adc_ChangeSamplingTimeInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(Adc_ChannelType, AUTOMATIC) PhysicalChannel,
  VAR(Adc_SamplingTimeType, AUTOMATIC) SamplingTime
)
{
  uint16 curChannelConfigIndex; /* Loop variable for channel configs */
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;
  Std_ReturnType result = E_NOT_OK;

  /* Iterate over logical channels of the group. */
  for (curChannelConfigIndex = GroupConfigPtr->FirstLogicalChannelConfigIndex;
       curChannelConfigIndex <= GroupConfigPtr->LastLogicalChannelConfigIndex;
       curChannelConfigIndex++)
  {
    /* Get the channel config of the current channel. */
    curChannelConfigPtr = Adc_GetChannelConfig(curChannelConfigIndex);

    /* Check if it is equal to the specified channel. */
    if (curChannelConfigPtr->PhysicalChannelId == PhysicalChannel)
    {
      /* Get a pointer to ESAR:CH_STRUCT registers. */
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
         Justification: The hardware address is provided as integral type by configuration. 
                        However, the hardware access must be handled by using pointer. */
      /* PRQA S 303 2 */
      curEsarChStructRegPtr
        = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))curChannelConfigPtr->RegisterBase;

      /* Call an internal function. */
      Adc_ChangeSamplingTimeRegister(
        curEsarChStructRegPtr, /* EsarChStructRegPtr */
        SamplingTime
      );
      result = E_OK; /* Set result to success */
    }
  }
  return result;
}

/** \brief Adc_ClearChannelInterrupt
 **
 ** This function is used to clear the interrupt flag for the ADC channel
 ** which is specified by logical channel index.
 **
 ** \param [in] LogicalChannelConfigIndex    Index of logical channel config.
 **
 */
FUNC(void, ADC_CODE) Adc_ClearChannelInterrupt
(
  CONST(uint16, AUTOMATIC) LogicalChannelConfigIndex
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;

  /* Get the channel config of the specified channel. */
  curChannelConfigPtr
    = Adc_GetChannelConfig(LogicalChannelConfigIndex);

  /* Call an internal function to clear the interrupt flag. */
  Adc_ClearChannelInterruptByBaseAddr(curChannelConfigPtr->RegisterBase);
}

/** \brief Adc_ClearChannelInterruptByBaseAddr
 **
 ** This function is used to clear the interrupt flag for the ADC channel
 ** which is specified by register address directly.
 **
 ** \param [in] EsarChannelBaseAddr    Base address for the ESAR channel.
 **
 */
FUNC(void, ADC_CODE) Adc_ClearChannelInterruptByBaseAddr
(
  VAR(uint32, AUTOMATIC) EsarChannelBaseAddr
)
{
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;

  /* Get a pointer to ESAR channel registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  curEsarChStructRegPtr
    = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))EsarChannelBaseAddr;

  /* Clear the interrupt flag for the specified channel. */
  Adc_ClearChannelInterruptFlags(curEsarChStructRegPtr);
}

/** \brief Adc_ClearChannelInterruptDmaByBaseAddr
 **
 ** This function is used to clear the interrupt flag for the DMA channel
 ** which is specified by register address directly.
 **
 ** \param [in] DmaChannelBaseAddr    Base address for the DMA channel.
 **
 */
FUNC(void, ADC_CODE) Adc_ClearChannelInterruptDmaByBaseAddr
(
  VAR(uint32, AUTOMATIC) DmaChannelBaseAddr
)
{
  /* Clear the interrupt flag for the specified channel. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  Adc_DmaClearChannelInterruptFlags(
    (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))DmaChannelBaseAddr);
}

/** \brief Adc_InitDma
 **
 ** Initialize all DMA channels used to transfer ADC result data.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **
 ** \param [in] ConfigPtr   Pointer to ADC driver configuration.
 **
 */
FUNC(void, ADC_CODE) Adc_InitDma
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
)
{
  P2CONST(Adc_DmaConfigType, AUTOMATIC, ADC_APPL_CONST)   dmaConfigPtr;
  volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE) dmaChStructRegPtr;
  uint8    dmaHwIndex;  /* Loop variable for Dma hardware unit configs */
  uint8    dmaChIndex;  /* Loop variable for Dma channel configs       */

  /* Iterate over the used DMA hardware unit. */
  for (dmaHwIndex = 0U; dmaHwIndex < ConfigPtr->DmaHwUnitConfigsNumber; dmaHwIndex++)
  {
    /* Get the current configuration of the DMA HW unit. */
    dmaConfigPtr = &(ConfigPtr->DmaConfigPtr[dmaHwIndex]);

    /* Iterate over the used DMA channels in DMA hardware unit. */
    for (dmaChIndex = 0U; dmaChIndex < dmaConfigPtr->DmaChannelsNumber; dmaChIndex++)
    {
      /* Get a pointer to DMA channel registers. */
      /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
         Justification: The hardware address is provided as integral type by configuration. 
                        However, the hardware access must be handled by using pointer. */
      /* PRQA S 303 2 */
      dmaChStructRegPtr
        = (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))
            dmaConfigPtr->DmaChannelConfigPtr[dmaChIndex].RegisterBase;

      /* Initialize a DMA channel. */
      Adc_DmaInitChannelRegister(dmaChStructRegPtr);
    }
  }
}

/** \brief Adc_SetCalibrationValueInternal
 **
 ** Sets alternate calibration values.
 ** And if paramter "Update" is true, triggers updating regular calibration 
 ** values with alternate calibration values.
 **
 ** PRECONDITIONS:
 **  - 'HwUnitConfigPtr' must be a valid HwUnit config pointer.
 **
 ** \param [in] HwUnitConfigPtr  Config pointer of the HwUnit that shall be affected by the operation.
 ** \param [in] Offset           Offset correction setting value.
 ** \param [in] Gain             Gain correction setting value.
 ** \param [in] Update           Update regular calibration values or not.
 **
 */
FUNC(void, ADC_CODE) Adc_SetCalibrationValueInternal
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr,
  VAR(Adc_OffsetValueType, AUTOMATIC) Offset,
  VAR(Adc_GainValueType,   AUTOMATIC) Gain,
  VAR(boolean,             AUTOMATIC) Update
)
{
  /* Get a pointer to ESAR registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr
    = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE)) HwUnitConfigPtr->RegisterBase;

  /* Set analog alternate calibration register. */
  Adc_SetupAnalogCalibrationAlternateRegister(curEsarRegPtr, Offset, Gain);

  if (Update == TRUE)
  {
    /* Set calibration update command. */
    Adc_SetupCalibrationUpdateRegister(curEsarRegPtr, 1U);
  }
}

/** \brief Adc_GetCalibrationAlternateInternal
 **
 ** Gets alternate calibration values.
 **
 ** PRECONDITIONS:
 **  - 'HwUnitConfigPtr' must be a valid HwUnit config pointer.
 **
 ** \param [in]  HwUnitConfigPtr  Config pointer of the HwUnit that shall be affected by the operation.
 ** \param [out] OffsetPtr        Buffer pointer stored offset value of alternate calibration.
 ** \param [out] GainPtr          Buffer pointer stored gain value of alternate calibration.
 **
 */
FUNC(void, ADC_CODE) Adc_GetCalibrationAlternateInternal
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr,
  P2VAR(Adc_OffsetValueType,    AUTOMATIC, ADC_APPL_DATA)  OffsetPtr,
  P2VAR(Adc_GainValueType,      AUTOMATIC, ADC_APPL_DATA)  GainPtr
)
{
  /* Get a pointer to ESAR registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr
    = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE)) HwUnitConfigPtr->RegisterBase;

  /* Get alternate calibration value. */
  Adc_GetCalibrationAlternateRegister(curEsarRegPtr, OffsetPtr, GainPtr);
}

/** \brief Adc_GetCalibrationInternal
 **
 ** Gets regular calibration values.
 **
 ** PRECONDITIONS:
 **  - 'HwUnitConfigPtr' must be a valid HwUnit config pointer.
 **
 ** \param [in]  HwUnitConfigPtr  Config pointer of the HwUnit that shall be affected by the operation.
 ** \param [out] OffsetPtr        Buffer pointer stored offset value of regular calibration.
 ** \param [out] GainPtr          Buffer pointer stored gain value of regular calibration.
 **
 */
FUNC(void, ADC_CODE) Adc_GetCalibrationInternal
(
  P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_APPL_CONST) HwUnitConfigPtr,
  P2VAR(Adc_OffsetValueType,    AUTOMATIC, ADC_APPL_DATA)  OffsetPtr,
  P2VAR(Adc_GainValueType,      AUTOMATIC, ADC_APPL_DATA)  GainPtr
)
{
  /* Get a pointer to ESAR registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE) curEsarRegPtr
    = (volatile P2VAR(Adc_EsarType, AUTOMATIC, REGSPACE)) HwUnitConfigPtr->RegisterBase;

  /* Get regular calibration value. */
  Adc_GetCalibrationRegister(curEsarRegPtr, OffsetPtr, GainPtr);
}

/** \brief Adc_ChangeCalibrationChannelInternal
 **
 ** Changes all input signals of the group to the specified calibration measurement analog signal.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [in] Signal          Calibration measurement analog signal.
 **
 */
FUNC(void, ADC_CODE) Adc_ChangeCalibrationChannelInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(Adc_SignalType, AUTOMATIC) Signal
)
{
  uint16 curChannelConfigIndex; /* Loop variable for channel configs */
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;

  /* Iterate over logical channels of the group. */
  for (curChannelConfigIndex = GroupConfigPtr->FirstLogicalChannelConfigIndex;
       curChannelConfigIndex <= GroupConfigPtr->LastLogicalChannelConfigIndex;
       curChannelConfigIndex++)
  {
    /* Get the channel config of the current channel. */
    curChannelConfigPtr = Adc_GetChannelConfig(curChannelConfigIndex);

    /* Get a pointer to ESAR:CH_STRUCT registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    curEsarChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))curChannelConfigPtr->RegisterBase;

    /* Change sampling signal. */
    Adc_ChangeSamplingSignalRegister(curEsarChStructRegPtr, Signal);
  }
}

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[internal function definitions]=========================*/

#define ADC_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/** \brief Adc_PushStream
 **
 ** Reads out the current results from the result registers and appends them to the stream.
 ** But, if DMA is used, this function doesn't read out the RESULT registers.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(void, ADC_CODE) Adc_PushStream
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2VAR(Adc_StreamInfoType, AUTOMATIC, ADC_APPL_DATA) streamInfoPtr;
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) bufferPtr;

  /* Get the stream info of the group. */
  streamInfoPtr = GroupConfigPtr->StreamInfoPtr;

  /* Set the buffer pointer to the stream buffer. */
  bufferPtr = streamInfoPtr->BufferBasePtr;

  /* Increment number of samples which were pushed into the stream */
  streamInfoPtr->LastPushedIndex++;

  /* Reset to 0 if buffer limit is reached. */
  if (streamInfoPtr->LastPushedIndex >= ((sint32)(GroupConfigPtr->StreamNumSamples)))
  {
    streamInfoPtr->LastPushedIndex = 0;
  }

  /* Circular streaming buffer allows wrapping around stream borders, but
     the number of valid samples cannot exceed 'StreamNumSamples'. */
  if (streamInfoPtr->ValidElementCount < GroupConfigPtr->StreamNumSamples)
  {
    streamInfoPtr->ValidElementCount++;
  }

  if (GroupConfigPtr->UseDma == FALSE)
  {
    /* If DMA is disabled, copy to result buffer from register and */
    /* clear the interrupt flag for the ESAR channel.              */
    Adc_ReadGroupFromRegister(GroupConfigPtr,
                              &(bufferPtr[streamInfoPtr->LastPushedIndex]),
                              GroupConfigPtr->StreamNumSamples);
  }
  else
  {
    /* If DMA is enabled, clear the interrupt flag for the Dma channel. */
    Adc_ClearChannelInterruptDmaByBaseAddr(GroupConfigPtr->DmaChannelConfigPtr->RegisterBase);
  }
}

/** \brief Adc_PushStreamForIsr
 **
 ** Reads out the current results from the result registers and appends them to the stream.
 ** But, if DMA is used, this function doesn't read out the RESULT registers.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(void, ADC_CODE) Adc_PushStreamForIsr
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2VAR(Adc_StreamInfoType, AUTOMATIC, ADC_APPL_DATA) streamInfoPtr;
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) bufferPtr;

  /* Get the stream info of the group. */
  streamInfoPtr = GroupConfigPtr->StreamInfoPtr;

  /* Set the buffer pointer to the stream buffer. */
  bufferPtr = streamInfoPtr->BufferBasePtr;

  /* Increment number of samples which were pushed into the stream */
  streamInfoPtr->LastPushedIndex++;

  /* Reset to 0 if buffer limit is reached. */
  if (streamInfoPtr->LastPushedIndex >= ((sint32)(GroupConfigPtr->StreamNumSamples)))
  {
    streamInfoPtr->LastPushedIndex = 0;
  }

  /* Circular streaming buffer allows wrapping around stream borders, but
     the number of valid samples cannot exceed 'StreamNumSamples'. */
  if (streamInfoPtr->ValidElementCount < GroupConfigPtr->StreamNumSamples)
  {
    streamInfoPtr->ValidElementCount++;
  }

  if (GroupConfigPtr->UseDma == FALSE)
  {
    /* If DMA is disabled, copy to result buffer from register and */
    /* clear the interrupt flag for the ESAR channel.              */
    Adc_ReadGroupFromRegisterForIsr(GroupConfigPtr,
                              &(bufferPtr[streamInfoPtr->LastPushedIndex]),
                              GroupConfigPtr->StreamNumSamples);
  }
  else
  {
    /* Do Nothing */
  }
}

/** \brief Adc_GetStreamCurrentPointer
 **
 ** Returns the pointer to the current (newest) entry to the stream.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                      Current stream pointer.
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC_P2VAR(Adc_ValueGroupType, ADC_APPL_DATA, ADC_CODE) Adc_GetStreamCurrentPointer
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2VAR(Adc_StreamInfoType, AUTOMATIC, ADC_APPL_DATA) streamInfoPtr;
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) bufferPtr;
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) resultPtr;

  /* Get the stream info of the group. */
  streamInfoPtr = GroupConfigPtr->StreamInfoPtr;

  /* Set the buffer pointer to the stream buffer. */
  bufferPtr = streamInfoPtr->BufferBasePtr;

  resultPtr = &(bufferPtr[streamInfoPtr->LastPushedIndex]);

  return resultPtr;
}

/** \brief Adc_GetStreamValidSamples
 **
 ** Returns the number of valid samples of the stream of the given group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                      Number of valid samples of the given stream.
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(Adc_StreamNumSampleType, ADC_CODE) Adc_GetStreamValidSamples
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2VAR(Adc_StreamInfoType, AUTOMATIC, ADC_APPL_DATA) streamInfoPtr;
  Adc_StreamNumSampleType result;

  /* Get the stream info of the group. */
  streamInfoPtr = GroupConfigPtr->StreamInfoPtr;

  /* Return number of valid samples. */
  result = streamInfoPtr->ValidElementCount;

  return result;
}

/** \brief Adc_CheckTriggersAndResetStream
 **
 ** Checks if triggers have to be disabled or re-triggered (one-shot vs.
 ** continuous/streaming mode) and resets the stream indices depending on
 ** the group configuration (i.e. linear vs. circular streaming buffer).
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 ** 
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 ** \param [in] GroupStatus      Current status for the specified ADC channel group.
 **
 */
static FUNC(void, ADC_CODE) Adc_CheckTriggersAndResetStream
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  VAR(Adc_StatusType, AUTOMATIC) GroupStatus
)
{
  /* Get the stream info of the group. */
  P2VAR(Adc_StreamInfoType, AUTOMATIC, ADC_APPL_DATA) streamInfoPtr = GroupConfigPtr->StreamInfoPtr;

  /* This internal function is called when Adc_ReadGroup or Adc_GetStreamLastPointer is called.
     It is intended to perform activating next conversion round and/or disabling the channel group. 
     Valid element count and stream index are cleared accordingly.
     Please see the following table in detail. */
  /*====================================+==================+==========================*/
  /* Conditions                         | ADC_COMPLETED    | ADC_STREAM_COMPLETED     */
  /*====================================+==================+==========================*/
  /* SW, one-shot,  single              | n/a              | [disable channel]*1      */
  /*                                    |                  | LastPushedIndex = -1     */
  /*------------------------------------+------------------+--------------------------*/
  /* SW, continuous, single             | n/a              |                          */
  /*------------------------------------+------------------+--------------------------*/
  /* SW, continuous, streaming, linear  |                  | [LastPushedIndex = -1]*2 */
  /*------------------------------------+------------------+--------------------------*/
  /* SW, continuous, streaming, circular|                  |                          */
  /*------------------------------------+------------------+--------------------------*/
  /* HW, one-shot,  single              | n/a              |                          */
  /*------------------------------------+------------------+--------------------------*/
  /* HW, one-shot,  streaming, linear   |                  | [LastPushedIndex = -1]*2 */
  /*------------------------------------+------------------+--------------------------*/
  /* HW, one-shot,  streaming, circular |                  |                          */
  /*====================================+==================+==========================*/
  /* []*1 means this action is only performed when interrupt mode is NOT enabled.
     []*2 means this action is only performed when interrupt mode is enabled,
     and ValidElementCount is cleared anytime. */

  /* Reset valid element count value. */
  streamInfoPtr->ValidElementCount = 0U;

  /* In case of ADC_STREAM_COMPLETED */
  if (GroupStatus == ADC_STREAM_COMPLETED)
  {
    if ((GroupConfigPtr->TriggerSource == ADC_TRIGG_SRC_SW) &&
        (GroupConfigPtr->GroupConvMode == ADC_CONV_MODE_ONESHOT))
    {
      /* In case of polling mode */
      if (GroupConfigPtr->InterruptMode == FALSE)
      {
        /* Disable channel. */
        Adc_SetChannelEnable(GroupConfigPtr, FALSE);
      }
      /* Reset stream index values. */
      streamInfoPtr->LastPushedIndex = -1;

      /* Change status to idle. */
      *(GroupConfigPtr->GroupStatusPtr) = ADC_IDLE;
    }
    else if ((GroupConfigPtr->GroupAccessMode == ADC_ACCESS_MODE_STREAMING) &&
             (GroupConfigPtr->StreamBufferMode == ADC_STREAM_BUFFER_LINEAR))
    {
      /* In case of interrupt mode (polling is NOT used in linear streaming access mode) */
      /* Reset stream index values. */
      streamInfoPtr->LastPushedIndex = -1;

      /* Change status to idle. */
      *(GroupConfigPtr->GroupStatusPtr) = ADC_IDLE;
    }
    else
    {
      /* Change status to busy. */
      *(GroupConfigPtr->GroupStatusPtr) = ADC_BUSY;
    }
  } /* End of ADC_STREAM_COMPLETED */
  else if (GroupStatus == ADC_COMPLETED)
  {
      /* Change status to busy. */
      *(GroupConfigPtr->GroupStatusPtr) = ADC_BUSY;
  }
  else /* In case of ADC_BUSY or ADC_IDLE */
  {
    /* This code is never reached in case of ADC_BUSY or ADC_IDLE.
       Because Adc_ReadGroup and Adc_GetStreamLastPointer is never performed
       as long as status is not ADC_COMPLETED or ADC_STREAM_COMPLETED.
       Therefore nothing to do here. */
  }
}

/** \brief Adc_DeInitHw_Channel
 **
 ** De-initializes all channels as configured.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 ** 
 ** \param [in] GroupConfigPtr   Pointer to config for group.
 */
static FUNC(void, ADC_CODE) Adc_DeInitHw_Channel
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;
  uint16 curChannelConfigIndex;             /* Loop variable for channel configs */
  uint16 curFirstLogicalChannelConfigIndex; /* First logical channel config index of the current group */
  uint16 curLastLogicalChannelConfigIndex;  /* Last logical channel config index of the current group  */

  curFirstLogicalChannelConfigIndex =
    GroupConfigPtr->FirstLogicalChannelConfigIndex;
  curLastLogicalChannelConfigIndex =
    GroupConfigPtr->LastLogicalChannelConfigIndex;

  /* Iterate over all logical channels of the group. */
  for (curChannelConfigIndex = curFirstLogicalChannelConfigIndex;
       curChannelConfigIndex <= curLastLogicalChannelConfigIndex;
       curChannelConfigIndex++)
  {
    /* Get the config of current logical channel. */
    curChannelConfigPtr = Adc_GetChannelConfig(curChannelConfigIndex);

    /* Get a pointer to ESAR:CH_STRUCT registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    curEsarChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))curChannelConfigPtr->RegisterBase;

    /* Disable ADC channel. */
    Adc_EnableChannelRegister(curEsarChStructRegPtr, FALSE);

    /* Clear the interrupt flag. */
    Adc_ClearChannelInterruptFlags(curEsarChStructRegPtr);

    /* Configure the current channel. */
    Adc_SetupChannelTriggerRegister(
      curEsarChStructRegPtr, /* Pointer to registers (ESAR) */
      0U,                    /* TR_CTL:PRIO                 */
      0U,                    /* TR_CTL:SEL                  */
      0U,                    /* TR_CTL:PREEMPT_TYPE         */
      TRUE,                  /* TR_CTL:GROUP_END            */
      0U                     /* TR_CTL:DONE_LEVEL           */
    );

    /* Setup channel sample register. */
    Adc_SetupChannelSampleRegister(
      curEsarChStructRegPtr, /* Pointer to registers (ESAR)            */
      0U,                    /* SAMPLE_CTL:PIN_ADDR                    */
      0U,                    /* SAMPLE_CTL:PORT_ADDR                   */
      0U,                    /* SAMPLE_CTL:PRECOND_MODE & OVERLAP_DIAG */
      0U,                    /* SAMPLE_CTL:SAMPLE_TIME                 */
      FALSE                  /* SAMPLE_CTL:ALT_CAL                     */
    );

    /* Setup channel post register. */
    Adc_SetupChannelPostRegister(
      curEsarChStructRegPtr, /* Pointer to registers (ESAR) */
      0U                     /* Default value shall be 0 because initial value is undefined */
    );

    /* Setup channel range registers. */
    Adc_SetupChannelRangeRegister(
      curEsarChStructRegPtr, /* Pointer to registers (ESAR) */
      0U,                    /* RANGE_CTL:RANGE_HI          */
      0U                     /* RANGE_CTL:RANGE_LO          */
    );
  } /* End of channel loop */
}

/** \brief Adc_DeInitHw_Group
 **
 ** De-initializes all groups as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 ** 
 ** \param [in] ConfigPtr         Pointer to config for Adc module.
 **
 */
static FUNC(void, ADC_CODE) Adc_DeInitHw_Group
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) curGroupConfigPtr;
  uint8 curGroupId; /* Loop variable for groups (ID is equivalent to index) */

  /* Iterate over all groups. */
  for (curGroupId = 0U; curGroupId < (ConfigPtr->GroupConfigsNumber); curGroupId++)
  {
    curGroupConfigPtr = Adc_GetGroupConfigInternal(curGroupId);

    /* De-initialize channels of each group. */
    Adc_DeInitHw_Channel(curGroupConfigPtr);
  } /* End of group loop */
}

/** \brief Adc_GetStreamStatus
 **
 ** Returns the status of the stream.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                       Status of the stream: ADC_COMPLETED or ADC_STREAM_COMPLETED.
 **                               ADC_COMPLETED          : some results
 **                               ADC_STREAM_COMPLETED   : filled
 **
 ** \param [in] GroupConfigPtr    Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(Adc_StatusType, ADC_CODE) Adc_GetStreamStatus
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  Adc_StreamNumSampleType validSamples;
  Adc_StatusType          result;

  /* Get the number of valid samples. */
  validSamples = Adc_GetStreamValidSamples(GroupConfigPtr);

  /* Determine the stream status by checking the number of valid samples. */
  if (validSamples >= GroupConfigPtr->StreamNumSamples)
  {
    result = ADC_STREAM_COMPLETED;
  }
  else
  {
    result = ADC_COMPLETED;
  }

  return result;
}

/** \brief Adc_InitHw_Channel
 **
 ** Initializes all channels as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] ConfigPtr        Pointer to configuration setting.
 ** \param [in] GroupConfigPtr   Pointer to config for group.
 */
static FUNC(void, ADC_CODE) Adc_InitHw_Channel
(
  P2CONST(Adc_ConfigType,      AUTOMATIC, ADC_APPL_CONST) ConfigPtr,
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;
  uint16 curChannelConfigIndex; /* Loop variable for channel configs */
  uint16 curFirstLogicalChannelConfigIndex; /* First logical channel config index of the current group */
  uint16 curLastLogicalChannelConfigIndex;  /* Last logical channel config index of the current group  */
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;
  Adc_GroupPriorityType curGroupHwPriority;
  uint8 curReplacementMode;
  uint8 curTriggerType;
  boolean curIsLastChannel;
  Adc_ChannelType curPinAddr;
  Adc_SarMuxType curPortAddr;

  curFirstLogicalChannelConfigIndex =
    GroupConfigPtr->FirstLogicalChannelConfigIndex;
  curLastLogicalChannelConfigIndex =
    GroupConfigPtr->LastLogicalChannelConfigIndex;

  curGroupHwPriority = GroupConfigPtr->GroupHwPriority;
  curReplacementMode = (uint8)GroupConfigPtr->GroupReplacement;
  curTriggerType     = (uint8)GroupConfigPtr->HwTriggerSource;

  /* Iterate over all logical channels of the group. */
  for (curChannelConfigIndex = curFirstLogicalChannelConfigIndex;
       curChannelConfigIndex <= curLastLogicalChannelConfigIndex;
       curChannelConfigIndex++)
  {
    curIsLastChannel = ((curChannelConfigIndex == curLastLogicalChannelConfigIndex) ? (TRUE) : (FALSE));
    curTriggerType   = ((curChannelConfigIndex == curFirstLogicalChannelConfigIndex) ? (curTriggerType) : (0U));

    /* Get the config of current ADC channel. */
    curChannelConfigPtr
      = &(ConfigPtr->ChannelConfigPtr[curChannelConfigIndex]);

    /* Get a pointer to ESAR:CH_STRUCT registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    curEsarChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))curChannelConfigPtr->RegisterBase;

    /* Configure the current channel. */
    Adc_SetupChannelTriggerRegister(
      curEsarChStructRegPtr, /* Pointer to registers (ESAR) */
      curGroupHwPriority,    /* TR_CTL:PRIO                 */
      curTriggerType,        /* TR_CTL:SEL                  */
      curReplacementMode,    /* TR_CTL:PREEMPT_TYPE         */
      curIsLastChannel,      /* TR_CTL:GROUP_END            */
      0U                     /* TR_CTL:DONE_LEVEL           */
    );

    /* Setup channel sample register. */
    curPinAddr = ADC_MASK_PHYSICAL_CHANNEL & curChannelConfigPtr->PhysicalChannelId;
    curPortAddr = (Adc_SarMuxType)(curChannelConfigPtr->PhysicalChannelId >> ADC_POS_PHYSICAL_PORT);
    Adc_SetupChannelSampleRegister(
      curEsarChStructRegPtr,                  /* Pointer to registers (ESAR) */
      curPinAddr,                             /* SAMPLE_CTL:PIN_ADDR         */
      curPortAddr,                            /* SAMPLE_CTL:PORT_ADDR        */
      GroupConfigPtr->SamplingMode,           /* SAMPLE_CTL:PRECOND_MODE & SAMPLE_CTL:OVERLAP_DIAG */
      curChannelConfigPtr->SamplingTime,      /* SAMPLE_CTL:SAMPLE_TIME      */
      GroupConfigPtr->UseAlternateCalibration /* SAMPLE_CTL:ALT_CAL          */
    );

    /* Setup channel post register. */
    Adc_SetupChannelPostRegister(
      curEsarChStructRegPtr,                  /* Pointer to registers (ESAR) */
      curChannelConfigPtr->PostCtrlSettingVal /* POST_CTL                    */
    );

    /* Setup channel range registers. */
    Adc_SetupChannelRangeRegister(
      curEsarChStructRegPtr,                              /* Pointer to registers (ESAR) */
      curChannelConfigPtr->RangeComparatorUpperThreshold, /* RANGE_CTL:RANGE_HI          */
      curChannelConfigPtr->RangeComparatorLowerThreshold  /* RANGE_CTL:RANGE_LO          */
    );

    /* Disable all ADC channels. */
    Adc_EnableChannelRegister(curEsarChStructRegPtr, FALSE);

    /* Disable interrupt for the specified ADC channel. */
    Adc_SetIntrMaskRegister(curEsarChStructRegPtr, 0U);
  } /* End of channel loop */

  /* Clear the interrupt flag for the last channel. */
  Adc_ClearChannelInterruptFlags(curEsarChStructRegPtr);
}

/** \brief Adc_InitHw_Group
 **
 ** Initializes all groups as configured.
 **
 ** PRECONDITIONS:
 **  - 'ConfigPtr' must be a valid config pointer.
 **
 ** \param [in] ConfigPtr   Pointer to config for Adc module.
 **
 */
static FUNC(void, ADC_CODE) Adc_InitHw_Group
(
  P2CONST(Adc_ConfigType, AUTOMATIC, ADC_APPL_CONST) ConfigPtr
)
{
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) curGroupConfigPtr;
  uint8 curGroupId; /* Loop variable for groups (ID is equivalent to index) */

  /* Iterate over all groups. */
  for (curGroupId = 0U; curGroupId < ConfigPtr->GroupConfigsNumber; curGroupId++)
  {
    curGroupConfigPtr = &(ConfigPtr->GroupConfigPtr[curGroupId]);

    /* Initialize channels of each group. */
    Adc_InitHw_Channel(ConfigPtr, curGroupConfigPtr);

    /* Initialize the stream info. */
    Adc_InitResultBuffer(curGroupConfigPtr, NULL_PTR);

    /* Clear the notification enable setting. */
    Adc_SetGroupNotification(curGroupConfigPtr, FALSE);

    /* Update group status to ADC_IDLE. */
    *(curGroupConfigPtr->GroupStatusPtr) = ADC_IDLE;
  } /* End of group loop */
}

/** \brief Adc_IsInterruptPending
 **
 ** Checks the interrupt cause for the given group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \return                        Returns the status of the interrupt flag.
 **                                ADC_INT_DONE    : Interrupt flag is set.
 **                                ADC_INT_NO      : Interrupt flag is not set.
 **                                ADC_INT_ERROR   : Interrupt flag is set of error.
 **
 ** \param [in] GroupConfigPtr     Pointer to config for group.
 ** \param [in] ChannelConfigPtr   Pointer to config for channel.
 */
static FUNC(uint8, ADC_CODE) Adc_IsInterruptPending
(
  P2CONST(Adc_GroupConfigType,   AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) ChannelConfigPtr
)
{
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) adcChStructRegPtr;
  volatile P2VAR(Adc_DwChStructType,   AUTOMATIC, REGSPACE) dmaChStructRegPtr;
  uint32   statusFlags;
  uint8    result;

  if (GroupConfigPtr->UseDma == FALSE)
  {
    /* Get a pointer to ESAR:CH_STRUCT registers */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    adcChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))ChannelConfigPtr->RegisterBase;

    /* Get channel interrupt status flag. */
    statusFlags = Adc_GetConversionStatusFlags(adcChStructRegPtr);

    /* Check whether group done interrupt or range detect interrupt occurred or not. */
    result = ((statusFlags & GroupConfigPtr->InterruptMaskValue) != 0U) ? (ADC_INT_DONE) : (ADC_INT_NO);
  }
  else
  {
    /* Get a pointer to DMA channel registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    dmaChStructRegPtr
      = (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))GroupConfigPtr->DmaChannelConfigPtr->RegisterBase;

    /* Get DMA channel interrupt status flag. */
    statusFlags = Adc_DmaGetChannelStatusFlags(dmaChStructRegPtr);

    /* Check the DMA interrupt cause. */
    if (statusFlags == ADC_DW_INTRCASE_COMPLETION)
    {
      result = ADC_INT_DONE;
    }
    else if (statusFlags == ADC_DW_INTRCASE_NO_INTR)
    {
      result = ADC_INT_NO;
    }
    else
    {
      result = ADC_INT_ERROR;
    }
  }

  return result;
}

/** \brief Adc_ReactionAfterGroupConversionDone
 **
 ** Continues the group conversion again or stops it according to group setting. 
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in] GroupConfigPtr   Config pointer of the group that shall be affected by the operation.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReactionAfterGroupConversionDone
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  Adc_StatusType streamStatus;

  /*====================================+======================+======================*/
  /* Conditions                         | ADC_COMPLETED        | ADC_STREAM_COMPLETED */
  /*====================================+======================+======================*/
  /* SW, one-shot,  single              | n/a                  | disable channel      */
  /*------------------------------------+----------------------+----------------------*/
  /* SW, continuous, single             | n/a                  |                      */
  /*------------------------------------+----------------------+----------------------*/
  /* SW, continuous, streaming, linear  | Set SW trigger       | disable channel      */
  /*------------------------------------+----------------------+----------------------*/
  /* SW, continuous, streaming, circular| Set SW trigger       | Set SW trigger       */
  /*------------------------------------+----------------------+----------------------*/
  /* HW, one-shot,  single              | n/a                  |                      */
  /*------------------------------------+----------------------+----------------------*/
  /* HW, one-shot,  streaming, linear   |                      | disable channel      */
  /*------------------------------------+----------------------+----------------------*/
  /* HW, one-shot,  streaming, circular |                      |                      */
  /*====================================+======================+======================*/

  /* In case of streaming access mode */
  if (GroupConfigPtr->GroupAccessMode == ADC_ACCESS_MODE_STREAMING)
  {
    /* Get the stream status. */
    streamStatus = Adc_GetStreamStatus(GroupConfigPtr);

    if ((streamStatus == ADC_STREAM_COMPLETED) &&
        (GroupConfigPtr->StreamBufferMode == ADC_STREAM_BUFFER_LINEAR))
    {
      /* In linear streaming access mode, the channel group is set to 'continuous trigger'.
         Therefore the channel group needs to be disabled implicitly
         after last conversion round is finished. */
      Adc_SetChannelEnable(GroupConfigPtr, FALSE); /* Disable ADC channel group */
    }
    else if (GroupConfigPtr->HwTriggerSource == ADC_HWTRIGG_SRC_OFF)
    {
      /* Start the next group conversion. */
      Adc_SetSwTrigger(GroupConfigPtr);
    }
    else
    {
      /* Nothing to do here */
    }
  }
  /* In case of single access mode */
  else
  {
    streamStatus = ADC_STREAM_COMPLETED;

    if ((GroupConfigPtr->TriggerSource == ADC_TRIGG_SRC_SW) && 
        (GroupConfigPtr->GroupConvMode == ADC_CONV_MODE_ONESHOT))
    {
      /* In SW trigger source and one-shot conversion mode,
         the channel group needs to be disabled implicitly
         after the conversion round is finished. */
      Adc_SetChannelEnable(GroupConfigPtr, FALSE); /* Disable ADC channel group. */
    }
  }

  /* Update a channel group status as stream status. */
  *(GroupConfigPtr->GroupStatusPtr) = streamStatus;
}

/** \brief Adc_ReadGroupFromRegister
 **
 ** Reads the result registers and returns the values.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 ** \param [in] ChannelOffset   Offset between the channel results to be written into ResultPtr.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReadGroupFromRegister
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  ResultPtr,
  VAR(Adc_StreamNumSampleType, AUTOMATIC)                 ChannelOffset
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;
  uint16 curChannelConfigIndex;
  uint16 bufferPos;
  uint16 conversionValue;

  /* Iterate until all channels in the ADC channel group are finished. */
  for (curChannelConfigIndex = GroupConfigPtr->FirstLogicalChannelConfigIndex;
       curChannelConfigIndex <= GroupConfigPtr->LastLogicalChannelConfigIndex;
       curChannelConfigIndex++)
  {
    /* Get the channel config of the current channel. */
    curChannelConfigPtr
      = Adc_GetChannelConfig(curChannelConfigIndex);

    /* Get a pointer to ESAR:CH_STRUCT registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    curEsarChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))curChannelConfigPtr->RegisterBase;

    /* Get the conversion value (which clears the 'conversion done' flag). */
    conversionValue = Adc_GetConversionValue(curEsarChStructRegPtr);

    /* Write the conversion value into the result buffer. */
    bufferPos =
      ((curChannelConfigIndex - GroupConfigPtr->FirstLogicalChannelConfigIndex)
        * ChannelOffset);

    ResultPtr[bufferPos] = conversionValue;
  } /* End of for-loop */

  /* Clear the interrupt flag for the last channel. */
  Adc_ClearChannelInterruptFlags(curEsarChStructRegPtr);
}

/** \brief Adc_ReadGroupFromRegisterForIsr
 **
 ** Reads the result registers and returns the values.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 ** \param [in] ChannelOffset   Offset between the channel results to be written into ResultPtr.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReadGroupFromRegisterForIsr
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  ResultPtr,
  VAR(Adc_StreamNumSampleType, AUTOMATIC)                 ChannelOffset
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) curChannelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;
  uint16 curChannelConfigIndex;
  uint16 bufferPos;
  uint16 conversionValue;

  /* Iterate until all channels in the ADC channel group are finished. */
  for (curChannelConfigIndex = GroupConfigPtr->FirstLogicalChannelConfigIndex;
       curChannelConfigIndex <= GroupConfigPtr->LastLogicalChannelConfigIndex;
       curChannelConfigIndex++)
  {
    /* Get the channel config of the current channel. */
    curChannelConfigPtr
      = Adc_GetChannelConfig(curChannelConfigIndex);

    /* Get a pointer to ESAR:CH_STRUCT registers. */
    /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. 
                      However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    curEsarChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))curChannelConfigPtr->RegisterBase;

    /* Get the conversion value (which clears the 'conversion done' flag). */
    conversionValue = Adc_GetConversionValue(curEsarChStructRegPtr);

    /* Write the conversion value into the result buffer. */
    bufferPos =
      ((curChannelConfigIndex - GroupConfigPtr->FirstLogicalChannelConfigIndex)
        * ChannelOffset);

    ResultPtr[bufferPos] = conversionValue;
  } /* End of for-loop */
}

/** \brief Adc_ReadGroupFromResultBuffer
 **
 ** Reads the result buffer and returns the values.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **  - 'ResultPtr' must be a valid pointer.
 **
 ** \param [in] GroupConfigPtr  Config pointer of the group that shall be affected by the operation.
 ** \param [out] ResultPtr      Pointer to the result buffer.
 **
 */
static FUNC(void, ADC_CODE) Adc_ReadGroupFromResultBuffer
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2VAR(Adc_ValueGroupType,    AUTOMATIC, ADC_APPL_DATA)  ResultPtr
)
{
  P2VAR(Adc_ValueGroupType, AUTOMATIC, ADC_APPL_DATA) bufferPtr;
  uint16 ResultPos;
  uint16 bufferPos;

  if (GroupConfigPtr->InterruptMode == TRUE)
  {
    /* In case of Interrupt mode */
    /* Set the buffer pointer to the storing address of the stream buffer. */
    bufferPtr = &GroupConfigPtr->StreamInfoPtr->BufferBasePtr[GroupConfigPtr->StreamInfoPtr->LastPushedIndex];
  }
  else
  {
    /* In case of Polling mode (I.e. only single access mode and using DMA)  */
    /* Set the buffer pointer to the first address of the stream buffer.     */
    bufferPtr = GroupConfigPtr->StreamInfoPtr->BufferBasePtr;
  }

  /* Iterate over all channels of the group. */
  for (ResultPos = 0U; ResultPos < GroupConfigPtr->NumberOfChannels; ResultPos++)
  {
    /* Update the result buffer position. */
    bufferPos = ResultPos * GroupConfigPtr->StreamNumSamples;

    ResultPtr[ResultPos] = bufferPtr[bufferPos];
  } /* End of for-loop */
}

/** \brief Adc_StartDmaInternal
 **
 ** Start a DMA channel.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 **
 ** \param [in]  GroupConfigPtr  Pointer to configuration for a group.
 **
 */
static FUNC(void, ADC_CODE) Adc_StartDmaInternal
(
  P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr
)
{
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) channelConfigPtr;
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) adcChStructRegPtr;
  volatile P2VAR(Adc_DwChStructType,   AUTOMATIC, REGSPACE) dmaChStructRegPtr;

  /* Get channel configuration of first logical channel. */
  channelConfigPtr
    = Adc_GetChannelConfig(GroupConfigPtr->FirstLogicalChannelConfigIndex);

  /* Get a pointer to ESAR:CH_STRUCT registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  adcChStructRegPtr
    = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))
        channelConfigPtr->RegisterBase;

  /* Setup a DMA descriptor. */
  Adc_DmaSetupDescriptor(GroupConfigPtr, adcChStructRegPtr);

  /* Get a pointer to DMA channel registers. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. 
                    However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  dmaChStructRegPtr
    = (volatile P2VAR(Adc_DwChStructType, AUTOMATIC, REGSPACE))
        GroupConfigPtr->DmaChannelConfigPtr->RegisterBase;

  /* Start a DMA channel. */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
     Justification: It is necessary to set pointer address as integral type. */
  /* PRQA S 306 2 */
  Adc_DmaStartChannelRegister(dmaChStructRegPtr,
                              (uint32)GroupConfigPtr->DmaChannelConfigPtr->DescriptorBasePtr);
}

/** \brief Adc_ClearInterrupt
 **
 ** Clear the interrupt cause for the given group.
 **
 ** PRECONDITIONS:
 **  - 'GroupConfigPtr' must be a valid group config pointer.
 ** \param [in] GroupConfigPtr     Pointer to config for group.
 ** \param [in] ChannelConfigPtr   Pointer to config for channel.
 */
static FUNC(void, ADC_CODE) Adc_ClearInterrupt
(
  P2CONST(Adc_GroupConfigType,   AUTOMATIC, ADC_APPL_CONST) GroupConfigPtr,
  P2CONST(Adc_ChannelConfigType, AUTOMATIC, ADC_APPL_CONST) ChannelConfigPtr
)
{
  volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE) curEsarChStructRegPtr;

  if (GroupConfigPtr->UseDma == FALSE)
  {
    /* Get a pointer to ESAR:CH_STRUCT registers. */
    /* Deviation from MISRA-C:2004 Rule 11.4, MISRA-C:2012 Rule-11.4
       Justification: It is a necessary for HW access. */
    /* PRQA S 303 2 */
    curEsarChStructRegPtr
      = (volatile P2VAR(Adc_EsarChStructType, AUTOMATIC, REGSPACE))ChannelConfigPtr->RegisterBase;

    /* Clear the interrupt flag for the last channel. */
    Adc_ClearChannelInterruptFlags(curEsarChStructRegPtr);
  }
  else
  {
    /* If DMA is enabled, clear the interrupt flag for the Dma channel. */
    Adc_ClearChannelInterruptDmaByBaseAddr(GroupConfigPtr->DmaChannelConfigPtr->RegisterBase);
  }
}

#define ADC_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Adc_MemMap.h>

/*==================[end of file]===========================================*/
