/** \brief Pwm_RegisterAccess.c
 **
 ** This file contains register access function for the AUTOSAR Pwm driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */
 
/*==================[inclusions]=============================================*/

#include <Pwm_RegisterAccess.h>

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/
typedef struct Pwm_TcpwmRegType_Struct
{
  VAR(uint32, AUTOMATIC) Ctrl;                  /* 0x00: Counter control register                      */
  VAR(uint32, AUTOMATIC) Status;                /* 0x04: Counter status register                       */
  VAR(uint32, AUTOMATIC) Counter;               /* 0x08: Counter count register                        */
  VAR(uint32, AUTOMATIC) Reserved0;             /* 0x0C: Reserved                                      */
  VAR(uint32, AUTOMATIC) Cc0;                   /* 0x10: Counter compare/capture 0 register            */
  VAR(uint32, AUTOMATIC) Cc0_Buff;              /* 0x14: Counter buffered compare/capture 0 register   */
  VAR(uint32, AUTOMATIC) Cc1;                   /* 0x18: Counter compare/capture 1 register            */
  VAR(uint32, AUTOMATIC) Cc1_Buff;              /* 0x1C: Counter buffered compare/capture 1 register   */
  VAR(uint32, AUTOMATIC) Period;                /* 0x20: Counter period register                       */
  VAR(uint32, AUTOMATIC) Period_Buff;           /* 0x24: Counter buffered period register              */
  VAR(uint32, AUTOMATIC) Line_Sel;              /* 0x28: Counter line selection register               */
  VAR(uint32, AUTOMATIC) Line_Sel_Buff;         /* 0x2C: Counter buffered line selection register      */
  VAR(uint32, AUTOMATIC) Dt;                    /* 0x30: Counter PWM dead time register                */
  VAR(uint32, AUTOMATIC) Reserved1[3];          /* 0x34: Reserved                                      */
  VAR(uint32, AUTOMATIC) Tr_Cmd;                /* 0x40: Counter trigger command register              */
  VAR(uint32, AUTOMATIC) Tr_In_Sel0;            /* 0x44: Counter input trigger selection register 0    */
  VAR(uint32, AUTOMATIC) Tr_In_Sel1;            /* 0x48: Counter input trigger selection register 1    */
  VAR(uint32, AUTOMATIC) Tr_In_Edge_Sel;        /* 0x4C: Counter input trigger edge selection register */
  VAR(uint32, AUTOMATIC) Tr_Pwm_Ctrl;           /* 0x50: Counter trigger PWM control register          */
  VAR(uint32, AUTOMATIC) Tr_Out_Sel;            /* 0x54: Counter output trigger selection register     */
  VAR(uint32, AUTOMATIC) Reserved2[6];          /* 0x58: Reserved                                      */
  VAR(uint32, AUTOMATIC) Intr;                  /* 0x70: Interrupt request register                    */
  VAR(uint32, AUTOMATIC) Intr_Set;              /* 0x74: Interrupt set request register                */
  VAR(uint32, AUTOMATIC) Intr_Mask;             /* 0x78: Interrupt mask register                       */
  VAR(uint32, AUTOMATIC) Intr_Masked;           /* 0x7C: Interrupt masked request register             */
} Pwm_TcpwmRegType;

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/

/*==================[external constants]=====================================*/

/*==================[internal constants]=====================================*/

/*==================[external data]==========================================*/

/*==================[internal data]==========================================*/

/*==================[external function definitions]==========================*/

#define PWM_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/** \brief Pwm_RaInitChannel
 **
 ** Set all one-time settings for a channel.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaInitChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(uint32, AUTOMATIC) CtrlRegValue;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  
  /* Get value of CTRL.PWM_DISABLE_MODE */
  CtrlRegValue = (uint32)(PwmReg->Ctrl & PWM_TCPWM_CTRL_PWM_DISABLE_MODE);
  /* Init register ctrl: set pwm mode and disable counter */
  PwmReg->Ctrl = (uint32)(CtrlRegValue | PWM_TCPWM_CTRL_INIT_VALUE);

  /* Check if debug freeze enable */
  if (PWM_TRUE == ChannelPtr->DebugMode)
  {
    /* Debug enable */
    CtrlRegValue |= (uint32)(PWM_TCPWM_CTRL_INIT_VALUE | PWM_TCPWM_CTRL_DBG_FREEZE_EN);
  }
  else
  {
    /* Debug disable */
    CtrlRegValue |= PWM_TCPWM_CTRL_INIT_VALUE;
  }
  
  /* Enable pwm_stop_on_kill and pwm_sync_kill*/
  CtrlRegValue |= (uint32)(PWM_TCPWM_CTRL_PWM_STOP_ON_KILL | PWM_TCPWM_CTRL_PWM_SYNC_KILL);

  /* Init LINE_SEL */
  PwmReg->Line_Sel      = (uint32)( ((uint32)(ChannelPtr->PwmCompOutputAtInit) << PWM_TCPWM_LINE_SEL_BUFF_COMPL_OUT_SEL_P) | (uint32)(ChannelPtr->PwmOutputAtInit) );
  /* Set LineSelBuff */
  ChannelPtr->ChannelStatePtr->LineSelBuff = (uint32)( ((uint32)(ChannelPtr->PwmCompOutputAtInit) << PWM_TCPWM_LINE_SEL_BUFF_COMPL_OUT_SEL_P) | (uint32)(ChannelPtr->PwmOutputAtInit) );
  PwmReg->Line_Sel_Buff = ChannelPtr->ChannelStatePtr->LineSelBuff;
  
  /* Set prescaler value */
  PwmReg->Dt = (uint32)(ChannelPtr->DefaultPrescalerValue);

  /* Init COUNTER */
  PwmReg->Counter = PWM_TCPWM_COUNTER_INIT_VALUE;

  /* Init CC0 */
  PwmReg->Cc0 = PWM_TCPWM_CC0_INIT_VALUE;

  /* Init CC0_BUFF */
  PwmReg->Cc0_Buff = PWM_TCPWM_CC0_BUFF_INIT_VALUE;

  /* Init CC1 */
  PwmReg->Cc1 = PWM_TCPWM_CC1_INIT_VALUE;

  /* Init CC1_BUFF */
  PwmReg->Cc1_Buff = PWM_TCPWM_CC1_BUFF_INIT_VALUE;

  /* Init PERIOD */
  PwmReg->Period = PWM_TCPWM_PERIOD_INIT_VALUE;

  /* Init PERIOD_BUFF */
  PwmReg->Period_Buff = PWM_TCPWM_PERIOD_BUFF_INIT_VALUE;

  /* Init TR_OUT_SEL */
  PwmReg->Tr_Out_Sel = PWM_TCPWM_TR_OUT_SEL_INIT_VALUE;

  /* Init TR_IN_SEL1 */
  PwmReg->Tr_In_Sel1 = PWM_TCPWM_TR_IN_SEL1_INIT_VALUE;

  /* Check if support stop group by hardware trigger */
  if (PWM_INVALID_TRIGGERVALUE != ChannelPtr->InputStopTrigger)
  {
    /* Set hardware stop trigger */
    PwmReg->Tr_In_Sel0 = (uint32)(PWM_TCPWM_TR_IN_SEL0_INIT_VALUE | 
                                  ((uint32)ChannelPtr->InputStopTrigger << PWM_TCPWM_TR_IN_SEL0_STOP_SEL_P));
    /* Generate a stop event when rising edge detect */
    PwmReg->Tr_In_Edge_Sel = (uint32)(PWM_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE & ~PWM_TCPWM_TR_IN_EDGE_SEL_STOP_EDGE);
  }
  else
  {
    /* Init TR_IN_SEL0 */
    PwmReg->Tr_In_Sel0 = PWM_TCPWM_TR_IN_SEL0_INIT_VALUE;
    /* Init TR_IN_EDGE_SEL */
    PwmReg->Tr_In_Edge_Sel = PWM_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE; 
  }

  /* Check if switch event trigger is configured for the channel. */
  if (PWM_INVALID_TRIGGERVALUE != ChannelPtr->SwitchEventTrigger)
  {
    /* Set Hardware switch event trigger. */
    PwmReg->Tr_In_Sel0 |= (uint32)ChannelPtr->SwitchEventTrigger;
    /* Generate a switch event when rising edge is detected. */
    PwmReg->Tr_In_Edge_Sel &= (uint32)(~PWM_TCPWM_TR_IN_EDGE_SEL_CAPTURE0_EDGE);    
  }

  /* Init INTR */
  PwmReg->Intr = PWM_TCPWM_INTR_INIT_VALUE;

  /* Init INTR_MASK */
  PwmReg->Intr_Mask = PWM_TCPWM_INTR_MASK_INIT_VALUE;

  /* Output offset is enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
  {
    /* Default: up/down mode is count up mode */
    /* Set line_out when cc0 match event generation */
    /* Clear line_out when overflow and cc1 match event generation */
    /* No change line_out when underflow event generation */
    PwmReg->Tr_Pwm_Ctrl = (ChannelPtr->ActiveOutput == PWM_HIGH) ? 
                          PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_WITH_OFFSET : PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_WITH_OFFSET_INVERT;
  }
  /* Output offset is disable */
  else
  {
    /* Left alignment */
    if (PWM_LEFT_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Default: up/down mode is count up mode */
      /* Set line_out when overflow event generation */
      /* No change line_out when underflow event generation */
      PwmReg->Tr_Pwm_Ctrl = (ChannelPtr->ActiveOutput == PWM_HIGH) ? 
                            PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_LEFTALIGN : PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_LEFTALIGN_INVERT;
    }
    /* Right alignment */
    else if (PWM_RIGHT_ALIGNED == ChannelPtr->OutAlignment)
    {
      /* Set COUNT_DOWN mode */
      CtrlRegValue |= (uint32)((uint32)PWM_COUNT_DOWN_MODE << PWM_TCPWM_CTRL_UP_DOWN_MODE_P);
      /* No change line_out when overflow event generation */
      /* Clear line_out when underflow event generation */
      /* Invert line_out when cc0 match event generation */
      PwmReg->Tr_Pwm_Ctrl = (ChannelPtr->ActiveOutput == PWM_HIGH) ? 
                            PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_RIGHTALIGN : PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_RIGHTALIGN_INVERT;
    }
    /* Center alignment */
    else
    {
      /* Set COUNT_UPDN1 mode */
      CtrlRegValue |= (uint32)((uint32)PWM_COUNT_UPDN1_MODE << PWM_TCPWM_CTRL_UP_DOWN_MODE_P);
      /* Enable cc0 match event generation when counting up and down */
      CtrlRegValue |= (uint32)(PWM_TCPWM_CTRL_CC0_MATCH_UP_EN | PWM_TCPWM_CTRL_CC0_MATCH_DOWN_EN);
      /* No change line_out when overflow event generation */
      /* Clear line_out when underflow event generation */
      /* Invert line_out when cc0 match event generation */
      PwmReg->Tr_Pwm_Ctrl = (ChannelPtr->ActiveOutput == PWM_HIGH) ?
                            PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_CENTERALIGN : PWM_TCPWM_TR_PWM_CTRL_INIT_VALUE_CENTERALIGN_INVERT;
    }
  }

  /* Enable auto reload line sel buff */
  if (PWM_TRUE == ChannelPtr->SetOutputEnable)
  {
    CtrlRegValue |= PWM_TCPWM_CTRL_AUTO_RELOAD_LINE_SEL;
  }
  /* Write CtrlRegValue to ctrl register */
  PwmReg->Ctrl = CtrlRegValue;
}

/** \brief Pwm_RaDeInitChannel
 **
 ** De-initialize channel timer: disable notification interrupt(s), 
 ** disable trigger, change channel output status to idle output and stop timer.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaDeInitChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  
  /* Idle state is high */
  if (PWM_HIGH == ChannelPtr->IdleState)
  {
    PwmReg->Ctrl = (uint32)(PWM_TCPWM_CTRL_RESET_VALUE | ((uint32)PWM_DISABLEMODE_HIGH << PWM_TCPWM_CTRL_PWM_DISABLE_MODE_P));
  }
  /* Idle state is low */
  else
  {
    PwmReg->Ctrl = (uint32)(PWM_TCPWM_CTRL_RESET_VALUE | ((uint32)PWM_DISABLEMODE_LOW << PWM_TCPWM_CTRL_PWM_DISABLE_MODE_P));
  }

  /* Init COUNTER */
  PwmReg->Counter = PWM_TCPWM_COUNTER_INIT_VALUE;

  /* Init CC0 */
  PwmReg->Cc0 = PWM_TCPWM_CC0_INIT_VALUE;

  /* Init CC0_BUFF */
  PwmReg->Cc0_Buff = PWM_TCPWM_CC0_BUFF_INIT_VALUE;

  /* Init CC1 */
  PwmReg->Cc1 = PWM_TCPWM_CC1_INIT_VALUE;

  /* Init CC1_BUFF */
  PwmReg->Cc1_Buff = PWM_TCPWM_CC1_BUFF_INIT_VALUE;

  /* Init PERIOD */
  PwmReg->Period = PWM_TCPWM_PERIOD_INIT_VALUE;

  /* Init PERIOD_BUFF */
  PwmReg->Period_Buff = PWM_TCPWM_PERIOD_BUFF_INIT_VALUE;

  /* Init TR_OUT_SEL */
  PwmReg->Tr_Out_Sel = PWM_TCPWM_TR_OUT_SEL_RESET_VALUE;

  /* Init TR_IN_SEL0 */
  PwmReg->Tr_In_Sel0 = PWM_TCPWM_TR_IN_SEL0_INIT_VALUE;

  /* Init TR_IN_SEL1 */
  PwmReg->Tr_In_Sel1 = PWM_TCPWM_TR_IN_SEL1_INIT_VALUE;

  /* Init TR_IN_EDGE_SEL */
  PwmReg->Tr_In_Edge_Sel = PWM_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE;
  
  /* Init DT */
  PwmReg->Dt = PWM_TCPWM_DT_INIT_VALUE;

  /* Init LINE_SEL */
  PwmReg->Line_Sel = PWM_TCPWM_LINE_SEL_INIT_VALUE;
  
  /* Init LINE_SEL_BUFF */
  PwmReg->Line_Sel_Buff = PWM_TCPWM_LINE_SEL_BUFF_INIT_VALUE;

  /* Init TR_PWM_CTRL */
  PwmReg->Tr_Pwm_Ctrl = PWM_TCPWM_TR_PWM_CTRL_RESET_VALUE;

  /* Init INTR */
  PwmReg->Intr = PWM_TCPWM_INTR_INIT_VALUE;

  /* Init INTR_MASK */
  PwmReg->Intr_Mask = PWM_TCPWM_INTR_MASK_INIT_VALUE;
}

/** \brief Pwm_RaInitDelayTimer
 **
 ** Set all one-time settings for a channel delay timer.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 */
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1.
   Justification: This function is called when PwmStartDelayTimer is effective. */
/* PRQA S 1503 1 */
FUNC(void, PWM_CODE) Pwm_RaInitDelayTimer
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg =
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->DelayConfigPtr->DelayBaseAddress);
  P2CONST(Pwm_DelayConfigType, AUTOMATIC, PWM_APPL_CONST) DelayPtr;
  VAR(uint32, AUTOMATIC) TrOutSelRegValue;

  /* Check if debug freeze enable */
  if (PWM_TRUE == ChannelPtr->DebugMode)
  {
    /* Write Debug enable to ctrl register */
    PwmReg->Ctrl = (uint32)(PWM_TCPWM_DELAY_CTRL_INIT_VALUE | PWM_TCPWM_CTRL_DBG_FREEZE_EN);
  }
  else
  {
    /* Write Debug disable to ctrl register */
    PwmReg->Ctrl = PWM_TCPWM_DELAY_CTRL_INIT_VALUE;
  }
  
  /* Set prescaler value */
  PwmReg->Dt = (uint32)(ChannelPtr->DefaultPrescalerValue);

  /* Init COUNTER */
  PwmReg->Counter = PWM_TCPWM_COUNTER_INIT_VALUE;

  /* Init PERIOD */
  PwmReg->Period = 0u;

  /* Get delay timer config pointer */
  DelayPtr = ChannelPtr->DelayConfigPtr;

  /* Output trigger 0 enable */
  if (PWM_TRIGGER_OUT0 == (DelayPtr->DelayTriggerOutputSelect & PWM_TRIGGER_OUT0))
  {
    /* Set tc event to generate the output trigger 0 */
    TrOutSelRegValue = (uint32)PWM_TRIGGEROUT_TC;
  }
  else
  {
    /* Output trigger 0 disabled */
    TrOutSelRegValue = (uint32)PWM_TRIGGEROUT_DISABLED;
  }

  /* Output trigger 1 enable */
  if (PWM_TRIGGER_OUT1 == (DelayPtr->DelayTriggerOutputSelect & PWM_TRIGGER_OUT1))
  {
    /* Set tc event to generate the output trigger 1 */
    TrOutSelRegValue |= (uint32)((uint32)PWM_TRIGGEROUT_TC << PWM_TCPWM_TR_OUT_SEL_OUT1_P);
  }
  else
  {
    /* Output trigger 1 disabled */
    TrOutSelRegValue |= (uint32)((uint32)PWM_TRIGGEROUT_DISABLED << PWM_TCPWM_TR_OUT_SEL_OUT1_P);
  }

  /* Init TR_OUT_SEL */
  PwmReg->Tr_Out_Sel = TrOutSelRegValue;

  /* Check if support stop group by hardware trigger */
  if (PWM_INVALID_TRIGGERVALUE != ChannelPtr->InputStopTrigger)
  {
    /* Set hardware stop trigger */
    PwmReg->Tr_In_Sel0 = (uint32)(PWM_TCPWM_TR_IN_SEL0_INIT_VALUE | 
                                  ((uint32)ChannelPtr->InputStopTrigger << PWM_TCPWM_TR_IN_SEL0_STOP_SEL_P));
    /* Generate a stop event when rising edge detect */
    PwmReg->Tr_In_Edge_Sel = (uint32)(PWM_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE & ~PWM_TCPWM_TR_IN_EDGE_SEL_STOP_EDGE);
  }
  else
  {
    /* Init TR_IN_SEL0 */
    PwmReg->Tr_In_Sel0 = PWM_TCPWM_TR_IN_SEL0_INIT_VALUE;
    /* Init TR_IN_EDGE_SEL */
    PwmReg->Tr_In_Edge_Sel = PWM_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE;
  }

  /* Init INTR */
  PwmReg->Intr = PWM_TCPWM_INTR_SET_INIT_VALUE;

  /* Init INTR_MASK */
  PwmReg->Intr_Mask = PWM_TCPWM_INTR_MASK_INIT_VALUE;
}

/** \brief Pwm_RaDeInitDelayTimer
 **
 ** De-initialize channel delay timer.
 **
 ** \param [in] DelayPtr      Pointer to the delay timer configuration.
 **
 */
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1.
   Justification: This function is called when PwmStartDelayTimer is effective. */
/* PRQA S 1503 1 */
FUNC(void, PWM_CODE) Pwm_RaDeInitDelayTimer
(
  P2CONST(Pwm_DelayConfigType, AUTOMATIC, PWM_APPL_CONST) DelayPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg =
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(DelayPtr->DelayBaseAddress);

  /* DeInit CTRL */
  PwmReg->Ctrl = PWM_TCPWM_DELAY_CTRL_RESET_VALUE;

  /* Init DT */
  PwmReg->Dt = PWM_TCPWM_DT_INIT_VALUE;

  /* Init COUNTER */
  PwmReg->Counter = PWM_TCPWM_COUNTER_INIT_VALUE;

  /* Init PERIOD */
  PwmReg->Period = PWM_TCPWM_PERIOD_INIT_VALUE;

  /* Init TR_OUT_SEL */
  PwmReg->Tr_Out_Sel = PWM_TCPWM_TR_OUT_SEL_RESET_VALUE ;

  /* Init TR_IN_SEL0 */
  PwmReg->Tr_In_Sel0 = PWM_TCPWM_TR_IN_SEL0_INIT_VALUE;

  /* Init TR_IN_EDGE_SEL */
  PwmReg->Tr_In_Edge_Sel = PWM_TCPWM_TR_IN_EDGE_SEL_INIT_VALUE;

  /* Init INTR */
  PwmReg->Intr = PWM_TCPWM_INTR_SET_INIT_VALUE;

  /* Init INTR_MASK */
  PwmReg->Intr_Mask = PWM_TCPWM_INTR_MASK_INIT_VALUE;
}

/** \brief Pwm_RaSetHwReloadTrigger
 **
 ** Set necessary register for hardware trigger channel reload start.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 ** \param [in] TriggerSel      Input trigger select.
 **
 ** Preconditions:
 ** - Counter Disabled.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaSetHwReloadTrigger
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC) TriggerSel
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);
  VAR(uint32, AUTOMATIC) TrInSel0RegVal = PwmReg->Tr_In_Sel0;

  /* TR_IN_SEL should be set when counter disabled */ 
  /* Set hardware start trigger */
  TrInSel0RegVal &= ~PWM_TCPWM_TR_IN_SEL0_RELOAD_SEL;
  TrInSel0RegVal |= (uint32)((uint32)TriggerSel << PWM_TCPWM_TR_IN_SEL0_RELOAD_SEL_P);

  /* Write to TR_IN_SEL register */
  PwmReg->Tr_In_Sel0 = TrInSel0RegVal;

  /* Generates an start event when rising edge detect */
  PwmReg->Tr_In_Edge_Sel &= ~PWM_TCPWM_TR_IN_EDGE_SEL_RELOAD_EDGE;
}

/** \brief Pwm_RaSetHwCapture0Trigger
 **
 ** Set necessary register for hardware trigger channel capture start.
 **
 ** \param [in] BaseAddress     Base address of the HW Timer register structure.
 ** \param [in] TriggerSel      Input trigger select.
 **
 ** Preconditions:
 ** - Counter Disabled.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaSetHwCapture0Trigger
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC) TriggerSel
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);
  VAR(uint32, AUTOMATIC) TrInSel0RegVal = PwmReg->Tr_In_Sel0;

  /* TR_IN_SEL should be set when counter disabled */ 
  /* Set hardware capture trigger */
  TrInSel0RegVal &= ~PWM_TCPWM_TR_IN_SEL0_CAPTURE0_SEL;
  TrInSel0RegVal |= (uint32)TriggerSel;

  /* Write to TR_IN_SEL register */
  PwmReg->Tr_In_Sel0 = TrInSel0RegVal;

  /* Generates an start event when rising edge detect */
  PwmReg->Tr_In_Edge_Sel &= ~PWM_TCPWM_TR_IN_EDGE_SEL_CAPTURE0_EDGE;
}

/** \brief Pwm_RaEnableChannel
 **
 ** Enable counter for a channel.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 ** \param [in] EnableFlag       Whether the channel shall be enabled 
 **                              (PWM_TRUE = Yes, PWM_FALSE = No).
 **
 */
FUNC(void, PWM_CODE) Pwm_RaEnableChannel
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(boolean, AUTOMATIC) EnableFlag
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  if (PWM_TRUE == EnableFlag)
  {
    /* Counter enable */
    PwmReg->Ctrl |= PWM_TCPWM_CTRL_ENABLED;
  }
  else
  {
    /* Counter disable */
    PwmReg->Ctrl &= ~PWM_TCPWM_CTRL_ENABLED;
  }
}

/** \brief Pwm_RaUpdateChannel
 **
 ** Updates necessary counter registers for a channel.
 **
 ** \param [in] ChannelPtr            Pointer to the channel configuration.
 ** \param [in] PeriodTickRegValue    Period in ticks to be set in register.
 ** \param [in] DutyTickRegValue      Duty in ticks to be set in register.
 ** \param [in] TriggerTickRegValue   Delay time for output trigger to be set in register.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaUpdateChannel
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC) PeriodTickRegValue,
  VAR(uint32, AUTOMATIC) DutyTickRegValue,
  VAR(uint32, AUTOMATIC) TriggerTickRegValue
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  
  /* Set period */
  PwmReg->Period = PeriodTickRegValue;
  /* Set cc0 */
  PwmReg->Cc0 = DutyTickRegValue;
  /* Set cc1 */
  PwmReg->Cc1 = TriggerTickRegValue;

  /* Read CTRL register (This read ensures that the write has been flushed to hardware) */
  (void)(PwmReg->Ctrl);
}

/** \brief Pwm_RaUpdateChannelBuff
 **
 ** Updates necessary counter buffer registers for a channel.
 **
 ** \param [in] ChannelPtr              Pointer to the channel configuration.
 ** \param [in] PeriodTickRegValue      Period in ticks to be set in register.
 ** \param [in] DutyTickRegValue        Duty in ticks to be set in register.
 ** \param [in] TriggerTickRegValue     Delay time for output trigger to be set in register.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaUpdateChannelBuff
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(uint32, AUTOMATIC) PeriodTickRegValue,
  VAR(uint32, AUTOMATIC) DutyTickRegValue,
  VAR(uint32, AUTOMATIC) TriggerTickRegValue
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Disable switch cc0 cc1 and period on terminal count event */
  PwmReg->Ctrl &= ~(PWM_TCPWM_CTRL_AUTO_RELOAD_CC0 |
                    PWM_TCPWM_CTRL_AUTO_RELOAD_CC1 |
                    PWM_TCPWM_CTRL_AUTO_RELOAD_PERIOD);

  /* Set period_buff */
  PwmReg->Period_Buff = PeriodTickRegValue;
  /* Set cc0_buff */
  PwmReg->Cc0_Buff = DutyTickRegValue;
  /* Set cc1_buff */
  PwmReg->Cc1_Buff = TriggerTickRegValue;
  /* Set LineSelBuff */
  PwmReg->Line_Sel_Buff = ChannelPtr->ChannelStatePtr->LineSelBuff;
  
  /* Enable switch cc0 cc1 and period on terminal count event */
  PwmReg->Ctrl |= (PWM_TCPWM_CTRL_AUTO_RELOAD_CC0 |
                   PWM_TCPWM_CTRL_AUTO_RELOAD_CC1 |
                   PWM_TCPWM_CTRL_AUTO_RELOAD_PERIOD);
}

/** \brief Pwm_RaGetInterruptPendingFlag
 **
 ** Get channel interrupt pending flag.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 ** \return  Return INTR_MASKED register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetInterruptPendingFlag
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Return INTR_MAKSED register value */
  return PwmReg->Intr_Masked;
}

/** \brief Pwm_RaClearInterruptFlag
 **
 ** Clears interrupt flag(s) of channel.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaClearInterruptFlag
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Clear interrupt flags */
  PwmReg->Intr = PWM_TCPWM_INTR;

  /* Read INTR register (This read ensures that the write has been flushed to hardware) */
  (void)(PwmReg->Intr);
}

/** \brief Pwm_RaSetPrescalerValue
 **
 ** Set necessary register to update prescaler value.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 ** Preconditions:
 ** - Counter Disabled.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaSetPrescalerValue
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  volatile P2VAR(Pwm_TcpwmRegType, AUTOMATIC, PWM_APPL_DATA) PwmDelayReg;
  P2CONST(Pwm_DelayConfigType, AUTOMATIC, PWM_APPL_CONST) DelayPtr;

  /* Set prescaler value */
  PwmReg->Dt = (uint32)(ChannelPtr->ChannelStatePtr->PrescalerRegisterValue);

  /* Get delay timer config pointer */
  DelayPtr = ChannelPtr->DelayConfigPtr;

  /* Check if delay timer is valid */
  if (NULL_PTR != DelayPtr)
  {
    /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
       Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
    /* PRQA S 303 2 */
    PwmDelayReg = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(DelayPtr->DelayBaseAddress);
    /* Disable counter */
    Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_FALSE);
    /* Set prescaler value */
    PwmDelayReg->Dt = (uint32)(ChannelPtr->ChannelStatePtr->PrescalerRegisterValue);
    /* Enable counter */
    Pwm_RaEnableChannel(DelayPtr->DelayBaseAddress, PWM_TRUE);
  }
}

/** \brief Pwm_RaSetStatusLineOut
 **
 ** Set channel output level.
 **
 ** Note: Applicable for channels holding Stepper Motor Control features.
 **
 ** \param [in] BaseAddress     Base address of the HW Timer register structure.
 ** \param [in] State           PWM output state.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaSetStatusLineOut
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(Pwm_OutputStateType, AUTOMATIC) State
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  if (PWM_HIGH == State)
  {
    /* Set line_out fix to high and line_compl_out fix to low */
    PwmReg->Line_Sel = (uint32)((uint32)PWM_LINE_SEL_H |
                               ((uint32)PWM_LINE_SEL_L << PWM_TCPWM_LINE_SEL_COMPL_OUT_SEL_P));
  }
  else
  {
    /* Set line_out fix to low and line_compl_out fix to high */
    PwmReg->Line_Sel = (uint32)((uint32)PWM_LINE_SEL_L |
                               ((uint32)PWM_LINE_SEL_H << PWM_TCPWM_LINE_SEL_COMPL_OUT_SEL_P));
  }
}

/** \brief Pwm_RaSetChannelOut
 **
 ** Set channel output level (Line_Sel).
 **
 ** Note: Applicable for channels holding Stepper Motor Control features.
 **
 ** \param [in] ChannelPtr         Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaSetChannelOut
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Set line_out and line_compl_out to LineState and LineCompState */
  PwmReg->Line_Sel = (uint32)ChannelPtr->ChannelStatePtr->LineSelBuff;
}

/** \brief Pwm_RaGetStatusLineOut
 **
 ** Get channel output level.
 **
 ** \param [in] BaseAddress    Base address of the HW Timer register structure.
 **
 ** \return  PWM_LOW:  channel output state is low.
 **          PWM_HIGH: channel output state is high.
 **
 ** Preconditions:
 ** - Counter Enabled.
 **
 */
FUNC(Pwm_OutputStateType, PWM_CODE) Pwm_RaGetStatusLineOut
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  VAR(Pwm_OutputStateType, AUTOMATIC) LineOutState;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Line output signal is high */
  if (PWM_TCPWM_STATUS_LINE_OUT == (PwmReg->Status & PWM_TCPWM_STATUS_LINE_OUT))
  {
    LineOutState = PWM_HIGH;
  }
  /* Line output signal is low */
  else
  {
    LineOutState = PWM_LOW;
  }

  /* return actual level of the PWM line output signal */
  return LineOutState;
}

/** \brief Pwm_RaChangeTrigger
 **
 ** Sets registers to enable/disable trigger.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] TriggerEnable   Enable/disable trigger.
 **                             PWM_TRUE: Enable trigger.
 **                             PWM_FALSE: Disable trigger.
 **
 ** Preconditions:
 ** - Counter Disabled.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaChangeTrigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) TriggerEnable
)
{
  VAR(uint32, AUTOMATIC) TrOutSelRegValue;
  VAR(uint32, AUTOMATIC) TriggerEvent;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  if (PWM_TRUE == TriggerEnable)
  {
    /* Output offset is enable */
    if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
    {
      /* Trigger synchronizes with duty */
      if (PWM_TRIGGER_SYNC_DUTY == ChannelPtr->TriggerFactor)
      {
        /* Generate trigger when cc0 match event occur */
        TriggerEvent = PWM_TRIGGEROUT_CC0_MATCH;
      }
      else
      {
        /* Generate trigger when overflow event occur */
        TriggerEvent = PWM_TRIGGEROUT_OVERFLOW;
      }
    }
    else
    {
      /* Generate trigger when cc1 match event occur */
      TriggerEvent = PWM_TRIGGEROUT_CC1_MATCH;
    }

    /* Output trigger 0 enable */
    if (PWM_TRIGGER_OUT0 == (ChannelPtr->TriggerOutputSelect & PWM_TRIGGER_OUT0))
    {
      /* Set trigger event to generate the output trigger 0 */
      TrOutSelRegValue = (uint32)TriggerEvent;
    }
    else
    {
      /* Output trigger 0 disabled */
      TrOutSelRegValue = (uint32)PWM_TRIGGEROUT_DISABLED;
    }

    /* Output trigger 1 enable */
    if (PWM_TRIGGER_OUT1 == (ChannelPtr->TriggerOutputSelect & PWM_TRIGGER_OUT1))
    {
      /* Set trigger event to generate the output trigger 1 */
      TrOutSelRegValue |= (uint32)((uint32)TriggerEvent << PWM_TCPWM_TR_OUT_SEL_OUT1_P);
    }
    else
    {
      /* Output trigger 1 disabled */
      TrOutSelRegValue |= (uint32)((uint32)PWM_TRIGGEROUT_DISABLED << PWM_TCPWM_TR_OUT_SEL_OUT1_P);
    }
  }
  else
  {
    /* Output trigger 0 and 1 disabled */
    TrOutSelRegValue = PWM_TCPWM_TR_OUT_SEL_INIT_VALUE;
  }

  /* Write to TR_OUT_SEL register */
  PwmReg->Tr_Out_Sel = TrOutSelRegValue;
}

/** \brief Pwm_RaDisableNotification
 **
 ** Sets registers to disable notification interrupt.
 **
 ** \param [in] BaseAddress    Base address of the HW Timer register structure.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaDisableNotification
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Disable all interrupt flags */
  PwmReg->Intr_Mask = PWM_TCPWM_INTR_MASK_INIT_VALUE;

  /* Read INTR_MASK register (This read ensures that the write has been flushed to hardware) */
  (void)(PwmReg->Intr_Mask);
}

/** \brief Pwm_RaEnableNotification
 **
 ** Sets registers to enable notification interrupt.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaEnableNotification
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(uint32, AUTOMATIC) DutyMatchInt;
  VAR(uint32, AUTOMATIC) PeriodMatchInt;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  VAR(uint32, AUTOMATIC) IntrMaskValue;

  /* Clear all interrupt flags */
  PwmReg->Intr = PWM_TCPWM_INTR;
  
  /* Read INTR register (This read ensures that the write has been flushed to hardware) */
  (void)(PwmReg->Intr);
  
  /* Output offset is enable */
  if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
  {
    DutyMatchInt = PWM_TCPWM_INTR_MASK_CC1_MATCH;
    PeriodMatchInt = PWM_TCPWM_INTR_MASK_CC0_MATCH;
  }
  /* Output offset is disable */
  else
  {
    DutyMatchInt = PWM_TCPWM_INTR_MASK_CC0_MATCH;
    PeriodMatchInt = PWM_TCPWM_INTR_MASK_TC;
  }
  
  /* Duty match interrupt enable setting */
  if ((PWM_END_OF_DUTY == ChannelPtr->ChannelStatePtr->NotifyReason) ||
      (PWM_END_OF_BOTH == ChannelPtr->ChannelStatePtr->NotifyReason))
  {
    IntrMaskValue = DutyMatchInt;
  }
  else
  {
    IntrMaskValue = PWM_TCPWM_INTR_MASK_INIT_VALUE;
  }

  /* Period match interrupt enable setting */
  if ((PWM_END_OF_PERIOD == ChannelPtr->ChannelStatePtr->NotifyReason) ||
      (PWM_END_OF_BOTH == ChannelPtr->ChannelStatePtr->NotifyReason))
  {
    IntrMaskValue |= PeriodMatchInt;
  }
  
  /* Write to INTR_MASK register */
  PwmReg->Intr_Mask = IntrMaskValue;
}

/** \brief Pwm_RaCheckChannelStatus_Interrupt
 **
 ** Check the interrupt setting.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 ** \return     PWM_TRUE: Software and hardware states are in sync.
 **             PWM_FALSE: Software and hardware states are inconsistent.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_Interrupt
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(uint32, AUTOMATIC) DutyMatchInt;
  VAR(uint32, AUTOMATIC) PeriodMatchInt;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  /* Get INTR_MASK register value */
  VAR(uint32, AUTOMATIC) IntrMaskValue = PwmReg->Intr_Mask;
  VAR(boolean, AUTOMATIC) InterruptStatus = PWM_TRUE;

  IntrMaskValue &= PWM_TCPWM_INTR_MASK;

  if ((PWM_DUTY_100_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle) &&
      (PWM_DUTY_0_PERCENTAGE != ChannelPtr->ChannelStatePtr->DutyCycle))
  {
    /* Output offset is enable */
    if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
    {
      DutyMatchInt = PWM_TCPWM_INTR_MASK_CC1_MATCH;
      PeriodMatchInt = PWM_TCPWM_INTR_MASK_CC0_MATCH;
    }
    /* Output offset is disable */
    else
    {
      DutyMatchInt = PWM_TCPWM_INTR_MASK_CC0_MATCH;
      PeriodMatchInt = PWM_TCPWM_INTR_MASK_TC;
    }

    /* PWM_END_OF_BOTH: check if cc0 match and terminal count interrupt enabled */
    if (PWM_END_OF_BOTH == ChannelPtr->ChannelStatePtr->NotifyReason)
    {
      if ((DutyMatchInt | PeriodMatchInt) != IntrMaskValue)
      {
        InterruptStatus = PWM_FALSE;
      }
    }
    /* PWM_END_OF_PERIOD: check if terminal count interrupt enabled */
    else if (PWM_END_OF_PERIOD == ChannelPtr->ChannelStatePtr->NotifyReason)
    {
      if (PeriodMatchInt != IntrMaskValue)
      {
        InterruptStatus = PWM_FALSE;
      }
    }
    /* PWM_END_OF_DUTY: check if cc0 match interrupt enabled */
    else if (PWM_END_OF_DUTY == ChannelPtr->ChannelStatePtr->NotifyReason)
    {
      if (DutyMatchInt != IntrMaskValue)
      {
        InterruptStatus = PWM_FALSE;
      }
    }
    /* PWM_NOTIFY_UNINIT: check if none interrupt enabled */
    else
    {
      if (0u != IntrMaskValue)
      {
        InterruptStatus = PWM_FALSE;
      }
    }
  }
  else
  {
    if (0u != IntrMaskValue)
    {
      InterruptStatus = PWM_FALSE;
    }
  }

  return InterruptStatus;
}

/** \brief Pwm_RaCheckChannelStatus_Enable
 **
 ** Check whether channel in enable state.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return    PWM_TRUE: The timer counter is enable.
 **            PWM_FALSE: The timer counter is disable.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_Enable
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  VAR(boolean, AUTOMATIC) EnabledStatus;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Check counter enable state */
  if (0u != (PwmReg->Ctrl & PWM_TCPWM_CTRL_ENABLED))
  {
    EnabledStatus = PWM_TRUE;
  }
  else
  {
    EnabledStatus = PWM_FALSE;
  }

  return EnabledStatus;
}

/** \brief Pwm_RaCheckChannelStatus_Running
 **
 ** Check whether channel is in running state.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return    PWM_TRUE: The timer counter is running.
 **            PWM_FALSE: The timer counter is not running.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_Running
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  VAR(boolean, AUTOMATIC) RunningStatus;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Check counter running state */
  if ((0u != (PwmReg->Status & PWM_TCPWM_STATUS_RUNNING)) ||
      (0u != (PwmReg->Tr_Cmd & PWM_TCPWM_TR_CMD_RELOAD)))
  {
    RunningStatus = PWM_TRUE;
  }
  else
  {
    RunningStatus = PWM_FALSE;
  }

  return RunningStatus;
}

/** \brief Pwm_RaCheckWaitingTrigger_Running
 **
 ** Check whether channel is in running state.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return    PWM_TRUE: The timer counter is running.
 **            PWM_FALSE: The timer counter is not running.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckWaitingTrigger_Running
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  VAR(boolean, AUTOMATIC) RunningStatus;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Check counter running state */
  if (0u != (PwmReg->Status & PWM_TCPWM_STATUS_RUNNING))
  {
    RunningStatus = PWM_TRUE;
  }
  else
  {
    RunningStatus = PWM_FALSE;
  }

  return RunningStatus;
}

/** \brief Pwm_RaCheckChannelStatus_Stop
 **
 ** Check whether channel is in stop state.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return    PWM_TRUE: The timer counter is stop.
 **            PWM_FALSE: The timer counter is running.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_Stop
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  VAR(boolean, AUTOMATIC) RunningStatus;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Check counter stop state */
  if (0u == (PwmReg->Status & PWM_TCPWM_STATUS_RUNNING))
  {
    RunningStatus = PWM_TRUE;
  }
  else
  {
    RunningStatus = PWM_FALSE;
  }

  return RunningStatus;
}

/** \brief Pwm_RaCheckChannelStatus_Trigger
 **
 **  Check channel trigger setting.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 ** \param [in] EnableFlag      Holds on trigger enable flag.
 **
 ** \return     PWM_TRUE: Software and hardware states are in sync.
 **             PWM_FALSE: Software and hardware states are inconsistent.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_Trigger
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr,
  VAR(boolean, AUTOMATIC) EnableFlag
)
{
  VAR(boolean, AUTOMATIC) TriggerStatus;
  VAR(uint32, AUTOMATIC) CheckValue;
  VAR(uint32, AUTOMATIC) TriggerEvent;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);
  
  /* Output trigger disable */
  if (PWM_FALSE == EnableFlag)
  {
    CheckValue = PWM_TCPWM_TR_OUT_SEL_INIT_VALUE;
  }
  else
  {
    /* Output offset is enable */
    if (PWM_TRUE == ChannelPtr->OutputOffsetEnable)
    {
      /* Trigger synchronizes with duty */
      if (PWM_TRIGGER_SYNC_DUTY == ChannelPtr->TriggerFactor)
      {
        TriggerEvent = PWM_TRIGGEROUT_CC0_MATCH;
      }
      else
      {
        TriggerEvent = PWM_TRIGGEROUT_OVERFLOW;
      }
    }
    else
    {
      TriggerEvent = PWM_TRIGGEROUT_CC1_MATCH;
    }
    
    /* Check if trigger out0 and out1 is select */
    if ((PWM_TRIGGER_OUT0 | PWM_TRIGGER_OUT1) == ChannelPtr->TriggerOutputSelect) 
    {
      CheckValue = (uint32)((uint32)TriggerEvent |
                            ((uint32)TriggerEvent << PWM_TCPWM_TR_OUT_SEL_OUT1_P));
    }
    /* Check if trigger out0 is select */
    else if (PWM_TRIGGER_OUT0 == ChannelPtr->TriggerOutputSelect)
    {
      CheckValue = (uint32)((uint32)TriggerEvent |
                            ((uint32)PWM_TRIGGEROUT_DISABLED << PWM_TCPWM_TR_OUT_SEL_OUT1_P));
    }
    /* Check if trigger out1 is select */
    else
    {
      CheckValue = (uint32)((uint32)PWM_TRIGGEROUT_DISABLED |
                            ((uint32)TriggerEvent << PWM_TCPWM_TR_OUT_SEL_OUT1_P));
    }
  }
  
  /* Check if register value equals to CheckValue */
  if ((PwmReg->Tr_Out_Sel & (PWM_TCPWM_TR_OUT_SEL_OUT0 | PWM_TCPWM_TR_OUT_SEL_OUT1)) != CheckValue)
  {
     TriggerStatus = PWM_FALSE;
  }
  else
  {
     TriggerStatus = PWM_TRUE;
  }

  return TriggerStatus;
}

/** \brief Pwm_RaCheckChannelStatus_WaitingUpdate
 **
 ** Check whether channel is in waiting update state.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 ** \return    PWM_TRUE: The timer counter is waiting update.
 **            PWM_FALSE: The timer counter is not waiting update.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_WaitingUpdate
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  VAR(boolean, AUTOMATIC) WaitingStatus;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  /* Check waiting update state */
  if ((ChannelPtr->TimerMax == PwmReg->Cc1) ||
      (0u != (PwmReg->Tr_Cmd & PWM_TCPWM_TR_CMD_CAPTURE0)))
  {
    WaitingStatus = PWM_TRUE;
  }
  else
  {
    WaitingStatus = PWM_FALSE;
  }

  return WaitingStatus;
}

/** \brief Pwm_RaCheckChannelStatus_LineSelIsPWM
 **
 ** Check whether channel line_sel is PWM state.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return    PWM_TRUE: The channel line_sel is PWM.
 **            PWM_FALSE: The channel line_sel is not PWM.
 */
FUNC(boolean, PWM_CODE) Pwm_RaCheckChannelStatus_LineSelIsPWM
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  VAR(boolean, AUTOMATIC) LineStatus;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  /* Check line_sel is PWM */
  if (PWM_LINE_SEL_PWM == PwmReg->Line_Sel)
  {
    LineStatus = PWM_TRUE;
  }
  else
  {
    LineStatus = PWM_FALSE;
  }

  return LineStatus;
}

/** \brief Pwm_RaGetPeriodBuff
 **
 ** Get period_buff register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns period_buff register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetPeriodBuff
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return PwmReg->Period_Buff;
}

/** \brief Pwm_RaGetCc1Buff
 **
 ** Get cc1_buff register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns cc1_buff register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetCc1Buff
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return PwmReg->Cc1_Buff;
}

/** \brief Pwm_RaGetCc0Buff
 **
 ** Get cc0_buff register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns cc0_buff register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetCc0Buff
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return PwmReg->Cc0_Buff;
}

/** \brief Pwm_RaGetPeriod
 **
 ** Get period register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns PERIOD register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetPeriod
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return PwmReg->Period;
}

/** \brief Pwm_RaGetCc1
 **
 **  Get cc1 register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns cc1 register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetCc1
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return PwmReg->Cc1;
}

/** \brief Pwm_RaGetCc0
 **
 ** Get cc0 register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns cc0 register value.
 */
FUNC(uint32, PWM_CODE) Pwm_RaGetCc0
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return PwmReg->Cc0;
}

/** \brief Pwm_RaGetPrescaler
 **
 **  Get prescaler register value.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 **
 ** \return Returns prescaler register value.
 */
FUNC(uint8, PWM_CODE) Pwm_RaGetPrescaler
(
  CONST(uint32, AUTOMATIC) BaseAddress
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);

  return (uint8)PwmReg->Dt;
}

/** \brief Pwm_RaUpdateCcMatchEvent
 **
 ** Enables / disables the compare match 1 event generation when 
 ** count up/down in CNT_UPDN1/2 mode.
 **
 ** Note: Applicable for channels holding Advanced Motor Control features.
 **
 ** \param [in] ChannelPtr      Pointer to the channel configuration.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaUpdateCcMatchEvent
(
  P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_APPL_CONST) ChannelPtr
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg
    = (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(ChannelPtr->BaseAddress);

  VAR(uint32, AUTOMATIC) CtrlRegValue = PwmReg->Ctrl;

  /* Enables compare match 1 event generation when counting up */
  if (PWM_TRUE == ChannelPtr->ChannelStatePtr->MatchUpEnable)
  {
    CtrlRegValue |= PWM_TCPWM_CTRL_CC1_MATCH_UP_EN;
  }
  /* Disables compare match 1 event generation when counting up  */
  else
  {
    CtrlRegValue &= ~PWM_TCPWM_CTRL_CC1_MATCH_UP_EN;
  }

  /* Enables compare match 1 event generation when counting down */
  if (PWM_TRUE == ChannelPtr->ChannelStatePtr->MatchDownEnable)
  {
    CtrlRegValue |= PWM_TCPWM_CTRL_CC1_MATCH_DOWN_EN;
  }
  /* Disables compare match 1 event generation when counting down  */
  else
  {
    CtrlRegValue &= ~PWM_TCPWM_CTRL_CC1_MATCH_DOWN_EN;
  }
  
  /* Write to CTRL register */
  PwmReg->Ctrl = CtrlRegValue;
}

/** \brief Pwm_RaEnableSwTrigger
 **
 ** Set register for enable software trigger event.
 **
 ** \param [in] BaseAddress      Base address of the HW Timer register structure.
 ** \param [in] TriggerFlag      Holds enabled software trigger event flags.
 **
 ** Preconditions:
 ** - Counter Enabled.
 */
FUNC(void, PWM_CODE) Pwm_RaEnableSwTrigger
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC) TriggerFlag
)
{
  VAR(uint32, AUTOMATIC) TrCmdRegValue;
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);
  
  /* Enable software start trigger */
  if (PWM_SW_START_TRIGGER == (TriggerFlag & PWM_SW_START_TRIGGER))
  {
    TrCmdRegValue = PWM_TCPWM_TR_CMD_START;
  }
  else
  {
    TrCmdRegValue = PWM_TCPWM_TR_CMD_INIT_VALUE;
  }

  /* Enable software reload trigger */
  if (PWM_SW_RELOAD_TRIGGER == (TriggerFlag & PWM_SW_RELOAD_TRIGGER))
  {
    TrCmdRegValue |= PWM_TCPWM_TR_CMD_RELOAD;
  }

  /* Enable software capture0 trigger */
  if (PWM_SW_CAPTURE0_TRIGGER == (TriggerFlag & PWM_SW_CAPTURE0_TRIGGER))
  {
    TrCmdRegValue |= PWM_TCPWM_TR_CMD_CAPTURE0;
  }

  /* Enable software capture1 trigger */
  if (PWM_SW_CAPTURE1_TRIGGER == (TriggerFlag & PWM_SW_CAPTURE1_TRIGGER))
  {
    TrCmdRegValue |= PWM_TCPWM_TR_CMD_CAPTURE1;
  }
  
  /* Enable software stop trigger */
  if (PWM_SW_STOP_TRIGGER == (TriggerFlag & PWM_SW_STOP_TRIGGER))
  {
    TrCmdRegValue |= PWM_TCPWM_TR_CMD_STOP;
  }

  /* Write to TR_CMD register */
  PwmReg->Tr_Cmd = TrCmdRegValue;
}

/** \brief Pwm_RaSetDisableMode
 **
 ** Set behavior of the PWM output state while the TCPWM counter is disabled or stopped.
 **
 ** \param [in] BaseAddress   Base address of the HW Timer register structure.
 ** \param [in] DisableMode   Channel disable mode.
 **
 */
FUNC(void, PWM_CODE) Pwm_RaSetDisableMode
(
  CONST(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC) DisableMode
)
{
  /* Deviation from MISRA-C:2004 rule 3.1 11.3, MISRA-C:2012 Rule-11.4
     Justification: The hardware address is provided as integral type by configuration. However, the hardware access must be handled by using pointer. */
  /* PRQA S 303 2 */
  volatile CONSTP2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE) PwmReg = 
      (volatile P2VAR(Pwm_TcpwmRegType, PWM_CONST, REGSPACE))(BaseAddress);
  VAR(uint32, AUTOMATIC) CtrlRegValue = PwmReg->Ctrl;
  
  /* Clear CTRL:PWM_DISABLE_MODE */
  CtrlRegValue &= ~PWM_TCPWM_CTRL_PWM_DISABLE_MODE;
  
  /* Set CTRL:PWM_DISABLE_MODE */
  CtrlRegValue |= (uint32)((uint32)DisableMode << PWM_TCPWM_CTRL_PWM_DISABLE_MODE_P);
  
  /* Write to CTRL register */
  PwmReg->Ctrl = CtrlRegValue;
}

#define PWM_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Pwm_MemMap.h>

/*==================[internal function definitions]==========================*/

/*==================[end of file]============================================*/
