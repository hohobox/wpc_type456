/** \brief AUTOSAR Port Port Driver
 **
 ** This file contains internal architecture function for the
 ** AUTOSAR Port driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Std_Types.h>           /* AUTOSAR standard types */
#include <Port_Internal_Arch.h>  /* interface types for Internal_Arch */
#include <Port_SchM.h>           /* interface types for critical section */
#include <Port_Regs.h>           /* interface types for Regs */

/*==================[macros]=================================================*/
/*==================[type definitions]=======================================*/
/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/
#define PORT_START_SEC_CODE_ASIL_B
#include <Port_MemMap.h>

/** \brief Port_Arch_CalcRegMaskValue() calculation of mask value
 ** for CFG/OUT Register
 **
 ** This function calculate the mask value of the bits of CFG/OUT register
 ** that need not be changed.
 **
 ** \param[in]  PinConfigDataPtr    pointer of data stored pin configuration information
 ** \param[in]  EnvDataPtr          pointer of data stored environment information
 ** \param[out] cfgNotChangeMask    pointer of data stored mask value of the bits of CFG register
 ** \param[out] outNotChangeMask    pointer of data stored mask value of the bits of OUT register
 ** */
static FUNC(void,PORT_CODE) Port_Arch_CalcRegMaskValue
(
  P2CONST(Port_PinChannelConfigType,AUTOMATIC,PORT_APPL_CONST)  PinConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)              EnvDataPtr,
  P2VAR(uint32, AUTOMATIC, PORT_APPL_DATA)                      cfgNotChangeMaskPtr,
  P2VAR(uint32, AUTOMATIC, PORT_APPL_DATA)                      outNotChangeMaskPtr
);

#define PORT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
/*==================[external function definitions]==========================*/
#define PORT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/** \brief Port_Arch_Init() initialization of port driver
 **
 ** This function initialize all ports.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** */
FUNC(void,PORT_CODE) Port_Arch_Init
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr
)
{
  P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST) channelCfgPtr;  /* ChannelConfigPointer */
  uint8  portNr;                 /* port number */
  uint8  cellNr;                 /* cell number */
  uint8  count;                  /* counter for loop */
  uint8  portCounter;            /* counter for port number */
  uint32 pinMask;                /* bit position of current port pin */
  uint32 cfgNotChangeMask;       /* bit mask for CFG register */
  uint32 outNotChangeMask;       /* bit mask for OUT register */
  uint32 out_value;              /* OUT Register value */
  uint32 out_write_value;        /* OUT Register write value */
  
  /* Enter critical section to provide atomic access to the port registers */
  Port_EnterCriticalSection();
  
  /* loop for all AMUX splitter cells */
  for ( count = 0U; count < ConfigDataPtr->numberOfAmuxSplitCtl; count++ )
  {
    /* Gets physical cell number */
    cellNr = ConfigDataPtr->configAmuxSplitCtlPtr[count].amuxSplitCtlNumber;
    /* Sets value to AMUX_SPLIT_CTL Register */
    Port_WriteAMUX_SPLIT_CTL(EnvDataPtr, cellNr, ConfigDataPtr->configAmuxSplitCtlPtr[count].AMUX_SPLIT_CTL_Data);
  }
  
  /* Exit critical section */
  Port_ExitCriticalSection();
  
  /* loop for all available ports */
  for ( portCounter = 0U; portCounter < ConfigDataPtr->numberOfPorts; portCounter++ )
  {
    /* Gets configChannelPtr. */
    channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[portCounter];
    /* Gets physical port number */
    portNr = (channelCfgPtr)->portNumber;
    
    /* Enter critical section to provide atomic access to the port registers */
    Port_EnterCriticalSection();
    
    /* Calculates mask value for CFG Register and OUT Register */
    Port_Arch_CalcRegMaskValue(channelCfgPtr, EnvDataPtr, &cfgNotChangeMask, &outNotChangeMask);
    /* Gets value of OUT Register */
    out_value = Port_ReadOUT(EnvDataPtr, portNr);
    /* Calculates write value of OUT Register */
    out_write_value = (out_value & outNotChangeMask) |
                      ((channelCfgPtr)->OUT_Data & (~outNotChangeMask));
    
    /* First, Sets value other than pins that do not need to be changed
       in the CFG register */
    Port_WriteCFG(EnvDataPtr, portNr, ((channelCfgPtr)->CFG_Data & cfgNotChangeMask));

    if ((channelCfgPtr)->hasSmartIo != PORT_FALSE)
    {
      /* CTL register shall be written: Disable SMARTIO with 'ENABLED' field */
      Port_WriteCTL(EnvDataPtr, portNr, 0U);
    }
    
    /* Sets value to OUT Register */
    Port_WriteOUT(EnvDataPtr, portNr, out_write_value);
    /* Sets value to PORT_SEL0 Register */
    Port_WritePORT_SEL0(EnvDataPtr, portNr, (channelCfgPtr)->PORT_SEL0_Data);
    /* Sets value to PORT_SEL1 Register */
    Port_WritePORT_SEL1(EnvDataPtr, portNr, (channelCfgPtr)->PORT_SEL1_Data);
    
    if ((channelCfgPtr)->hasSmartIo != PORT_FALSE)
    {
      /* Sets value to SYNC_CTL Register */
      Port_WriteSYNC_CTL(EnvDataPtr, portNr, (channelCfgPtr)->SYNC_CTL_Data);
    
      /* loop for available pin for a port */
      for ( count = 0U; count < (PORT_MAX_PIN / PORT_MAX_PORT); count++ )
      {
        pinMask = ((uint32)1U << count);  /* Gets pin position for loop count */
      
        /* Checks "current loop count is available pin" */
        if ( ((channelCfgPtr)->availablePins & pinMask) != 0U )
        {
          /* Sets value to LUT_SEL Register */
          Port_WriteLUT_SEL(EnvDataPtr, (Port_PortType)portNr, (Port_PinType)count,
                          (channelCfgPtr)->LUT_SEL_Data[count]);
          /* Sets value to LUT_CTL Register */
          Port_WriteLUT_CTL(EnvDataPtr, (Port_PortType)portNr, (Port_PinType)count,
                          (channelCfgPtr)->LUT_CTL_Data[count]);
        }
      }
      /* Sets value to DU_SEL Register */
      Port_WriteDU_SEL(EnvDataPtr, portNr, (channelCfgPtr)->DU_SEL_Data);
      /* Sets value to DU_CTL Register */
      Port_WriteDU_CTL(EnvDataPtr, portNr, (channelCfgPtr)->DU_CTL_Data);
      /* Sets value to DATA Register */
      Port_WriteDATA(EnvDataPtr, portNr, (channelCfgPtr)->DATA_Data);
    }
    
    /* Sets value to CFG_IN Register */
    Port_WriteCFG_IN(EnvDataPtr, portNr, (channelCfgPtr)->CFG_IN_Data);
    /* Sets value to CFG_OUT Register */
    Port_WriteCFG_OUT(EnvDataPtr, portNr, (channelCfgPtr)->CFG_OUT_Data);

    if ((channelCfgPtr)->hasSlewExt != PORT_FALSE)
    {
      /* Sets value to CFG_SLEW_EXT Register */
      Port_WriteCFG_SLEW_EXT(EnvDataPtr, portNr, (channelCfgPtr)->CFG_SLEW_EXT_Data);
    }

    if ((channelCfgPtr)->hasDriveExt != PORT_FALSE)
    {
      /* Sets value to CFG_DRIVE_EXT0 Register */
      Port_WriteCFG_DRIVE_EXT0(EnvDataPtr, portNr, (channelCfgPtr)->CFG_DRIVE_EXT0_Data);
      /* Sets value to CFG_DRIVE_EXT1 Register */
      Port_WriteCFG_DRIVE_EXT1(EnvDataPtr, portNr, (channelCfgPtr)->CFG_DRIVE_EXT1_Data);
    }

    if ((channelCfgPtr)->hasSio != PORT_FALSE)
    {
      /* Sets value to CFG_SIO Register */
      Port_WriteCFG_SIO(EnvDataPtr, portNr, (channelCfgPtr)->CFG_SIO_Data);
      /* Sets value to DFT_SIO Register */
      Port_WriteDFT_SIO(EnvDataPtr, portNr, (channelCfgPtr)->DFT_SIO_Data);
    }

    /* Sets value to CFG_IN_GPIO5V (CFG_IN_AUTOLVL) Register */
    Port_WriteCFG_IN_GPIO5V(EnvDataPtr, portNr, (channelCfgPtr)->CFG_IN_GPIO5V_Data);

    if ((channelCfgPtr)->hasDsCtrl != PORT_FALSE)
    {
      /* Sets value to CFG_OUT2 Register */
      Port_WriteCFG_OUT2(EnvDataPtr, portNr, (channelCfgPtr)->CFG_OUT2_Data);
    }

    if ((channelCfgPtr)->hasSmartIo != PORT_FALSE)
    {
      /* Finaly, Sets value to CTL Register for SMARTIO */
      Port_WriteCTL(EnvDataPtr, portNr, (channelCfgPtr)->CTL_Data);
    }
    /* And Sets value to CFG Register for GPIO */
    Port_WriteCFG(EnvDataPtr, portNr, (channelCfgPtr)->CFG_Data);

    /* Exit critical section */
    Port_ExitCriticalSection();
  }
  /* Read-back to ensure that the register values has been changed before exit this function */
  /* Note that registers accessed by this function belong to a same IO group. */
  /* So read-back from one of the register can satify the synchronization. */
  channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[0];
  (void)Port_ReadCFG(EnvDataPtr, channelCfgPtr->portNumber);
}


/** \brief Port_Arch_RefreshPortDirection() refresh port direction
 **
 ** This function refresh the direction of all ports that are configured as
 ** direction not changeable.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** */
FUNC(void,PORT_CODE) Port_Arch_RefreshPortDirection
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr
)
{
  P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST) channelCfgPtr;
  uint8  ArrayIndex;            /* loop counter */
  uint32 maskCfg;               /* Mask value of CFG Register */
  uint32 regValue;              /* Register value */
  uint32 setValue;              /* Setting value */
  
  for ( ArrayIndex = (uint8)0U; ArrayIndex < ConfigDataPtr->numberOfPorts; ArrayIndex++ )
  {
    /* Gets configChannelPtr. */
    channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[ArrayIndex];

    /* Gets the mask for CFG register */
    maskCfg = (channelCfgPtr)->directionChangeable;

    /* Enter critical section to provide atomic access to the port registers */
    Port_EnterCriticalSection();

    /* Gets value of setting CFG Register */
    regValue = Port_ReadCFG(EnvDataPtr, (channelCfgPtr)->portNumber);

    /* Sets value to CFG Register */
    setValue = (regValue & maskCfg) | ((channelCfgPtr)->CFG_Data & (~maskCfg));
    Port_WriteCFG(EnvDataPtr, (channelCfgPtr)->portNumber, setValue);

    /* Exit critical section */
    Port_ExitCriticalSection();
  }
}


/** \brief Port_Arch_SetPinDirection() set port direction
 **
 ** This function sets the direction of port pin to the new direction.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** \param[in]  pin_id        The id of port pin
 ** \param[in]  pin_direction The direction to be set for port pin
 ** */
FUNC(void,PORT_CODE) Port_Arch_SetPinDirection
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_PinType          pin_id,
  Port_PinDirectionType pin_direction
)
{
  P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST) channelCfgPtr; /* channel config pointer */
  uint8 portNr = (uint8)(pin_id >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 pinNr  = (uint8)(pin_id & PORT_PIN_MASK);  /* Gets pin ID. */
  uint32 dirValue;                  /* Direction value: Input buffer enable and output drive mode */
  uint32 regValue;                  /* Register value */
  uint32 maskValue;                 /* Mask value */
  uint32 setValue;                  /* Setting value */
  uint8 shift_out_drive = (PORT_GPIO_CFG_PIN_SHIFT * pinNr);        /* Shift value for CFG.DRIVEMODEx */
  uint8 shift_in_en = PORT_GPIO_CFG_IN_EN_SHIFT + shift_out_drive;  /* Shift value for CFG.IN_ENx */
  
  /* Gets configChannelPtr for pin_id. */
  channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[portNr];
  /* Gets physical port ID. */
  portNr = (channelCfgPtr)->portNumber;
  
  /* Checks direction. */
  if ( pin_direction == PORT_PIN_IN )
  {
    /* In case of Input */
    /* Input buffer is enabled and output drive mode is High-Impedance */
    dirValue = ((uint32)PORT_PIN_IN_ENABLE << PORT_GPIO_CFG_IN_EN_SHIFT) | PORT_PIN_OUT_MODE_HIGHZ;
  }
  else if ( pin_direction == PORT_PIN_OUT )
  {
    /* In case of Output */
    /* Input buffer enable and output drive mode are set to configuration data */
    dirValue = (uint32)((channelCfgPtr)->outputDrive[pinNr]);
  }
  else
  {
    /* In case of Input and Output are disabled */
    /* Input buffer is disabled and output drive mode is High-Impedance */
    dirValue = ((uint32)PORT_PIN_IN_DISABLE << PORT_GPIO_CFG_IN_EN_SHIFT) | PORT_PIN_OUT_MODE_HIGHZ;
  }

  /* Calculate setting value for CFG Register */
  maskValue = ((uint32)PORT_GPIO_CFG_DRIVEMODE_MASK << shift_out_drive);
  maskValue |= ((uint32)PORT_GPIO_CFG_IN_EN_MASK << shift_in_en);

  /* Enters critical section to provide atomic access to the port registers. */
  Port_EnterCriticalSection();
  
  /* Gets value of setting CFG Register */
  regValue = Port_ReadCFG(EnvDataPtr, portNr);
  
  /* Calculate setting value for CFG Register */
  setValue = (regValue & (~maskValue)) | ((dirValue << shift_out_drive) & maskValue);
  
  /* Sets value to CFG Register */
  Port_WriteCFG(EnvDataPtr, portNr, setValue);
  /* Read-back to ensure that the register value has been changed before exit this function */
  (void)Port_ReadCFG(EnvDataPtr, portNr);
  
  /* Exit critical section */
  Port_ExitCriticalSection();
}

/** \brief Port_Arch_SetPinMode() set port pin mode
 **
 ** This function sets the mode of port pin the new mode.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** \param[in]  pin_id        The ID of port pin
 ** \param[in]  pin_mode      The new mode of the pin
 ** */
FUNC(void,PORT_CODE) Port_Arch_SetPinMode
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_PinType     pin_id,
  Port_PinModeType pin_mode
)
{
  uint8  portNr;            /* port ID */
  uint8  pinNr;             /* pin ID */
  uint32 regValue;          /* Register value */
  uint32 maskValue;         /* Mask value */
  uint32 setValue;          /* Setting value */
  
  portNr = (uint8)(pin_id >> PORT_PORT_POSITION); /* Gets logical port ID. */
  pinNr  = (uint8)(pin_id & PORT_PIN_MASK);  /* Gets pin ID. */
  
  /* Gets physical port ID. */
  portNr = (&ConfigDataPtr->configChannelPtr[portNr])->portNumber;

  /* Enters critical section to provide atomic access to the port registers. */
  Port_EnterCriticalSection();

  if (pinNr <= 3U)
  {
    /* Gets value of setting PORT_SEL0 Register */
    regValue = Port_ReadPORT_SEL0(EnvDataPtr, portNr);
    
    /* Calculate setting value for PORT_SEL0 Register */
    maskValue = ((uint32)PORT_HSIOM_PORT_SEL_MASK << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr));
    setValue = (regValue & (~maskValue)) | ((uint32)pin_mode << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr));
    
    /* Sets value to PORT_SEL0 Register */
    Port_WritePORT_SEL0(EnvDataPtr, portNr, setValue);
    /* Read-back to ensure that the register value has been changed before exit this function */
    (void)Port_ReadPORT_SEL0(EnvDataPtr, portNr);
  }
  else
  {
    /* Gets value of setting PORT_SEL1 Register */
    regValue = Port_ReadPORT_SEL1(EnvDataPtr, portNr);
    
    /* Calculate setting value for PORT_SEL1 Register */
    maskValue = ((uint32)PORT_HSIOM_PORT_SEL_MASK << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U)));
    setValue = (regValue & (~maskValue)) | ((uint32)pin_mode << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U)));
    
    /* Sets value to PORT_SEL1 Register */
    Port_WritePORT_SEL1(EnvDataPtr, portNr, setValue);
    /* Read-back to ensure that the register value has been changed before exit this function */
    (void)Port_ReadPORT_SEL1(EnvDataPtr, portNr);
  }
  
  /* Exit critical section */
  Port_ExitCriticalSection();
}

/** \brief Port_Arch_SetTrigger() set the trigger
 **
 ** Sets the configuration for specified trigger.
 **
 ** \param[in]  EnvDataPtr      Pointer of data stored environment information
 ** \param[in]  group_id        Trigger Group ID number
 ** \param[in]  out_trg         Output Trigger ID number
 ** \param[in]  in_trg          Input Trigger ID number
 ** \param[in]  inv_flg         Trigger Invert Flag
 ** \param[in]  sensitive_type  Trigger Sensitive Type
 ** \param[in]  dbg_freeze_flg  Debug Freeze Flag
 ** */
FUNC(void,PORT_CODE) Port_Arch_SetTrigger
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_TriggerGroupIdType     group_id,
  Port_TriggerIdType          out_trg,
  Port_TriggerIdType          in_trg,
  boolean                     inv_flg,
  Port_TriggerSensitiveType   sensitive_type,
  boolean                     dbg_freeze_flg
)
{
  uint32 setValue;  /* Setting value */
  uint32 tr_inv_val = 0U;
  uint32 dbg_freeze_en_val = 0U;

  /* Calculate setting value for TR_CTL Register */
  if(inv_flg != (boolean)PORT_FALSE)
  {
    tr_inv_val = 1U;
  }
  if(dbg_freeze_flg != (boolean)PORT_FALSE)
  {
    dbg_freeze_en_val = 1U;
  }
  setValue = PORT_SET_TR_CTL(in_trg, tr_inv_val, sensitive_type, dbg_freeze_en_val);

  /* Sets value to TR_CTL Register */
  Port_WriteTR_CTL(EnvDataPtr, group_id, out_trg, setValue);
  /* Read-back to ensure that the register value has been changed before exit this function */
  (void)Port_ReadTR_CTL(EnvDataPtr, group_id, out_trg);
}

/** \brief Port_Arch_ActTrigger() activate the trigger command
 **
 ** Activate the specified trigger.
 **
 ** \param[in]  EnvDataPtr      Pointer of data stored environment information
 ** \param[in]  group_id        Trigger Group ID number
 ** \param[in]  trg_id          Trigger ID number
 ** \param[in]  act_type        Trigger activation type
 ** \param[in]  sensitive_type  Trigger Sensitive Type
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_ActTrigger
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_TriggerGroupIdType     group_id,
  Port_TriggerIdType          trg_id,
  Port_TriggerActivationType  act_type,
  Port_TriggerSensitiveType   sensitive_type
)
{
  uint32 setValue;  /* Setting value */

  /* TRM: At first MUST update the other register bits as needed. */
  /* Deviation from MISRA-C:2012 Rule-2.2
     Justification: The tool has detected it incorrectly. This operation is NOT redundant. */
  /* PRQA S 2985 1 */
  setValue = PORT_SET_TR_CMD(trg_id, group_id, sensitive_type, act_type, 0x00U);
  Port_WriteTR_CMD(EnvDataPtr, setValue);

  /* TRM: Then set ACTIVATE to '1' with a new register write. */
  setValue = PORT_SET_TR_CMD(trg_id, group_id, sensitive_type, act_type, 0x01U);
  Port_WriteTR_CMD(EnvDataPtr, setValue);

  return PORT_TRUE;
}

/** \brief Port_Arch_DeactTrigger() deactivate the trigger command
 **
 ** Deactivates the trigger activated by Port_ActTrigger.
 **
 ** \param[in]  EnvDataPtr    Pointer of data stored environment information
 ** */
FUNC(void,PORT_CODE) Port_Arch_DeactTrigger
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr
)
{
  uint32 regValue;   /* Register value */
  uint32 maskValue;  /* Mask value */
  uint32 setValue;   /* Setting value */

  /* Gets value of setting TR_CMD Register */
  regValue = Port_ReadTR_CMD(EnvDataPtr);

  /* Calculate setting value for TR_CMD Register */
  maskValue = ((uint32)PORT_TR_CMD_ACTIVATE_MASK << PORT_TR_CMD_ACTIVATE_SHIFT);
  setValue = regValue & (~maskValue);

  /* Sets value to TR_CMD Register */
  Port_WriteTR_CMD(EnvDataPtr, setValue);
  /* Read-back to ensure that the register value has been changed before exit this function */
  (void)Port_ReadTR_CMD(EnvDataPtr);
}

/** \brief Port_Arch_GetTriggerIdStatus() get the trigger status
 **
 ** Gets the status of specified trigger.
 **
 ** \param[in]  EnvDataPtr              Pointer of data stored environment information
 ** \param[in]  group_id                Trigger Group ID number
 ** \param[in]  out_trg                 Output Trigger ID number
 ** \param[out] TrigIdStatusInfoPtr     Pointer to where to store the trigger status information
 ** */
FUNC(void,PORT_CODE) Port_Arch_GetTriggerIdStatus
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_TriggerGroupIdType     group_id,
  Port_TriggerIdType          out_trg,
  P2VAR(Port_TriggerIdStatusType, AUTOMATIC, PORT_APPL_DATA) TrigIdStatusInfoPtr
)
{
  uint32 regValue;  /* Register value */

  /* Gets value of setting TR_CTL Register */
  regValue = Port_ReadTR_CTL(EnvDataPtr, group_id, out_trg);

  /* Set status information */
  TrigIdStatusInfoPtr->trInput = (Port_TriggerIdType)(regValue & PORT_TR_CTL_TR_SEL_MASK);
  TrigIdStatusInfoPtr->trInvertEnable = (boolean)
            ((regValue >> PORT_TR_CTL_TR_INV_SHIFT) & PORT_TR_CTL_TR_INV_MASK);
  if(((regValue >> PORT_TR_CTL_TR_EDGE_SHIFT) & PORT_TR_CTL_TR_EDGE_MASK) == 0U)
  {
    TrigIdStatusInfoPtr->trSensitiveType = PORT_TR_SENSITIVE_LEVEL;
  }
  else
  {
    TrigIdStatusInfoPtr->trSensitiveType = PORT_TR_SENSITIVE_EDGE;
  }
  TrigIdStatusInfoPtr->trDbgFreezeEnable = (boolean)
            ((regValue >> PORT_TR_CTL_DBG_FREEZE_EN_SHIFT) & PORT_TR_CTL_DBG_FREEZE_EN_MASK);
}

/** \brief Port_Arch_GetTriggerCmdStatus() get the trigger command status
 **
 ** Gets the status of trigger command.
 **
 ** \param[in]  EnvDataPtr              Pointer of data stored environment information
 ** \param[out] TrigCmdStatusInfoPtr    Pointer to where to store the trigger command status information
 ** */
FUNC(void,PORT_CODE) Port_Arch_GetTriggerCmdStatus
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  P2VAR(Port_TriggerCmdStatusType, AUTOMATIC, PORT_APPL_DATA) TrigCmdStatusInfoPtr
)
{
  uint32 regValue;  /* Register value */

  /* Gets value of setting TR_CMD Register */
  regValue = Port_ReadTR_CMD(EnvDataPtr);

  /* Set status information */
  TrigCmdStatusInfoPtr->trg_id = (Port_TriggerIdType)(regValue & PORT_TR_CMD_TR_SEL_MASK);
  TrigCmdStatusInfoPtr->group_id = (Port_TriggerGroupIdType)
                  ((regValue >> PORT_TR_CMD_GROUP_SEL_SHIFT) & PORT_TR_CMD_GROUP_SEL_MASK);
  if(((regValue >> PORT_TR_CMD_TR_EDGE_SHIFT) & PORT_TR_CMD_TR_EDGE_MASK) == 0U)
  {
    TrigCmdStatusInfoPtr->sensitive_type = PORT_TR_SENSITIVE_LEVEL;
  }
  else
  {
    TrigCmdStatusInfoPtr->sensitive_type = PORT_TR_SENSITIVE_EDGE;
  }
  if(((regValue >> PORT_TR_CMD_OUT_SEL_SHIFT) & PORT_TR_CMD_OUT_SEL_MASK) == 0U)
  {
    TrigCmdStatusInfoPtr->act_type = PORT_TR_ACTIVATION_INPUT;
  }
  else
  {
    TrigCmdStatusInfoPtr->act_type = PORT_TR_ACTIVATION_OUTPUT;
  }
  TrigCmdStatusInfoPtr->activate = (uint8)(regValue >> PORT_TR_CMD_ACTIVATE_SHIFT);
}

/*==================[internal function definitions]==========================*/
/** \brief Port_Arch_CheckConfigPtr() cheack config pointer
 **
 ** This function check the configration pointer adress.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** \return result of check (PORT_TRUE:OK / PORT_FALSE:NG)
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_CheckConfigPtr
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr
)
{
  uint8 count;   /* counter for loop */
  boolean result = (boolean)PORT_FALSE;  /* set false to result */
  
  /* loop for all Config Patern */
  for (count = 0U; count < EnvDataPtr->numberOfConfigSet; count++)
  {
    /* Find the configuration pattern that matches */
    if (ConfigDataPtr == &EnvDataPtr->configSetPtr[count])
    {
      result = PORT_TRUE;
    }
  }
  return result;
}

/** \brief Port_Arch_GetPinStatus() get port pin status
 **
 ** This function gets the status of port pin.
 **
 ** \param[in]  ConfigDataPtr       pointer of data stored configuration information
 ** \param[in]  EnvDataPtr          pointer of data stored environment information
 ** \param[in]  pin_id              The ID of port pin
 ** \param[out] PortStatusInfoPtr   pointer of status of port pins
 ** \return the status of the port pin in a Port_StatusType structure.
 ** \return result of check (PORT_TRUE:OK / PORT_FALSE:NG)
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_GetPinStatus
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_PinType          pin_id,
  P2VAR(Port_StatusType, AUTOMATIC, PORT_APPL_DATA) PortStatusInfoPtr
)
{
  P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST) channelCfgPtr; /* channel config pointer */
  uint8 portNr = (uint8)(pin_id >> PORT_PORT_POSITION); /* Gets logical port ID. */
  uint8 pinNr  = (uint8)(pin_id & PORT_PIN_MASK);  /* Gets pin ID. */
  boolean result = (boolean)PORT_TRUE;      /* result */
  uint32 port_sel_value;        /* PORT_SELx Register value */
  uint32 ctl_value;             /* CTL Register value */
  uint32 sync_ctl_value;        /* SYNC_CTL Register value */
  uint32 lut_sel_value;         /* LUT_SEL Register value */
  uint32 lut_ctl_value;         /* LUT_CTL Register value */
  uint32 du_sel_value;          /* DU_SEL Register value */
  uint32 du_ctl_value;          /* DU_CTL Register value */
  uint32 data_value;            /* DATA Register value */
  uint32 cfg_value;             /* CFG Register value */
  uint32 cfg_in_value;          /* CFG_IN Register value */
  uint32 cfg_out_value;         /* CFG_OUT Register value */
  uint32 cfg_sio_value;         /* CFG_SIO Register value */
  uint32 dft_sio_value;         /* DFT_SIO Register value */
  uint32 cfg_in_gpio5v_value;   /* CFG_IN_GPIO5V Register value */
  uint32 cfg_out2_value;        /* CFG_OUT2 Register value */
  uint32 cfg_slew_ext_value;    /* CFG_SLEW_EXT Register value */
  uint32 cfg_drive_ext_value;   /* CFG_DRIVE_EXT Register value */
  uint32 tempValue;             /* Temporary value */
  
  /* Gets configChannelPtr for pin_id. */
  channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[portNr];
  /* Gets physical port ID. */
  portNr = (channelCfgPtr)->portNumber;
  
  /* Enters critical section to provide atomic access to the port registers. */
  Port_EnterCriticalSection();
  
  if (pinNr <= 3U)
  {
    /* Gets value of setting PORT_SEL0 Register */
    port_sel_value = Port_ReadPORT_SEL0(EnvDataPtr, portNr);
  }
  else
  {
    /* Gets value of setting PORT_SEL1 Register */
    port_sel_value = Port_ReadPORT_SEL1(EnvDataPtr, portNr);
  }
  
  /* Get SMARTIO register value */
  if ((channelCfgPtr)->hasSmartIo != PORT_FALSE)
  {
    /* Gets value of setting CTL Register */
    ctl_value = Port_ReadCTL(EnvDataPtr, portNr);
    /* Gets value of setting SYNC_CTL Register */
    sync_ctl_value = Port_ReadSYNC_CTL(EnvDataPtr, portNr);
    /* Gets value of setting LUT_SEL Register */
    lut_sel_value = Port_ReadLUT_SEL(EnvDataPtr, portNr, (Port_PinType)pinNr);
    /* Gets value of setting LUT_CTL Register */
    lut_ctl_value = Port_ReadLUT_CTL(EnvDataPtr, portNr, (Port_PinType)pinNr);
    /* Gets value of setting DU_SEL Register */
    du_sel_value = Port_ReadDU_SEL(EnvDataPtr, portNr);
    /* Gets value of setting DU_CTL Register */
    du_ctl_value = Port_ReadDU_CTL(EnvDataPtr, portNr);
    /* Gets value of setting DATA Register */
    data_value = Port_ReadDATA(EnvDataPtr, portNr);
  }
  else
  {
    ctl_value = 0x0UL;
    sync_ctl_value = 0x0UL;
    lut_sel_value = 0x0UL;
    lut_ctl_value = 0x0UL;
    du_sel_value = 0x0UL;
    du_ctl_value = 0x0UL;
    data_value = 0x0UL;
  }

  /* Gets value of setting CFG Register */
  cfg_value = Port_ReadCFG(EnvDataPtr, portNr);
  /* Gets value of setting CFG_IN Register */
  cfg_in_value = Port_ReadCFG_IN(EnvDataPtr, portNr);
  /* Gets value of setting CFG_OUT Register */
  cfg_out_value = Port_ReadCFG_OUT(EnvDataPtr, portNr);
  /* Gets value of setting CFG_IN_GPIO5V Register */
  cfg_in_gpio5v_value = Port_ReadCFG_IN_GPIO5V(EnvDataPtr, portNr);

  /* Get SIO register value */
  if ((channelCfgPtr)->hasSio != PORT_FALSE)
  {
    /* Gets value of setting CFG_SIO Register */
    cfg_sio_value = Port_ReadCFG_SIO(EnvDataPtr, portNr);
    /* Gets value of setting DFT_SIO Register */
    dft_sio_value = Port_ReadDFT_SIO(EnvDataPtr, portNr);
  }
  else
  {
    cfg_sio_value = 0x0UL;
    dft_sio_value = 0x0UL;
  }

  /* Gets value of setting CFG_OUT2 Register */
  if ((channelCfgPtr)->hasDsCtrl != PORT_FALSE)
  {
    cfg_out2_value = Port_ReadCFG_OUT2(EnvDataPtr, portNr);
  }
  else
  {
    cfg_out2_value = 0x0UL;
  }

  /* Gets value of setting CFG_SLEW_EXT Register */
  if ((channelCfgPtr)->hasSlewExt != PORT_FALSE)
  {
    cfg_slew_ext_value = Port_ReadCFG_SLEW_EXT(EnvDataPtr, portNr);
  }
  else
  {
    cfg_slew_ext_value = 0x0UL;
  }

  /* Gets value of setting CFG_DRIVE_EXT Register */
  if ((channelCfgPtr)->hasDriveExt != PORT_FALSE)
  {
    if (pinNr <= 3U)
    {
      cfg_drive_ext_value = Port_ReadCFG_DRIVE_EXT0(EnvDataPtr, portNr);
    }
    else
    {
      cfg_drive_ext_value = Port_ReadCFG_DRIVE_EXT1(EnvDataPtr, portNr);
    }
  }
  else
  {
    cfg_drive_ext_value = 0x0UL;
  }

  /* Exit critical section */
  Port_ExitCriticalSection();
  
  if (pinNr <= 3U)
  {
    tempValue = (port_sel_value >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr)) & PORT_HSIOM_PORT_SEL_MASK;
  }
  else
  {
    tempValue = (port_sel_value >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U))) & PORT_HSIOM_PORT_SEL_MASK;
  }
  /* Set mode */
  PortStatusInfoPtr->mode = (uint8)tempValue;
  
  /* Set smartioBypassEnable */
  tempValue = ((ctl_value >> pinNr) & PORT_SMARTIO_CTL_BYPASS_MASK);
  PortStatusInfoPtr->smartioBypassEnable = (uint8)tempValue;
  /* Set smartioClockSource */
  tempValue = ((ctl_value >> PORT_SMARTIO_CTL_CLOCK_SRC_SHIFT) & PORT_SMARTIO_CTL_CLOCK_SRC_MASK);
  PortStatusInfoPtr->smartioClockSource = (uint8)tempValue;
  /* Set smartioHoldOverrideEnable */
  tempValue = ((ctl_value >> PORT_SMARTIO_CTL_HLD_OVR_SHIFT) & PORT_SMARTIO_CTL_HLD_OVR_MASK);
  PortStatusInfoPtr->smartioHoldOverrideEnable = (uint8)tempValue;
  /* Set smartioPipelineEnable */
  tempValue = ((ctl_value >> PORT_SMARTIO_CTL_PIPELINE_EN_SHIFT) & PORT_SMARTIO_CTL_PIPELINE_EN_MASK);
  PortStatusInfoPtr->smartioPipelineEnable = (uint8)tempValue;
  /* Set smartioEnable */
  tempValue = (ctl_value >> PORT_SMARTIO_CTL_ENABLED_SHIFT);
  PortStatusInfoPtr->smartioEnable = (uint8)tempValue;
  /* Set smartioSyncIoEnable */
  tempValue = ((sync_ctl_value >> pinNr) & PORT_SMARTIO_SYNC_CTL_IO_EN_MASK);
  PortStatusInfoPtr->smartioSyncIoEnable = (uint8)tempValue;
  /* Set smartioSyncChipEnable */
  tempValue = ((sync_ctl_value >> (PORT_SMARTIO_SYNC_CTL_CHIP_EN_SHIFT + pinNr)) & PORT_SMARTIO_SYNC_CTL_CHIP_EN_MASK);
  PortStatusInfoPtr->smartioSyncChipEnable = (uint8)tempValue;
  /* Set smartioLutTr0Source */
  tempValue = (lut_sel_value & PORT_SMARTIO_LUT_TR_SEL_MASK);
  PortStatusInfoPtr->smartioLutTr0Source = (uint8)tempValue;
  /* Set smartioLutTr1Source */
  tempValue = ((lut_sel_value >> PORT_SMARTIO_LUT_TR1_SEL_SHIFT) & PORT_SMARTIO_LUT_TR_SEL_MASK);
  PortStatusInfoPtr->smartioLutTr1Source = (uint8)tempValue;
  /* Set smartioLutTr2Source */
  tempValue = ((lut_sel_value >> PORT_SMARTIO_LUT_TR2_SEL_SHIFT) & PORT_SMARTIO_LUT_TR_SEL_MASK);
  PortStatusInfoPtr->smartioLutTr2Source = (uint8)tempValue;
  /* Set smartioLut */
  tempValue = (lut_ctl_value & PORT_SMARTIO_LUT_CTL_LUT_MASK);
  PortStatusInfoPtr->smartioLut = (uint8)tempValue;
  /* Set smartioLutOperation */
  tempValue = ((lut_ctl_value >> PORT_SMARTIO_LUT_CTL_LUT_OPC_SHIFT) & PORT_SMARTIO_LUT_CTL_LUT_OPC_MASK);
  PortStatusInfoPtr->smartioLutOperation = (uint8)tempValue;
  /* Set smartioDataUnitTr0Source */
  tempValue = (du_sel_value & PORT_SMARTIO_DU_SEL_TR_SEL_MASK);
  PortStatusInfoPtr->smartioDataUnitTr0Source = (uint8)tempValue;
  /* Set smartioDataUnitTr1Source */
  tempValue = ((du_sel_value >> PORT_SMARTIO_DU_SEL_TR1_SEL_SHIFT) & PORT_SMARTIO_DU_SEL_TR_SEL_MASK);
  PortStatusInfoPtr->smartioDataUnitTr1Source = (uint8)tempValue;
  /* Set smartioDataUnitTr2Source */
  tempValue = ((du_sel_value >> PORT_SMARTIO_DU_SEL_TR2_SEL_SHIFT) & PORT_SMARTIO_DU_SEL_TR_SEL_MASK);
  PortStatusInfoPtr->smartioDataUnitTr2Source = (uint8)tempValue;
  /* Set smartioDataUnitData0Source */
  tempValue = ((du_sel_value >> PORT_SMARTIO_DU_SEL_DATA0_SEL_SHIFT) & PORT_SMARTIO_DU_SEL_DATA_SEL_MASK);
  PortStatusInfoPtr->smartioDataUnitData0Source = (uint8)tempValue;
  /* Set smartioDataUnitData1Source */
  tempValue = ((du_sel_value >> PORT_SMARTIO_DU_SEL_DATA1_SEL_SHIFT) & PORT_SMARTIO_DU_SEL_DATA_SEL_MASK);
  PortStatusInfoPtr->smartioDataUnitData1Source = (uint8)tempValue;

  /* Set smartioDataUnitBitSize */
  if ((channelCfgPtr)->hasSmartIo != PORT_FALSE)
  {
    tempValue = (du_ctl_value & PORT_SMARTIO_DU_CTL_DU_SIZE_MASK);
    PortStatusInfoPtr->smartioDataUnitBitSize = (uint8)(tempValue + 1U);
  }
  else
  {
    PortStatusInfoPtr->smartioDataUnitBitSize = 0U;
  }

  /* Set smartioDataUnitOperation */
  tempValue = ((du_ctl_value >> PORT_SMARTIO_DU_CTL_DU_OPC_SHIFT) & PORT_SMARTIO_DU_CTL_DU_OPC_MASK);
  PortStatusInfoPtr->smartioDataUnitOperation = (uint8)tempValue;
  /* Set smartioDataUnitSource */
  tempValue = (data_value & PORT_SMARTIO_DU_DATA_DATA_MASK);
  PortStatusInfoPtr->smartioDataUnitSource = (uint8)tempValue;
  /* Set outputDrive */
  tempValue = ((cfg_value >> (PORT_GPIO_CFG_PIN_SHIFT * pinNr)) & PORT_GPIO_CFG_DRIVEMODE_MASK);
  PortStatusInfoPtr->outputDrive = (uint8)tempValue;
  /* Set direction */
  tempValue = ((cfg_value >>
                (PORT_GPIO_CFG_IN_EN_SHIFT + (PORT_GPIO_CFG_PIN_SHIFT * pinNr))) &
               PORT_GPIO_CFG_IN_EN_MASK);
  /* Check direction */
  if (PortStatusInfoPtr->outputDrive != PORT_PIN_OUT_MODE_HIGHZ)
  {
    PortStatusInfoPtr->direction = (uint8)PORT_PIN_OUT;
  }
  else if (tempValue == PORT_PIN_IN_ENABLE)
  {
    PortStatusInfoPtr->direction = (uint8)PORT_PIN_IN;
  }
  else
  {
    PortStatusInfoPtr->direction = (uint8)PORT_PIN_IN_OUT_DISABLED;
  }
  /* Set inputBufferMode */
  tempValue = ((cfg_in_value >> pinNr) & PORT_GPIO_CFG_IN_VTRIP_SEL_MASK);
  PortStatusInfoPtr->inputBufferMode = (uint8)tempValue;
  /* Set outputSlowSlewRateEnable */
  tempValue = ((cfg_out_value >> pinNr) & PORT_GPIO_CFG_OUT_SLOW_MASK);
  PortStatusInfoPtr->outputSlowSlewRateEnable = (uint8)tempValue;
  /* Set outputDriveStrength */
  tempValue = ((cfg_out_value >>
                (PORT_GPIO_CFG_OUT_DRIVE_SEL_SHIFT + (PORT_GPIO_CFG_OUT_DRIVE_SEL_PIN_SHIFT * pinNr))) &
               PORT_GPIO_CFG_OUT_DRIVE_SEL_MASK);
  PortStatusInfoPtr->outputDriveStrength = (uint8)tempValue;
  /* Set sioPinsOutputBufferMode */
  tempValue = ((cfg_sio_value >> (PORT_GPIO_CFG_SIO_PINS_SHIFT * (pinNr >> 1U))) & PORT_GPIO_CFG_SIO_VREG_EN_MASK);
  PortStatusInfoPtr->sioPinsOutputBufferMode = (uint8)tempValue;
  /* Set sioPinsInputBufferMode */
  tempValue = ((cfg_sio_value >>
                (PORT_GPIO_CFG_SIO_IBUF_VTRIP_SEL_SHIFT + (PORT_GPIO_CFG_SIO_PINS_SHIFT * (pinNr >> 1U)))) &
               PORT_GPIO_CFG_SIO_IBUF_VTRIP_SEL_MASK);
  PortStatusInfoPtr->sioPinsInputBufferMode = (uint8)tempValue;
  /* Set sioPinsInputBufferVrefTripPoint */
  tempValue = ((cfg_sio_value >>
                (PORT_GPIO_CFG_SIO_VREF_SEL_SHIFT + (PORT_GPIO_CFG_SIO_PINS_SHIFT * (pinNr >> 1U)))) &
               PORT_GPIO_CFG_SIO_VREF_SEL_MASK);
  PortStatusInfoPtr->sioPinsInputBufferVrefTripPoint = (uint8)tempValue;
  /* Set sioPinsInputBufferVohOutputLevel */
  tempValue = ((cfg_sio_value >>
                (PORT_GPIO_CFG_SIO_VOH_SEL_SHIFT + (PORT_GPIO_CFG_SIO_PINS_SHIFT * (pinNr >> 1U)))) &
               PORT_GPIO_CFG_SIO_VOH_SEL_MASK);
  PortStatusInfoPtr->sioPinsInputBufferVohOutputLevel = (uint8)tempValue;
  /* Set sioPinsAnalogDftEnable */
  tempValue = ((dft_sio_value >> (pinNr >> 1U)) & PORT_GPIO_DFT_SIO_DFT_REFGEN_MASK);
  PortStatusInfoPtr->sioPinsAnalogDftEnable = (uint8)tempValue;
  /* Set inputBufferMode5VPin */
  tempValue = ((cfg_in_gpio5v_value >> pinNr) & PORT_GPIO_CFG_IN_GPIO5V_MASK);
  PortStatusInfoPtr->inputBufferMode5VPin = (uint8)tempValue;
  /* Set outputDriveSelectTrim */
  tempValue = ((cfg_out2_value >> (PORT_GPIO_CFG_OUT2_DS_TRIM_SHIFT * pinNr)) &
               PORT_GPIO_CFG_OUT2_DS_TRIM_MASK);
  PortStatusInfoPtr->outputDriveSelectTrim = (uint8)tempValue;
  /* Set outputSlewRateExt */
  tempValue = ((cfg_slew_ext_value >> (PORT_GPIO_CFG_SLEW_EXT_SLEW_SHIFT * pinNr)) &
               PORT_GPIO_CFG_SLEW_EXT_SLEW_MASK);
  PortStatusInfoPtr->outputSlewRateExt = (uint8)tempValue;
  /* Set outputDriveStrengthExt */
  if (pinNr <= 3U)
  {
    tempValue = (cfg_drive_ext_value >> (PORT_GPIO_CFG_DRIVE_EXT_DRIVE_SEL_EXT_SHIFT * pinNr))
                & PORT_GPIO_CFG_DRIVE_EXT_DRIVE_SEL_EXT_MASK;
  }
  else
  {
    tempValue = (cfg_drive_ext_value >> (PORT_GPIO_CFG_DRIVE_EXT_DRIVE_SEL_EXT_SHIFT * (pinNr - 4U)))
                & PORT_GPIO_CFG_DRIVE_EXT_DRIVE_SEL_EXT_MASK;
  }
  PortStatusInfoPtr->outputDriveStrengthExt = (uint8)tempValue;

  return result;
}

/** \brief Port_Arch_GetAmuxSplitCtlStatus() get AMUX cell status
 **
 ** This function gets the status of AMUX cell.
 **
 ** \param[in]  ConfigDataPtr               pointer of data stored configuration information
 ** \param[in]  EnvDataPtr                  pointer of data stored environment information
 ** \param[in]  cell_id                     The id of AMUX splitter cell
 ** \param[out] AmuxSplitCtlStatusInfoPtr   pointer of status of AMUX cells
 ** \return the status of the AMUX cell in a Port_AmuxSplitCtlStatusType structure.
 ** \return result of check (PORT_TRUE:OK / PORT_FALSE:NG)
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_GetAmuxSplitCtlStatus
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_AmuxCellType         cell_id,
  P2VAR(Port_AmuxSplitCtlStatusType, AUTOMATIC, PORT_APPL_DATA) AmuxSplitCtlStatusInfoPtr
)
{
  P2CONST(Port_AmuxSplitCtlConfigType, AUTOMATIC, PORT_CONST) amuxCfgPtr; /* amux config pointer */
  uint8 cellNr;                                     /* Gets cell ID. */
  boolean result = (boolean)PORT_TRUE;              /* result */
  uint32 amux_split_ctl_value;  /* AMUX_SPLIT_CTL Register value */
  uint32 tempValue;             /* Temporary value */
  
  /* Gets configChannelPtr for pin_id. */
  amuxCfgPtr = (P2CONST(Port_AmuxSplitCtlConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configAmuxSplitCtlPtr[cell_id];
  /* Gets physical cell ID. */
  cellNr = (amuxCfgPtr)->amuxSplitCtlNumber;
  
  /* Gets value of setting AMUX_SPLIT_CTL Register */
  amux_split_ctl_value = Port_ReadAMUX_SPLIT_CTL(EnvDataPtr, cellNr);
  
  /* Set amuxBusaSwitchSL */
  tempValue = (amux_split_ctl_value & PORT_HSIOM_AMUX_BUSA_SL_MASK);
  AmuxSplitCtlStatusInfoPtr->amuxBusaSwitchSL = (uint8)tempValue;
  /* Set amuxBusaSwitchSR */
  tempValue = ((amux_split_ctl_value & PORT_HSIOM_AMUX_BUSA_SR_MASK) >> PORT_HSIOM_AMUX_BUSA_SR_SHIFT);
  AmuxSplitCtlStatusInfoPtr->amuxBusaSwitchSR = (uint8)tempValue;
  /* Set amuxBusaSwitchS0 */
  tempValue = ((amux_split_ctl_value & PORT_HSIOM_AMUX_BUSA_S0_MASK) >> PORT_HSIOM_AMUX_BUSA_S0_SHIFT);
  AmuxSplitCtlStatusInfoPtr->amuxBusaSwitchS0 = (uint8)tempValue;
  /* Set amuxBusbSwitchSL */
  tempValue = ((amux_split_ctl_value & PORT_HSIOM_AMUX_BUSB_SL_MASK) >> PORT_HSIOM_AMUX_BUSB_SL_SHIFT);
  AmuxSplitCtlStatusInfoPtr->amuxBusbSwitchSL = (uint8)tempValue;
  /* Set amuxBusbSwitchSR */
  tempValue = ((amux_split_ctl_value & PORT_HSIOM_AMUX_BUSB_SR_MASK) >> PORT_HSIOM_AMUX_BUSB_SR_SHIFT);
  AmuxSplitCtlStatusInfoPtr->amuxBusbSwitchSR = (uint8)tempValue;
  /* Set amuxBusbSwitchS0 */
  tempValue = ((amux_split_ctl_value & PORT_HSIOM_AMUX_BUSB_S0_MASK) >> PORT_HSIOM_AMUX_BUSB_S0_SHIFT);
  AmuxSplitCtlStatusInfoPtr->amuxBusbSwitchS0 = (uint8)tempValue;
  
  return result;
}

/** \brief Port_Arch_SetToDioMode() set port pin mode to DIO mode
 **
 ** This function sets the mode of port pin to DIO mode.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** \param[in]  pin_id        The ID of port pin
 ** */
FUNC(void,PORT_CODE) Port_Arch_SetToDioMode
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_PinType     pin_id
)
{
  P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST) channelCfgPtr; /* channel config pointer */
  uint8  portNr;            /* port ID */
  uint8  pinNr;             /* pin ID */
  uint8  checkMode;         /* Mode for checking */
  uint32 tempValue;         /* Temporary */
  uint32 regValue;          /* Register value */
  uint32 maskValue;         /* Mask value */
  uint32 setValue;          /* Setting value */
  
  portNr = (uint8)(pin_id >> PORT_PORT_POSITION); /* Gets logical port ID. */
  pinNr  = (uint8)(pin_id & PORT_PIN_MASK);  /* Gets pin ID. */
  
  /* Gets configChannelPtr for pin_id. */
  channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[portNr];
  /* Gets physical port ID. */
  portNr = (channelCfgPtr)->portNumber;
  
  /* Gets initialization mode */
  if (pinNr <= 3U)
  {
    tempValue = (((channelCfgPtr)->PORT_SEL0_Data) >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr)) & 
                PORT_HSIOM_PORT_SEL_MASK;
    checkMode = (uint8)tempValue;
  }
  else
  {
    tempValue = (((channelCfgPtr)->PORT_SEL1_Data) >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U))) &
                PORT_HSIOM_PORT_SEL_MASK;
    checkMode = (uint8)tempValue;
  }
  
  /* Check initialization mode */
  if (checkMode != PORT_PIN_MODE_GPIO)
  {
    /* Enters critical section to provide atomic access to the port registers. */
    Port_EnterCriticalSection();
    
    if (pinNr <= 3U)
    {
      /* Gets value of setting PORT_SEL0 Register */
      regValue = Port_ReadPORT_SEL0(EnvDataPtr, portNr);
      
      /* Gets current mode */
      tempValue = ((regValue >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr)) & PORT_HSIOM_PORT_SEL_MASK);
      checkMode = (uint8)tempValue;
      
      /* Check current mode */
      if (checkMode != PORT_PIN_MODE_GPIO)
      {
        /* Calculate setting value for PORT_SEL0 Register */
        maskValue = ((uint32)PORT_HSIOM_PORT_SEL_MASK << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr));
        setValue = (regValue & (~maskValue));
        
        /* Sets value to PORT_SEL0 Register */
        Port_WritePORT_SEL0(EnvDataPtr, portNr, setValue);
        /* Read-back to ensure that the register value has been changed before exit this function */
        (void)Port_ReadPORT_SEL0(EnvDataPtr, portNr);
      }
    }
    else
    {
      /* Gets value of setting PORT_SEL1 Register */
      regValue = Port_ReadPORT_SEL1(EnvDataPtr, portNr);
      
      /* Gets current mode */
      tempValue = ((regValue >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U))) & PORT_HSIOM_PORT_SEL_MASK);
      checkMode = (uint8)tempValue;
      
      /* Check current mode */
      if (checkMode != PORT_PIN_MODE_GPIO)
      {
        /* Calculate setting value for PORT_SEL1 Register */
        maskValue = ((uint32)PORT_HSIOM_PORT_SEL_MASK << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U)));
        setValue = (regValue & (~maskValue));
        
        /* Sets value to PORT_SEL1 Register */
        Port_WritePORT_SEL1(EnvDataPtr, portNr, setValue);
        /* Read-back to ensure that the register value has been changed before exit this function */
        (void)Port_ReadPORT_SEL1(EnvDataPtr, portNr);
      }
    }
    
    /* Exit critical section */
    Port_ExitCriticalSection();
  }
}

/** \brief Port_Arch_SetToAlternateMode() set port pin mode to alternate mode from DIO mode
 **
 ** This function sets the mode of port pin to alternate mode from DIO mode.
 **
 ** \param[in]  ConfigDataPtr pointer of data stored configuration information
 ** \param[in]  EnvDataPtr    pointer of data stored environment information
 ** \param[in]  pin_id        The ID of port pin
 ** */
FUNC(void,PORT_CODE) Port_Arch_SetToAlternateMode
(
  P2CONST(Port_ConfigType,AUTOMATIC,PORT_APPL_CONST)    ConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)      EnvDataPtr,
  Port_PinType     pin_id
)
{
  P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST) channelCfgPtr; /* channel config pointer */
  uint8  portNr;            /* port ID */
  uint8  pinNr;             /* pin ID */
  uint8  initialMode;       /* Initialization mode */
  uint8  currentMode;       /* Current mode */
  uint32 tempValue;         /* Temporary */
  uint32 regValue;          /* Register value */
  uint32 setValue;          /* Setting value */
  
  portNr = (uint8)(pin_id >> PORT_PORT_POSITION); /* Gets logical port ID. */
  pinNr  = (uint8)(pin_id & PORT_PIN_MASK);  /* Gets pin ID. */
  
  /* Gets configChannelPtr for pin_id. */
  channelCfgPtr = (P2CONST(Port_PinChannelConfigType, AUTOMATIC, PORT_CONST))&ConfigDataPtr->configChannelPtr[portNr];
  /* Gets physical port ID. */
  portNr = (channelCfgPtr)->portNumber;
  
  /* Gets initialization mode */
  if (pinNr <= 3U)
  {
    tempValue = (((channelCfgPtr)->PORT_SEL0_Data) >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr)) &
                PORT_HSIOM_PORT_SEL_MASK;
    initialMode = (uint8)tempValue;
  }
  else
  {
    tempValue = (((channelCfgPtr)->PORT_SEL1_Data) >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U))) &
                PORT_HSIOM_PORT_SEL_MASK;
    initialMode = (uint8)tempValue;
  }
  
  /* Check initialization mode */
  if (initialMode != PORT_PIN_MODE_GPIO)
  {
    /* Enters critical section to provide atomic access to the port registers. */
    Port_EnterCriticalSection();
    
    if (pinNr <= 3U)
    {
      /* Gets value of setting PORT_SEL0 Register */
      regValue = Port_ReadPORT_SEL0(EnvDataPtr, portNr);
      
      /* Gets current mode */
      tempValue = ((regValue >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr)) & PORT_HSIOM_PORT_SEL_MASK);
      currentMode = (uint8)tempValue;
      
      /* Check current mode */
      if (currentMode == PORT_PIN_MODE_GPIO)
      {
        /* Calculate setting value for PORT_SEL0 Register */
        setValue = regValue | ((uint32)initialMode << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * pinNr));
        
        /* Sets value to PORT_SEL0 Register */
        Port_WritePORT_SEL0(EnvDataPtr, portNr, setValue);
        /* Read-back to ensure that the register value has been changed before exit this function */
        (void)Port_ReadPORT_SEL0(EnvDataPtr, portNr);
      }
    }
    else
    {
      /* Gets value of setting PORT_SEL1 Register */
      regValue = Port_ReadPORT_SEL1(EnvDataPtr, portNr);
      
      /* Gets current mode */
      tempValue = ((regValue >> (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U))) & PORT_HSIOM_PORT_SEL_MASK);
      currentMode = (uint8)tempValue;
      
      /* Check current mode */
      if (currentMode == PORT_PIN_MODE_GPIO)
      {
        /* Calculate setting value for PORT_SEL1 Register */
        setValue = regValue | ((uint32)initialMode << (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (pinNr - 4U)));
        
        /* Sets value to PORT_SEL1 Register */
        Port_WritePORT_SEL1(EnvDataPtr, portNr, setValue);
        /* Read-back to ensure that the register value has been changed before exit this function */
        (void)Port_ReadPORT_SEL1(EnvDataPtr, portNr);
      }
    }
    
    /* Exit critical section */
    Port_ExitCriticalSection();
  }
}

/** \brief Port_Arch_CheckTrCmdSet() cheack trigger command for set trigger
 **
 ** This function check the trigger command status for setting trigger control.
 **
 ** \param[in]  EnvDataPtr  Pointer of data stored environment information
 ** \param[in]  group_id    Trigger Group ID number
 ** \return result of check (PORT_TRUE:OK / PORT_FALSE:NG)
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_CheckTrCmdSet
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)  EnvDataPtr,
  Port_TriggerGroupIdType  group_id
)
{
  boolean result = (boolean)PORT_TRUE;  /* set false to result */
  uint32 regValue;  /* Register value */

  /* Gets value of setting TR_CMD Register */
  regValue = Port_ReadTR_CMD(EnvDataPtr);

  /* Check activated and activated group */
  if (((regValue >> PORT_TR_CMD_ACTIVATE_SHIFT) != (uint32)0U) &&
      (((regValue >> PORT_TR_CMD_GROUP_SEL_SHIFT) & PORT_TR_CMD_GROUP_SEL_MASK) == (uint32)group_id))
  {
    result = PORT_FALSE;
  }

  return result;
}

/** \brief Port_Arch_CheckTrCmdAct() cheack trigger command for act trigger
 **
 ** This function check the trigger command status for activating trigger command.
 **
 ** \param[in]  EnvDataPtr    Pointer of data stored environment information
 ** \return result of check (PORT_TRUE:OK / PORT_FALSE:NG)
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_CheckTrCmdAct
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)  EnvDataPtr
)
{
  boolean result = (boolean)PORT_FALSE;  /* set false to result */
  uint32 regValue;  /* Register value */

  /* Gets value of setting TR_CMD Register */
  regValue = Port_ReadTR_CMD(EnvDataPtr);

  /* Check deactivated */
  if ((regValue >> PORT_TR_CMD_ACTIVATE_SHIFT) == (uint32)0U)
  {
    result = PORT_TRUE;
  }

  return result;
}

/** \brief Port_Arch_CheckTrCmdDeact() cheack trigger command for deact trigger
 **
 ** This function check the trigger command status for deactivating trigger command.
 **
 ** \param[in]  EnvDataPtr    Pointer of data stored environment information
 ** \return result of check (PORT_TRUE:OK / PORT_FALSE:NG)
 ** */
FUNC(boolean,PORT_CODE) Port_Arch_CheckTrCmdDeact
(
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)  EnvDataPtr
)
{
  boolean result = (boolean)PORT_FALSE;  /* set false to result */
  uint32 regValue;  /* Register value */

  /* Gets value of setting TR_CMD Register */
  regValue = Port_ReadTR_CMD(EnvDataPtr);

  /* Check activated */
  if ((regValue >> PORT_TR_CMD_ACTIVATE_SHIFT) != (uint32)0U)
  {
    /* Check level sensitive */
    if (((regValue >> PORT_TR_CMD_TR_EDGE_SHIFT) & PORT_TR_CMD_TR_EDGE_MASK) == (uint32)0U)
    {
      result = PORT_TRUE;
    }
  }

  return result;
}

/** \brief Port_Arch_CalcRegMaskValue() calculation of mask value
 ** for CFG/OUT Register
 **
 ** This function calculates the mask value of the bits of CFG/OUT register
 ** that need not be changed.
 **
 ** \param[in]  PinConfigDataPtr    pointer of data stored pin configuration information
 ** \param[in]  EnvDataPtr          pointer of data stored environment information
 ** \param[out] cfgNotChangeMaskPtr pointer of data stored mask value of the bits of CFG register
 ** \param[out] outNotChangeMaskPtr pointer of data stored mask value of the bits of OUT register
 ** */
static FUNC(void,PORT_CODE) Port_Arch_CalcRegMaskValue
(
  P2CONST(Port_PinChannelConfigType,AUTOMATIC,PORT_APPL_CONST)  PinConfigDataPtr,
  P2CONST(Port_DriverEnvType,AUTOMATIC,PORT_CONST)              EnvDataPtr,
  P2VAR(uint32, AUTOMATIC, PORT_APPL_DATA)                      cfgNotChangeMaskPtr,
  P2VAR(uint32, AUTOMATIC, PORT_APPL_DATA)                      outNotChangeMaskPtr
)
{
  uint8  portNr;                 /* port number */
  uint8  count;                  /* counter for loop */
  uint32 pinMask;                /* bit position of current port pin */
  uint32 cfg_value;              /* CFG Register value */
  uint32 cfg_port_sel_value;     /* Configuration data for PORT_SELx Register value */
  uint32 dirMask;                /* bit mask for port pin direction */
  uint32 cfg_direction;          /* Configuration data for direction */
  uint32 reg_direction;          /* Register value for direction */
  uint32 drive_mode_mask;        /* Mask value for DRIVE_MODE field of CFG Register */
  
  /* Gets physical port number */
  portNr = (PinConfigDataPtr)->portNumber;
  
  /* Gets value of setting CFG Register */
  cfg_value = Port_ReadCFG(EnvDataPtr, portNr);
  
  *cfgNotChangeMaskPtr = 0U;
  *outNotChangeMaskPtr = 0U;
  /* loop for available pin for a port */
  for ( count = 0U; count < (PORT_MAX_PIN / PORT_MAX_PORT); count++ )
  {
    pinMask = ((uint32)1U << count);  /* Gets pin position for loop count */
    
    /* Checks "current loop count is available pin" */
    if ( ((PinConfigDataPtr)->availablePins & pinMask) != 0U )
    {
      /* Gets mask value for pin direction */
      dirMask = ((((uint32)PORT_GPIO_CFG_IN_EN_MASK << PORT_GPIO_CFG_IN_EN_SHIFT) |
                  (uint32)PORT_GPIO_CFG_DRIVEMODE_MASK) << (PORT_GPIO_CFG_PIN_SHIFT * count));
      drive_mode_mask = (uint32)PORT_GPIO_CFG_DRIVEMODE_MASK;
      
      reg_direction = (cfg_value & dirMask) >> (PORT_GPIO_CFG_PIN_SHIFT * count);
      cfg_direction = ((PinConfigDataPtr)->CFG_Data & dirMask) >> (PORT_GPIO_CFG_PIN_SHIFT * count);
      /* Checks "current pin direction is same with configuration data" */
      if ((cfg_direction == reg_direction) ||
          (((cfg_direction & drive_mode_mask) != 0U) &&
           ((reg_direction & drive_mode_mask) != 0U)))
      {
        /* Calculates mask value for CFG Register */
        *cfgNotChangeMaskPtr |= dirMask;
      }
      
      if (count <= 3U)
      {
        /* Gets mask value for pin mode */
        cfg_port_sel_value = (((PinConfigDataPtr)->PORT_SEL0_Data) >>
                              (PORT_HSIOM_PORT_SEL_PIN_SHIFT * count)) &
                              PORT_HSIOM_PORT_SEL_MASK;
      }
      else
      {
        /* Gets mask value for pin mode */
        cfg_port_sel_value = (((PinConfigDataPtr)->PORT_SEL1_Data) >>
                              (PORT_HSIOM_PORT_SEL_PIN_SHIFT * (count - 4U))) &
                              PORT_HSIOM_PORT_SEL_MASK;
      }
      
      /* Checks "pin configuration mode is not GPIO mode" */
      if (cfg_port_sel_value != PORT_PIN_MODE_GPIO)
      {
        /* Calculates mask value for OUT Register */
        *outNotChangeMaskPtr |= pinMask;
      }
    }
  }
}

#define PORT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: In AUTOSAR specification, it is a necessary process. */
/* PRQA S 5087 1 */
#include <Port_MemMap.h>

/*==================[end of file]============================================*/
