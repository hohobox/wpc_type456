/** \brief AUTOSAR SPI Driver
 **
 ** This file contains implementation of the Spi hardware control functions.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Spi_Hw.h>
#include <Spi_Common.h>
#include <Spi_Internal.h>
#include <Spi_Job.h>
#include <Spi_Channel.h>
#include <Spi_Dma.h>

/*==================[macros]================================================*/
/** \brief SCB enable bit */
#define SPI_SCB_CTRL_DISABLED   (0x0U)
#define SPI_SCB_CTRL_ENABLED    (0x1U)

/** \brief SCB FIFO CLEAR bit */
#define SPI_SCB_FIFO_NOCLEAR    (0x0U)
#define SPI_SCB_FIFO_CLEAR      (0x1U)

/** \brief SCB Interrupt ALL MMASK value */
#define SPI_SCB_INTR_M_MASK_ALL  (0x000U)
#define SPI_SCB_INTR_TX_MASK_ALL (0x000U)
#define SPI_SCB_INTR_RX_MASK_ALL (0x000U)

/** \brief SCB BUS IDLE MMASK value */
#define SPI_SCB_INTR_M_SPI_DONE         (0x200U)
#define SPI_SCB_INTR_M_SPI_DONE_ENABLE  (0x200U)

/** \brief SCB INTR_CAUSE bit mask */
#define SPI_SCB_INTR_CAUSE_M            (0x01U)
#define SPI_SCB_INTR_CAUSE_RX           (0x08U)


/** \brief SCB RX_FIFO not empty mask value */
#define SPI_SCB_INTR_RX_NOT_EMPTY_MASK  (0x04U)

/** \brief SCB RX_FIFO over flow mask value */
#define SPI_SCB_INTR_RX_OVERFLOW_MASK  (0x20U)

/** \brief SCB RX_FIFO trigger mask value */
#define SPI_SCB_INTR_RX_TRIGGER_MASK  (0x01U)

/** \brief SCB TX_FIFO trigger mask value */
#define SPI_SCB_INTR_TX_TRIGGER_MASK  (0x01U)

/** \brief SCB SPI_CTRL CS polarity mask value */
#define SPI_SCB_SPI_CTRL_SSEL_POLARITY_MASK (0x00000F00U)

/** \brief SCB FIFO element size */
#define SPI_FIFO_ELEMENT_SIZE   (4U)
/*****************************/
/* Set Value of SCB  register */
/* CTRL register */
/*   OVS=15, EC_AM_MODE=0, EC_OP_MODE=0, EZ_MODE=0,
     CMD_RESP_MODE=0, MEM_WIDTH=2, ADDR_ACCEPT=0, BLOCK=0, 
     MODE=1, ENABLED=0 
*/
#define SPI_SCB_CTRL_INIT    (0x0100800FU)
/* OVS=15, EC_AM_MODE=0, EC_OP_MODE=0, EZ_MODE=0,
CMD_RESP_MODE=0, MEM_WIDTH=1, ADDR_ACCEPT=0, BLOCK=0, 
MODE=3, ENABLED=0 
*/
#define SPI_SCB_CTRL_UNINIT  (0x0300400FU)
/* SPI_CTRL register */
/*   SSEL_CONTINUOUS=1, SELECT_PRECEDE=0, CPHA=0, CPOL=0, 
     LATE_MISO_SAMPLE=0, SCLK_CONTINUOUS=0, SSEL_POLARITY0=0, 
     SSEL_POLARITY1=0, SSEL_POLARITY2=0, SSEL_POLARITY3=0,
     SSEL_SETUP_DEL=0, SSEL_HOLD_DEL=0, SSEL_INTER_FRAME_DEL=0,
     LOOPBACK=0, MODE=0, SSEL=0, MASTER_MODE=1
*/
#define SPI_SCB_SPI_CTRL_INIT   (0x80000001U)
/* SSEL_CONTINUOUS=0, SELECT_PRECEDE=0, CPHA=0, CPOL=0, 
LATE_MISO_SAMPLE=1, SCLK_CONTINUOUS=0, SSEL_POLARITY0=0, 
SSEL_POLARITY1=0, SSEL_POLARITY2=0, SSEL_POLARITY3=0,
SSEL_SETUP_DEL=0, SSEL_HOLD_DEL=0, SSEL_INTER_FRAME_DEL=0,
LOOPBACK=0, MODE=3, SSEL=0, MASTER_MODE=1
*/
#define SPI_SCB_SPI_CTRL_UNINIT (0x03000010U)
/* SPI_TX_CTRL register */
/*    PARITY=0, PARITY_ENABLED=0
*/
#define SPI_SCB_SPI_TX_CTRL_INIT   (0x00000000U)
#define SPI_SCB_SPI_TX_CTRL_UNINIT SPI_SCB_SPI_TX_CTRL_INIT
/* SPI_RX_CTRL register */
/*    PARITY=0, PARITY_ENABLED=0, DROP_ON_PARITY_ERROR
*/
#define SPI_SCB_SPI_RX_CTRL_INIT   (0x00000000U)
#define SPI_SCB_SPI_RX_CTRL_UNINIT SPI_SCB_SPI_RX_CTRL_INIT
/* TX_CTRL register */
/*    DATA_WIDTH=7, MSB_FIRST=1, OPEN_DRAIN=0
*/
#define SPI_SCB_TX_CTRL_INIT   (0x00000107U)
#define SPI_SCB_TX_CTRL_UNINIT SPI_SCB_TX_CTRL_INIT
/* TX_FIFO_CTRL register */
/*    TRIGGER_LEVEL=0, CLEAR=1, FREEZE=0
*/
#define SPI_SCB_TX_FIFO_CTRL_INIT   (0x00010000U)
/* TX_FIFO_CTRL register */
/*    TRIGGER_LEVEL=0, CLEAR=0, FREEZE=0
*/
#define SPI_SCB_TX_FIFO_CTRL_UNINIT (0x00000000U)
/* RX_CTRL register */
/*    DATA_WIDTH=7, MSB_FIRST=1, MEDIAN=0
*/
#define SPI_SCB_RX_CTRL_INIT   (0x00000107U)
#define SPI_SCB_RX_CTRL_UNINIT SPI_SCB_RX_CTRL_INIT
/* RX_FIFO_CTRL register */
/*    TRIGGER_LEVEL=0, CLEAR=1, FREEZE=0
*/
#define SPI_SCB_RX_FIFO_CTRL_INIT   (0x00010000U)
/* RX_FIFO_CTRL register */
/*    TRIGGER_LEVEL=0, CLEAR=0, FREEZE=0
*/
#define SPI_SCB_RX_FIFO_CTRL_UNINIT (0x00000000U)
/* INTR_I2C_EC_MASK register */
/*    WAKE_UP=0, EZ_STOP=0, EZ_WRITE_STOP=0, WZ_WRITE_READ=0
*/
#define SPI_SCB_INTR_I2C_EC_MASK_INIT   (0x00000000U)
#define SPI_SCB_INTR_I2C_EC_MASK_UNINIT SPI_SCB_INTR_I2C_EC_MASK_INIT
/* INTR_SPI_EC_MASK register */
/*    WAKE_UP=0, EZ_STOP=0, EZ_WRITE_STOP=0, WZ_WRITE_READ=0
*/
#define SPI_SCB_INTR_SPI_EC_MASK_INIT   (0x00000000U)
#define SPI_SCB_INTR_SPI_EC_MASK_UNINIT SPI_SCB_INTR_SPI_EC_MASK_INIT
/* INTR_M register */
/*    I2C_ARB_LOST=1, I2C_NACK=1, I2C_ACK=1, I2C_STOP=1, I2C_BIS_ERROR=1, 
      SPI_DONE=1
*/
#define SPI_SCB_INTR_M_INIT   SPI_SCB_INTR_M_CLEAR
#define SPI_SCB_INTR_M_UNINIT SPI_SCB_INTR_M_INIT
/* INTR_M_MASK register */
/*    I2C_ARB_LOST=0, I2C_NACK=0, I2C_ACK=0, I2C_STOP=0, I2C_BIS_ERROR=0, 
      SPI_DONE=0
*/
#define SPI_SCB_INTR_M_MASK_INIT   SPI_SCB_INTR_M_MASK_ALL
#define SPI_SCB_INTR_M_MASK_UNINIT SPI_SCB_INTR_M_MASK_INIT
/* INTR_S_MASK register */
/*    I2C_ARB_LOST=0, I2C_NACK=0, I2C_ACK=0, I2C_WRITE_STOP=0, I2C_STOP=0,
      I2C_START=0, I2C_ADDR_MATCH=0, I2C_GENERA=0, I2C_BUS_ERROR=0, 
      SPI_EZ_WRITE_STOP=0, SPI_EZ_STOP=0, SPI_BUS_ERROR=0
*/
#define SPI_SCB_INTR_S_MASK_INIT   (0x00000000U)
#define SPI_SCB_INTR_S_MASK_UNINIT SPI_SCB_INTR_S_MASK_INIT
/* INTR_TX register */
/*    TRIGGER=1, NOT_FULL=1, EMPTY=1, OVERFLOW=1, UNDERFLOW=1, 
      BLOCKED=1, UART_NACK=1, UART_DONE=1, UART_ARB_LOST=1
*/
#define SPI_SCB_INTR_TX_INIT   SPI_SCB_INTR_TX_CLEAR
#define SPI_SCB_INTR_TX_UNINIT SPI_SCB_INTR_TX_INIT
/* INTR_TX_MASK register */
/*    TRIGGER=0, NOT_FULL=0, EMPTY=0, OVERFLOW=0, UNDERFLOW=0, 
      BLOCKED=0, UART_NACK=0, UART_DONE=0, UART_ARB_LOST=0
*/
#define SPI_SCB_INTR_TX_MASK_INIT   SPI_SCB_INTR_TX_MASK_ALL
#define SPI_SCB_INTR_TX_MASK_UNINIT SPI_SCB_INTR_TX_MASK_INIT
/* INTR_RX register */
/*    TRIGGER=1, NOT_EMPTY=1, FULL=1, OVERFLOW=1, UNDERFLOW=1, 
      BLOCKED=1, FRAME_ERROR=1, PARITY_ERROR=1, BAUD_DETECT=1,
      BREAK_DETECT=1
*/
#define SPI_SCB_INTR_RX_INIT   SPI_SCB_INTR_RX_CLEAR
#define SPI_SCB_INTR_RX_UNINIT SPI_SCB_INTR_RX_INIT
/* INTR_RX_MASK register */
/*    TRIGGER=0, NOT_EMPTY=0, FULL=0, OVERFLOW=0, UNDERFLOW=0, 
      BLOCKED=0, FRAME_ERROR=0, PARITY_ERROR=0, BAUD_DETECT=0,
      BREAK_DETECT=0
*/
#define SPI_SCB_INTR_RX_MASK_INIT   SPI_SCB_INTR_RX_MASK_ALL
#define SPI_SCB_INTR_RX_MASK_UNINIT SPI_SCB_INTR_RX_MASK_INIT


/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define SPI_START_SEC_CODE_ASIL_B

#include <Spi_MemMap.h>

/** \brief Spi_Hw_GetHwInfo
 **
 ** Returns the HW unit information.
 **
 ** \return Pointer to HW unit information.
 ** \param [in] HwUnit      Id of HW unit.
 **
 */
static FUNC_P2VAR( Spi_HwInfoType, AUTOMATIC, SPI_CODE ) Spi_Hw_GetHwInfo
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
);

/** \brief Spi_Hw_StopHwUnit
 **
 ** Sets the HW unit for SCB to stop transmission.
 **
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job      Id of Job.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
);

/** \brief Spi_Hw_StopFifo
 **
 ** Sets the HW unit for fifo to stop transmission.
 **
 ** \return SPI_OK: Transmission has been finished successfully.
 ** SPI_NOT_OK: Transmission has not been finished successfully.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job      Id of Job.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopFifo
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
);

/** \brief Spi_Hw_DisableSCB
 **
 ** Disable SCB Unit.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_DisableSCB
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr
);

/** \brief Spi_Hw_FinishedDMA
 **
 ** Sets the HW unit to stop transmission for finished.
 **
 ** \return None.
 **
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HwUnit   Id of HW unit.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_FinishedDMA
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
);

/** \brief Spi_Hw_FinishedSCB
 **
 ** Sets the HW unit to stop transmission for finished.
 **
 ** \return None.
 **
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HwUnit   Id of HW unit.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_FinishedSCB
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
);

/** \brief Spi_Hw_StopSCBSend
 **
 ** Sets the HW unit to stop send transmission.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job   Job id.
 ** \param [in] Channel   Channel id.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopSCBSend
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel
);

/** \brief Spi_Hw_StopSCBRecv
 **
 ** Sets the HW unit to stop receive transmission.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job   Job id.
 ** \param [in] Channel   Channel id.
 ** \param [in] Sync   Asynchronous or synchronous transmission.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopSCBRecv
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel,
  CONST(Spi_HWUnitSyncType, TYPEDEF) Sync
);

/** \brief Spi_Hw_StartHwUnit
 **
 ** Starts the SCB transmission.
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HWUnit       Id of HW Unit.
 ** \param [in] Job       Id of Job.
 ** \param [in] Channel   Id of Channel.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StartHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel
);

/** \brief Spi_Hw_SetupFifo
 **
 ** Initial setting before transmission for FIFO
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] UseDMA Using DMA or not.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_SetupFifo
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(boolean, AUTOMATIC) UseDMA
);

/** \brief Spi_Hw_StartFifo
 **
 ** Starts the SCB transmission for FIFO.
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HWUnit       Id of HW Unit.
 ** \param [in] Job       Id of Job.
 ** \param [in] Channel   Id of Channel.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StartFifo
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel
);

/** \brief Spi_Hw_CheckFinishedHwUnit
 **
 ** Checks whether the transmission of SCB is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HwUnit       Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinishedHwUnit
(
  P2CONST(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
);

/** \brief Spi_Hw_CheckFinishedHwUnitPost
 **
 ** Post process of checking whether the transmission is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] Job      Current job id.
 ** \param [in] Result   Result of Spi_Hw_CheckFinishedHwUnit.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinishedHwUnitPost
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ReturnType, AUTOMATIC) Result
);

/** \brief Spi_Hw_CheckFinishedDmaPost
 **
 ** Post process of checking whether the transmission of DMA is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] DmaState   Result of Spi_Dma_CheckFinishedHwUnit.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinishedDmaPost
(
  volatile P2CONST(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(uint8, AUTOMATIC) DmaState
);

/** \brief Spi_Hw_CheckErrorFinished
 **
 ** Checks the cause of SCB error when using DMA.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HwUnit       Id of HW unit.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckErrorFinished
(
  P2CONST(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
);

/** \brief Spi_Hw_InitHwUnit
 **
 ** Initializes the specified HW unit.
 **
 ** \return None.
 ** \param [in] CurScbPtr Pointer to the current SCB register.
 ** \param [in] CurExtDevPtr Pointer to the current external device.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_InitHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) CurExtDevPtr
);

/** \brief Spi_Hw_DeInitHwUnit
 **
 ** De-initializes the specified HW units.
 **
 ** \return None.
 ** \param [in] CurScbPtr Pointer to the current SCB register.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_DeInitHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr
);

/** \brief Spi_Hw_SetupHwUnitSCB
 **
 ** Initial setting of SCB according to external Device configuration.
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr    Pointer to external device configuration.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_SetupHwUnitSCB
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr
);

/** \brief Spi_Hw_SetupHwUnitChannel
 **
 ** Initial setting of SCB according to channel configuration.
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ChannelConfigPtr    Pointer to channel configuration.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_SetupHwUnitChannel
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr
);

/** \brief Spi_Hw_WriteBufferDataToRegister
 **
 ** Get data from the transmission buffer and set it to TX_FIFO.
 **
 ** \return None.
 ** \param [in] CurScbPtr            Pointer to the current SCB register.
 ** \param [in] TxBuffPtr            Pointer to Tx buffer.
 ** \param [in] BytesPerDataElement  Byte size of data width.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_WriteBufferDataToRegister
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) TxBuffPtr,
  VAR(uint8, AUTOMATIC) BytesPerDataElement
);

/** \brief Spi_Hw_WriteRegisterDataToBuffer
 **
 ** Get data from the RX_FIFO and set it to the reception buffer.
 **
 ** \return None.
 ** \param [in] CurScbPtr            Pointer to the current SCB register.
 ** \param [in] RxBuffPtr            Pointer to Rx Buffer
 ** \param [in] BytesPerDataElement  Byte size of data width.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_WriteRegisterDataToBuffer
(
  P2CONST(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) RxBuffPtr,
  VAR(uint8, AUTOMATIC) BytesPerDataElement
);

/** \brief Spi_Hw_DeInitActiveOvs
 **
 ** De-initialize active OVS value of external device.
 **
 ** \return None.
 ** \param None.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_DeInitActiveOvs(void);

/** \brief Spi_Hw_CheckReqSCBDisable
 **
 ** Check if SCB disable is required.
 **
 ** \return                     Check result.
 **                               SPI_FALSE : No need SCB disable
 **                               SPI_TRUE  : Need SCB disable
 ** \param [in] CurExtDevPtr    Pointer to the current external device.
 ** \param [in] NextExtDevPtr   Pointer to the next external device.
 **
 */
static FUNC(uint8, SPI_CODE) Spi_Hw_CheckReqSCBDisable
(
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) CurExtDevPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) NextExtDevPtr
);

/** \brief Spi_Hw_GetBufferDataToBeSent
 **
 ** Get revelant data of the current transmission buffer.
 ** \return None.
 ** \param [in] ChannelInfPtr         Pointer to the channel info
 ** \param [in] ChannelConfigPtr      Pointer to the channel config
 ** \param [in] Pos                   Current position of transmission buffer
 ** \param [in] BytesPerDataElement   Number of bytes per data element
 ** \param [out] BuffPtr              Pointer to the actual transmission buffer
 ** \param [out] BuffPos              Pointer to the variable to store the actual buffer position
 ** \param [out] PosIncrSize          Pointer to the variable to store buffer increment size in bytes 
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_GetBufferDataToBeSent
(
  P2CONST( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) ChannelInfPtr,
  P2CONST( Spi_ChannelConfigType , AUTOMATIC, AUTOMATIC ) ChannelConfigPtr,
  VAR(Spi_NumberOfDataType, AUTOMATIC) Pos,
  VAR(uint8, AUTOMATIC) BytesPerDataElement,
  P2VAR(P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) BuffPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) BuffPos,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PosIncrSize
);

/** \brief Spi_Hw_GetBufferDataToBeReceived
 **
 ** Get revelant data of the current reception buffer.
 ** \return None.
 ** \param [in] ChannelInfPtr         Pointer to the channel info
 ** \param [in] DummyBuff             Pointer to the dummy read buffer
 ** \param [in] Pos                   Current position of reception buffer
 ** \param [in] BytesPerDataElement   Number of bytes per data element
 ** \param [out] BuffPtr              Pointer to the actual reception buffer
 ** \param [out] BuffPos              Pointer to the variable to store the actual buffer position
 ** \param [out] PosIncrSize          Pointer to the variable to store buffer increment size in bytes 
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_GetBufferDataToBeReceived
(
  P2CONST( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) ChannelInfPtr,
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) DummyBuff,
  VAR(Spi_NumberOfDataType, AUTOMATIC) Pos,
  VAR(uint8, AUTOMATIC) BytesPerDataElement,
  P2VAR(P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) BuffPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) BuffPos,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PosIncrSize
);

/** \brief Spi_Hw_GetHwUnitInternalStatus
 **
 ** Returns the transmission/reception status of the specified HW unit.
 **
 ** \return HW unit internal status.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   the factor of the transmission or reception.
 **
 */
static FUNC(uint8, SPI_CODE) Spi_Hw_GetHwUnitInternalStatus
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
);

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Hw_StartTransmit
 **
 ** Sets the HW unit to start transmission.
 **
 ** \return None.
 ** \param [in] Job       Id of Job.
 ** \param [in] Channel   Id of Channel.
 ** \param [in] SyncType  Synchronous or asynchronous.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_StartTransmit
(
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel,
  VAR(Spi_HWUnitSyncType, AUTOMATIC) SyncType
)
{
  VAR( uint8, AUTOMATIC ) LevelDelivered; /* level delivered */
  VAR( Spi_AsyncModeType, AUTOMATIC ) AsyncMode; /* async mode */
  VAR(Spi_ChannelIndexType, TYPEDEF) Index;
  
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) ExtDevPtr = 
      Spi_Current_ConfigPtr->JobConfigListPtr[Job].ExternalDevicePtr;
  /* get pointer to SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = 
      Spi_Current_ConfigPtr->ScbRegsPtr[ExtDevPtr->HwUnit];

  /* enter a critical section */
  /* avoid contention with Terminate */
  Spi_Com_SchMEnterCriticalSection();

  if ( (ExtDevPtr->UseDma == SPI_FALSE) || ( SyncType == SPI_HWUNIT_SYNC ))
  {
    if ( ( ExtDevPtr->UseFifo == SPI_FALSE ) || ( SyncType == SPI_HWUNIT_SYNC ) )
    {
      /* start transmission using SCB. Only for non dma-use Sync Transmit. */
      Spi_Hw_StartHwUnit(CurScbPtr, ExtDevPtr->HwUnit, Job, Channel);
    }
    else
    { /* For non-dma async transmit */
      /* setup before transmission for FIFO */
      Spi_Hw_SetupFifo(CurScbPtr, SPI_FALSE);
      /* start transmission using SCB for FIFO */
      Spi_Hw_StartFifo(CurScbPtr, ExtDevPtr->HwUnit, Job, Channel);
    }
  }
  else
  { /* For dma async transmit */

    /* set buffer position */
    Spi_Info.HwInfoListPtr[ExtDevPtr->HwUnit].BufferPosReceived = 0U;

    /* set buffer position of current channel */
    for( Index = 0U; Index < Spi_Current_ConfigPtr->JobConfigListPtr[Job].ChannelCount; Index++)
    {
      Spi_Info.ChannelInfoListPtr[Spi_Current_ConfigPtr->JobConfigListPtr[Job].ChannelListPtr[Index]].BufferPosStoredForSend = 0U;
      Spi_Info.ChannelInfoListPtr[Spi_Current_ConfigPtr->JobConfigListPtr[Job].ChannelListPtr[Index]].BufferPosReceived = 0U;
    }

    /* Initial setting for using DMA  */
    Spi_Dma_SetupHwUnit( Job );
    if ( ExtDevPtr->UseFifo == SPI_TRUE )
    {
      /* Only when using FIFO */
      /* setup before transmission for FIFO */
      Spi_Hw_SetupFifo(CurScbPtr, SPI_TRUE);
    }

    /* Get level delivered and async mode */
    LevelDelivered = Spi_Com_GetLevelDelivered();
    AsyncMode = Spi_Internal_GetAsyncMode();

    /* interrupt will be set enabled if the Level1 or the Interrupt mode. */
    if ( (LevelDelivered == SPI_LEVEL_DELIVERED_1)
    ||   (AsyncMode != SPI_POLLING_MODE) )
    {
      /* start transmission for using DMA (enable interrupt)  */
      Spi_Dma_StartHwUnit( ExtDevPtr->HwUnit, SPI_TRUE );
    }
    else
    {
      /* start transmission for using DMA (disable interrupt)  */
      Spi_Dma_StartHwUnit( ExtDevPtr->HwUnit, SPI_FALSE );
    }
  }
  /* Set to the waiting for transmission/reception state */
  Spi_Info.HwInfoListPtr[ExtDevPtr->HwUnit].TxStatus = SPI_NOT_OK;
  Spi_Info.HwInfoListPtr[ExtDevPtr->HwUnit].RxStatus = SPI_NOT_OK;
  /* exit a critical section */
  Spi_Com_SchMExitCriticalSection();
}

/** \brief Spi_Hw_SetupHwUnit
 **
 ** Initial setting of SCB according to job configuration.
 **
 ** \return None.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_SetupHwUnit
(
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr
)
{
  P2VAR( Spi_HwInfoType, AUTOMATIC, AUTOMATIC ) CurHwInfoPtr;
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr;
  
  /* Get current HwInfo pointer */
  CurHwInfoPtr = &(Spi_Info.HwInfoListPtr[ExternalDevicePtr->HwUnit]);

  /* get pointer to SCB register information */
  CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[ExternalDevicePtr->HwUnit];

  if (Spi_Hw_CheckReqSCBDisable(CurHwInfoPtr->ExtDevicePtr, 
    ExternalDevicePtr) == SPI_TRUE)
  { /* Need to change SCB setting with disabling */
    /* Setup for SCB */
    Spi_Hw_SetupHwUnitSCB(CurScbPtr, ExternalDevicePtr);
  }
  else
  { /* Set SSEL */
    if ((ExternalDevicePtr->EnableCs == SPI_TRUE) && 
      (ExternalDevicePtr->CsSelection == SPI_CS_VIA_PERIPHERAL_ENGINE))
    {
      CurScbPtr->unSPI_CTRL.stcField.u2SSEL = ExternalDevicePtr->CsIdentifier;
    }
    else
    {
      CurScbPtr->unSPI_CTRL.stcField.u2SSEL = SPI_SELECT0;
    }
  }
  CurHwInfoPtr->ExtDevicePtr = ExternalDevicePtr;
}

/** \brief Spi_Hw_SetupChannel
 **
 ** Sets the HW unit for SCB channel configuration.
 **
 ** \return None.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] ChannelConfigPtr    Pointer to channel configuration.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_SetupChannel
(
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr
)
{
  /* get pointer to SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr =
    Spi_Current_ConfigPtr->ScbRegsPtr[ExternalDevicePtr->HwUnit];

  /* Setup for specified channel */
  Spi_Hw_SetupHwUnitChannel(CurScbPtr, ChannelConfigPtr);
}

/** \brief Spi_Hw_Finished
 **
 ** Sets the HW unit to stop transmission for finished.
 **
 ** \return None.
 **
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HwUnit   Id of HW unit.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_Finished
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  /* Check Factor */
  if ( (Factor == SPI_HW_FACTOR_SCB_RX) || (Factor == SPI_HW_FACTOR_SCB_TX) )
  {
    /* When the Job does not use DMA. */
    Spi_Hw_FinishedSCB(Factor, HwUnit);
  }
  else
  {
    /* When the Job uses DMA. */
    Spi_Hw_FinishedDMA(Factor, HwUnit);
  }
}

/** \brief Spi_Hw_SyncFinished
 **
 ** Sets the HW unit to stop transmission for Sync.
 **
 ** \return None.
 **
 ** \param [in] JobConfigPtr    Pointer of Job config.
 ** \param [in] HwUnit          Id of HW unit.
 ** \param [in] Factor          Specify the factor of the transmission or 
 **                             reception.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_SyncFinished
(
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* get pointer to SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[HwUnit];

  /* enter a critical section */
  /* avoid contention with Terminate */
  Spi_Com_SchMEnterCriticalSection();
  /* Check Factor */
  Spi_Hw_StopHwUnit(CurScbPtr, JobConfigPtr->ExternalDevicePtr, JobConfigPtr->JobId, Factor);
  /* exit a critical section */
  Spi_Com_SchMExitCriticalSection();
}

/** \brief Spi_Hw_CheckFinished
 **
 ** Checks whether the transmission is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HwUnit   Id of Channel.
 **
 */
FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinished
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  VAR(Spi_ReturnType, AUTOMATIC) RetVal = SPI_NOT_OK; /* return value */
  VAR(uint8, AUTOMATIC) DmaState; /* DMA check result */
  VAR(Spi_ChannelIndexType, AUTOMATIC) CurTxChannelIndex;
  VAR(Spi_ChannelType, AUTOMATIC) CurTxChannel;
  
  /* get pointer to SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[HwUnit];
  /* get current job id */
  VAR(Spi_JobType, AUTOMATIC) CurrentJob = Spi_Info.DriverHwInfoListPtr[HwUnit].Job;
  
  if ( CurrentJob == SPI_INVALID_JOB )
  {
    /* disable reception and transmission and clear error flag */
    Spi_Hw_DisableSCB(CurScbPtr);
  }
  else
  {
    /* Check Factor */
    if( Factor == SPI_HW_FACTOR_SCB_TX )
    {
      CurTxChannelIndex = Spi_Info.JobInfoListPtr[CurrentJob].CurTxChannelIndex;
      CurTxChannel = Spi_Current_ConfigPtr->JobConfigListPtr[CurrentJob].ChannelListPtr[CurTxChannelIndex];

      if( Spi_Info.ChannelInfoListPtr[CurTxChannel].BufferPosStoredForSend >= 
          Spi_Info.ChannelInfoListPtr[CurTxChannel].BufferSize )
      {
        RetVal = Spi_Hw_CheckFinishedHwUnit(CurScbPtr, HwUnit, Factor);
        RetVal = Spi_Hw_CheckFinishedHwUnitPost(Factor, CurrentJob, RetVal);
      }
    }
    else if ( Factor == SPI_HW_FACTOR_SCB_RX )
    { /* SCB Interrupt occurred */
      RetVal = Spi_Hw_CheckFinishedHwUnit(CurScbPtr, HwUnit, Factor);
      RetVal = Spi_Hw_CheckFinishedHwUnitPost(Factor, CurrentJob, RetVal);
    }
    else if ( Factor == SPI_HW_FACTOR_SCB_ERROR )
    {
      /* when SCB error is detected */
      RetVal = Spi_Hw_CheckErrorFinished(CurScbPtr, HwUnit);
    }
    else
    {
      /* DMA Interrupt occurred */
      DmaState = Spi_Dma_CheckFinishedHwUnit(HwUnit, Factor);
      RetVal = Spi_Hw_CheckFinishedDmaPost(CurScbPtr, HwUnit, Factor, DmaState);
    }
  }
  return RetVal;
}

/** \brief Spi_Hw_ValidateEvent
 **
 ** Validates the Event and transmission/reception status.
 **
 ** \return SPI_OK: transmission and reception have been finished.
 ** SPI_NOT_OK: transmission and reception have not been finished.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [out] EventStatus   Pointer to event status.
 **
 */
FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_ValidateEvent
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) EventStatusPtr
)
{
  VAR(Spi_ReturnType, AUTOMATIC) RetVal = SPI_OK;
  VAR(Spi_ReturnType, AUTOMATIC) StatusTx = Spi_Hw_GetHwUnitInternalStatus(HwUnit, SPI_HW_FACTOR_SCB_TX);
  VAR(Spi_ReturnType, AUTOMATIC) StatusRx = Spi_Hw_GetHwUnitInternalStatus(HwUnit, SPI_HW_FACTOR_SCB_RX);
  
  if ( (StatusTx == SPI_FAILED) || (StatusRx == SPI_FAILED) )
  {
    *EventStatusPtr = SPI_DEM_EVENT_STATUS_FAILED;
  }
  else
  {
    *EventStatusPtr = SPI_DEM_EVENT_STATUS_PASSED;
  }
  if ( (StatusTx == SPI_NOT_OK) || (StatusRx == SPI_NOT_OK) )
  {
    RetVal = SPI_NOT_OK;
  }
  return RetVal;
}

/** \brief Spi_Hw_SetHwUnitStatus
 **
 ** Sets the status of the specified HW unit.
 **
 ** \return None.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Status   HW unit status.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_SetHwUnitStatus
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_StatusType, AUTOMATIC) Status
)
{
  /* helpers to avoid too many lookups */
  P2VAR( Spi_HwInfoType, AUTOMATIC, AUTOMATIC ) CurHwInfoPtr = &(Spi_Info.HwInfoListPtr[HwUnit]);
  
  /* sets the status for the specified HW unit */
  CurHwInfoPtr->Status = Status;
}


/** \brief Spi_Hw_Init
 **
 ** Initializes the all HW units.
 **
 ** \return None.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_Init(void)
{
  /* counter for external devices */
  VAR(Spi_ExtDeviceType, AUTOMATIC) ExtDevCnt;
  /* Number of external devices */
  VAR(uint8, AUTOMATIC) MaxExtDevices;
  /* Pointer to external device config */
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) CurExtDevicePtr;
  /* Pointer to SCB register */
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, AUTOMATIC) CurScbPtr;
  /* pointer to HW information of each HW units */
  P2VAR( Spi_HwInfoType, AUTOMATIC, AUTOMATIC ) CurHwInfoPtr;
  /* counter for HW unit */
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnitCnt;
  /* Number of HW units */
  VAR(uint8, AUTOMATIC) MaxHwUnit; 

  /* get a maximum number of external device */
  MaxExtDevices = Spi_Current_ConfigPtr->ExternalDeviceCount;
  /* Get number of HW units */
  MaxHwUnit = Spi_Com_GetMaxNrOfHwUnits();
  for (ExtDevCnt=0U; ExtDevCnt<MaxExtDevices; ExtDevCnt++)
  {
    CurExtDevicePtr = &( Spi_Current_ConfigPtr->ExternalDevicesPtr[ExtDevCnt] );
    /* Initialize active OVS value of external device. */
    *(CurExtDevicePtr->ActiveOvsPtr) = CurExtDevicePtr->OVSSetting;

    /* Get current SCB register */
    CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[CurExtDevicePtr->HwUnit];
    CurHwInfoPtr = &(Spi_Info.HwInfoListPtr[CurExtDevicePtr->HwUnit]);
    /* initialize SCB register */
    if ( NULL_PTR != CurScbPtr )
    { /* avarable SCB */
      Spi_Hw_InitHwUnit(CurScbPtr, CurExtDevicePtr);
      /* initialize HW information */
      CurHwInfoPtr->Status = SPI_IDLE;
      CurHwInfoPtr->ExtDevicePtr = CurExtDevicePtr;
    }
    else
    {
      /* initialize HW information */
      CurHwInfoPtr->Status = SPI_UNINIT;
      CurHwInfoPtr->ExtDevicePtr = NULL_PTR;
    }
    CurHwInfoPtr->TxStatus = SPI_OK;
    CurHwInfoPtr->RxStatus = SPI_OK;
    CurHwInfoPtr->BufferPosReceived = 0U;
  }
  /* Enable SCB */
  for ( HwUnitCnt = 0U; HwUnitCnt < MaxHwUnit; HwUnitCnt++ )
  {
    /* Get current SCB register */
    CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[HwUnitCnt];
    if ( NULL_PTR != CurScbPtr )
    { /* avarable SCB */
      /* initialize DMA transmit channel */
      Spi_Dma_Init(HwUnitCnt, SPI_HW_FACTOR_DMA_TX);
      /* initialize DMA reception channel */
      Spi_Dma_Init(HwUnitCnt, SPI_HW_FACTOR_DMA_RX);
      
      /* enable SCB unit */
      CurScbPtr->unCTRL.stcField.u1ENABLED = STD_ON;
    }
  }
}

/** \brief Spi_Hw_DeInit
 **
 ** De-initializes the all HW units.
 **
 ** \return None.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_DeInit(void)
{
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnitCnt; /* counter for HW unit */
  VAR(uint8, AUTOMATIC) MaxHwUnit; /* Number of HW units */
  /* Pointer to SCB register */
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, AUTOMATIC) CurScbPtr;
  /* Pointer to HW information of each HW units */
  P2VAR( Spi_HwInfoType, AUTOMATIC, AUTOMATIC ) CurHwInfoPtr;
  VAR( Spi_JobIndexType, AUTOMATIC ) JobIndex;
  
  /* Get number of HW units */
  MaxHwUnit = Spi_Com_GetMaxNrOfHwUnits();

  /* De-initialize Active OVS value */
  Spi_Hw_DeInitActiveOvs();

  for ( HwUnitCnt = 0U; HwUnitCnt < MaxHwUnit; HwUnitCnt++ )
  {
    CurHwInfoPtr = &(Spi_Info.HwInfoListPtr[HwUnitCnt]);

    /* Get current SCB register */
    CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[HwUnitCnt];
        
    if ( NULL_PTR != CurScbPtr )
    {
      Spi_Hw_DeInitHwUnit(CurScbPtr);
      /* de-initialize DMA transmit channel */
      Spi_Dma_DeInit(HwUnitCnt, SPI_HW_FACTOR_DMA_TX);
      /* de-initialize DMA reception channel */
      Spi_Dma_DeInit(HwUnitCnt, SPI_HW_FACTOR_DMA_RX);
    }
    /* initialize HW information */
    CurHwInfoPtr->Status = SPI_UNINIT;
    CurHwInfoPtr->ExtDevicePtr = NULL_PTR;
  }
  
  /* Deinitialize all descriptor in all job */
  for ( JobIndex = 0U; JobIndex < Spi_Current_ConfigPtr->JobCount; JobIndex++ )
  {
    if (Spi_Current_ConfigPtr->JobConfigListPtr[JobIndex].ExternalDevicePtr->UseDma != SPI_FALSE)
    {
      Spi_Dma_DeInitDescriptor(JobIndex);
    }
  }
}

/** \brief Spi_Hw_TerminateHwUnit
 **
 ** Terminate the HW unit.
 **
 ** \return SPI_OK:     Terminate command has been accepted
 **         SPI_NOT_OK: Terminate command has not been accepted
 **
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] SyncType            Synchronous or asynchronous.
 **
 */
FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_TerminateHwUnit
(
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_HWUnitSyncType, AUTOMATIC) SyncType
)
{
  /* SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr;
  /* get transmission and reception status */
  VAR(Spi_ReturnType, AUTOMATIC) StatusTx = 
    Spi_Hw_GetHwUnitInternalStatus(ExternalDevicePtr->HwUnit, SPI_HW_FACTOR_SCB_TX);
  VAR(Spi_ReturnType, AUTOMATIC) StatusRx =
    Spi_Hw_GetHwUnitInternalStatus(ExternalDevicePtr->HwUnit, SPI_HW_FACTOR_SCB_RX);
  VAR(Spi_ReturnType, AUTOMATIC) RetVal;
  /* SCB TX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unTxFifoCtrl; 
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl; 
  /* check transmission and reception status */
  if ( ( StatusTx == SPI_NOT_OK ) || ( StatusRx == SPI_NOT_OK ) )
  {
    /* get pointer to SCB register information */
    CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[ExternalDevicePtr->HwUnit];

    /* Disable reception and transmission */
    unTxFifoCtrl.u32Register = CurScbPtr->unTX_FIFO_CTRL.u32Register;
    unRxFifoCtrl.u32Register = CurScbPtr->unRX_FIFO_CTRL.u32Register;
    unTxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
    unRxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
    CurScbPtr->unTX_FIFO_CTRL.u32Register = unTxFifoCtrl.u32Register;
    CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;

    /* disable interrupts and clear error flag */
    CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_MASK_UNINIT;
    CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_UNINIT;
    (void)CurScbPtr->unINTR_M.u32Register;
    CurScbPtr->unINTR_TX_MASK.u32Register = SPI_SCB_INTR_TX_MASK_UNINIT;
    CurScbPtr->unINTR_TX.u32Register = SPI_SCB_INTR_TX_UNINIT;
    (void)CurScbPtr->unINTR_TX.u32Register;
    CurScbPtr->unINTR_RX_MASK.u32Register = SPI_SCB_INTR_RX_MASK_UNINIT;
    CurScbPtr->unINTR_RX.u32Register = SPI_SCB_INTR_RX_UNINIT;
    (void)CurScbPtr->unINTR_RX.u32Register;

    /* updates internal status */
    Spi_Info.HwInfoListPtr[ExternalDevicePtr->HwUnit].TxStatus = SPI_FAILED;
    Spi_Info.HwInfoListPtr[ExternalDevicePtr->HwUnit].RxStatus = SPI_FAILED;
    /* only used DMA */
    if ( ( ExternalDevicePtr->UseDma == SPI_TRUE )
      && ( SyncType == SPI_HWUNIT_ASYNC ) )
    {
      /* stop DMA for transmission */
      Spi_Dma_StopHwUnit(ExternalDevicePtr->HwUnit, SPI_HW_FACTOR_DMA_TX);
      /* stop DMA for reception */
      Spi_Dma_StopHwUnit(ExternalDevicePtr->HwUnit, SPI_HW_FACTOR_DMA_RX);
    }
    /* set result to ok */
    RetVal = SPI_OK;
  }
  else
  {
    /* set result to ng */
    RetVal = SPI_NOT_OK;
  }
  return RetVal;
}

/** \brief Spi_Hw_ChangeOvs
 **
 ** Change over sampling setting of SCB CTRL.OVS bits to Active OVS value.
 **
 ** \return None
 **
 ** \param [in] ExtDev        Id of external device.
 ** \param [in] ScbOvsValue   Value of OVS bits in SCB CTRL register.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_ChangeOvs
(
  CONST(Spi_ExtDeviceType, AUTOMATIC) ExtDev,
  VAR(Spi_OvsValueType, AUTOMATIC) ScbOvsValue
)
{
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) ExtDeviceConfigPtr;
  P2VAR( Spi_HwInfoType, AUTOMATIC, AUTOMATIC ) CurHwInfoPtr;


  /* get a external device config pointer*/
  ExtDeviceConfigPtr = &( Spi_Current_ConfigPtr->ExternalDevicesPtr[ExtDev] );
  
  /* Get current external device pointer */
  CurHwInfoPtr = &(Spi_Info.HwInfoListPtr[ExtDeviceConfigPtr->HwUnit]);
  
  /* Set OVS value */
  *(ExtDeviceConfigPtr->ActiveOvsPtr) = ScbOvsValue;
  /* Check Valid HWUnit */
  if ( CurHwInfoPtr != (Spi_HwInfoType *)NULL_PTR )
  {
    if (CurHwInfoPtr->ExtDevicePtr == ExtDeviceConfigPtr)
    { /* Target device is current device */
      /* get pointer to SCB register information */
      volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr =
        Spi_Current_ConfigPtr->ScbRegsPtr[ExtDeviceConfigPtr->HwUnit];

      if (CurScbPtr != (volatile Spi_SCBRegsType *)NULL_PTR)
      {
        /* Disable SCB */
        CurScbPtr->unCTRL.stcField.u1ENABLED = STD_OFF;
        /* Change OVS */
        CurScbPtr->unCTRL.stcField.u4OVS = ScbOvsValue;
        /* Enable SCB */
        CurScbPtr->unCTRL.stcField.u1ENABLED = STD_ON;
      }
    }
  }
}

/** \brief Spi_Hw_JudgeSCBFactor
 **
 ** Judge Factor type of SCB interrupts.
 **
 ** \return The factor of the transmission or reception.
 **
 ** \param [in] HwUnit        Hw Unit Id
 **
 */
FUNC(Spi_HwFactorType, SPI_CODE) Spi_Hw_JudgeSCBFactor
(
  CONST(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  /* SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = 
    Spi_Current_ConfigPtr->ScbRegsPtr[HwUnit];
  /* Return value */
  VAR(Spi_HwFactorType, AUTOMATIC) RetVal = SPI_HW_FACTOR_SCB_ERROR;
  /* SCB INTR_CAUSE register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_Cause_Type, AUTOMATIC) unIntrCause;
  /* SCB INTR_M register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_M_Type, AUTOMATIC)     unIntrM;
  /* SCB INTR_M_MASK register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_M_Type, AUTOMATIC)     unIntrMMask;
  /* SCB INTR_RX register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_Rx_Type, AUTOMATIC)    unIntrRx;
  /* SCB INTR_RX_MASK register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_Rx_Type, AUTOMATIC)    unIntrRxMask;

  /* register value */
  unIntrCause.u32Register  = CurScbPtr->unINTR_CAUSE.u32Register;
  unIntrM.u32Register      = CurScbPtr->unINTR_M.u32Register;
  unIntrMMask.u32Register  = CurScbPtr->unINTR_M_MASK.u32Register;
  unIntrRx.u32Register     = CurScbPtr->unINTR_RX.u32Register;
  unIntrRxMask.u32Register = CurScbPtr->unINTR_RX_MASK.u32Register;

  if ( (unIntrCause.u32Register & SPI_SCB_INTR_CAUSE_M) != 0U )
  { /* SPI_DONE ? */
    if ( (unIntrM.stcField.u1SPI_DONE == STD_HIGH) && (unIntrMMask.stcField.u1SPI_DONE == STD_HIGH) )
    { /* Detect SPI_DONE */
      VAR(Spi_JobType, AUTOMATIC) CurrentJob = Spi_Info.DriverHwInfoListPtr[HwUnit].Job;
      P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr;
      JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurrentJob] );
      if ( JobConfigPtr->ExternalDevicePtr->UseDma == SPI_TRUE )
      { /* DMA use */
        RetVal = SPI_HW_FACTOR_DMA_TX;
      }
      else
      { /* Not DMA use */
        RetVal = SPI_HW_FACTOR_SCB_TX;
      }
    }
  }
  else if ( (unIntrCause.u32Register & SPI_SCB_INTR_CAUSE_RX) != 0U )
  {
    if ( (unIntrRx.stcField.u1TRIGGER == STD_HIGH) && (unIntrRxMask.stcField.u1TRIGGER == STD_HIGH) )
    { /* Detect Receive trigger */
      RetVal = SPI_HW_FACTOR_SCB_RX;
    }    
  }
  else
  { /* Others should be error */
    RetVal = SPI_HW_FACTOR_SCB_ERROR;
  }
  return RetVal;
}

/** \brief Spi_Hw_JudgeDMAFactor
 **
 ** Judge error or complettion of SPI used  DMA channels.
 **
 ** \return The factor of the transmission or reception.
 **
 ** \param [in] HwUnit    Hw Unit Id
 ** \param [in] Factor    Specify the factor of the transmission or reception.
 **
 */
FUNC(Spi_HwFactorType, SPI_CODE) Spi_Hw_JudgeDMAFactor
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* DMA channel register information */
  volatile P2VAR(Spi_DmaChannelRegsType, AUTOMATIC, REGSPACE) CurDmaChannelRegPtr = 
      Spi_Com_GetDmaChannelRegPtr(HwUnit, Factor);
  /* SCB register information */
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = 
      Spi_Current_ConfigPtr->ScbRegsPtr[HwUnit];
  /* DMA Channel CH_STATUS register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Dw1_Ch_Status_Type, AUTOMATIC) unChStatus;
  /* DMA Channel INTR_MASK register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Dw1_Intr_Type, AUTOMATIC) unIntrMask;
  
  VAR(Spi_HwFactorType, AUTOMATIC) RetVal = SPI_HW_FACTOR_DMA_ERROR;

  unChStatus.u32Register = CurDmaChannelRegPtr->unCH_STATUS.u32Register;
  unIntrMask.u32Register = CurDmaChannelRegPtr->unINTR_MASK.u32Register;

  if ( unChStatus.stcField.u4INTR_CAUSE  == SPI_DMA_INTR_CAUSE_COMPLETION )
  { /* Only completion */
    if ( unIntrMask.stcField.u1CH == STD_HIGH )
    {
      if (CurScbPtr->unINTR_RX.stcField.u1OVERFLOW == STD_HIGH)
      { /* Hardware error detect */
        RetVal = SPI_HW_FACTOR_SCB_ERROR;
      }
      else
      {
        RetVal = Factor;
      }
    }
  }
  return RetVal;
}

/** \brief Spi_Hw_InitDescriptor
 **
 ** Initialize descriptor for channel.
 **
 ** \return None.
 ** \param [in] Job    Id of Job.
 **
 */
FUNC(void, SPI_CODE) Spi_Hw_InitDescriptor
(
  VAR(Spi_JobType, AUTOMATIC) Job
)
{
  Spi_Dma_InitDescriptor( Job );
}

/** \brief Spi_Hw_UpdateDescriptor
 **
 ** Update descriptor for channel.
 **
 ** \return None.
 ** \param [in] Channel Channel ID
 **                 
 ** \param [in] SrcDataBufferPtr Pointer to source data buffer
 **                 
 ** \param [in] DesDataBufferPtr
 **             Pointer to destination data buffer in RAM
 ** \param [in] Length
 *              Length (in number of data elements) of the data to be  
 **             transmitted from SrcdataBufferPtr and/or received 
 **             from DesDataBufferPtr.
 **               Min.: 1
 **               Max.: Maximum of data specified at configuration
 **                     for this channel **
 */
FUNC(void, SPI_CODE) Spi_Hw_UpdateDescriptor
(
  VAR( Spi_ChannelType, AUTOMATIC ) Channel,
  P2CONST( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) SrcDataBufferPtr,
  P2VAR( Spi_DataBufferType, AUTOMATIC, AUTOMATIC ) DesDataBufferPtr,
  VAR( Spi_NumberOfDataType, AUTOMATIC ) Length
)
{
  Spi_Dma_UpdateDescriptor(Channel, SrcDataBufferPtr, DesDataBufferPtr, Length);
}

/** \brief Spi_Hw_ClearAllIrqFactor
 **
 ** Clear All Interrupt request factors
 **
 ** \return None.
 ** \param [in] CurScbPtr Pointer to the current SCB register.
 */
FUNC(void, SPI_CODE) Spi_Hw_ClearAllIrqFactor
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr
)
{
  /* Clear All Irq factor */
  CurScbPtr->unINTR_I2C_EC.u32Register = SPI_SCB_INTR_FACTOR_CLEAR;
  CurScbPtr->unINTR_SPI_EC.u32Register = SPI_SCB_INTR_FACTOR_CLEAR;
  CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_CLEAR;
  CurScbPtr->unINTR_S.u32Register = SPI_SCB_INTR_FACTOR_CLEAR;
  CurScbPtr->unINTR_TX.u32Register = SPI_SCB_INTR_TX_CLEAR;
  CurScbPtr->unINTR_RX.u32Register = SPI_SCB_INTR_RX_CLEAR;
  (void) CurScbPtr->unINTR_RX.u32Register;
}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[internal function definitions]==========================*/

#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Hw_GetHwInfo
 **
 ** Returns the HW unit information.
 **
 ** \return Pointer to HW unit information.
 ** \param [in] HwUnit      Id of HW unit.
 **
 */
static FUNC_P2VAR( Spi_HwInfoType, AUTOMATIC, SPI_CODE ) Spi_Hw_GetHwInfo
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  /* get a pointer for the relevant Hw unit information */
  return &( Spi_Info.HwInfoListPtr[HwUnit] );
}


/** \brief Spi_Hw_CheckFinishedHwUnit
 **
 ** Checks whether the transmission of SCB is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HwUnit       Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinishedHwUnit
(
  P2CONST(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* return value */
  VAR(Spi_ReturnType, AUTOMATIC) RetVal = SPI_NOT_OK;
  /* SCB INTR_RX register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_Rx_Type, AUTOMATIC)   unIntrRx;

  /* transmission interrupt */
  if ( Factor == SPI_HW_FACTOR_SCB_TX )
  {
    /* Check bus idle flag */
    if( ((CurScbPtr->unINTR_M.u32Register & SPI_SCB_INTR_M_SPI_DONE) != 0U) &&
        (CurScbPtr->unTX_FIFO_STATUS.stcField.u9USED == 0U) )
    { /* Bus idle */
      if( CurScbPtr->unSPI_STATUS.stcField.u1BUS_BUSY == 0U )
      {
        RetVal = SPI_OK;
      }
    }
  }
  /* reception interrupt */
  else
  {
    /* get INTR_RX value */
    unIntrRx.u32Register = CurScbPtr->unINTR_RX.u32Register;
    /* Checks all error (Overflow) flags regardless of FIFO and DMA usage. */
    if ( (unIntrRx.u32Register & SPI_SCB_INTR_RX_OVERFLOW_MASK) != 0U )
    {
      /* detect HW error */
      Spi_Info.HwInfoListPtr[HwUnit].TxStatus = SPI_FAILED;
      Spi_Info.HwInfoListPtr[HwUnit].RxStatus = SPI_FAILED;
      RetVal = SPI_OK;
    }
    else if ( unIntrRx.stcField.u1NOT_EMPTY != STD_LOW )
    { /* Data was received */
      RetVal = SPI_OK;
    }
    else
    {
      RetVal = SPI_NOT_OK;
    }
  }
  return RetVal;
}

/** \brief Spi_Hw_CheckFinishedHwUnitPost
 **
 ** Post process of checking whether the transmission is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] Job      Current job id.
 ** \param [in] Result   Result of Spi_Hw_CheckFinishedHwUnit.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinishedHwUnitPost
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ReturnType, AUTOMATIC) Result
)
{
  /* current job config */
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr =
    &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  /* Index of currently transmitted channel in channel list */
  VAR(Spi_ChannelIndexType, TYPEDEF) ChannelIndex;
  /* return value */
  VAR(Spi_ReturnType, AUTOMATIC) RetVal; /* return value */

  RetVal = Result;
  if ( (Factor == SPI_HW_FACTOR_SCB_TX) && (RetVal == SPI_OK ) )
  {
    ChannelIndex = Spi_Job_GetChannelIndex( Job, SPI_HW_FACTOR_SCB_TX );      
    if ( ((ChannelIndex + 1U) < JobConfigPtr->ChannelCount) && 
      (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
    { /* Not last channel */
       RetVal = SPI_NOT_OK;
    }
  }
  return RetVal;
}

/** \brief Spi_Hw_CheckFinishedDmaPost
 **
 ** Post process of checking whether the transmission of DMA is finished or not.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] DmaState   Result of Spi_Dma_CheckFinishedHwUnit.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckFinishedDmaPost
(
  volatile P2CONST(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(uint8, AUTOMATIC) DmaState
)
{
  /* return value */
  VAR(Spi_ReturnType, AUTOMATIC) RetVal; /* return value */

  if ( DmaState == SPI_FAILED )
  {
    Spi_Info.HwInfoListPtr[HwUnit].TxStatus = DmaState;
    Spi_Info.HwInfoListPtr[HwUnit].RxStatus = DmaState;
    RetVal = SPI_OK;
  }
  else if ( Factor == SPI_HW_FACTOR_DMA_TX )
  {
    RetVal = DmaState;
    /* Check bus idle flag when last transmit */
    if( ((DmaState == SPI_OK) || (Spi_Info.HwInfoListPtr[HwUnit].RxStatus == SPI_OK)) &&
        ((CurScbPtr->unINTR_M.u32Register & SPI_SCB_INTR_M_SPI_DONE) != 0U) )
    {
      RetVal = SPI_OK;
    }
  }
  else
  {
    RetVal = DmaState;
  }
  return RetVal;
}

/** \brief Spi_Hw_CheckErrorFinished
 **
 ** Checks the cause of SCB error when using DMA.
 **
 ** \return SPI_OK: Transmission has been finished.
 ** SPI_NOT_OK: Transmission has not been finished.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HwUnit       Id of HW unit.
 **
 */
static FUNC(Spi_ReturnType, SPI_CODE) Spi_Hw_CheckErrorFinished
(
  P2CONST(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  VAR(Spi_ReturnType, AUTOMATIC) RetVal; /* return value */
  
  /* Checks all error flags regardless of FIFO usage. */
  if ( (CurScbPtr->unINTR_RX.u32Register & SPI_SCB_INTR_RX_OVERFLOW_MASK) != 0U )
  {
    /* detect HW error */
    Spi_Info.HwInfoListPtr[HwUnit].TxStatus = SPI_FAILED;
    Spi_Info.HwInfoListPtr[HwUnit].RxStatus = SPI_FAILED;
    RetVal = SPI_OK;
  }
  else
  {
    RetVal = SPI_NOT_OK;
  }
  
  return RetVal;
}

/** \brief Spi_Hw_StopHwUnit
 **
 ** Sets the HW unit for SCB to stop sync transmission.
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job      Id of Job.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* Channel id */
  VAR(Spi_ChannelType, AUTOMATIC) Channel;

  /* Get current channel */
  Channel = Spi_Job_GetCurrentChannel(Job, Factor);

  /* Check HW error */
  if ( Spi_Hw_GetHwUnitInternalStatus(ExternalDevicePtr->HwUnit, Factor) == SPI_FAILED )
  { /* Error detected */
    /* Disable SCB */
    Spi_Hw_DisableSCB(CurScbPtr);
  }
  else
  { /* HW error not detected */
    if ( Factor == SPI_HW_FACTOR_SCB_TX )
    { /* For transmition factor */
      Spi_Hw_StopSCBSend(CurScbPtr, ExternalDevicePtr, Job, Channel);
    }
    else
    { /* For reception factor */
      Spi_Hw_StopSCBRecv(CurScbPtr, ExternalDevicePtr, Job, Channel, SPI_HWUNIT_SYNC);
    }
  }
}

/** \brief Spi_Hw_StopFifo
 **
 ** Sets the HW unit for fifo to stop transmission.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job      Id of Job.
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopFifo
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  /* Channel id */
  VAR(Spi_ChannelType, AUTOMATIC) Channel;

  /* Get current channel */
  Channel = Spi_Job_GetCurrentChannel(Job, Factor);

  /* Check HW error */
  if ( Spi_Hw_GetHwUnitInternalStatus(ExternalDevicePtr->HwUnit, Factor) == SPI_FAILED )
  { /* Error detected */
    /* Disable SCB */
    Spi_Hw_DisableSCB(CurScbPtr);
  }
  else
  { /* HW error not detected */
    /* check transmission or reception interrupt */
    if ( Factor == SPI_HW_FACTOR_SCB_TX )
    { /* For transmition factor */
      Spi_Hw_StopSCBSend(CurScbPtr, ExternalDevicePtr, Job, Channel);
    }
    else
    { /* For reception factor */
      Spi_Hw_StopSCBRecv(CurScbPtr, ExternalDevicePtr, Job, Channel, SPI_HWUNIT_ASYNC);
    }
  }
}

/** \brief Spi_Hw_DisableSCB
 **
 ** Disable SCB Unit.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_DisableSCB
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr
)
{
  /* SCB TX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unTxFifoCtrl;
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl; 

  /* disable reception and transmission */
  unTxFifoCtrl.u32Register = CurScbPtr->unTX_FIFO_CTRL.u32Register;
  unRxFifoCtrl.u32Register = CurScbPtr->unRX_FIFO_CTRL.u32Register;
  unTxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
  unRxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
  CurScbPtr->unTX_FIFO_CTRL.u32Register = unTxFifoCtrl.u32Register;
  CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;

  /* disable interrupts & clear flag */
  CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_MASK_ALL;
  CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_CLEAR;
  (void)CurScbPtr->unINTR_M.u32Register;
  CurScbPtr->unINTR_TX_MASK.u32Register = SPI_SCB_INTR_TX_MASK_ALL;
  CurScbPtr->unINTR_TX.u32Register = SPI_SCB_INTR_TX_CLEAR;
  (void)CurScbPtr->unINTR_TX.u32Register;
  CurScbPtr->unINTR_RX_MASK.u32Register = SPI_SCB_INTR_RX_MASK_ALL;
  CurScbPtr->unINTR_RX.u32Register = SPI_SCB_INTR_RX_CLEAR;
  (void)CurScbPtr->unINTR_RX.u32Register;
}

/** \brief Spi_Hw_StopSCBSend
 **
 ** Sets the HW unit to stop send transmission.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job   Job id.
 ** \param [in] Channel   Channel id.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopSCBSend
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel
)
{
  /* Pointer to JobConfig */
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr;
  /* Index of currently RX transmitted channel in channel list */
  VAR(Spi_ChannelIndexType, TYPEDEF) ChannelIndex;
  /* SCB INTR_RX register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_Rx_Type, AUTOMATIC)   unIntrRx;
  /* Pointer to channel info */
  P2VAR(Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC) CurChannelInfoPtr;
  /* Pointer to HW unit infomation */
  P2VAR(Spi_HwInfoType , AUTOMATIC, AUTOMATIC) CurHwInfoPtr;
  /*  Read buffer position */
  VAR(Spi_NumberOfDataType, AUTOMATIC) PosRx;
  /* Number of bytes per data element */
  VAR(uint8, AUTOMATIC) BytesPerDataElement;
  /* RX_FIFO_STATUS register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Status_Type, AUTOMATIC)   unRxFifoStatus;
  /* Specifies the number of size in bytes per elements */
  VAR(uint8, AUTOMATIC) PosIncrSize;
  /* Current RX buffer pointer */
  P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) CurBufferPtr;
  /* Dummy read buffer */
  VAR(Spi_DataBufferType, AUTOMATIC) DummyReadBuffer[4] = {0U};
  /* Buffer position to be stored */
  VAR(uint32, AUTOMATIC) CurBufferPos;
  
  /* Get register value */
  unIntrRx.u32Register = CurScbPtr->unINTR_RX.u32Register;

  /* get channel configuration */
  ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
  /* Set the number of bytes per data element (determined by SpiDataWidth). */
  BytesPerDataElement = ChannelConfigPtr->DataWidth;
  
  if ( unIntrRx.stcField.u1NOT_EMPTY == STD_HIGH )
  { /* Not Empty */
    VAR(Spi_ChannelType, AUTOMATIC) RxChannel; /* Channel Id for RX */
    /* Get channel index */
    ChannelIndex = Spi_Job_GetChannelIndex( Job, SPI_HW_FACTOR_SCB_RX );
    /* Get Rx channel */
    RxChannel = JobConfigPtr->ChannelListPtr[ChannelIndex];
    /* get buffer pointer */
    CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[RxChannel] );
    /* get buffer position */
    CurHwInfoPtr = Spi_Hw_GetHwInfo( ExternalDevicePtr->HwUnit );
    /* Initialize PosRx */
    PosRx =  CurHwInfoPtr->BufferPosReceived;
    unRxFifoStatus.u32Register = CurScbPtr->unRX_FIFO_STATUS.u32Register;
    
    /* Determine the write data is default or not */
    Spi_Hw_GetBufferDataToBeReceived(CurChannelInfoPtr, DummyReadBuffer, PosRx, BytesPerDataElement,
                                    &CurBufferPtr, &CurBufferPos, &PosIncrSize);
    while ( unRxFifoStatus.stcField.u9USED > 0U )
    { /* Data exist in FIFO */
      if ( PosRx >= CurChannelInfoPtr->BufferSize )
      { /* Channel end */
        if ( ((ChannelIndex + 1U) < JobConfigPtr->ChannelCount) && 
          (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
        { /* Not Last channel */
          CurChannelInfoPtr->BufferPosReceived = PosRx;
          /* update Rx index */
          ChannelIndex++;
          Spi_Job_SetChannelIndex( Job, ChannelIndex, SPI_HW_FACTOR_SCB_RX );
          /* update current rx channel */
          RxChannel = JobConfigPtr->ChannelListPtr[ChannelIndex];
          CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[RxChannel] );
          /* get channel configuration */
          ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[RxChannel] );
          /* Set the number of bytes per data element (determined by 
            SpiDataWidth). */
          BytesPerDataElement = ChannelConfigPtr->DataWidth;

          /* Buffer position setup */
          CurHwInfoPtr->BufferPosReceived = 0U;
          /* set buffer position of current channel */
          CurChannelInfoPtr->BufferPosReceived = 0U;
          PosRx = 0U;

          /* Determine the write data is default or not */
          Spi_Hw_GetBufferDataToBeReceived(CurChannelInfoPtr, DummyReadBuffer, PosRx, BytesPerDataElement,
                                           &CurBufferPtr, &CurBufferPos, &PosIncrSize);
        }
        else
        { /* Last Channel */
          break;
        }
      }

      Spi_Hw_WriteRegisterDataToBuffer( CurScbPtr, &CurBufferPtr[CurBufferPos], BytesPerDataElement );
      CurBufferPos += PosIncrSize;
      PosRx++;
      unRxFifoStatus.u32Register = CurScbPtr->unRX_FIFO_STATUS.u32Register;
    }
    /* Clear Factor */
    CurScbPtr->unINTR_RX.u32Register =
      (SPI_SCB_INTR_RX_NOT_EMPTY_MASK | SPI_SCB_INTR_RX_TRIGGER_MASK);
    (void)CurScbPtr->unINTR_RX.u32Register;

    /* updates internal status. */
    Spi_Info.HwInfoListPtr[ExternalDevicePtr->HwUnit].RxStatus = SPI_OK;
    /* set buffer position of HW */
    CurHwInfoPtr->BufferPosReceived = PosRx;
    /* set buffer position of current channel */
    CurChannelInfoPtr->BufferPosReceived = PosRx;
  }

  /* last channel and detect bus idle */
  Spi_Info.HwInfoListPtr[ExternalDevicePtr->HwUnit].TxStatus = SPI_OK;
  /* disable transmission and bus idle interrupt */
  /* Disable SCB */
  Spi_Hw_DisableSCB(CurScbPtr);
}

/** \brief Spi_Hw_StopSCBRecv
 **
 ** Sets the HW unit to stop receive transmission.
 **
 ** \return None.
 **
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr   Pointer to HW unit configuration.
 ** \param [in] Job   Job id.
 ** \param [in] Channel   Channel id.
 ** \param [in] Sync   Asynchronous or synchronous transmission.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StopSCBRecv
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel,
  CONST(Spi_HWUnitSyncType, TYPEDEF) Sync
)
{
  /* Pointer to JobConfig */
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );
  /* get TX current channel */
  VAR( Spi_ChannelType, AUTOMATIC ) TxChannel = Spi_Job_GetCurrentChannel( Job, SPI_HW_FACTOR_SCB_TX) ;
  /* Index of currently RX transmitted channel in channel list */
  VAR(Spi_ChannelIndexType, TYPEDEF) RxChannelIndex = Spi_Job_GetChannelIndex( Job, SPI_HW_FACTOR_SCB_RX );
  /* Index of currently TX transmitted channel in channel list */
  VAR(Spi_ChannelIndexType, TYPEDEF) TxChannelIndex = Spi_Job_GetChannelIndex( Job, SPI_HW_FACTOR_SCB_TX );
  /* Pointer to HW unit infomation */
  P2VAR(Spi_HwInfoType , AUTOMATIC, AUTOMATIC) CurHwInfoPtr;
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr;
  /* pointer to channel configuration */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) TxChannelConfigPtr; 
  /* Pointer to channel info */
  P2VAR(Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC) CurChannelInfoPtr;
  /* get TX current chanel info */
  P2VAR( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) CurTxChannelInfoPtr;
  /* Number of bytes per data element */
  VAR(uint8, AUTOMATIC) BytesPerDataElement;
  /* Number of bytes per data element */
  VAR(uint8, AUTOMATIC) TxBytesPerDataElement;
  /*  Read buffer position */
  VAR(Spi_NumberOfDataType, AUTOMATIC) PosRx;
  /*  Write buffer position */
  VAR(Spi_NumberOfDataType, AUTOMATIC) PosTx;
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl;

  /* Number of Received data */
  VAR(uint32, AUTOMATIC) RecvNum;
  /* Number of free tx fifo */
  VAR(uint32, AUTOMATIC) RestFifo;

  /* Specifies the number of size in bytes per elements */
  VAR(uint8, AUTOMATIC) PosIncrSize;
  /* Current RX buffer pointer */
  P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) CurBufferPtr;
  /* Dummy read buffer */
  VAR(Spi_DataBufferType, AUTOMATIC) DummyReadBuffer[4] = {0U};
  /* Buffer position to be stored */
  VAR(uint32, AUTOMATIC) CurBufferPos;

  /* Specifies the number of size in bytes per elements */
  VAR(uint8, AUTOMATIC) TxPosIncrSize;
  /* Current TX buffer pointer */
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) TxCurBufferPtr;
  /* Buffer position to be sent */
  VAR(uint32, AUTOMATIC) TxCurBufferPos;

  /* get channel info */
  CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[Channel] );
  /* get Tx channel info */
  CurTxChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[TxChannel] );
  /* get buffer position */
  CurHwInfoPtr = Spi_Hw_GetHwInfo( ExternalDevicePtr->HwUnit );
  /* get channel configuration */
  ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
  /* Set the number of bytes per data element (determined by SpiDataWidth). */
  BytesPerDataElement = ChannelConfigPtr->DataWidth;
  /* get TX channel configuration */
  TxChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[TxChannel] ) ;
  /* Set the number of bytes per data element (determined by SpiDataWidth). */
  TxBytesPerDataElement = TxChannelConfigPtr->DataWidth;
  
  /* get position */
  PosRx = CurHwInfoPtr->BufferPosReceived;
  PosTx = CurTxChannelInfoPtr->BufferPosStoredForSend;

  /* Clear INTR RX factor */
  CurScbPtr->unINTR_RX.u32Register =
    (SPI_SCB_INTR_RX_NOT_EMPTY_MASK | SPI_SCB_INTR_RX_TRIGGER_MASK);
  (void)CurScbPtr->unINTR_RX.u32Register;

  /* Get received data */
  RecvNum = CurScbPtr->unRX_FIFO_STATUS.stcField.u9USED;
  /* Get rest fifo size. */
  RestFifo = (((uint32)Spi_Com_GetDerivateFIFOSize() / 
      SPI_FIFO_ELEMENT_SIZE)) - 
      CurScbPtr->unTX_FIFO_STATUS.stcField.u9USED;

  /* Determine the write data is default or not */
  Spi_Hw_GetBufferDataToBeReceived(CurChannelInfoPtr, DummyReadBuffer, PosRx, BytesPerDataElement,
                                   &CurBufferPtr, &CurBufferPos, &PosIncrSize);
  /* Determine the write data is default or not */
  Spi_Hw_GetBufferDataToBeSent(CurTxChannelInfoPtr, TxChannelConfigPtr, PosTx, TxBytesPerDataElement,
                               &TxCurBufferPtr, &TxCurBufferPos, &TxPosIncrSize);

  while ( RecvNum > 0U )
  { 
    /* Exist received data */
    if ( PosRx >= CurChannelInfoPtr->BufferSize )
    {
      if ( ((RxChannelIndex + 1U) < JobConfigPtr->ChannelCount) && 
        (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
      { /* next channel data was received */
        /* set buffer position of current channel */
         CurChannelInfoPtr->BufferPosReceived = PosRx;
        /* update Rx index */
        RxChannelIndex++;
        Spi_Job_SetChannelIndex( Job, RxChannelIndex, SPI_HW_FACTOR_SCB_RX );
        /* update current rx channel */
        Channel = JobConfigPtr->ChannelListPtr[RxChannelIndex];
        CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[Channel] );
        /* get channel configuration */
        ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] );
        /* Set the number of bytes per data element (determined by 
          SpiDataWidth). */
        BytesPerDataElement = ChannelConfigPtr->DataWidth;

        /* Buffer position setup */
        CurHwInfoPtr->BufferPosReceived = 0U;
        /* set buffer position of current channel */
        CurChannelInfoPtr->BufferPosReceived = 0U;
        PosRx = 0U;

        /* Determine the write data is default or not */
        Spi_Hw_GetBufferDataToBeReceived(CurChannelInfoPtr, DummyReadBuffer, PosRx, BytesPerDataElement,
                                        &CurBufferPtr, &CurBufferPos, &PosIncrSize);
      }
      else
      { /* Last channel data received complete */
        break;
      }
    }
    /* set RX_FIFO_RD data to buffer */
    Spi_Hw_WriteRegisterDataToBuffer( CurScbPtr, &CurBufferPtr[CurBufferPos], BytesPerDataElement );
    CurBufferPos += PosIncrSize;
    PosRx++;
    RecvNum--;

    if ( 0U < RestFifo )
    { /* TX fifo is not full */
      if ( PosTx >= CurTxChannelInfoPtr->BufferSize)
      {
        if ( ((TxChannelIndex + 1U) < JobConfigPtr->ChannelCount) && 
          (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
        { /* next channel data to send is exists */
          /* set buffer position of current channel */
          CurTxChannelInfoPtr->BufferPosStoredForSend = PosTx;
          /* update Tx index */
          TxChannelIndex++;
          Spi_Job_SetChannelIndex( Job, TxChannelIndex, SPI_HW_FACTOR_SCB_TX );
          /* update current rx channel */
          TxChannel = JobConfigPtr->ChannelListPtr[TxChannelIndex];
          CurTxChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[TxChannel] );
          /* get channel configuration */
          TxChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[TxChannel] );
          /* Set the number of bytes per data element (determined by 
            SpiDataWidth). */
          TxBytesPerDataElement = TxChannelConfigPtr->DataWidth;

          /* set buffer position of current channel */
          CurTxChannelInfoPtr->BufferPosStoredForSend = 0U;
          PosTx = 0U;

          /* Determine the write data is default or not */
          Spi_Hw_GetBufferDataToBeSent(CurTxChannelInfoPtr, TxChannelConfigPtr, PosTx, TxBytesPerDataElement,
                                       &TxCurBufferPtr, &TxCurBufferPos, &TxPosIncrSize);
        }
      }

      if ( PosTx < CurTxChannelInfoPtr->BufferSize)
      { /* send data is exist in current channel */
        /* set buffer data to TX_FIFO_WR */
        Spi_Hw_WriteBufferDataToRegister( CurScbPtr, &TxCurBufferPtr[TxCurBufferPos], TxBytesPerDataElement );
        TxCurBufferPos += TxPosIncrSize;
        PosTx++;
        RestFifo--;
      }
    }
  }

  /* Update position */
  CurHwInfoPtr->BufferPosReceived = PosRx;
  CurTxChannelInfoPtr->BufferPosStoredForSend = PosTx;
  CurChannelInfoPtr->BufferPosReceived = PosRx;

  if ( ( PosRx >= CurChannelInfoPtr->BufferSize )
    && ( ((RxChannelIndex + 1U) >= JobConfigPtr->ChannelCount) ||
         (JobConfigPtr->WidthType == SPI_MULTI_WIDTH) ) )
  {
    /* Disable reception and rx interrupt */
    Spi_Info.HwInfoListPtr[ExternalDevicePtr->HwUnit].RxStatus = SPI_OK;
    unRxFifoCtrl.u32Register = CurScbPtr->unRX_FIFO_CTRL.u32Register;
    unRxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
    CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;
    CurScbPtr->unINTR_RX_MASK.u32Register = SPI_SCB_INTR_RX_MASK_ALL;
    CurScbPtr->unINTR_RX.u32Register = SPI_SCB_INTR_RX_CLEAR;
    (void)CurScbPtr->unINTR_RX.u32Register;
  }
  if ( ( PosTx >= CurTxChannelInfoPtr->BufferSize )
    && ( ((TxChannelIndex + 1U) >= JobConfigPtr->ChannelCount) ||
         (JobConfigPtr->WidthType == SPI_MULTI_WIDTH)) )
  { /* Sended all data */
    if( Sync == SPI_HWUNIT_ASYNC )
    {
      /* level delivered */
      VAR(uint8, AUTOMATIC) LevelDelivered;
      /* async mode */
      VAR(Spi_AsyncModeType, AUTOMATIC) AsyncMode;

      /* Get level delivered and async mode */
      LevelDelivered = Spi_Com_GetLevelDelivered();
      AsyncMode = Spi_Internal_GetAsyncMode();
      if ( ( LevelDelivered == SPI_LEVEL_DELIVERED_1 )
          || ( AsyncMode != SPI_POLLING_MODE ) )
      { /* Only interrupt mode  */
        if(CurScbPtr->unTX_FIFO_STATUS.stcField.u9USED != 0U)
        {
           CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_CLEAR;
           (void)CurScbPtr->unINTR_M.u32Register;
        }
        /* Enable SPI_DONE interrupt */
        CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_SPI_DONE_ENABLE;
      }
    }
  }
}

/** \brief Spi_Hw_StartHwUnit
 **
 ** Starts the SCB Sync transmission with out DMA.
 ** \return None.
 ** \param [in] CurScbPtr    Pointer to the current SCB register.
 ** \param [in] HWUnit       Id of HW Unit.
 ** \param [in] Job       Id of Job.
 ** \param [in] Channel   Id of Channel.
 **
 */

static FUNC(void, SPI_CODE) Spi_Hw_StartHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel
)
{
  /* position in buffer */
  VAR(Spi_NumberOfDataType, AUTOMATIC) Position;
  /* total write counts */
  VAR(Spi_NumberOfDataType, AUTOMATIC) WriteCount;
  /* Maximum number of write counts */
  VAR(Spi_NumberOfDataType, AUTOMATIC) MaxFifoNum;
  /* byte value of the data width */
  VAR( uint8, AUTOMATIC ) BytesPerDataElement;

  /* Pointer to Channel Config */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] ); 
  /* Pointer to Job config */
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );

  /* SCB TX_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Tx_Ctrl_Type, AUTOMATIC) unTxCtrl;
  /* SCB RX_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Rx_Ctrl_Type, AUTOMATIC) unRxCtrl;
  /* SCB TX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unTxFifoCtrl;
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl;

  /* Channel info pointer */
  P2VAR( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) CurChannelInfoPtr;
  /* Channel Index. */
  VAR(Spi_ChannelIndexType, AUTOMATIC) CurChannelIndex;
  /* Trigger level for FIFO. */
  VAR(uint8, AUTOMATIC) TriggerLevel;
  /* Current TX channel */
  VAR(Spi_ChannelType, AUTOMATIC) CurChannel;

  /* Specifies the number of size in bytes per elements */
  VAR(uint8, AUTOMATIC) TxPosIncrSize;
  /* Current TX buffer pointer */
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) TxCurBufferPtr;
  /* Buffer position to be sent */
  VAR(uint32, AUTOMATIC) TxCurBufferPos;
  
  /* get register value */
  unTxCtrl.u32Register     = CurScbPtr->unTX_CTRL.u32Register;
  unRxCtrl.u32Register     = CurScbPtr->unRX_CTRL.u32Register;
  unTxFifoCtrl.u32Register = CurScbPtr->unTX_FIFO_CTRL.u32Register;
  unRxFifoCtrl.u32Register = CurScbPtr->unRX_FIFO_CTRL.u32Register;

  /* setup hw for transmission */
  /* Set the number of bytes per data element (determined by SpiDataWidth). */
  BytesPerDataElement = ChannelConfigPtr->DataWidth;
  /* Set DATA_WIDTH of TX and RX */
  unTxCtrl.stcField.u5DATA_WIDTH = ChannelConfigPtr->DataWidthBitMask;
  unTxCtrl.stcField.u1MSB_FIRST = ChannelConfigPtr->TransferStart;
  unRxCtrl.stcField.u5DATA_WIDTH = ChannelConfigPtr->DataWidthBitMask;
  unRxCtrl.stcField.u1MSB_FIRST = ChannelConfigPtr->TransferStart;

  /* setup TX FIFO Trigger Level */
  TriggerLevel = (Spi_Com_GetDerivateFIFOSize() / SPI_FIFO_ELEMENT_SIZE);
  unTxFifoCtrl.stcField.u8TRIGGER_LEVEL = TriggerLevel;
  /* setup RX FIFO Trigger Level */
  unRxFifoCtrl.stcField.u8TRIGGER_LEVEL = TriggerLevel;

  /* Write to register */
  CurScbPtr->unTX_CTRL.u32Register = unTxCtrl.u32Register;
  CurScbPtr->unRX_CTRL.u32Register = unRxCtrl.u32Register;

  /* Enable FIFO & SCB */
  unTxFifoCtrl.stcField.u1CLEAR = STD_LOW;
  unRxFifoCtrl.stcField.u1CLEAR = STD_LOW;

  /* Write to register */
  CurScbPtr->unTX_FIFO_CTRL.u32Register = unTxFifoCtrl.u32Register;
  CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;

  /* Get MAX Fifo size in number of data elements. */
  
  MaxFifoNum = ((Spi_NumberOfDataType)Spi_Com_GetDerivateFIFOSize() / 
      (Spi_NumberOfDataType)SPI_FIFO_ELEMENT_SIZE);
  /* get Current TX Channel */
  CurChannelIndex = Spi_Job_GetChannelIndex(Job, SPI_HW_FACTOR_SCB_TX);
  CurChannel = JobConfigPtr->ChannelListPtr[CurChannelIndex];
  CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[CurChannel] );
  /* Write Tx data to SCB */
  Position = 0U;
  /* Determine the write data is default or not */
  Spi_Hw_GetBufferDataToBeSent(CurChannelInfoPtr, ChannelConfigPtr, Position, BytesPerDataElement,
                               &TxCurBufferPtr, &TxCurBufferPos, &TxPosIncrSize);

  for ( WriteCount = 0U; WriteCount < MaxFifoNum; WriteCount++ )
  {
    if( Position >= CurChannelInfoPtr->BufferSize )
    {
      if ( ((CurChannelIndex + 1U) < JobConfigPtr->ChannelCount) &&
           (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
      { /* Not last channel and same data width */ 
        /* update position */
        CurChannelInfoPtr->BufferPosStoredForSend = Position;
        /* prepare next channel */
        CurChannelIndex++;
        CurChannel = JobConfigPtr->ChannelListPtr[CurChannelIndex];
        CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[CurChannel] );
        ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[CurChannel] );
        Position = 0U;
        /* Determine the write data is default or not */
        Spi_Hw_GetBufferDataToBeSent(CurChannelInfoPtr, ChannelConfigPtr, Position, BytesPerDataElement,
                                     &TxCurBufferPtr, &TxCurBufferPos, &TxPosIncrSize);
       }
      else
      { /* all data of the channel stored. */
        break;
      }
    }
    /* set buffer data to FIFO */
    Spi_Hw_WriteBufferDataToRegister(CurScbPtr, &TxCurBufferPtr[TxCurBufferPos], BytesPerDataElement);
    TxCurBufferPos += TxPosIncrSize;
    Position++;
  }
  /* set buffer position */
  /* set buffer position of current channel */
  Spi_Info.HwInfoListPtr[HwUnit].BufferPosReceived = 0U;

  /* set buffer position of current channel */
  Spi_Info.ChannelInfoListPtr[Channel].BufferPosReceived = 0U;
  Spi_Info.ChannelInfoListPtr[CurChannel].BufferPosStoredForSend = Position;

  /* Set TX Current Channel Index */
  Spi_Job_SetChannelIndex( Job, CurChannelIndex, SPI_HW_FACTOR_SCB_TX);
}

/** \brief Spi_Hw_SetupFifo
 **
 ** Initial setting before transmission for FIFO
 **
 ** \return None.
 ** \param [in] CurScbPtr    Pointer to the current SCB register.
 ** \param [in] BytesPerDataElement byte value of the data width
 ** \param [in] UseDMA Using DMA or not.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_SetupFifo
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(boolean, AUTOMATIC) UseDMA
)
{
  /* Trigger level for TX. */
  VAR(uint8, AUTOMATIC) u8TxTriggerLevel;
  /* Trigger level for RX. */
  VAR(uint8, AUTOMATIC) u8RxTriggerLevel;
  /* SCB TX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unTxFifoCtrl;
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl;
  
  /* get register value */
  unTxFifoCtrl.u32Register = SPI_SCB_TX_FIFO_CTRL_INIT;
  unRxFifoCtrl.u32Register = SPI_SCB_RX_FIFO_CTRL_INIT;

  if ( UseDMA == SPI_TRUE )
  {
    u8TxTriggerLevel = (Spi_Com_GetDerivateFIFOSize() / SPI_FIFO_ELEMENT_SIZE)-1U;
    u8RxTriggerLevel = 0U;
  }
  else
  {
    VAR( uint8, AUTOMATIC ) LevelDelivered; /* level delivered */
    VAR( Spi_AsyncModeType, AUTOMATIC ) AsyncMode; /* async mode */

    AsyncMode = Spi_Internal_GetAsyncMode();
    LevelDelivered = Spi_Com_GetLevelDelivered();
    if ( (AsyncMode != SPI_POLLING_MODE) ||
         (LevelDelivered == SPI_LEVEL_DELIVERED_1) )
    { /* Interrupt mode */
      u8TxTriggerLevel = 1U;
      u8RxTriggerLevel = (Spi_Com_GetDerivateFIFOSize() - 24U)/ SPI_FIFO_ELEMENT_SIZE;
    }
    else
    { /* Pooling mode */
      u8TxTriggerLevel = (Spi_Com_GetDerivateFIFOSize() / SPI_FIFO_ELEMENT_SIZE) - 1U;
      u8RxTriggerLevel = 0U;
    }
  }
  /* setup TX FIFO Trigger Level */
  unTxFifoCtrl.stcField.u8TRIGGER_LEVEL = u8TxTriggerLevel;
  /* setup RX FIFO Trigger Level */
  unRxFifoCtrl.stcField.u8TRIGGER_LEVEL = u8RxTriggerLevel;
  /* Enable FIFO */
  unTxFifoCtrl.stcField.u1CLEAR = STD_LOW;
  unRxFifoCtrl.stcField.u1CLEAR = STD_LOW;

  /* write to register */
  CurScbPtr->unTX_FIFO_CTRL.u32Register = unTxFifoCtrl.u32Register;
  CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;
  /* read back for synchronization */
  (void)CurScbPtr->unRX_FIFO_CTRL.u32Register;
}

/** \brief Spi_Hw_StartFifo
 **
 ** Starts the SCB transmission for FIFO.
 **
 ** \return None.
 ** \param [in] CurScbPtr   Pointer to the current SCB register.
 ** \param [in] HWUnit       Id of HW Unit.
 ** \param [in] Job       Id of Job.
 ** \param [in] Channel   Id of Channel.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_StartFifo
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_JobType, AUTOMATIC) Job,
  VAR(Spi_ChannelType, AUTOMATIC) Channel
)
{
  /* byte value of the data width */
  VAR( uint8, AUTOMATIC ) BytesPerDataElement;
   /* Max Fifo size */
  VAR( uint8, AUTOMATIC ) DerivateFIFOSize = Spi_Com_GetDerivateFIFOSize();
  /* current position in channel buffer */
  VAR( Spi_NumberOfDataType, AUTOMATIC )  Position;
  /* total write counts */
  VAR( Spi_NumberOfDataType, AUTOMATIC) WriteCount;
  /* count of units in FIFO */
  VAR( uint8, AUTOMATIC ) MaxFifoNums;
  /* Current TX Channel index */
  VAR( uint8, AUTOMATIC ) CurChannelIndex;
  /* Current TX Channel */
  VAR( Spi_ChannelType, AUTOMATIC ) CurChannel;
  /* channel infomation pointer */
  P2VAR( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) CurChannelInfoPtr;
  /* level delivered */
  VAR( uint8, AUTOMATIC ) LevelDelivered;
  /* async mode */
  VAR( Spi_AsyncModeType, AUTOMATIC ) AsyncMode;
  /* Channel Config Pointer */
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr = 
      &( Spi_Current_ConfigPtr->ChannelConfigListPtr[Channel] ); 
  /* Get Job Config pointer */
  P2CONST( Spi_JobConfigType, AUTOMATIC, AUTOMATIC ) JobConfigPtr = &( Spi_Current_ConfigPtr->JobConfigListPtr[Job] );

  /* SCB TX_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Tx_Ctrl_Type, AUTOMATIC) unTxCtrl;
  /* SCB RX_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Rx_Ctrl_Type, AUTOMATIC) unRxCtrl;
  /* SCB TX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unTxFifoCtrl;
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl;
  /* SCB INTR_RX_MASK register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_Rx_Type, AUTOMATIC)   unIntrRxMask;
  /* SCB INTR_M_MASK register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Intr_M_Type, AUTOMATIC)   unIntrMMask;
  /* Last channel flag */
  VAR( boolean, AUTOMATIC) LastFlag;

  /* Specifies the number of size in bytes per elements */
  VAR(uint8, AUTOMATIC) TxPosIncrSize;
  /* Current TX buffer pointer */
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) TxCurBufferPtr;
  /* Buffer position to be sent */
  VAR(uint32, AUTOMATIC) TxCurBufferPos;
  
  /* get register value */
  unTxCtrl.u32Register     = CurScbPtr->unTX_CTRL.u32Register;
  unRxCtrl.u32Register     = CurScbPtr->unRX_CTRL.u32Register;
  unTxFifoCtrl.u32Register = CurScbPtr->unTX_FIFO_CTRL.u32Register;
  unRxFifoCtrl.u32Register = CurScbPtr->unRX_FIFO_CTRL.u32Register;

  /* Set the number of bytes per data element (determined by SpiDataWidth). */
  BytesPerDataElement = ChannelConfigPtr->DataWidth;
  MaxFifoNums = DerivateFIFOSize / SPI_FIFO_ELEMENT_SIZE;

  /* setup hw for transmission */
  /* Set DATA_WIDTH of TX and RX */
  unTxCtrl.stcField.u5DATA_WIDTH = ChannelConfigPtr->DataWidthBitMask;
  unTxCtrl.stcField.u1MSB_FIRST = ChannelConfigPtr->TransferStart;
  unRxCtrl.stcField.u5DATA_WIDTH = ChannelConfigPtr->DataWidthBitMask;
  unRxCtrl.stcField.u1MSB_FIRST = ChannelConfigPtr->TransferStart;

  /* Get level delivered and async mode */
  LevelDelivered = Spi_Com_GetLevelDelivered();
  AsyncMode = Spi_Internal_GetAsyncMode();

  /* interrupt will be set enabled if the Level1 or the Interrupt mode. */
  if ( (LevelDelivered == SPI_LEVEL_DELIVERED_1)
    || (AsyncMode != SPI_POLLING_MODE) )
  {
    /* Enable Rx interrupts (INTR_RX.TRIGGER) for SCB. */
    unIntrRxMask.u32Register = CurScbPtr->unINTR_RX_MASK.u32Register;
    unIntrRxMask.stcField.u1TRIGGER = STD_HIGH;
    CurScbPtr->unINTR_RX_MASK.u32Register = unIntrRxMask.u32Register;
  }

  /* Enable FIFO & SCB */
  unTxFifoCtrl.stcField.u1CLEAR = STD_LOW;
  unRxFifoCtrl.stcField.u1CLEAR = STD_LOW;

  /* Write to register */
  CurScbPtr->unTX_FIFO_CTRL.u32Register = unTxFifoCtrl.u32Register;
  CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;
  CurScbPtr->unTX_CTRL.u32Register = unTxCtrl.u32Register;
  CurScbPtr->unRX_CTRL.u32Register = unRxCtrl.u32Register;
  
  /* get buffer setting */
  CurChannelIndex = Spi_Job_GetChannelIndex(Job, SPI_HW_FACTOR_SCB_TX);
  CurChannel = JobConfigPtr->ChannelListPtr[CurChannelIndex];
  CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[CurChannel] );

  /* Write Tx data to SCB */
  Position = 0U;
  LastFlag = SPI_FALSE;
  /* Determine the write data is default or not */
  Spi_Hw_GetBufferDataToBeSent(CurChannelInfoPtr, ChannelConfigPtr, Position, BytesPerDataElement,
                               &TxCurBufferPtr, &TxCurBufferPos, &TxPosIncrSize);
                               
  for ( WriteCount = 0U; WriteCount < MaxFifoNums; WriteCount++ )
  {
    if( Position >= CurChannelInfoPtr->BufferSize )
    {
      if ( ((CurChannelIndex + 1U) < JobConfigPtr->ChannelCount) &&
           (JobConfigPtr->WidthType == SPI_SINGLE_WIDTH) )
      { /* Not last channel and same data width */ 
        /* update position */
        CurChannelInfoPtr->BufferPosStoredForSend = Position;
        /* prepare next channel */
        CurChannelIndex++;
        CurChannel = JobConfigPtr->ChannelListPtr[CurChannelIndex];
        CurChannelInfoPtr = &( Spi_Info.ChannelInfoListPtr[CurChannel] );
        ChannelConfigPtr = &( Spi_Current_ConfigPtr->ChannelConfigListPtr[CurChannel] );
        Position = 0U;
        /* Determine the write data is default or not */
        Spi_Hw_GetBufferDataToBeSent(CurChannelInfoPtr, ChannelConfigPtr, Position, BytesPerDataElement,
                                    &TxCurBufferPtr, &TxCurBufferPos, &TxPosIncrSize);
      }
      else
      { /* all data of the channel stored. */
        LastFlag = SPI_TRUE;
        break;
      }
    }
    /* set buffer data to FIFO */
    Spi_Hw_WriteBufferDataToRegister(CurScbPtr, &TxCurBufferPtr[TxCurBufferPos], BytesPerDataElement);
    TxCurBufferPos += TxPosIncrSize;
    Position++;
  }
  /* set buffer position */
  Spi_Info.HwInfoListPtr[HwUnit].BufferPosReceived = 0U;

  /* set buffer position of current channel */
  Spi_Info.ChannelInfoListPtr[Channel].BufferPosReceived = 0U;
  Spi_Info.ChannelInfoListPtr[CurChannel].BufferPosStoredForSend = Position;
  
  /* Set TX Current Channel Index */
  Spi_Job_SetChannelIndex( Job, CurChannelIndex, SPI_HW_FACTOR_SCB_TX);
  if ( LastFlag == SPI_TRUE )
  {
    if ( (LevelDelivered == SPI_LEVEL_DELIVERED_1)
      || (AsyncMode != SPI_POLLING_MODE) )
    {
      /* Enable M Interrupt (INTR_M.SPI_DONE) for SCB. */
      unIntrMMask.u32Register = CurScbPtr->unINTR_M_MASK.u32Register;
      unIntrMMask.stcField.u1SPI_DONE = STD_HIGH;
      CurScbPtr->unINTR_M_MASK.u32Register = unIntrMMask.u32Register;
    }
  }
}

/** \brief Spi_Hw_InitHwUnit
 **
 ** Initializes the specified HW unit.
 **
 ** \return None.
 ** \param [in] CurScbPtr Pointer to the current SCB register.
 ** \param [in] CurExtDevPtr Pointer to the current external device.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_InitHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) CurExtDevPtr
)
{
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Ctrl_Type, AUTOMATIC)           unTmpCTRL;
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Spi_Ctrl_Type, AUTOMATIC)       unTmpSPI_CTRL;

  /* Set up CTRL */
  unTmpCTRL.u32Register = SPI_SCB_CTRL_INIT;
  /* u4OVS */
  unTmpCTRL.stcField.u4OVS = *(CurExtDevPtr->ActiveOvsPtr);
  /* Write to register */
  CurScbPtr->unCTRL.u32Register = unTmpCTRL.u32Register;

  /* Set up  SPI_CTRL */
  unTmpSPI_CTRL.u32Register = SPI_SCB_SPI_CTRL_INIT;
  /* Get CS polarity */
   unTmpSPI_CTRL.u32Register |= 
    (CurScbPtr->unSPI_CTRL.u32Register & SPI_SCB_SPI_CTRL_SSEL_POLARITY_MASK);
  /* CPHA */
  unTmpSPI_CTRL.stcField.u1CPHA = CurExtDevPtr->DataShiftEdge;
  /* CPOL */
  unTmpSPI_CTRL.stcField.u1CPOL = CurExtDevPtr->ShiftClockIdleLevel;
  /* SSEL_SETUP_DEL */
  unTmpSPI_CTRL.stcField.u1SSEL_SETUP_DEL = CurExtDevPtr->SetupDelay;
  /* SSEL_HOLD_DEL */
  unTmpSPI_CTRL.stcField.u1SSEL_HOLD_DEL = CurExtDevPtr->HoldDelay;
  /* Update CS polarity and SSEL */
  if (CurExtDevPtr->EnableCs == SPI_TRUE)
  { /* CS Enable */
    if (CurExtDevPtr->CsSelection == SPI_CS_VIA_PERIPHERAL_ENGINE)
    { /* Harware CS */
      switch (CurExtDevPtr->CsIdentifier)
      {
        case SPI_SELECT0 : /* CS0 */
          unTmpSPI_CTRL.stcField.u1SSEL_POLARITY0 = CurExtDevPtr->CsPolarity;
          unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT0;
          break;
        case SPI_SELECT1 : /* CS1 */
          unTmpSPI_CTRL.stcField.u1SSEL_POLARITY1 = CurExtDevPtr->CsPolarity;
          unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT1;
          break;
        case SPI_SELECT2 : /* CS2 */
          unTmpSPI_CTRL.stcField.u1SSEL_POLARITY2 = CurExtDevPtr->CsPolarity;
          unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT2;
          break;
        case SPI_SELECT3 : /* CS3 */
          unTmpSPI_CTRL.stcField.u1SSEL_POLARITY3 = CurExtDevPtr->CsPolarity;
          unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT3;
          break;
        default :
          unTmpSPI_CTRL.stcField.u1SSEL_POLARITY0 = CurExtDevPtr->CsPolarity;
          unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT0;
          break;
      }
    }
    else {  /* GPIO */
      unTmpSPI_CTRL.stcField.u1SSEL_POLARITY0 = CurExtDevPtr->CsPolarity;
      unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT0;
    }
  }
  else
  { /* Not enable CS */
      unTmpSPI_CTRL.stcField.u1SSEL_POLARITY0 = CurExtDevPtr->CsPolarity;
      unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT0;
  }
  /* Write to register */
  CurScbPtr->unSPI_CTRL.u32Register = unTmpSPI_CTRL.u32Register;

  /* Set up SPI_TX_CTRL */
  CurScbPtr->unSPI_TX_CTRL.u32Register = SPI_SCB_SPI_TX_CTRL_INIT;
  /* Set up SPI_RX_CTRL */
  CurScbPtr->unSPI_RX_CTRL.u32Register = SPI_SCB_SPI_RX_CTRL_INIT;
  /* Set up TX_CTRL */
  CurScbPtr->unTX_CTRL.u32Register = SPI_SCB_TX_CTRL_INIT;
  /* Set up RX_CTRL */
  CurScbPtr->unRX_CTRL.u32Register = SPI_SCB_RX_CTRL_INIT;
  /* Set up TX_FIFO_CTRL */
  CurScbPtr->unTX_FIFO_CTRL.u32Register = SPI_SCB_TX_FIFO_CTRL_INIT;
  /* Set up RX_FIFO_CTRL */
  CurScbPtr->unRX_FIFO_CTRL.u32Register = SPI_SCB_RX_FIFO_CTRL_INIT;


  /* Set up Interrupt & Mask */
  CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_INIT;
  (void)CurScbPtr->unINTR_M.u32Register;
  CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_MASK_INIT;
  CurScbPtr->unINTR_TX.u32Register = SPI_SCB_INTR_TX_INIT;
  (void)CurScbPtr->unINTR_TX.u32Register;
  CurScbPtr->unINTR_TX_MASK.u32Register = SPI_SCB_INTR_TX_MASK_INIT;
  CurScbPtr->unINTR_RX.u32Register = SPI_SCB_INTR_RX_INIT;
  (void)CurScbPtr->unINTR_RX.u32Register;
  CurScbPtr->unINTR_RX_MASK.u32Register = SPI_SCB_INTR_RX_MASK_INIT;
  CurScbPtr->unINTR_I2C_EC_MASK.u32Register = SPI_SCB_INTR_I2C_EC_MASK_INIT;
  CurScbPtr->unINTR_SPI_EC_MASK.u32Register = SPI_SCB_INTR_SPI_EC_MASK_INIT;
  CurScbPtr->unINTR_S_MASK.u32Register = SPI_SCB_INTR_S_MASK_INIT;
}

/** \brief Spi_Hw_DeInitHwUnit
 **
 ** De-initializes the specified HW units.
 **
 ** \return None.
 ** \param [in] CurScbPtr Pointer to the current SCB register.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_DeInitHwUnit
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr
)
{
  /* disable interrupts */
  CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_MASK_UNINIT;
  CurScbPtr->unINTR_TX_MASK.u32Register = SPI_SCB_INTR_TX_MASK_UNINIT;
  CurScbPtr->unINTR_RX_MASK.u32Register = SPI_SCB_INTR_RX_MASK_UNINIT;
  CurScbPtr->unINTR_I2C_EC_MASK.u32Register = SPI_SCB_INTR_I2C_EC_MASK_UNINIT;
  CurScbPtr->unINTR_SPI_EC_MASK.u32Register = SPI_SCB_INTR_SPI_EC_MASK_UNINIT;
  CurScbPtr->unINTR_S_MASK.u32Register = SPI_SCB_INTR_S_MASK_UNINIT;

  /* Disable  SCB */
  CurScbPtr->unCTRL.u32Register = SPI_SCB_CTRL_UNINIT;
  /* Set up SPI_TX_CTRL */
  CurScbPtr->unSPI_TX_CTRL.u32Register = SPI_SCB_SPI_TX_CTRL_UNINIT;
  /* Set up SPI_RX_CTRL */
  CurScbPtr->unSPI_RX_CTRL.u32Register = SPI_SCB_SPI_RX_CTRL_UNINIT;
  /* Set up SPI_CTRL */
  CurScbPtr->unSPI_CTRL.u32Register = SPI_SCB_SPI_CTRL_UNINIT;
  /* Set up TX_CTRL */
  CurScbPtr->unTX_CTRL.u32Register = SPI_SCB_TX_CTRL_UNINIT;
  /* Set up RX_CTRL */
  CurScbPtr->unRX_CTRL.u32Register = SPI_SCB_RX_CTRL_UNINIT;
  /* Set up TX_FIFO_CTRL */
  CurScbPtr->unTX_FIFO_CTRL.u32Register = SPI_SCB_TX_FIFO_CTRL_UNINIT;
  /* Set up RX_FIFO_CTRL */
  CurScbPtr->unRX_FIFO_CTRL.u32Register = SPI_SCB_RX_FIFO_CTRL_UNINIT;

  /* Clear interrupt flag */
  CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_UNINIT;
  (void)CurScbPtr->unINTR_M.u32Register;
  CurScbPtr->unINTR_TX.u32Register = SPI_SCB_INTR_TX_UNINIT;
  (void)CurScbPtr->unINTR_TX.u32Register;
  CurScbPtr->unINTR_RX.u32Register = SPI_SCB_INTR_RX_UNINIT;
  (void)CurScbPtr->unINTR_RX.u32Register;
}

/** \brief Spi_Hw_SetupHwUnitSCB
 **
 ** Initial setting of SCB according to external Device configuration.
 **
 ** \return None.
 ** \param [in] CurScbPtr    Pointer to the current SCB register.
 ** \param [in] ExternalDevicePtr    Pointer to HW unit configuration.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_SetupHwUnitSCB
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExternalDevicePtr
)
{
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Ctrl_Type, AUTOMATIC)      unTmpCTRL;
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Spi_Ctrl_Type, AUTOMATIC)  unTmpSPI_CTRL;

  /* enter a critical section */
  /* This data is protected until register value is written. */
  Spi_Com_SchMEnterCriticalSection();

  /* Get SCB CTRL */
  unTmpCTRL.u32Register = CurScbPtr->unCTRL.u32Register;
  /* Set ENABLED */
  unTmpCTRL.stcField.u1ENABLED = STD_OFF;
  /* Set OVS */
  unTmpCTRL.stcField.u4OVS = *(ExternalDevicePtr->ActiveOvsPtr);
  /* Get SPI_CTRL */
  unTmpSPI_CTRL.u32Register = CurScbPtr->unSPI_CTRL.u32Register;
  /* Set CPHA */
  unTmpSPI_CTRL.stcField.u1CPHA = ExternalDevicePtr->DataShiftEdge;
  /* Set CPOL */
  unTmpSPI_CTRL.stcField.u1CPOL = ExternalDevicePtr->ShiftClockIdleLevel;
  /* Set SSEL_SETUP_DEL */
  unTmpSPI_CTRL.stcField.u1SSEL_SETUP_DEL = ExternalDevicePtr->SetupDelay;
  /* Set SSEL_HOLD_DEL */
  unTmpSPI_CTRL.stcField.u1SSEL_HOLD_DEL = ExternalDevicePtr->HoldDelay;
  /* Set SSEL */
  if ((ExternalDevicePtr->EnableCs == SPI_TRUE) && 
    (ExternalDevicePtr->CsSelection == SPI_CS_VIA_PERIPHERAL_ENGINE))
  {
    unTmpSPI_CTRL.stcField.u2SSEL = ExternalDevicePtr->CsIdentifier;
  }
  else
  {
    unTmpSPI_CTRL.stcField.u2SSEL = SPI_SELECT0;
  }
  /* Disable SCB */
  CurScbPtr->unCTRL.stcField.u1ENABLED = STD_OFF;
  /* Write to register */
  CurScbPtr->unCTRL.u32Register = unTmpCTRL.u32Register;
  CurScbPtr->unSPI_CTRL.u32Register = unTmpSPI_CTRL.u32Register;
  /* Enable SCB */
  CurScbPtr->unCTRL.stcField.u1ENABLED = STD_ON;

  /* exit a critical section */
  /* This data is protected until register value is written. */
  Spi_Com_SchMExitCriticalSection();
}

/** \brief Spi_Hw_SetupHwUnitChannel
 **
 ** Initial setting of SCB according to channel configuration.
 **
 ** \return None.
 ** \param [in] CurScbPtr    Pointer to the current SCB register.
 ** \param [in] ChannelConfigPtr    Pointer to channel configuration.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_SetupHwUnitChannel
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_ChannelConfigType, AUTOMATIC, AUTOMATIC) ChannelConfigPtr
)
{
  /* SCB TX_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Tx_Ctrl_Type, AUTOMATIC) unTxCtrl;
  /* SCB RX_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */
  VAR(Spi_un_Scb_Rx_Ctrl_Type, AUTOMATIC) unRxCtrl;

  /* get register value */
  unTxCtrl.u32Register = SPI_SCB_TX_CTRL_INIT;
  unRxCtrl.u32Register = SPI_SCB_RX_CTRL_INIT;

  /* setup bit direction for channel */
  if ( ChannelConfigPtr->TransferStart == SPI_TRANSFER_START_LSB )
  { /* LSB First */
    unTxCtrl.stcField.u1MSB_FIRST = STD_LOW;
    unRxCtrl.stcField.u1MSB_FIRST = STD_LOW;
  }
  else
  { /* MSB First */
    unTxCtrl.stcField.u1MSB_FIRST = STD_HIGH;
    unRxCtrl.stcField.u1MSB_FIRST = STD_HIGH;
  }

  /* set data width for channel according to configuration */
  unTxCtrl.stcField.u5DATA_WIDTH = ChannelConfigPtr->DataWidthBitMask;
  unRxCtrl.stcField.u5DATA_WIDTH = ChannelConfigPtr->DataWidthBitMask;


  /* Write to register */
  CurScbPtr->unTX_CTRL.u32Register = unTxCtrl.u32Register;
  CurScbPtr->unRX_CTRL.u32Register = unRxCtrl.u32Register;
}

/** \brief Spi_Hw_WriteBufferDataToRegister
 **
 ** Get data from the transmission buffer and set it to TX_FIFO_WR.
 **
 ** \return None.
 ** \param [in] CurScbPtr            Pointer to the current SCB register.
 ** \param [in] TxBuffPtr            Pointer to Tx buffer.
 ** \param [in] BytesPerDataElement  Byte size of data width.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_WriteBufferDataToRegister
(
  P2VAR(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) TxBuffPtr,
  VAR(uint8, AUTOMATIC) BytesPerDataElement
)
{
  VAR(uint32, AUTOMATIC) Temp = 0U; /* variable for writing TX_FIFO_WR register */
  P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) DataPtr;
  VAR(uint8, AUTOMATIC) i;

  /* Deviation from MISRA-C:2004 Rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: This deviation is due to handling with 8-bit type 
     address. */
  /* PRQA S 310 1 */
  DataPtr = (P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))(&Temp);
  for ( i = 0U; i < BytesPerDataElement; i++)
  {
      DataPtr[i] = TxBuffPtr[i];
  }
  CurScbPtr->TX_FIFO_WR = Temp;
}

/** \brief Spi_Hw_WriteRegisterDataToBuffer
 **
 ** Get data from the RX_FIFO_RD and set it to the reception buffer.
 **
 ** \return None.
 ** \param [in] CurScbPtr            Pointer to the current SCB register.
 ** \param [in] RxBuffPtr            Pointer to Rx Buffer
 ** \param [in] BytesPerDataElement  Byte size of data width.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_WriteRegisterDataToBuffer
(
  P2CONST(volatile Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr,
  P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) RxBuffPtr,
  VAR(uint8, AUTOMATIC) BytesPerDataElement
)
{
   /* variable for reading RX_FIFO_RD register */
  VAR(uint32, AUTOMATIC) Temp;
  P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) DataPtr;
  VAR(uint8, AUTOMATIC) i;

  /* read reception data */
  Temp = CurScbPtr->RX_FIFO_RD;
  /* Deviation from MISRA-C:2004 Rule 11.4, MISRA-C:2012 Rule-11.3.
     Justification: This deviation is due to handling with 8-bit type 
     address. */
  /* PRQA S 310 1 */
  DataPtr = (P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))(&Temp);

  for ( i = 0U; i < BytesPerDataElement; i++)
  {
    RxBuffPtr[i] = DataPtr[i];
  }
}


/** \brief Spi_Hw_DeInitActiveOvs
 **
 ** De-initialize active OVS value of external device.
 **
 ** \return None.
 ** \param None.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_DeInitActiveOvs(void)
{
  VAR( Spi_ExtDeviceType, AUTOMATIC ) MaxExtDevice;
  VAR( Spi_ExtDeviceType, AUTOMATIC ) ExtDeviceIndex;
  P2CONST( Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC ) ExtDeviceConfigPtr;
  
  /* get a maximum number of external device */
  MaxExtDevice = Spi_Current_ConfigPtr->ExternalDeviceCount;

  /* iterate to de-initialize all external device active OVS value */
  for( ExtDeviceIndex = 0U; ExtDeviceIndex < MaxExtDevice; ExtDeviceIndex++ )
  {
    ExtDeviceConfigPtr = &( Spi_Current_ConfigPtr->ExternalDevicesPtr[ExtDeviceIndex] );

    *(ExtDeviceConfigPtr->ActiveOvsPtr) = 0U;
  }
}

/** \brief Spi_Hw_CheckReqSCBDisable
 **
 ** Check if SCB disable is required.
 **
 ** \return                     Check result.
 **                               SPI_FALSE : No need SCB disable
 **                               SPI_TRUE  : Need SCB disable
 ** \param [in] CurExtDevPtr    Pointer to the current external device.
 ** \param [in] NextExtDevPtr   Pointer to the next external device.
 **
 */
static FUNC(uint8, SPI_CODE) Spi_Hw_CheckReqSCBDisable
(
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) CurExtDevPtr,
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) NextExtDevPtr
)
{
  VAR(uint8, AUTOMATIC) chkResult = SPI_FALSE;

  if (NextExtDevPtr->FroceOverwrite == SPI_TRUE)
  { /* Force overwrite */
    chkResult = SPI_TRUE;
  }
  else
  {
    if (CurExtDevPtr != NextExtDevPtr)
    { /* Different external device */
      /* active OVS value */
      if (*(CurExtDevPtr->ActiveOvsPtr) != *(NextExtDevPtr->ActiveOvsPtr))
      { /* Different : Need dsiable */
        chkResult = SPI_TRUE;
      }
      /* DataShiftEdge */
      if (CurExtDevPtr->DataShiftEdge != NextExtDevPtr->DataShiftEdge)
      { /* Different : Need dsiable */
        chkResult = SPI_TRUE;
      }
      /* ShiftClockIdleLevel */
      if (CurExtDevPtr->ShiftClockIdleLevel != NextExtDevPtr->ShiftClockIdleLevel)
      { /* Different : Need dsiable */
        chkResult = SPI_TRUE;
      }
      if ((NextExtDevPtr->EnableCs == SPI_TRUE) && 
        (NextExtDevPtr->CsSelection == SPI_CS_VIA_PERIPHERAL_ENGINE))
      { /* Hardware CS use */
        /* SetupDelay */
        if (CurExtDevPtr->SetupDelay != NextExtDevPtr->SetupDelay)
        { /* Different : Need dsiable */
          chkResult = SPI_TRUE;
        }
        /* HoldDelay */
        if (CurExtDevPtr->HoldDelay != NextExtDevPtr->HoldDelay)
        { /* Different : Need dsiable */
          chkResult = SPI_TRUE;
        }
      }
    }
  }
  return chkResult;
}

/** \brief Spi_Hw_GetBufferDataToBeSent
 **
 ** Get revelant data of the current transmission buffer.
 ** \return None.
 ** \param [in] ChannelInfPtr         Pointer to the channel info
 ** \param [in] ChannelConfigPtr      Pointer to the channel config
 ** \param [in] Pos                   Current position of transmission buffer
 ** \param [in] BytesPerDataElement   Number of bytes per data element
 ** \param [out] BuffPtr              Pointer to the actual transmission buffer
 ** \param [out] BuffPos              Pointer to the variable to store the actual buffer position
 ** \param [out] PosIncrSize          Pointer to the variable to store buffer increment size in bytes 
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_GetBufferDataToBeSent
(
  P2CONST( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) ChannelInfPtr,
  P2CONST( Spi_ChannelConfigType , AUTOMATIC, AUTOMATIC ) ChannelConfigPtr,
  VAR(Spi_NumberOfDataType, AUTOMATIC) Pos,
  VAR(uint8, AUTOMATIC) BytesPerDataElement,
  P2VAR(P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) BuffPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) BuffPos,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PosIncrSize
)
{
  /* Determine the write data is default or not */
  if (ChannelInfPtr->TxBufferPtr != (P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))NULL_PTR)
  {
    *BuffPtr = (P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))(ChannelInfPtr->TxBufferPtr);
    /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6.
       Justification: As a result of this expression, it will not exceed
       the essential type. */
    /* PRQA S 4491 1 */
    *BuffPos = Pos * BytesPerDataElement;
    *PosIncrSize = BytesPerDataElement;
  }
  else
  {
    /* Deviation from MISRA-C:2004 Rule 11.4, MISRA-C:2012 Rule-11.3.
       Justification: This deviation is due to handling with 8-bit type 
       address. */
    /* PRQA S 310 1 */
    *BuffPtr = (P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))(&(ChannelConfigPtr->DefaultData));
    *BuffPos = 0U;
    *PosIncrSize = 0U;
  }
}

/** \brief Spi_Hw_GetBufferDataToBeReceived
 **
 ** Get revelant data of the current reception buffer.
 ** \return None.
 ** \param [in] ChannelInfPtr         Pointer to the channel info
 ** \param [in] DummyBuff             Pointer to the dummy read buffer
 ** \param [in] Pos                   Current position of reception buffer
 ** \param [in] BytesPerDataElement   Number of bytes per data element
 ** \param [out] BuffPtr              Pointer to the actual reception buffer
 ** \param [out] BuffPos              Pointer to the variable to store the actual buffer position
 ** \param [out] PosIncrSize          Pointer to the variable to store buffer increment size in bytes 
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_GetBufferDataToBeReceived
(
  P2CONST( Spi_ChannelInfoType , AUTOMATIC, AUTOMATIC ) ChannelInfPtr,
  P2CONST(Spi_DataBufferType, AUTOMATIC, AUTOMATIC) DummyBuff,
  VAR(Spi_NumberOfDataType, AUTOMATIC) Pos,
  VAR(uint8, AUTOMATIC) BytesPerDataElement,
  P2VAR(P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) BuffPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) BuffPos,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PosIncrSize
)
{
  /* Determine the read data is required or not */
  if (ChannelInfPtr->RxBufferPtr != (P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))NULL_PTR)
  {
    *BuffPtr = ChannelInfPtr->RxBufferPtr;
    /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.6.
       Justification: As a result of this expression, it will not exceed
       the essential type. */
    /* PRQA S 4491 1 */
    *BuffPos = Pos * BytesPerDataElement;
    *PosIncrSize = BytesPerDataElement;
  }
  else
  {
    /* Deviation from MISRA-C:2004 rule 11.5, MISRA-C:2012 Rule-11.8.
       Justification: Cast is necessary for writing to the buffer 
       in other case. */
    /* PRQA S 311 1 */
    *BuffPtr = (P2VAR(Spi_DataBufferType, AUTOMATIC, AUTOMATIC))DummyBuff;
    *BuffPos = 0U;
    *PosIncrSize = 0U;
  }
}

/** \brief Spi_Hw_GetHwUnitInternalStatus
 **
 ** Returns the transmission/reception status of the specified HW unit.
 **
 ** \return HW unit internal status.
 ** \param [in] HwUnit   Id of HW unit.
 ** \param [in] Factor   the factor of the transmission or reception.
 **
 */
static FUNC(uint8, SPI_CODE) Spi_Hw_GetHwUnitInternalStatus
(
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit,
  VAR(Spi_HwFactorType, AUTOMATIC) Factor
)
{
  VAR(uint8, AUTOMATIC) InternalStatus;
  
  /* helpers to avoid too many lookups */
  P2VAR( Spi_HwInfoType, AUTOMATIC, AUTOMATIC ) CurHwInfoPtr = &(Spi_Info.HwInfoListPtr[HwUnit]);
  
  /* checks the transmission or the reception. */
  if ( (Factor == SPI_HW_FACTOR_SCB_TX) || (Factor == SPI_HW_FACTOR_DMA_TX) )
  {
    /* read tx status */
    InternalStatus = CurHwInfoPtr->TxStatus;
  }
  else
  {
    /* read rx status */
    InternalStatus = CurHwInfoPtr->RxStatus;
  }
  /* returns the status for the specified HW unit */
  return InternalStatus;
}

/** \brief Spi_Hw_FinishedSCB
 **
 ** Sets the HW unit to stop transmission for finished.
 **
 ** \return None.
 **
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HwUnit   Id of HW unit.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_FinishedSCB
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  VAR(Spi_JobType, AUTOMATIC) CurrentJob = Spi_Info.DriverHwInfoListPtr[HwUnit].Job;
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr
    = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurrentJob] );
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[HwUnit];
  P2CONST(Spi_ExternalDeviceConfigType, AUTOMATIC, AUTOMATIC) ExtDevPtr;

  /* enter a critical section */
  /* avoid contention with Terminate */
  Spi_Com_SchMEnterCriticalSection();

  /* get HW unit configuration */
  ExtDevPtr = JobConfigPtr->ExternalDevicePtr;
  Spi_Hw_StopFifo(CurScbPtr, ExtDevPtr, CurrentJob, Factor);

  /* exit a critical section */
  Spi_Com_SchMExitCriticalSection();
}

/** \brief Spi_Hw_FinishedDMA
 **
 ** Sets the HW unit to stop transmission for finished.
 **
 ** \return None.
 **
 ** \param [in] Factor   Specify the factor of the transmission or reception.
 ** \param [in] HwUnit   Id of HW unit.
 **
 */
static FUNC(void, SPI_CODE) Spi_Hw_FinishedDMA
(
  VAR(Spi_HwFactorType, AUTOMATIC) Factor,
  VAR(Spi_HWUnitType, AUTOMATIC) HwUnit
)
{
  VAR( uint8, AUTOMATIC ) StatusTx; /* HW Tx status */
  VAR( uint8, AUTOMATIC ) StatusRx; /* HW Rx status */
  VAR(Spi_JobType, AUTOMATIC) CurrentJob = Spi_Info.DriverHwInfoListPtr[HwUnit].Job;
  volatile P2VAR(Spi_SCBRegsType, AUTOMATIC, REGSPACE) CurScbPtr = Spi_Current_ConfigPtr->ScbRegsPtr[HwUnit];
  VAR( Spi_AsyncModeType, AUTOMATIC ) AsyncMode; /* async mode */
  VAR( uint8, AUTOMATIC ) LevelDelivered; /* level delivered */
  P2CONST(Spi_JobConfigType, AUTOMATIC, AUTOMATIC) JobConfigPtr 
    = &( Spi_Current_ConfigPtr->JobConfigListPtr[CurrentJob] );
  VAR(Spi_ChannelIndexType, TYPEDEF) ChannelIndex;

  /* SCB TX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */ 
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unTxFifoCtrl;
  /* SCB RX_FIFO_CTRL register */
  /* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2.
     Justification: This union type is used for accessing to register. */
  /* PRQA S 759 1 */ 
  VAR(Spi_un_Scb_Fifo_Ctrl_Type, AUTOMATIC) unRxFifoCtrl; 

  /* enter a critical section */
  /* avoid contention with Terminate */
  Spi_Com_SchMEnterCriticalSection();

  /* Get HW Tx/Rx Status */
  StatusTx = Spi_Hw_GetHwUnitInternalStatus(HwUnit, SPI_HW_FACTOR_DMA_TX);
  StatusRx = Spi_Hw_GetHwUnitInternalStatus(HwUnit, SPI_HW_FACTOR_DMA_RX);

  /* Check HW error */
  if ((StatusTx == SPI_FAILED) || (StatusRx == SPI_FAILED))
  { /* HW error detected */
    /* disable SCB */
    Spi_Hw_DisableSCB(CurScbPtr);

    if (Spi_Com_GetDmaChannelRegPtr(HwUnit, SPI_HW_FACTOR_DMA_TX) != (volatile Spi_DmaChannelRegsType*)NULL_PTR)
    {
      /* stop DMA for transmission */
      Spi_Dma_StopHwUnit(HwUnit, SPI_HW_FACTOR_DMA_TX);
      /* stop DMA for reception */
      Spi_Dma_StopHwUnit(HwUnit, SPI_HW_FACTOR_DMA_RX);
    }
  }
  else if (Factor == SPI_HW_FACTOR_DMA_TX)
  {
    /* stop DMA for transmission */
    Spi_Dma_StopHwUnit(HwUnit, Factor);

    /* set buffer position of current channel */
    for( ChannelIndex = 0U; ChannelIndex < JobConfigPtr->ChannelCount; ChannelIndex++)
    {
      Spi_Info.ChannelInfoListPtr[JobConfigPtr->ChannelListPtr[ChannelIndex]].BufferPosStoredForSend 
        = Spi_Current_ConfigPtr->ChannelConfigListPtr[ChannelIndex].BufferSize;
    }
    
    if ((StatusRx == SPI_OK) &&
        ((CurScbPtr->unINTR_M.u32Register & SPI_SCB_INTR_M_SPI_DONE) != 0U))
    { /* Bus Idle detect */
      /* last channel and detect bus idle */
      Spi_Info.HwInfoListPtr[HwUnit].TxStatus = SPI_OK;

      /* Interruption by bus idle */
      CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_MASK_ALL;

      CurScbPtr->unINTR_M.u32Register = SPI_SCB_INTR_M_CLEAR;
      (void)CurScbPtr->unINTR_M.u32Register;

      /* Disable Fifo & SCB  */
      unTxFifoCtrl.u32Register = CurScbPtr->unTX_FIFO_CTRL.u32Register;
      unTxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
      CurScbPtr->unTX_FIFO_CTRL.u32Register = unTxFifoCtrl.u32Register;
    }
  }
  else if (Factor == SPI_HW_FACTOR_DMA_RX)
  {
    /* DMA reception interrupt */
    /* stop DMA for reception */
    Spi_Dma_StopHwUnit(HwUnit, Factor);

    /* set buffer position of current channel */
    for( ChannelIndex = 0U; ChannelIndex < JobConfigPtr->ChannelCount; ChannelIndex++)
    {
      Spi_Info.ChannelInfoListPtr[JobConfigPtr->ChannelListPtr[ChannelIndex]].BufferPosReceived 
        = Spi_Current_ConfigPtr->ChannelConfigListPtr[ChannelIndex].BufferSize;
    }
    
    /* updates internal status */
    Spi_Info.HwInfoListPtr[HwUnit].RxStatus = SPI_OK;
    
    /* Disable FIFO */
    unRxFifoCtrl.u32Register = CurScbPtr->unRX_FIFO_CTRL.u32Register;
    unRxFifoCtrl.stcField.u1CLEAR = STD_HIGH;
    CurScbPtr->unRX_FIFO_CTRL.u32Register = unRxFifoCtrl.u32Register;

    /* Get level delivered and async mode */
    LevelDelivered = Spi_Com_GetLevelDelivered();
    AsyncMode = Spi_Internal_GetAsyncMode();

    /* check async mode */
    if ((LevelDelivered == SPI_LEVEL_DELIVERED_1) ||
        (AsyncMode != SPI_POLLING_MODE))
    { /* Enable SPI_DONE Interrupt */
      CurScbPtr->unINTR_M_MASK.u32Register = SPI_SCB_INTR_M_SPI_DONE_ENABLE;
    }
  }
  else
  { /* Do nothing */
    ;
  }
  /* exit a critical section */
  Spi_Com_SchMExitCriticalSection();
}

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[end of file]===========================================*/
