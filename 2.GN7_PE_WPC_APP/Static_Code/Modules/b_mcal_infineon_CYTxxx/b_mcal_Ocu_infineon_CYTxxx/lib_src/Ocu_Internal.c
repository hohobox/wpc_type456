/** \brief AUTOSAR Ocu Driver
 **
 ** This file contains internal architecture function for the AUTOSAR Ocu driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/
#include <Ocu_Internal.h>         /* Module internal declaration */
#include <Ocu_RegisterAccess.h>   /* Module register types */

/*==================[macros]=================================================*/

/*==================[type definitions]=======================================*/

/*==================[internal data]==========================================*/

#define OCU_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
#include <Ocu_MemMap.h>

/** Holds current status of driver. */
static VAR( Ocu_DriverStatusType, OCU_VAR_INIT ) Ocu_DriverStatus = OCU_S_UNINITIALIZED;

#define OCU_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>


#define OCU_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** Record count direction for the whole OCU driver. */
static VAR( Ocu_CountDirectionType, OCU_VAR_NO_INIT ) Ocu_CountDirection;

#define OCU_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[external function declarations]=========================*/

/*==================[internal function declarations]=========================*/

#define OCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** \brief Ocu_CheckChannelStatus_Common
 **
 ** This function verifies register settings.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE: Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Common
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
);

/** \brief Ocu_CheckChannelStatus_Running
 **
 ** This function verifies register settings for channel state running.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE: Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Running
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
);

/** \brief Ocu_CheckChannelStatus_Stopped
 **
 ** This function verifies register settings for channel state stop.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE: Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Stopped
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
);

/** \brief Ocu_GetPrescalerValue
 **
 ** Calculate channel prescaler value.
 **
 ** \param [in] TickFrequency    Tick frequency of channel configuration.
 ** \param [in] ClockFrequency   Input clock frequency.
 **
 ** \return  If ClockFrequency is valid value return calculated prescaler value.
 **          Else return OCU_INVALID_PRESCALER.
 **
 */
static FUNC( uint8, OCU_CODE ) Ocu_GetPrescalerValue
(
  VAR( Ocu_ClkFrequencyType, AUTOMATIC ) TickFrequency,
  VAR( Ocu_ClkFrequencyType, AUTOMATIC ) ClockFrequency
);

/** \brief Ocu_GetReturnValue
 **
 ** Calculate the return value for SetAbosluteThreshold and SetRealativeThreshold
 **
 ** \param [in] Current      Current counter value.
 ** \param [in] Reference    Reference counter value.
 ** \param [in] Threshold    New threshold value.
 **
 ** \return  If the compare match will occur inside the current Reference Interval,
 **          return TRUE, else return FALSE.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_GetReturnValue
(
  VAR( Ocu_ValueType, AUTOMATIC ) Current,
  VAR( Ocu_ValueType, AUTOMATIC ) Reference,
  VAR( Ocu_ValueType, AUTOMATIC ) Threshold
);

#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[external function definitions]==========================*/

#define OCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** \brief Ocu_GetDriverStatus
 **
 ** Provides current driver status.
 **
 ** \return  Driver status.
 **
 */
FUNC( Ocu_DriverStatusType, OCU_CODE ) Ocu_GetDriverStatus( void )
{
  return Ocu_DriverStatus;
}

/** \brief Ocu_SetDriverStatus
 **
 ** Set current driver status.
 **
 ** \param [in] DrvStatus  Driver status.
 **
 */
FUNC( void, OCU_CODE ) Ocu_SetDriverStatus
(
  VAR( Ocu_DriverStatusType, AUTOMATIC ) DrvStatus
)
{
  Ocu_DriverStatus = DrvStatus;
}

/** \brief Ocu_Init_Internal
 **
 ** OCU driver initialization.
 **
 ** \param [in] ConfigPtr           Pointer of data stored configuration set information.
 **
 */
FUNC( void, OCU_CODE ) Ocu_Init_Internal
(
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigPtr
)
{
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;
  P2VAR( Ocu_ChannelStatusType, AUTOMATIC, OCU_APPL_DATA ) ChannelStatePtr;
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber;

  Ocu_EnterCriticalSection();

  /* Keep driver count direction */
  Ocu_CountDirection = ConfigPtr->CountDirection;

  /* Initialize all configured channels */
  for ( ChannelNumber = 0U; ChannelNumber < ConfigPtr->NumberOfChannels; ChannelNumber++ )
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigPtr->ChannelCfgPtr[ChannelNumber] );
    ChannelStatePtr = ChannelConfigPtr->ChannelStatusPtr;

    /* Update channel status with default values */
    ChannelStatePtr->SettingThreshold    = ChannelConfigPtr->DefaultThreshold;
    ChannelStatePtr->PinState            = ChannelConfigPtr->OutputPinDefaultState;
    ChannelStatePtr->PinAction           = OCU_DISABLE;
    ChannelStatePtr->ChannelState        = OCU_CH_STOPPED;
    ChannelStatePtr->ChannelId           = ChannelConfigPtr->ChannelId;
    ChannelStatePtr->Prescale            = ChannelConfigPtr->Prescale;
    ChannelStatePtr->NotificationEnabled = FALSE;

    /* Initialize HW channels */
    Ocu_RaInit( ChannelConfigPtr, Ocu_CountDirection );

    if ( OCU_PIN_STATE_INVALID_VALUE != ChannelConfigPtr->OutputPinDefaultState )
    {
      /* Set default Pin State */
      Ocu_RaSetPinState( ChannelConfigPtr, ChannelConfigPtr->OutputPinDefaultState, Ocu_CountDirection );
    }

    if ( OCU_INVALID_TRIGGERVALUE != ChannelConfigPtr->StartTriggerSelectValue )
    {
      /* Set hardware start trigger */
      Ocu_RaHwTriggerStart( ChannelConfigPtr );
    }
    else
    {
      /* Start a counter */
      Ocu_RaReloadFreeRunningCounter( ChannelConfigPtr );
    }
  }

  Ocu_ExitCriticalSection();
}

/** \brief Ocu_DeInit_Internal
 **
 ** Internal implementation of OCU driver De-initialization.
 **
 ** \param [in] ConfigPtr  Pointer of data stored configuration set information.
 **
 */
FUNC( void, OCU_CODE ) Ocu_DeInit_Internal
(
  P2CONST( Ocu_ConfigType, AUTOMATIC, OCU_APPL_CONST ) ConfigPtr
)
{
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelConfigPtr;
  P2VAR( Ocu_ChannelStatusType, AUTOMATIC, OCU_APPL_DATA ) ChannelStatePtr;
  VAR( Ocu_ChannelType, AUTOMATIC ) ChannelNumber;

  /* De-Initialize driver count direction */
  Ocu_CountDirection = OCU_UPCOUNTING;

  /* De-Initialize all configured channels */
  for ( ChannelNumber = 0U; ChannelNumber < ConfigPtr->NumberOfChannels; ChannelNumber++ )
  {
    /* Get config pointer for specified channel */
    ChannelConfigPtr = &( ConfigPtr->ChannelCfgPtr[ChannelNumber] );
    ChannelStatePtr  = ChannelConfigPtr->ChannelStatusPtr;

    /* De-initialize to hardware channel */
    Ocu_RaDeInit( ChannelConfigPtr );

    /* Set initial value to channel status */
    ChannelStatePtr->SettingThreshold    = OCU_REG_VALUE_TCPWM_CC0;
    ChannelStatePtr->PinState            = OCU_PIN_STATE_INVALID_VALUE;
    ChannelStatePtr->PinAction           = OCU_DISABLE;
    ChannelStatePtr->ChannelState        = OCU_CH_UNINITIALIZED;
    ChannelStatePtr->ChannelId           = 0U;
    ChannelStatePtr->Prescale            = 0U;
    ChannelStatePtr->NotificationEnabled = FALSE;
  }
}

/** \brief Ocu_StartChannel_Internal
 **
 ** Start an OCU channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_StartChannel_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  Ocu_EnterCriticalSection();

  if ( TRUE == ChannelCfgPtr->ChannelStatusPtr->NotificationEnabled )
  {
    /* Enable interrupt */
    Ocu_RaEnableNotification( ChannelCfgPtr->BaseAddress );
  }

  /* Start channel on HW */
  Ocu_RaStartChannel( ChannelCfgPtr );

  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->ChannelState = OCU_CH_RUNNING;

  Ocu_ExitCriticalSection();
}

/** \brief Ocu_StopChannel_Internal
 **
 ** Stop an OCU channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_StopChannel_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  Ocu_EnterCriticalSection();

  /* Disable interrupt */
  Ocu_RaDisableNotification( ChannelCfgPtr->BaseAddress );

  /* Stop channel on HW */
  Ocu_RaStopChannel( ChannelCfgPtr );

  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->ChannelState = OCU_CH_STOPPED;

  Ocu_ExitCriticalSection();
}

/** \brief Ocu_SetPinState_Internal
 **
 ** Set immediately the level of the pin associated to an OCU channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 ** \param [in] PinState       Type of pin state:
 **                            OCU_LOW or
 **                            OCU_HIGH.
 **
 */
FUNC( void, OCU_CODE ) Ocu_SetPinState_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_PinStateType, AUTOMATIC ) PinState
)
{
  Ocu_EnterCriticalSection();

  /* Stop timer */
  Ocu_RaStopFreeRunningCounter( ChannelCfgPtr );

  /* Set pin state on HW */
  Ocu_RaSetPinState( ChannelCfgPtr, PinState, Ocu_CountDirection );

  /* Restart timer */
  Ocu_RaReloadFreeRunningCounter( ChannelCfgPtr );

  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->PinState = PinState;

  Ocu_ExitCriticalSection();
}

/** \brief Ocu_SetPinAction_Internal
 **
 ** Indicate the driver what shall be done automatically by hardware upon compare match.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 ** \param [in] PinAction      Type of pin action:
 **                            OCU_SET_LOW or
 **                            OCU_SET_HIGH or
 **                            OCU_TOGGLE or
 **                            OCU_DISABLE.
 **
 */
FUNC( void, OCU_CODE ) Ocu_SetPinAction_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_PinActionType, AUTOMATIC ) PinAction
)
{
  Ocu_EnterCriticalSection();

  /* Stop timer */
  Ocu_RaStopFreeRunningCounter( ChannelCfgPtr );

  /* Set pin action on HW */
  Ocu_RaSetPinAction( ChannelCfgPtr, PinAction );

  /* Restart timer */
  Ocu_RaStartFreeRunningCounter( ChannelCfgPtr );

  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->PinAction = PinAction;

  Ocu_ExitCriticalSection();
}

/** \brief Ocu_GetCounter_Internal
 **
 ** Read the current value of the counter.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  Content of the counter in ticks.
 **
 */
FUNC( Ocu_ValueType, OCU_CODE ) Ocu_GetCounter_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  VAR( Ocu_ValueType, AUTOMATIC ) CounterValue;

  /* Get counter */
  CounterValue = Ocu_RaGetCounter( ChannelCfgPtr );

  return CounterValue;
}

/** \brief Ocu_SetAbsoluteThreshold_Internal
 **
 ** Set the value of the channel threshold using an absolute input data.
 **
 ** \param [in] ChannelCfgPtr   Pointer to channel configuration.
 ** \param [in] ReferenceValue  Value given by the upper layer and used as a base to determine
 **                             whether to call the notification before the function exits or not.
 ** \param [in] AbsoluteValue   Value to compare with the content of the counter. This value is in ticks.
 **
 ** \return  If the compare match will occur inside the current Reference Interval,
 **          return TRUE, else return FALSE.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_SetAbsoluteThreshold_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_ValueType, AUTOMATIC ) ReferenceValue,
  VAR( Ocu_ValueType, AUTOMATIC ) AbsoluteValue
)
{
  VAR( boolean, AUTOMATIC ) Result;
  VAR( Ocu_ValueType, AUTOMATIC ) CounterValue;

  if ( OCU_CH_RUNNING == ChannelCfgPtr->ChannelStatusPtr->ChannelState )
  {
    Ocu_EnterCriticalSection();
    /* Set absolute threshold on HW */
    Ocu_RaSetThresholdValue( ChannelCfgPtr, AbsoluteValue );

    /* Get counter */
    CounterValue = Ocu_GetCounter_Internal( ChannelCfgPtr );

    Ocu_ExitCriticalSection();

    Result = Ocu_GetReturnValue ( CounterValue, ReferenceValue, AbsoluteValue );
  }
  else
  {
    Result = FALSE;
  }

  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->SettingThreshold = AbsoluteValue;

  return Result;
}

/** \brief Ocu_SetRelativeThreshold_Internal
 **
 ** Set the value of the channel threshold relative to the current value of the counter.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 ** \param [in] RelativeValue  Value to use for computing the new threshold.
 **
 ** \return  If the compare match will occur inside the current Reference Interval,
 **          return TRUE, else return FALSE.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_SetRelativeThreshold_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_ValueType, AUTOMATIC ) RelativeValue
)
{
  VAR( boolean, AUTOMATIC ) Result;
  VAR( Ocu_ValueType, AUTOMATIC ) ReadValue;
  VAR( Ocu_ValueType, AUTOMATIC ) CounterValue;
  VAR( Ocu_ValueType, AUTOMATIC ) NewThresholdValue;

  Ocu_EnterCriticalSection();

  ReadValue = Ocu_GetCounter_Internal( ChannelCfgPtr );

  if (Ocu_CountDirection != OCU_DOWNCOUNTING)
  {
    /* Roll over */
    if ( ReadValue > ( ChannelCfgPtr->MaxCounterValue - RelativeValue ) )
    {
      /* Calculate new threshold value. */
      NewThresholdValue = RelativeValue - ( ( ChannelCfgPtr->MaxCounterValue - ReadValue ) + 1U );
    }
    else
    {
      NewThresholdValue = ReadValue + RelativeValue;
    }
  }
  else
  {
    /* Calculate new threshold value */
    if (ReadValue >= RelativeValue)
    {
      NewThresholdValue = ReadValue - RelativeValue;
    }
    /* Roll over */
    else
    {
      NewThresholdValue = ChannelCfgPtr->MaxCounterValue - RelativeValue + 1U + ReadValue;
    }
  }
  
  if ( OCU_CH_RUNNING == ChannelCfgPtr->ChannelStatusPtr->ChannelState )
  {
    /* Set relative threshold on HW. */
    Ocu_RaSetThresholdValue( ChannelCfgPtr, NewThresholdValue );

    /* Get counter */
    CounterValue = Ocu_GetCounter_Internal( ChannelCfgPtr );

    Ocu_ExitCriticalSection();

    Result = Ocu_GetReturnValue ( CounterValue, ReadValue, NewThresholdValue );
  }
  else
  {
    Ocu_ExitCriticalSection();

    Result = FALSE;
  }

  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->SettingThreshold = NewThresholdValue;

  return Result;
}

/** \brief Ocu_EnableNotification_Internal
 **
 ** Enable notifications from an OCU channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_EnableNotification_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  if ( OCU_CH_RUNNING == ChannelCfgPtr->ChannelStatusPtr->ChannelState )
  {
    /* Critical section is not needed, because function is non-reentrant for the same channel.
    For different channels there is no interference */
    Ocu_RaEnableNotification( ChannelCfgPtr->BaseAddress );
  }
  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->NotificationEnabled = TRUE;
}

/** \brief Ocu_DisableNotification_Internal
 **
 ** Disable notifications from an OCU channel.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_DisableNotification_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  if ( OCU_CH_RUNNING == ChannelCfgPtr->ChannelStatusPtr->ChannelState )
  {
    /* Critical section is not needed, because function is non-reentrant for the same channel.
       For different channels there is no interference */
    Ocu_RaDisableNotification( ChannelCfgPtr->BaseAddress );
  }
  /* Set channel status */
  ChannelCfgPtr->ChannelStatusPtr->NotificationEnabled = FALSE;
}

/** \brief Ocu_CheckChannelStatus_Internal
 **
 ** Check the current status of the channel.
 **
 ** \param [in] ChannelCfgPtr      Pointer to channel configuration.
 ** \param [out] ChannelStatusPtr  Pointer to where to store the channel status information.
 **
 ** \return  TRUE:  Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  P2VAR( Ocu_ChannelStatusType, AUTOMATIC, OCU_APPL_DATA ) ChannelStatusPtr
)
{
  VAR( boolean, AUTOMATIC ) Result;

  Ocu_EnterCriticalSection();

  /* Set channel status */
  ChannelStatusPtr->SettingThreshold    = ChannelCfgPtr->ChannelStatusPtr->SettingThreshold;
  ChannelStatusPtr->PinState            = ChannelCfgPtr->ChannelStatusPtr->PinState;
  ChannelStatusPtr->PinAction           = ChannelCfgPtr->ChannelStatusPtr->PinAction;
  ChannelStatusPtr->ChannelState        = ChannelCfgPtr->ChannelStatusPtr->ChannelState;
  ChannelStatusPtr->ChannelId           = ChannelCfgPtr->ChannelStatusPtr->ChannelId;
  ChannelStatusPtr->Prescale            = ChannelCfgPtr->ChannelStatusPtr->Prescale;
  ChannelStatusPtr->NotificationEnabled = ChannelCfgPtr->ChannelStatusPtr->NotificationEnabled;

  /* Driver status: OCU_S_INITIALIZED */
  if ( OCU_S_INITIALIZED == Ocu_DriverStatus )
  {
    /* Check common register values */
    if ( TRUE != Ocu_CheckChannelStatus_Common( ChannelCfgPtr ) )
    {
      Result = FALSE;
    }
    else
    {
      /* Channel status: OCU_CH_RUNNING */
      if ( OCU_CH_RUNNING == ChannelStatusPtr->ChannelState )
      {
        Result = Ocu_CheckChannelStatus_Running( ChannelCfgPtr );
      }
      /* Channel status: OCU_CH_STOPPED */
      else if ( OCU_CH_STOPPED == ChannelStatusPtr->ChannelState )
      {
        Result = Ocu_CheckChannelStatus_Stopped( ChannelCfgPtr );
      }
      /* Channel status: OCU_CH_UNINITIALIZED */
      else
      {
        Result = FALSE;
      }
    }
  }
  /* Driver status: OCU_S_UNINITIALIZED */
  else
  {
    Result = Ocu_RaCheckChannelStatus_Uninit( ChannelCfgPtr );
  }

  Ocu_ExitCriticalSection();

  return Result;
}

/** \brief Ocu_SetPrescaler_Internal
 **
 ** Calculate prescaler value and update value on hardware.
 **
 ** \param [in] ChannelCfgPtr   Pointer to channel configuration.
 ** \param [in] ClockFrequency  Input clock frequency.
 **
 ** \return  If calculated prescaler value is valid, return TRUE, else return FALSE.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_SetPrescaler_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr,
  VAR( Ocu_ClkFrequencyType, AUTOMATIC ) ClockFrequency
)
{
  VAR( boolean, AUTOMATIC ) Result;
  VAR( uint8, AUTOMATIC ) PreValue;

  /* Check clock frequency and get prescaler value */
  PreValue = Ocu_GetPrescalerValue( ChannelCfgPtr->TickFrequency, ClockFrequency );

  if ( PreValue == OCU_INVALID_PRESCALER )
  {
    Result = FALSE;
  }
  else
  {
    Ocu_EnterCriticalSection();

    /* Stop timer */
    Ocu_RaStopFreeRunningCounter( ChannelCfgPtr );

    /* Set prescaler value */
    Ocu_RaSetPrescaler( ChannelCfgPtr, PreValue );

    /* Restart timer */
    Ocu_RaReloadFreeRunningCounter( ChannelCfgPtr );

    /* Update prescaler value */
    ChannelCfgPtr->ChannelStatusPtr->Prescale = PreValue;

    Ocu_ExitCriticalSection();

    Result = TRUE;
  }
  return Result;
}

/** \brief Ocu_InterruptHandler_Internal
 **
 ** Generic interrupt handler that is called from specific interrupt handlers.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 */
FUNC( void, OCU_CODE ) Ocu_InterruptHandler_Internal
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  VAR( boolean, AUTOMATIC ) Result;
  Result = Ocu_RaIsInterruptPending( ChannelCfgPtr->BaseAddress );

  /* Clear the interrupt flag */
  Ocu_RaClearInterruptFlag( ChannelCfgPtr->BaseAddress );

  /* Check if interrupt detected */
  if ( TRUE == Result )
  {
    /* Notification enabled and function pointer existing */
    if ( ( TRUE == ChannelCfgPtr->ChannelStatusPtr->NotificationEnabled )
      && ( NULL_PTR != ChannelCfgPtr->Notification ) )
    {
      /* Call notification function */
      ( *ChannelCfgPtr->Notification )();
    }
  }
}

/** \brief Ocu_ClearChannelInterruptByBaseAddr
 **
 ** Clear the interrupt flag by base address of HW timer.
 **
 ** \param [in] BaseAddress  Base address of the HW Timer register structure.
 **
 */
FUNC(void, OCU_CODE) Ocu_ClearChannelInterruptByBaseAddr
(
  CONST( uint32, AUTOMATIC ) BaseAddress
)
{
  Ocu_RaClearInterruptFlag( BaseAddress );
}

#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[internal function definitions]==========================*/
#define OCU_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/** \brief Ocu_CheckChannelStatus_Common
 **
 ** This function verifies register settings.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE:  Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Common
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  VAR( boolean, AUTOMATIC ) Result = TRUE;
  VAR( uint32, AUTOMATIC )  RegCtrl;
  VAR( uint32, AUTOMATIC )  RegTrOutSel;

  if ( TRUE != Ocu_RaCheckChannelStatus_Common( ChannelCfgPtr ) )
  {
    Result = FALSE;
  }
  else
  {
    RegCtrl = Ocu_RaGetCtrl( ChannelCfgPtr->BaseAddress );
    RegTrOutSel  = Ocu_RaGetTrOutSel( ChannelCfgPtr->BaseAddress );

    /* is counter enabled check */
    if ( OCU_REG_MASK_TCPWM_CTRL_ENABLED != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_ENABLED ) )
    {
      Result = FALSE;
    }

    /* is pwm mode check */
    if ( OCU_REG_MASK_TCPWM_CTRL_MODE_PWM != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_MODE ) )
    {
      Result = FALSE;
    }

    /* is counter up down check */
    if ( OCU_UPCOUNTING == Ocu_CountDirection )
    {
      if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_UP_DOWN_MODE ) )
      {
        Result = FALSE;
      }
    }
    else
    {
      if ( OCU_REG_MASK_TCPWM_CTRL_COUNT_DOWN != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_UP_DOWN_MODE ) )
      {
        Result = FALSE;
      }
    }

    /* is debug mode check */
    if ( TRUE == ChannelCfgPtr->DebugMode )
    {
      /* Debug enable */
      if ( OCU_REG_MASK_TCPWM_CTRL_DBG_FREEZE_EN != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_DBG_FREEZE_EN ) )
      {
        Result = FALSE;
      }
    }
    else
    {
      /* Debug disable */
      if ( 0U != ( RegCtrl & OCU_REG_MASK_TCPWM_CTRL_DBG_FREEZE_EN ) )
      {
        Result = FALSE;
      }
    }

    /* Output trigger 0/1 enable */
    if ( OCU_TRIGGER_DISABLE != ChannelCfgPtr->TriggerOutputSelect )
    {
      /* Output trigger 0 enable */
      if ( OCU_TRIGGER_OUT0 == ( ChannelCfgPtr->TriggerOutputSelect & OCU_TRIGGER_OUT0 ) )
      {
        /* is output trigger 0 enable check */
        if ( OCU_TRIGGEROUT_CC0_MATCH != ( RegTrOutSel & OCU_TRIGGEROUT_DISABLED ) )
        {
          Result = FALSE;
        }
      }
      /* Output trigger 0 disable */
      else
      {
        /* is output trigger 0 disable check */
        if ( OCU_TRIGGEROUT_DISABLED != ( RegTrOutSel & OCU_TRIGGEROUT_DISABLED ) )
        {
          Result = FALSE;
        }
      }

      /* Output trigger 1 enable */
      if ( OCU_TRIGGER_OUT1 == ( ChannelCfgPtr->TriggerOutputSelect & OCU_TRIGGER_OUT1 ) )
      {
        /* is output trigger 1 enable check */
        if ( OCU_TRIGGEROUT_CC0_MATCH
        != ( ( RegTrOutSel>>OCU_REG_BIT_TCPWM_TR_OUT_SEL_OUT1 ) & OCU_TRIGGEROUT_DISABLED ) )
        {
          Result = FALSE;
        }
      }
      /* Output trigger 1 disable */
      else
      {
        /* is output trigger 1 disable check */
        if ( OCU_TRIGGEROUT_DISABLED
        != ( ( RegTrOutSel>>OCU_REG_BIT_TCPWM_TR_OUT_SEL_OUT1 ) & OCU_TRIGGEROUT_DISABLED ) )
        {
          Result = FALSE;
        }
      }
    }
    /* Output trigger disable */
    else
    {
      /* is output trigger disable check */
      if ( OCU_REG_VALUE_TCPWM_TR_OUT_SEL != RegTrOutSel )
      {
        Result = FALSE;
      }
    }
  }

  return Result;
}

/** \brief Ocu_CheckChannelStatus_Running
 **
 ** This function verifies register settings for channel state running.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE: Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Running
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  VAR( boolean, AUTOMATIC ) Result = TRUE;
  VAR( uint32, AUTOMATIC )  RegIntrMask;
  VAR( uint32, AUTOMATIC )  RegCC0;

  RegIntrMask  = Ocu_RaGetIntrMask( ChannelCfgPtr->BaseAddress );
  RegCC0       = Ocu_RaGetCC0( ChannelCfgPtr->BaseAddress );

  /* is CC0 check */
  if ( ChannelCfgPtr->ChannelStatusPtr->SettingThreshold != RegCC0 )
  {
    Result = FALSE;
  }

  if ( TRUE == ChannelCfgPtr->ChannelStatusPtr->NotificationEnabled )
  {
    /* is enable inter mask correct check */
    if ( OCU_REG_MASK_TCPWM_INTR_MASK_CC0_MATCH
    != ( RegIntrMask & OCU_REG_MASK_TCPWM_INTR_MASK_CC0_MATCH ) )
    {
      Result = FALSE;
    }
  }
  else
  {
    /* is disable inter mask correct check */
    if ( 0U != ( RegIntrMask & OCU_REG_MASK_TCPWM_INTR_MASK_CC0_MATCH ) )
    {
      Result = FALSE;
    }
  }

  return Result;
}

/** \brief Ocu_CheckChannelStatus_Stopped
 **
 ** This function verifies register settings for channel state stop.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE: Software and hardware states are in sync.
 **          FALSE: Software and hardware states are inconsistent.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_CheckChannelStatus_Stopped
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  VAR( boolean, AUTOMATIC ) Result = TRUE;
  VAR( uint32, AUTOMATIC )  RegIntrMask;
  VAR( uint32, AUTOMATIC )  RegTrPwmCtrl;
  VAR( uint32, AUTOMATIC )  RegCC0;

  RegIntrMask  = Ocu_RaGetIntrMask( ChannelCfgPtr->BaseAddress );
  RegTrPwmCtrl = Ocu_RaGetTrPwmCtrl( ChannelCfgPtr->BaseAddress );
  RegCC0       = Ocu_RaGetCC0( ChannelCfgPtr->BaseAddress );

  /* is CC0 default (0xFFFFFFFF(32bit)/0xFFFF(16bit)) check */
  if( OCU_TIMER_WIDTH_32 == ChannelCfgPtr->TimerWide )
  {
    if ( OCU_REG_VALUE_TCPWM_CC0 != RegCC0 )
    {
      Result = FALSE;
    }
  }
  else
  {
    if ( ( uint32 )( OCU_REG_VALUE_TCPWM_CC0 & OCU_REG_MASK_TCPWM_16BITS_MASK ) != RegCC0 )
    {
      Result = FALSE;
    }
  }

  /* is disable inter mask correct check */
  if ( 0U != ( RegIntrMask & OCU_REG_MASK_TCPWM_INTR_MASK_CC0_MATCH ) )
  {
    Result = FALSE;
  }

  /* Pin state check */
  if ( OCU_PIN_STATE_INVALID_VALUE != ChannelCfgPtr->ChannelStatusPtr->PinState )
  {
    if ( ( uint32 )( ChannelCfgPtr->ChannelStatusPtr->PinState )
      != ((RegTrPwmCtrl >> OCU_REG_BIT_TCPWM_TR_PWM_CTRL_CC1_MATCH_MODE) & OCU_TCPWM_TR_PWM_CTRL_NO_CHANGE ))
    {
      Result = FALSE;
    }
  }

  return Result;
}

/** \brief Ocu_GetPrescalerValue
 **
 ** Calculate channel prescaler value.
 **
 ** \param [in] TickFrequency    Tick frequency of channel configuration.
 ** \param [in] ClockFrequency   Input clock frequency.
 **
 ** \return  If ClockFrequency is valid value return calculated prescaler value.
 **          Else return OCU_INVALID_PRESCALER.
 **
 */
static FUNC( uint8, OCU_CODE ) Ocu_GetPrescalerValue
(
  VAR( Ocu_ClkFrequencyType, AUTOMATIC ) TickFrequency,
  VAR( Ocu_ClkFrequencyType, AUTOMATIC ) ClockFrequency
)
{
  VAR( uint8, AUTOMATIC ) Prescaler;
  VAR( uint32, AUTOMATIC ) DividerValue;

  DividerValue = ClockFrequency / TickFrequency;

  /* Input clock frequency check */
  if( OCU_PRESCALING_DIVIDE_NONE == DividerValue )
  {
    Prescaler = OCU_INVALID_PRESCALER;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_1 + OCU_PRESCALING_DIVIDE_BY_2 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_1;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_2 + OCU_PRESCALING_DIVIDE_BY_4 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_2;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_4 + OCU_PRESCALING_DIVIDE_BY_8 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_4;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_8 + OCU_PRESCALING_DIVIDE_BY_16 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_8;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_16 + OCU_PRESCALING_DIVIDE_BY_32 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_16;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_32 + OCU_PRESCALING_DIVIDE_BY_64 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_32;
  }
  else if ( DividerValue <= ( ( OCU_PRESCALING_DIVIDE_BY_64 + OCU_PRESCALING_DIVIDE_BY_128 ) / OCU_HALF_DIVIDER ) )
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_64;
  }
  else
  {
    Prescaler = OCU_PRESCALER_DIVIDE_BY_128;
  }

  return Prescaler;
}

/** \brief Ocu_GetStatusRunning
 **
 ** Get counter running status.
 **
 ** \param [in] ChannelCfgPtr  Pointer to channel configuration.
 **
 ** \return  TRUE:  Counter is running.
 **          FALSE: Counter is not running.
 **
 */
FUNC( boolean, OCU_CODE ) Ocu_GetStatusRunning
(
  P2CONST( Ocu_ChannelConfigType, AUTOMATIC, OCU_APPL_CONST ) ChannelCfgPtr
)
{
  VAR( boolean, AUTOMATIC ) Result;

  /* Get counter running status */
  Result = Ocu_RaGetStatusRunning( ChannelCfgPtr->BaseAddress );

  return Result;
}

/** \brief Ocu_GetReturnValue
 **
 ** Calculate the return value for SetAbosluteThreshold and SetRealativeThreshold
 **
 ** \param [in] Current      Current counter value.
 ** \param [in] Reference    Reference counter value.
 ** \param [in] Threshold    New threshold value.
 **
 ** \return  If the compare match will occur inside the current Reference Interval,
 **          return TRUE, else return FALSE.
 **
 */
static FUNC( boolean, OCU_CODE ) Ocu_GetReturnValue
(
  VAR( Ocu_ValueType, AUTOMATIC ) Current,
  VAR( Ocu_ValueType, AUTOMATIC ) Reference,
  VAR( Ocu_ValueType, AUTOMATIC ) Threshold
)
{
  VAR( boolean, AUTOMATIC ) Result;

  /* OCU_UPCOUNTING */
  if (Ocu_CountDirection != OCU_DOWNCOUNTING)
  {
    if ( Reference < Threshold )
    {
      /* Check the compare match will occur inside the current Reference Interval */
      if( ( Reference <= Current ) && ( Current < Threshold ) )
      {
        Result = TRUE;
      }
      else
      {
        Result = FALSE;
      }
    }
    /* Roll over */
    else
    {
      /* Check the compare match will occur inside the current Reference Interval */
      if( ( Reference <= Current ) || ( Current < Threshold ) )
      {
        Result = TRUE;
      }
      else
      {
        Result = FALSE;
      }
    }
  }
  /* OCU_DOWNCOUNTING */
  else
  {
    if ( Reference > Threshold )
    {
      /* Check the compare match will occur inside the current Reference Interval */
      if( ( Reference >= Current ) && ( Current > Threshold ) )
      {
        Result = TRUE;
      }
      else
      {
        Result = FALSE;
      }
    }
    /* Roll over */
    else
    {
      /* Check the compare match will occur inside the current Reference Interval */
      if( ( Reference >= Current ) || ( Current > Threshold ) )
      {
        Result = TRUE;
      }
      else
      {
        Result = FALSE;
      }
    }
  }

  return Result;
}


#define OCU_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Ocu_MemMap.h>

/*==================[end of file]============================================*/
