/** \brief AUTOSAR Gpt GPT Driver
 **
 ** This file contains internal architecture function for the
 ** AUTOSAR Gpt driver.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include <Std_Types.h>              /* AUTOSAR standard types */
#include <Gpt_Status.h>             /* status types */
#include <Gpt_External.h>           /* External modules types */
#include <Gpt_Controller.h>         /* Internal Architecture types */
#include <Gpt_Timer_Counter.h>      /* Timer Counter types */

/*==================[macros]================================================*/
/*==================[type definitions]======================================*/
/*==================[external function declarations]========================*/
/*==================[internal function declarations]========================*/
#define GPT_START_SEC_CODE_ASIL_B
#include <Gpt_MemMap.h>

/** \brief Gpt_GetPrescalerValue() checks the register.
 **
 ** If the input clockfrequency is invalid, return GPT_NOT_OK.
 ** Else return divider value.
 ** 
 ** \param[in] TickFrequency     Tick frequency of channel configuration.
 ** \param[in] ClockFrequency    Input clock frequency.
 **
 ** \retval IF clockfrequency is valiad value return calculated precaler value.
 **         Else return GPT_PRESCALER_INVALID.
 **/
static FUNC(uint8, GPT_CODE) Gpt_GetPrescalerValue(
  Gpt_ClkFrequencyType TickFrequency,
  Gpt_ClkFrequencyType ClockFrequency);

/** \brief Gpt_GetPredefTimerId()
 **
 ** This function gets the ID of specific PredefTimer.
 **
 ** \param[in]  PredefTimer GPT Predef Timer.
 ** \param[out] PredefTimerId Pointer to index of Predef Timer.
 **
 ** \retval GPT_OK      Set Predef prescaler is success.
 **         GPT_NOT_OK  Set Predef prescaler is failed.
 **
 **/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_GetPredefTimerId(
  Gpt_PredefTimerType                                 PredefTimer,
  P2VAR(Gpt_PredefTimerIdType, AUTOMATIC, GPT_APPL_DATA)  PredefTimerIdPtr
);

#define GPT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/*==================[external constants]====================================*/
/*==================[internal constants]====================================*/
/*==================[external data]=========================================*/
/*==================[internal data]=========================================*/
/*==================[external function definitions]=========================*/
#define GPT_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>

/** \brief Gpt_GetTimeElapsed_Internal()
 **
 ** This function reads the timer counter value of elapsed time.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \return the time already elapsed.
**/
FUNC(Gpt_ValueType, GPT_CODE) Gpt_GetTimeElapsed_Internal(Gpt_ChannelType Channel)
{
  Gpt_ValueType Time;
  Gpt_ValueType Interval;
  Gpt_ChannelStateValueType State;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];

  State = Gpt_ReadChannelStatus(Channel);
  if (State != GPT_STATE_INITIALIZED)
  {
    if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) != GPT_MODE_CONTINUOUS)
    {
      /* reads interval time */
      Interval = Gpt_ReadChannelInterval(Channel);

      /* when channel is running or stopping, returns current elapsed time. */
      if (State != GPT_STATE_EXPIRED)
      {
        /* gets function table */
        FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

        /* get time process (oneshot) of hardware */
        Time = FuncTablePtr->drvGetTimeElapsedOneShotFct(ChannelCfgPtr, Interval);
      }
      else
      {
        /* when channel is expired, returns the target time as elapsed time.*/
        Time = Interval;
      }
    }
    else
    {
      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      /* get time process (continuous) of hardware */
      Time = FuncTablePtr->drvGetTimeElapsedContinuousFct(ChannelCfgPtr);
    }
  }
  else
  {
    /* when channel has not yet started, returns 0. */
    Time = 0U;
  }

  return Time;
}

/** \brief Gpt_GetTimeRemaining_Internal()
 **
 ** This function reads the timer counter value of remaining time.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \return the timer remaining until the target time is reached.
**/
FUNC(Gpt_ValueType, GPT_CODE) Gpt_GetTimeRemaining_Internal(Gpt_ChannelType Channel)
{

  Gpt_ValueType Time;
  Gpt_ValueType Interval;
  Gpt_ChannelStateValueType State;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];

  /* reads status */
  State = Gpt_ReadChannelStatus(Channel);
  if (State != GPT_STATE_INITIALIZED)
  {
    if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) != GPT_MODE_CONTINUOUS)
    {
      /* when channel is running or stopping, returns current elapsed time. */
      if (State != GPT_STATE_EXPIRED)
      {
        /* reads interval time */
        Interval = Gpt_ReadChannelInterval(Channel);

        /* gets function table */
        FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

        /* get time process (oneshot) of hardware */
        Time = FuncTablePtr->drvGetTimeRemainOneShotFct(ChannelCfgPtr, Interval);
      }
      else
      {
        /* when channel is expired, returns the 0 as remaining time */
        Time = 0U;
      }
    }
    else
    {
      /* reads interval time */
      Interval = Gpt_ReadChannelInterval(Channel);

      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      /* get time process (continuous) of hardware */
      Time = FuncTablePtr->drvGetTimeRemainContinuousFct(ChannelCfgPtr, Interval);
    }
  }
  else
  {
    /* when channel has not yet started, returns 0. */
    Time = 0U;
  }

  return Time;
}

/** \brief Gpt_SetNotification()
 **
 ** This function sets(enables) the notification flag if the parameter Noti is GPT_TRUE, 
 ** and clears(disables) the notification flag if the parameter Noti is GPT_FALSE.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 ** \param[in] Noti     GPT_TRUE:  Sets the notification flag.
 **                     GPT_FALSE: Clears the notification flag.
**/
FUNC(void, GPT_CODE) Gpt_SetNotification(Gpt_ChannelType Channel, boolean Noti)
{
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];

  Gpt_EnterCriticalSection();

  if (Noti == GPT_TRUE)
  {
    /* Notification enabled */
    Gpt_SetChannelStateFlag(Channel, (Gpt_ChannelStateFlagType)GPT_NOTIFY_EN, GPT_FALSE);

    if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) == GPT_MODE_CONTINUOUS)
    {
      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      /* Enable interrupt */
      FuncTablePtr->drvSetInterrupt(ChannelCfgPtr, GPT_TRUE);
    }
  }
  else
  {
    /* Notification disabled */
    Gpt_SetChannelStateFlag(Channel, (Gpt_ChannelStateFlagType)(~GPT_NOTIFY_EN), GPT_TRUE);

    if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) == GPT_MODE_CONTINUOUS)
    {
      /* Disable interrupt */
      if ((Gpt_ReadChannelStateFlag(Channel) & GPT_WAKEUP_EN) != GPT_WAKEUP_EN)
      {
        /* gets function table */
        FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

        FuncTablePtr->drvSetInterrupt(ChannelCfgPtr, GPT_FALSE);
      }
    }
  }
  Gpt_ExitCriticalSection();
}

/** \brief Gpt_SetWakeup()
 **
 ** This function sets(enables) the wakeup flag if Wak is GPT_TRUE, 
 ** and clears(disables) the wakeup flag if Wak is GPT_FALSE.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 ** \param[in] Wak      GPT_TRUE: Sets the wakeup flag.
 **                     GPT_FALSE: Clears the wakeup flag.
**/
FUNC(void, GPT_CODE) Gpt_SetWakeup(Gpt_ChannelType Channel, boolean Wak)
{
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];

  Gpt_EnterCriticalSection();

  if (Wak == GPT_TRUE)
  {
    /* enable wakeup */
    Gpt_SetChannelStateFlag(Channel, (Gpt_ChannelStateFlagType)GPT_WAKEUP_EN, GPT_FALSE);

    if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) == GPT_MODE_CONTINUOUS)
    {
      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      /* Enable interrupt */
      FuncTablePtr->drvSetInterrupt(ChannelCfgPtr, GPT_TRUE);
    }
  }
  else
  {
    /* disable wakeup */
    Gpt_SetChannelStateFlag(Channel, (Gpt_ChannelStateFlagType)(~GPT_WAKEUP_EN), GPT_TRUE);

    if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) == GPT_MODE_CONTINUOUS)
    {
      /* Disable interrupt */
      if ((Gpt_ReadChannelStateFlag(Channel) & GPT_NOTIFY_EN) != GPT_NOTIFY_EN)
      {
        /* gets function table */
        FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

        /* Disable interrupt */
        FuncTablePtr->drvSetInterrupt(ChannelCfgPtr, GPT_FALSE);
      }
    }
  }
  Gpt_ExitCriticalSection();
}

/** \brief Gpt_SetDeInit()
 **
 ** This function de-initializes the GPT driver.
 ** This function is executed when DET is ON.
 **
 ** \retval GPT_NOT_OK :   De-initialization is failed.
 **         GPT_OK :       De-initialization is success.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_SetDeInit(void)
{
  Gpt_ChannelType Channel;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  Gpt_ReturnType result = GPT_OK;
  
  Gpt_EnterCriticalSection();
  
  /* sets uninitialize to initialization flag */
  Gpt_SetDriverInitialised(GPT_DRIVER_UNINITIALIZE);
  
  /* loop for all channels */
  for (Channel = 0U; Channel < drvCfgPtr->nChannels; Channel++)
  {
    /* When status is running, break */
    if (Gpt_ReadChannelStatus(Channel) == GPT_STATE_RUNNING)
    {
      break;
    }
  }
  /* When status is running, returns not ok,   */
  /* and sets initilize to initialization flag */
  if (Channel != drvCfgPtr->nChannels)
  {
    result = GPT_NOT_OK;
    Gpt_SetDriverInitialised(GPT_DRIVER_INITIALIZE);
  }
  else
  {
    /* loop for all channel */
    for (Channel = 0U; Channel < drvCfgPtr->nChannels; Channel++)
    {
      /* de-initialization of hardware */
      ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
      
      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
      
      FuncTablePtr->drvDeInitFct(ChannelCfgPtr);

      /* initialization of channel data */
      Gpt_SetChannelStatus(Channel, GPT_STATE_UNINITIALIZE);
      Gpt_SetChannelStateFlag(Channel, 0U, GPT_TRUE);
      Gpt_SetChannelInterval(Channel, GPT_TCPWM_COUNTER);
      Gpt_SetChannelInterruptOccurred(Channel, GPT_NO_INTERRUPT_DETECT);
      Gpt_SetChannelTickFrequency(Channel, 0U);
      Gpt_SetChannelPrescalerValue(Channel, GPT_PRESCALING_DIVIDE_NONE);
    }
  }
  Gpt_ExitCriticalSection();

  return (result);
}

/** \brief Gpt_SetDeInitStopTimer()
 **
 ** This function de-initializes the GPT driver.
 ** This function is executed when DET is OFF.
**/
/* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1.
   Justification: This function is called when GPT_DEV_ERROR_DETECT is switched off. */
/* PRQA S 1503 1 */
FUNC(void, GPT_CODE) Gpt_SetDeInitStopTimer(void)
{
  Gpt_ChannelType Channel;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  Gpt_EnterCriticalSection();
  
  /* loop for all channels */
  for (Channel = 0U; Channel < drvCfgPtr->nChannels; Channel++)
  {
    ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
    
    /* de-initialization of hardware */
    FuncTablePtr->drvDeInitFct(ChannelCfgPtr);

    /* initialization of channel data */
    Gpt_SetChannelStatus(Channel, GPT_STATE_UNINITIALIZE);
    Gpt_SetChannelStateFlag(Channel, 0U, GPT_TRUE);
    Gpt_SetChannelInterval(Channel, GPT_TCPWM_COUNTER);
    Gpt_SetChannelInterruptOccurred(Channel, GPT_NO_INTERRUPT_DETECT);
    Gpt_SetChannelTickFrequency(Channel, 0U);
    Gpt_SetChannelPrescalerValue(Channel, GPT_PRESCALING_DIVIDE_NONE);

  }

  /* sets uninitialize to initialization flag */
  Gpt_SetDriverInitialised(GPT_DRIVER_UNINITIALIZE);

  Gpt_ExitCriticalSection();
}

/** \brief Gpt_SetPredefTimerDeInit()
 **
 ** This function de-initializes the Predef Timer.
 **
**/
FUNC(void, GPT_CODE) Gpt_SetPredefTimerDeInit(void)
{
  Gpt_PredefTimerIdType PredefTimerId;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  Gpt_EnterCriticalSection();

  /* loop for all predef timer */
  for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
  {
    /* init process of hardware */
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

    /* de-initialization of hardware */
    FuncTablePtr->drvDeInitFct(ChannelCfgPtr);
    
    /* set uninitialize to status */
    Gpt_SetPredefTimerStatus(PredefTimerId, GPT_STATE_UNINITIALIZE);
    Gpt_SetPredefTimerTickFrequency(PredefTimerId, 0U);
    Gpt_SetPredefTimerPrescalerValue(PredefTimerId, GPT_PRESCALING_DIVIDE_NONE);
  }

  Gpt_ExitCriticalSection();
}

/** \brief Gpt_SetInit() initializes the driver.
 **
 ** This function initializes the GPT driver.
 **
 ** \param[in] ConfigPtr  Pointer to a selected configuration structure.
*/
FUNC(void, GPT_CODE) Gpt_SetInit
(
  P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_CONST) ConfigPtr
)
{
  Gpt_ChannelType Channel;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = ConfigPtr;
  Gpt_SetConfigPtr(ConfigPtr);
  
  /* sets uninitialize to initialization flag */
  Gpt_SetDriverInitialised(GPT_DRIVER_UNINITIALIZE);
  /* sets normal to status */
  Gpt_SetDriverStatus(GPT_MODE_NORMAL);
  
  Gpt_EnterCriticalSection();
  
  /* loop for all channels */
  for (Channel = 0U; Channel < drvCfgPtr->nChannels; Channel++)
  {
    /* initialization of channel data */
    Gpt_SetChannelStatus(Channel, GPT_STATE_INITIALIZED);
    Gpt_SetChannelStateFlag(Channel, 0U, GPT_TRUE);
    Gpt_SetChannelInterval(Channel, 0U);
    Gpt_SetChannelInterruptOccurred(Channel, GPT_NO_INTERRUPT_DETECT);
    
    /* init process of hardware */
    ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
    FuncTablePtr->drvInitFct(ChannelCfgPtr, GPT_PREDEF_TIMER_START_TRIGGER_INVALID);
    
    Gpt_SetChannelTickFrequency(Channel, ChannelCfgPtr->TickFrequency);
    
    Gpt_SetChannelPrescalerValue(Channel, ChannelCfgPtr->Prescaler);
  }

  Gpt_ExitCriticalSection();

  /* sets initialize to initialization flag */
  Gpt_SetDriverInitialised(GPT_DRIVER_INITIALIZE);
}

/** \brief Gpt_SetPredefTimerInit() initializes the Predef Timer.
 **
 ** This function initializes the Predef Timer.
 **
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
*/
FUNC(void, GPT_CODE) Gpt_SetPredefTimerInit
(
  Gpt_InputTriggerType PredefTimerStartTrigger
)
{
  Gpt_PredefTimerIdType PredefTimerId;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  Gpt_EnterCriticalSection();

  /* loop for all predef timer */
  for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
  {
    /* init process of hardware */
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
    FuncTablePtr->drvInitFct(ChannelCfgPtr, PredefTimerStartTrigger);

    /* initialization of channel data */
    Gpt_SetPredefTimerStatus(PredefTimerId, GPT_STATE_RUNNING);
    Gpt_SetPredefTimerTickFrequency(PredefTimerId, ChannelCfgPtr->TickFrequency);
    Gpt_SetPredefTimerPrescalerValue(PredefTimerId, ChannelCfgPtr->Prescaler);
  }

  if (PredefTimerStartTrigger == GPT_PREDEF_TIMER_START_TRIGGER_INVALID)
  {
    /* loop for all predef timer to start */
    for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
    {
      /* init process of hardware */
      ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      /* predef timer will start while init */
      FuncTablePtr->drvStartFct(ChannelCfgPtr, ChannelCfgPtr->timerMax);
    }
  }

  Gpt_ExitCriticalSection();
}

/** \brief Gpt_SetMode_Internal()
 **
 ** This function sets the driver mode.
 **
 ** \param[in] Mode  GPT_MODE_NORMAL: Normal operation mode of the GPT driver. 
 **                  GPT_MODE_SLEEP : Sleep mode of the GPT driver.
 **
 ** \retval GPT_NOT_OK :   Sets the driver mode is failed.
 **         GPT_OK :       Sets the driver mode is success.
*/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_SetMode_Internal(Gpt_ModeType Mode)
{
  Gpt_ChannelType Channel;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  Gpt_ReturnType result = GPT_OK;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  Gpt_EnterCriticalSection();
  
  /* is mode SLEEP? */
  if ((Gpt_ReadDriverStatus() == GPT_MODE_NORMAL) && (Mode == GPT_MODE_SLEEP))
  {
    for (Channel = 0U; Channel < drvCfgPtr->nChannels; Channel++)
    {
      if (Gpt_ReadChannelStatus(Channel) == GPT_STATE_RUNNING)
      {
        if ((Gpt_ReadChannelStateFlag(Channel) & GPT_WAKEUP_EN) == GPT_WAKEUP_EN)
        {
          Gpt_SetChannelInterruptOccurred(Channel, GPT_NO_INTERRUPT_DETECT);
        }
        else
        {
          ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
          FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
          
          /* cancel process of hardware */
          FuncTablePtr->drvCancelFct(ChannelCfgPtr);
          
          /* set stoped to status */
          Gpt_SetChannelStatus(Channel, GPT_STATE_STOPPED);
        }
      }
    }

    /* set sleep to status */
    Gpt_SetDriverStatus(GPT_MODE_SLEEP);
  }
  else if ((Gpt_ReadDriverStatus() == GPT_MODE_SLEEP) && (Mode == GPT_MODE_NORMAL)) /*  Mode == GPT_MODE_NORMAL  */
  {
    /* set normal to status */
    Gpt_SetDriverStatus(GPT_MODE_NORMAL);
  }
  else 
  {
    result = GPT_NOT_OK;
  }
  Gpt_ExitCriticalSection();
  
  return result;
}

/** \brief Gpt_SetPredefTimerMode_Internal()
 **
 ** This function sets the Predef Timer reference to driver mode.
 **
 ** \param[in] Mode  GPT_MODE_NORMAL: Normal operation mode of the GPT driver. 
 **                  GPT_MODE_SLEEP : Sleep mode of the GPT driver.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
*/
FUNC(void, GPT_CODE) Gpt_SetPredefTimerMode_Internal(Gpt_ModeType Mode, Gpt_InputTriggerType PredefTimerStartTrigger)
{
  Gpt_PredefTimerIdType PredefTimerId;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  Gpt_EnterCriticalSection();
  
  /* is mode SLEEP? */
  if (Mode == GPT_MODE_SLEEP)
  {
    /* loop for all predef timer */
    for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
    {
      /* init process of hardware */
      ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
      
      /* cancel process of hardware */
      FuncTablePtr->drvCancelFct(ChannelCfgPtr);

      if (PredefTimerStartTrigger != GPT_PREDEF_TIMER_START_TRIGGER_INVALID)
      {
        /* clear the start trigger of predef timer */
        FuncTablePtr->drvSetStartTriggerFct(ChannelCfgPtr, PredefTimerStartTrigger, GPT_FALSE);
      }

      /* set stoped to status */
      Gpt_SetPredefTimerStatus(PredefTimerId, GPT_STATE_STOPPED);
    }
  }
  else if (Mode == GPT_MODE_NORMAL)  /*  Mode == GPT_MODE_NORMAL  */
  {
    /* loop for all predef timer */
    for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
    {
      /* init process of hardware */
      ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      if (PredefTimerStartTrigger != GPT_PREDEF_TIMER_START_TRIGGER_INVALID)
      {
        /* restart predef timers synchronously by hardware start trigger (PORT API) */
        FuncTablePtr->drvSetStartTriggerFct(ChannelCfgPtr, PredefTimerStartTrigger, GPT_TRUE);
      }
      else
      {
        /* restart predef timers sequentially by software trigger */
        FuncTablePtr->drvStartFct(ChannelCfgPtr, ChannelCfgPtr->timerMax);
      }

      /* set RUNNING to status */
      Gpt_SetPredefTimerStatus(PredefTimerId, GPT_STATE_RUNNING);
    }
  }
  else 
  {
    /* do nothing*/
  }
  Gpt_ExitCriticalSection();
}

/** \brief Gpt_SetStartTimer()
 **
 ** This function starts the GPT timer.
 **
 ** \param[in] Channel    Numeric identifier of the GPT channel.
 ** \param[in] Interval   Target time in number of ticks.
*/
FUNC(void, GPT_CODE) Gpt_SetStartTimer(Gpt_ChannelType Channel, Gpt_ValueType Interval)
{
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
  
  /* set running to status */
  Gpt_SetChannelStatus(Channel, GPT_STATE_RUNNING);
  
  /* set OFF to intterrupt occurred flag */
  Gpt_SetChannelInterruptOccurred(Channel, GPT_NO_INTERRUPT_DETECT);
  
  /* set interval to variable */
  Gpt_SetChannelInterval(Channel, Interval);
  
  /* gets function table */
  FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
  
  /* start process of hardware */
  FuncTablePtr->drvStartFct(ChannelCfgPtr, Interval);
}

/** \brief Gpt_SetStopTimer()
 **
 ** This function stops the GPT timer.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
*/
FUNC(void, GPT_CODE) Gpt_SetStopTimer(Gpt_ChannelType Channel)
{
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
  
  Gpt_EnterCriticalSection();
  
  if (Gpt_ReadChannelStatus(Channel) == GPT_STATE_RUNNING)
  {
    /* gets function table */
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
    
    /* channel process of hardware */
    FuncTablePtr->drvCancelFct(ChannelCfgPtr);
    
    /* set stopped to status */
    Gpt_SetChannelStatus(Channel, GPT_STATE_STOPPED);
  }
  Gpt_ExitCriticalSection();
}

/** \brief Gpt_Arch_CheckChannelWakeup()
 **
 ** This function checks whether the wakeup function is enabled.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \retval GPT_OK      Wakeup setting is enabled.
 **         GPT_NOT_OK  Wakeup setting is disabled.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_Arch_CheckChannelWakeup(Gpt_ChannelType Channel)
{
  Gpt_ReturnType result = GPT_NOT_OK;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
  
  /* When wakeupsource is true, returns OK */
  if ((ChannelCfgPtr->ChannelConfigFlags & GPT_WAKEUPSOURCE_TRUE) == GPT_WAKEUPSOURCE_TRUE)
  {
    result = GPT_OK;
  }

  return result;
}

/** \brief Gpt_Arch_CheckPredefTimerParameter()
 **
 ** This function checks the Predef timer parameter value whether is valid.
 **
 ** \param[in] PredefTimer  GPT Predef Timer.
 **
 ** \retval GPT_OK      PredefTimer is valid.
 **         GPT_NOT_OK  PredefTimer is invalid.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_Arch_CheckPredefTimerParameter(Gpt_PredefTimerType PredefTimer)
{
  Gpt_PredefTimerIdType PredefTimerId;
  uint8 ConfigTimerType;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  Gpt_ReturnType result = GPT_NOT_OK;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  /* check predef timer is defined or not */
  for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
  {
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];

    /* get PredefTimer type from configuration flags */
    ConfigTimerType = ((ChannelCfgPtr->ChannelConfigFlags & GPT_PREDEFTIMER_MASK) >> GPT_PREDEF_TIMER_BIT_POSITION);

    /* If configured PredefTimer is not 1us timer, it only allows same timer type. */
    /* If configured PredefTimer is 1us timer, it also allows lower bit timer. */
    if (((uint8)PredefTimer == ConfigTimerType) ||
        (((uint8)ConfigTimerType < (uint8)GPT_PREDEF_TIMER_100US_32BIT) && ((uint8)PredefTimer < ConfigTimerType)))
    {
      result = GPT_OK;
      break;
    }
  }

  return result;
}

/** \brief Gpt_Arch_CheckPredefTimerRunning()
 **
 ** This function checks the Predef timer is running.
 **
 ** \param[in] PredefTimer  GPT Predef Timer.
 **
 ** \retval GPT_OK      PredefTimer is running.
 **         GPT_NOT_OK  PredefTimer is not running.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_Arch_CheckPredefTimerRunning(Gpt_PredefTimerType PredefTimer)
{
  Gpt_PredefTimerIdType PredefTimerId;
  uint8 ConfigTimerType;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  Gpt_ReturnType result = GPT_NOT_OK;
  P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_TcpwmDrvFctTable_t, AUTOMATIC, GPT_CONST) FuncTablePtr;

  Gpt_EnterCriticalSection();

  /* check predef timer is defined or not */
  for (PredefTimerId = 0U; PredefTimerId < drvCfgPtr->nPredefTimers; PredefTimerId++)
  {
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];

    /* get PredefTimer type from configuration flags */
    ConfigTimerType = ((ChannelCfgPtr->ChannelConfigFlags & GPT_PREDEFTIMER_MASK) >> GPT_PREDEF_TIMER_BIT_POSITION);

    /* If configured PredefTimer is not 1us timer, it only allows same timer type. */
    /* If configured PredefTimer is 1us timer, it also allows lower bit timer. */
    if (((uint8)PredefTimer == ConfigTimerType) ||
        (((uint8)ConfigTimerType < (uint8)GPT_PREDEF_TIMER_100US_32BIT) && ((uint8)PredefTimer < ConfigTimerType)))
    {
      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

      /* check running status of hardware */
      result = FuncTablePtr->drvCheckRunningFct(ChannelCfgPtr);

      break;
    }
  }

  Gpt_ExitCriticalSection();

  return result;
}

/** \brief Gpt_Arch_GetClockSource()
 **
 ** This function gets the Clock Source of channel.
 **
 ** \param[in] ChannelNumber   Numeric identifier of the GPT channel.
 **
 ** \retval   GPT_CLK_EXT : External clock.
 **          GPT_CLK_INT : Internal clock.
**/
FUNC(Gpt_ClockType, GPT_CODE) Gpt_Arch_GetClockSource(Gpt_ChannelType ChannelNumber)
{
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[ChannelNumber];
  
  return ChannelCfgPtr->SourceClock;
}

/** \brief Gpt_CheckNeedWakeup()
 **
 ** This function checks whether this module need call the EcuM_CheckWakeup.
 **
 ** \param[in] Channel Numeric identifier of the GPT channel.
 **
 ** \retval GPT_OK :  Need to wake up.
 **         GPT_NOT_OK:  Not need to wake up.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_CheckNeedWakeup(Gpt_ChannelType Channel)
{
  Gpt_ReturnType result = GPT_NOT_OK;
  
  /* When wakeup is enable, returns OK */
  if (Gpt_ReadDriverStatus() == GPT_MODE_SLEEP)
  {
    if (Gpt_ReadChannelInterruptOccurred(Channel) == GPT_INTERRUPT_DETECT)
    {
      if ((Gpt_ReadChannelStateFlag(Channel) & GPT_WAKEUP_EN) == GPT_WAKEUP_EN)
      {
        Gpt_SetChannelInterruptOccurred(Channel, GPT_NO_INTERRUPT_DETECT);

        result = GPT_OK;
      }
    }
  }

  return result;
}

/** \brief Gpt_Arch_CheckTimerRange()
 **
 ** This function checks whether the parameter Value is inside of range.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 ** \param[in] Value    Target time in number of the ticks.
 **
 ** \retval GPT_OK:     In range.
 **         GPT_NOT_OK: Out of range.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_Arch_CheckTimerRange(Gpt_ChannelType Channel, Gpt_ValueType Value)
{
  Gpt_ReturnType Result = GPT_NOT_OK;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
  
  /* When range of value is valid, returns OK */
  if ((Value <= ChannelCfgPtr->timerMax) && (Value != 0U))
  {
    Result = GPT_OK;
  }

  return Result;
}

/** \brief Gpt_Arch_TimerExpire()
 **
 ** This function executes the ISR's processing.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \retval GPT_OK      Calls EcuM_CheckWakeup function.
 **         GPT_NOT_OK  Don't call EcuM_CheckWakeup function.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_Arch_TimerExpire(Gpt_ChannelType Channel)
{
  Gpt_ReturnType result = GPT_NOT_OK;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
  
  Gpt_EnterCriticalSection();
  
  /* set ON to interrupt occurred flag */
  Gpt_SetChannelInterruptOccurred(Channel, GPT_INTERRUPT_DETECT);
  
  /* Is mode continuous? */
  if ((ChannelCfgPtr->ChannelConfigFlags & GPT_MODE_CONTINUOUS) == GPT_MODE_CONTINUOUS)
  {
    /* do nothing */
   }
  else
  {
    /* set expired to status */
    Gpt_SetChannelStatus(Channel, GPT_STATE_EXPIRED);
  }
  
  Gpt_ExitCriticalSection();
  
  if ((Gpt_ReadChannelStateFlag(Channel) & GPT_NOTIFY_EN) == GPT_NOTIFY_EN)
  {
    if (Gpt_ReadDriverStatus() == GPT_MODE_NORMAL)
    {
      Gpt_NotifyFunc(Channel);
    }
  }
  
  if ((Gpt_ReadChannelStateFlag(Channel) & GPT_WAKEUP_EN) == GPT_WAKEUP_EN)
  {
    if (Gpt_ReadDriverStatus() == GPT_MODE_SLEEP)
    {
      result = GPT_OK;
    }
  }
  
  return result;
}

/** \brief Gpt_Arch_ClearInterruptFlag()
 **
 ** This function reads and clears the interrupt flag.
 **
 ** \param[in] Channel  Numeric identifier of the GPT channel.
 **
 ** \retval GPT_OK      Interrupt flag is ON and cleared.
 **         GPT_NOT_OK  Interrupt flag is OFF.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_Arch_ClearInterruptFlag(Gpt_ChannelType Channel)
{
  Gpt_ReturnType result;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];

  Gpt_EnterCriticalSection();

  FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
  
  result = FuncTablePtr->drvClearInterruptFlagFct(ChannelCfgPtr);

  Gpt_ExitCriticalSection();

  return result;
}

/** \brief Gpt_CheckChannelStatus_Internal()
 **
 ** This function checks whether register value is correct, and gets status value.
 **
 ** \param[in]  Channel          Numeric identifier of the GPT channel.
 ** \param[out] DriverStatusPtr  Pointer of driver status data.
 ** \param[out] ChannelStatusPtr Pointer of channel status data.
 **
 ** \retval GPT_OK      read register is not failed.
 **         GPT_NOT_OK  read register is failed.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_CheckChannelStatus_Internal
(
  Gpt_ChannelType Channel,
  P2VAR(Gpt_DriverStateType,  AUTOMATIC, GPT_APPL_DATA) DriverStatusPtr,
  P2VAR(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr
)
{
  Gpt_ReturnType result;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[Channel];
  
  Gpt_EnterCriticalSection();
  
  DriverStatusPtr->driverInitialised         = Gpt_ReadDriverInitialised();
  DriverStatusPtr->driverStateFlags          = Gpt_ReadDriverStatus();
  ChannelStatusPtr->channelInterruptOccurred = Gpt_ReadChannelInterruptOccurred(Channel);
  ChannelStatusPtr->channelStateFlags        = Gpt_ReadChannelStateFlag(Channel);
  ChannelStatusPtr->interval                 = Gpt_ReadChannelInterval(Channel);
  ChannelStatusPtr->frequency                = Gpt_ReadChannelTickFrequency(Channel);
  ChannelStatusPtr->prescaler                = Gpt_ReadChannelPrescalerValue(Channel);
  ChannelStatusPtr->state                    = Gpt_ReadChannelStatus(Channel);

  FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
  result = FuncTablePtr->drvCheckRegisterFct(ChannelCfgPtr, DriverStatusPtr, ChannelStatusPtr, GPT_PREDEF_TIMER_START_TRIGGER_INVALID);
  
  Gpt_ExitCriticalSection();
  
  return result;
}

/** \brief Gpt_CheckPredefTimerStatus_Internal()
 **
 ** This function checks whether register value is correct, and gets status value.
 **
 ** \param[in]  PredefTimer      GPT Predef Timer.
 ** \param[out] DriverStatusPtr  Pointer of driver status data.
 ** \param[out] ChannelStatusPtr Pointer of channel status data.
 ** \param[in]  PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      read register is not failed.
 **         GPT_NOT_OK  read register is failed.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_CheckPredefTimerStatus_Internal
(
  Gpt_PredefTimerType PredefTimer,
  P2VAR(Gpt_DriverStateType,  AUTOMATIC, GPT_APPL_DATA) DriverStatusPtr,
  P2VAR(Gpt_ChannelStateType, AUTOMATIC, GPT_APPL_DATA) ChannelStatusPtr,
  Gpt_InputTriggerType PredefTimerStartTrigger
)
{
  Gpt_ReturnType result;
  Gpt_PredefTimerIdType PredefTimerId;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  result = Gpt_GetPredefTimerId(PredefTimer, &PredefTimerId);
  
  if (result != GPT_NOT_OK)
  {
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
    Gpt_EnterCriticalSection();

    DriverStatusPtr->driverInitialised         = Gpt_ReadDriverInitialised();
    DriverStatusPtr->driverStateFlags          = Gpt_ReadDriverStatus();
    ChannelStatusPtr->channelInterruptOccurred = 0U;
    ChannelStatusPtr->channelStateFlags        = 0U;
    if (DriverStatusPtr->driverInitialised == GPT_DRIVER_INITIALIZE)
    {
        ChannelStatusPtr->interval             = ChannelCfgPtr->timerMax;
    }
    else
    {
        ChannelStatusPtr->interval             = 0U;
    }
    ChannelStatusPtr->state                    = Gpt_ReadPredefTimerStatus(PredefTimerId);
    ChannelStatusPtr->frequency                = Gpt_ReadPredefTimerTickFrequency(PredefTimerId);
    ChannelStatusPtr->prescaler                = Gpt_ReadPredefTimerPrescalerValue(PredefTimerId);

    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
    result = FuncTablePtr->drvCheckRegisterFct(ChannelCfgPtr, DriverStatusPtr, ChannelStatusPtr, PredefTimerStartTrigger);

    Gpt_ExitCriticalSection();
  }

  return result;
}

/** \brief Gpt_GetPredefTimerValue_Internal()
 **
 ** This function reads the Predef Timer counter value of remaining time.
 **
 ** \param[in]  PredefTimer   GPT Predef Timer.
 ** \param[out] TimeValuePtr  Pointer to time value destination data.
 **
 ** \retval GPT_NOT_OK : Reading Predef Timer value is failed.
 **         GPT_OK :     Reading Predef Timer value is success.
**/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_GetPredefTimerValue_Internal
(
  Gpt_PredefTimerType PredefTimer,
  P2VAR(Gpt_ValueType,  AUTOMATIC, GPT_APPL_DATA) TimeValuePtr
)
{
  Gpt_ReturnType result;
  Gpt_PredefTimerIdType PredefTimerId;
  P2CONST(Gpt_TcpwmDrvFctTable_t, AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  result = Gpt_GetPredefTimerId(PredefTimer, &PredefTimerId);
  
  if (GPT_NOT_OK != result)
  {
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

    /* when channel is running or stopping, returns current elapsed time. */
    /* get time process (continuous) of hardware directly */
    *TimeValuePtr = FuncTablePtr->drvGetTimeElapsedContinuousFct(ChannelCfgPtr);

    switch (PredefTimer)
    {
      case GPT_PREDEF_TIMER_1US_16BIT:
        *TimeValuePtr &= GPT_PREDEF_TIMER_16BIT_MASK;
        break;
      case GPT_PREDEF_TIMER_1US_24BIT:
        *TimeValuePtr &= GPT_PREDEF_TIMER_24BIT_MASK;
        break;
      default:
        /* do nothing */
        break;
    }

    result = GPT_OK;
  }

  return result;
}

/** \brief Gpt_SetPrescaler_Internal().
 **
 ** This function sets the prescaler value.
 **
 ** \param[in] ChannelNumber   Numeric identifier of the GPT channel.
 ** \param[in] ClockFrequency  Clock Frequency.
 **
 ** \retval GPT_OK      Set prescaler is success.
 **         GPT_NOT_OK  Set prescaler is failed.
*/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_SetPrescaler_Internal
(
  Gpt_ChannelType ChannelNumber, 
  Gpt_ClkFrequencyType ClockFrequency
)
{
  Gpt_ReturnType result;
  uint8 prescalerValue;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr = &drvCfgPtr->ChannelsCfgPtr[ChannelNumber];
  
  prescalerValue = Gpt_GetPrescalerValue(ChannelCfgPtr->TickFrequency, ClockFrequency);

  if (GPT_PRESCALER_INVALID == prescalerValue)
  {
    result = GPT_NOT_OK;
  }
  else 
  {
    /* gets function table */
    FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();
    
    /* set prescaler of hardware */
    FuncTablePtr->drvSetPrescalerFct(ChannelCfgPtr, prescalerValue);

    /* set prescaler to status */
    Gpt_SetChannelPrescalerValue(ChannelNumber, prescalerValue);

    result = GPT_OK;
  }

  return result;
}

/** \brief Gpt_SetPredefTimerPrescaler_Internal()
 **
 ** This function sets the Predef timer's Prescaler value.
 **
 ** \param[in] PredefTimer     GPT Predef Timer.
 ** \param[in] ClockFrequency  Input clock Frequency.
 ** \param[in] PredefTimerStartTrigger  Start trigger of Predef Timer synchronous start.
 **
 ** \retval GPT_OK      Set Predef prescaler is success.
 **         GPT_NOT_OK  Set Predef prescaler is failed.
*/
FUNC(Gpt_ReturnType, GPT_CODE) Gpt_SetPredefTimerPrescaler_Internal(
Gpt_PredefTimerType PredefTimer, 
Gpt_ClkFrequencyType ClockFrequency,
Gpt_InputTriggerType PredefTimerStartTrigger
)
{
  Gpt_ReturnType result;
  uint8 prescalerValue;
  Gpt_PredefTimerIdType PredefTimerId;
  P2CONST(Gpt_TcpwmDrvFctTable_t,     AUTOMATIC, GPT_CONST) FuncTablePtr;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  
  result = Gpt_GetPredefTimerId(PredefTimer, &PredefTimerId);
  
  if (GPT_NOT_OK != result)
  {
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[PredefTimerId];

    /* clock frequency check*/
    prescalerValue = Gpt_GetPrescalerValue(ChannelCfgPtr->TickFrequency, ClockFrequency);

    if (GPT_PRESCALER_INVALID == prescalerValue)
    {
      result = GPT_NOT_OK;
    }
    else 
    {
      Gpt_EnterCriticalSection();

      /* gets function table */
      FuncTablePtr = (*ChannelCfgPtr->getFuncTable)();

     /* stop runing timer counter */
      FuncTablePtr->drvCancelFct(ChannelCfgPtr);

      /* set prescaler of hardware */
      FuncTablePtr->drvSetPrescalerFct(ChannelCfgPtr, prescalerValue);

      if (PredefTimerStartTrigger != GPT_PREDEF_TIMER_START_TRIGGER_INVALID)
      {
        /* restart predef timers synchronously by hardware start trigger (PORT API) */
        FuncTablePtr->drvSetStartTriggerFct(ChannelCfgPtr, PredefTimerStartTrigger, GPT_TRUE);
      }
      else
      {
        /* When mode is sleep, not restarts predef timer */
        /* (expects restarting predef timer when mode changes to normal) */
        if (Gpt_ReadDriverStatus() != GPT_MODE_SLEEP)
        {
          /* restart predef timer counter */
          FuncTablePtr->drvStartFct(ChannelCfgPtr, ChannelCfgPtr->timerMax);
        }
      }

      /* set prescaler to status */
      Gpt_SetPredefTimerPrescalerValue(PredefTimerId, prescalerValue);

      Gpt_ExitCriticalSection();
      result = GPT_OK;
    }
  }

  return result;
}

/** \brief Gpt_DisableInterruptByBaseAddr()
 **
 ** This function disable interrupt.
 **
 ** \param[in] BaseAddrPtr  Base address of channel to disable interrupt.
**/
FUNC(void, GPT_CODE) Gpt_DisableInterruptByBaseAddr
(
  volatile P2VAR(uint32, GPT_CONST, REGSPACE) BaseAddrPtr
)
{
  Gpt_EnterCriticalSection();

  /* Access to register */
  Gpt_TimerCounterDisableInterrupt(BaseAddrPtr);  
  
  Gpt_ExitCriticalSection();
}

/*==================[internal function definitions]=========================*/
/** \brief Gpt_GetPredefTimerId()
 **
 ** This function gets the ID of specific PredefTimer.
 **
 ** \param[in]  PredefTimer GPT Predef Timer.
 ** \param[out] PredefChannelPtr Pointer to index of Predef Timer.
 **
 ** \retval GPT_OK      Get Predef Timer index is success.
 **         GPT_NOT_OK  Get Predef Timer index is failed.
 **
 **/
static FUNC(Gpt_ReturnType, GPT_CODE) Gpt_GetPredefTimerId(
  Gpt_PredefTimerType                               PredefTimer,
  P2VAR(Gpt_PredefTimerIdType, AUTOMATIC, GPT_APPL_DATA)  PredefTimerIdPtr
)
{
  Gpt_PredefTimerIdType TempPredefTimerId;
  uint8 ConfigTimerType;
  P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONST) ChannelCfgPtr;
  P2CONST(Gpt_ConfigType,        AUTOMATIC, GPT_CONST) drvCfgPtr = Gpt_GetConfigPtr();
  Gpt_ReturnType result = GPT_NOT_OK;

  /* check predef timer is defined or not */
  for (TempPredefTimerId = 0U; TempPredefTimerId < drvCfgPtr->nPredefTimers; TempPredefTimerId++)
  {
    ChannelCfgPtr = &drvCfgPtr->PredefTimersCfgPtr[TempPredefTimerId];

    /* get PredefTimer type from configuration flags */
    ConfigTimerType = ((ChannelCfgPtr->ChannelConfigFlags & GPT_PREDEFTIMER_MASK) >> GPT_PREDEF_TIMER_BIT_POSITION);

    /* If configured PredefTimer is not 1us timer, it only allows same timer type. */
    /* If configured PredefTimer is 1us timer, it also allows lower bit timer. */
    if (((uint8)PredefTimer == ConfigTimerType) ||
        (((uint8)ConfigTimerType < (uint8)GPT_PREDEF_TIMER_100US_32BIT) && ((uint8)PredefTimer < ConfigTimerType)))
    {
      *PredefTimerIdPtr = TempPredefTimerId;
      result = GPT_OK;
      break;
    } 
  }
  
  return result;
}

/** \brief Gpt_GetPrescalerValue() checks the register.
 **
 ** If the input clockfrequency is invalid, return GPT_NOT_OK.
 ** Else return divider value.
 ** 
 ** \param[in] TickFrequency     Tick frequency of channel configuration.
 ** \param[in] ClockFrequency    Input clock frequency.
 **
 ** \retval If clockfrequency is valiad value return calculated precaler value.
 **         Else return GPT_PRESCALER_INVALID.
 **/
static FUNC(uint8, GPT_CODE) Gpt_GetPrescalerValue(
  Gpt_ClkFrequencyType TickFrequency,
  Gpt_ClkFrequencyType ClockFrequency)
{
  uint8 prescalerValue;
  uint32 divider;
  
  divider = ClockFrequency / TickFrequency;
  
  /* input clock frequency check */
  if (GPT_PRESCALING_DIVIDE_NONE == divider)
  {
    prescalerValue = GPT_PRESCALER_INVALID;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_1 + GPT_PRESCALING_DIVIDE_BY_2) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_1;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_2 + GPT_PRESCALING_DIVIDE_BY_4) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_2;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_4 + GPT_PRESCALING_DIVIDE_BY_8) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_4;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_8 + GPT_PRESCALING_DIVIDE_BY_16) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_8;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_16 + GPT_PRESCALING_DIVIDE_BY_32) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_16;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_32 + GPT_PRESCALING_DIVIDE_BY_64) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_32;
  }
  else if (divider <= ((GPT_PRESCALING_DIVIDE_BY_64 + GPT_PRESCALING_DIVIDE_BY_128) / GPT_HALF_DIVIDER))
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_64;
  }
  else
  {
    prescalerValue = GPT_PRESCALER_DIVIDE_BY_128;
  }
  
  return prescalerValue;
}

#define GPT_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Gpt_MemMap.h>
/*==================[end of file]===========================================*/
