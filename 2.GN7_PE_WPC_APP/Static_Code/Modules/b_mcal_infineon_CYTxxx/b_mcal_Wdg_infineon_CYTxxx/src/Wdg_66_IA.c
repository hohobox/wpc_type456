
/** \brief AUTOSAR Wdg Driver
 **
 ** This file contains the implementation of the AUTOSAR module Wdg.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]=============================================*/

#include <Wdg_Cbk.h>
#include <Wdg_66_IA_Controller.h>
#include <Wdg_66_IA_Trigger.h>
#include <Wdg_66_IA_SchM.h>
#include <Wdg_66_IA_Det.h>
#include <Wdg_66_IA_Dem.h>
#include <Wdg_66_IA.h>
#include <SchM_Wdg_66_IA.h>

/*==================[macros]=================================================*/
/*==================[type definitions]=======================================*/
/*==================[external function declarations]=========================*/
/*==================[internal function declarations]=========================*/
#define WDG_66_IA_START_SEC_CODE
#include <Wdg_66_IA_MemMap.h>
/** \brief Wdg_66_IA_GetMaxTimeoutValue
 **
 ** This function compares configuration parameter WdgMaxTimeout and hardware 
 ** acceptable maximum timeout value which is calculated from source clock of the watchdog timer.
 ** And returns smaller value as the real maximum timeout value.
 **
 ** \param [in] ConfigPtr   A pointer to configuration which be used to initialize watchdog driver.
 **
 ** \return smaller value of the configured maximum timeout and maximum hardware acceptable timeout.
 */
static FUNC( uint16, WDG_CODE )
Wdg_66_IA_GetMaxTimeoutValue( P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr );

#define WDG_66_IA_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[external constants]=====================================*/
/*==================[internal constants]=====================================*/
/*==================[external data]==========================================*/
/*==================[internal data]==========================================*/
/*------------------[unspecified const data]---------------------------------*/
/*------------------[unspecified data]---------------------------------------*/
#define WDG_66_IA_START_SEC_VAR_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/* A pointer to configuration setting */
static P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST )
Wdg_66_IA_ConfigPtr = NULL_PTR;

#define WDG_66_IA_STOP_SEC_VAR_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*------------------[unspecified const data]---------------------------------*/
#define WDG_66_IA_START_SEC_CONST_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/* A pointer to SRSS registers about Wdg driver */
static CONSTP2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE )
/* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
   Justification: It is necessary to set pointer address as integral type. */
/* PRQA S 306 4 */
/* Deviation from MISRA-C:2004 rule 8.7, MISRA-C:2012 Rule-8.9
   Justification: This data is accessed from other functions by using pointer. */
/* PRQA S 3218 1 */
Wdg_66_IA_SRSSRegisterPtr = WDG_66_IA_SRSS_SRSS_BASE_ADDR;

#define WDG_66_IA_STOP_SEC_CONST_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[external function definitions]==========================*/

#define WDG_66_IA_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/** \brief Wdg_66_IA_Init
 **
 ** This API is used to initialize watchdog driver and watchdog hardware, i.e.
 ** it sets the default watchdog mode and timeout period as provided in the
 ** configuration set.
 ** This configuration set shall be chosen from a limited number of
 ** statically configured sets.
 **
 ** \param [in] ConfigPtr   Pointer to configuration which be used to initialize
 **                         watchdog driver.
 */
FUNC( void, WDG_CODE )
Wdg_66_IA_Init( P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr )
{
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr;

  /* Check if ConfigPtr is valid or not */
  if ( Wdg_66_IA_CheckConfigPointer( ConfigPtr ) == FALSE )
  {
    Wdg_66_IA_ReportDetError( WDG_66_IA_API_INIT,
                              WDG_66_IA_E_INIT_FAILED );
  }
  else
  {
    /* Select effective setting */
    SettingPtr = ConfigPtr->SettingWdgPtr;

    /* Check if default mode is valid or not */
    if ( ( WDGIF_FAST_MODE != SettingPtr->DefaultMode ) &&
         ( WDGIF_SLOW_MODE != SettingPtr->DefaultMode ) &&
         ( WDGIF_OFF_MODE  != SettingPtr->DefaultMode ) )
    {
      Wdg_66_IA_ReportDetError( WDG_66_IA_API_INIT,
                                WDG_66_IA_E_PARAM_CONFIG );
    }
    /* Call the internal initialization function */
    else if ( Wdg_66_IA_Internal_Init( ConfigPtr ) == E_OK )
    {
      /* Set the pointer to the configuration setting */
      Wdg_66_IA_ConfigPtr = ConfigPtr;
    }
    /* If the HWDG cannot be initialized as configured, a DET will be reported */
    else
    {
      Wdg_66_IA_ReportDetError( WDG_66_IA_API_INIT,
                                WDG_66_IA_E_PARAM_CONFIG );
    }
  }
}

/** \brief Wdg_66_IA_SetMode
 **
 ** This API is used to switch the watchdog mode between the following
 ** three different modes:
 ** - WDGIF_OFF_MODE
 ** - WDGIF_SLOW_MODE
 ** - WDGIF_FAST_MODE
 **
 ** \param [in] Mode   One of the three different modes.
 **
 ** \return E_OK:     Switching completed successfully.
 **         E_NOT_OK: Switching failed.
 */
FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_SetMode( WdgIf_ModeType Mode )
{
  Std_ReturnType ret_val = (Std_ReturnType) E_NOT_OK;

  /* Check if Wdg_66_IA_ConfigPtr is valid or not */
  if ( Wdg_66_IA_CheckConfigPointer( Wdg_66_IA_ConfigPtr ) == FALSE )
  {
    Wdg_66_IA_ReportDetError( WDG_66_IA_API_SETMODE,
                              WDG_66_IA_E_DRIVER_STATE );
  }
  else
  {
    /* Check if OffMode is acceptable */
    if ( ( Mode == WDGIF_OFF_MODE ) &&
         ( Wdg_66_IA_ConfigPtr->SettingCommonPtr->DisableAllowed == FALSE ) )
    {
      Wdg_66_IA_ReportDetError( WDG_66_IA_API_SETMODE,
                                WDG_66_IA_E_PARAM_MODE );
      Wdg_66_IA_ReportDemErrorStatusDisableRejected( WDG_66_IA_API_SETMODE,
                                                   (boolean) WDG_66_IA_DEM_EVENT_STATUS_FAILED );
      Wdg_66_IA_ReportDemErrorStatusModeFailed( WDG_66_IA_API_SETMODE,
                                                (boolean) WDG_66_IA_DEM_EVENT_STATUS_FAILED );
    }
    /* Check if parameter Mode is switched into SupportedModes  */
    else if ( ( ( Mode == WDGIF_FAST_MODE ) &&
                ( ( Wdg_66_IA_ConfigPtr->SettingCommonPtr->SupportedModes & (uint8) WDG_66_IA_FAST_MODE ) == 0U ) ) ||
              ( ( Mode == WDGIF_SLOW_MODE ) &&
                ( ( Wdg_66_IA_ConfigPtr->SettingCommonPtr->SupportedModes & (uint8) WDG_66_IA_SLOW_MODE ) == 0U ) ) ||
              ( ( Mode == WDGIF_OFF_MODE ) &&
                ( ( Wdg_66_IA_ConfigPtr->SettingCommonPtr->SupportedModes & (uint8) WDG_66_IA_OFF_MODE ) == 0U ) ) )
    {
      Wdg_66_IA_ReportDetError( WDG_66_IA_API_SETMODE,
                                WDG_66_IA_E_PARAM_MODE );
      Wdg_66_IA_ReportDemErrorStatusModeFailed( WDG_66_IA_API_SETMODE,
                                                (boolean) WDG_66_IA_DEM_EVENT_STATUS_FAILED );
    }
    /* Check if the parameter Mode is within the allowed range(fast mode/slow mode/off mode) */
    else if ( ( Mode != WDGIF_FAST_MODE ) &&
         ( Mode != WDGIF_SLOW_MODE ) &&
         ( Mode != WDGIF_OFF_MODE  ) )
    {
      Wdg_66_IA_ReportDetError( WDG_66_IA_API_SETMODE,
                                WDG_66_IA_E_PARAM_MODE );
    }
    /* Check if status is IDLE */
    else if ( Wdg_66_IA_Internal_GetStatus() != WDG_66_IA_IDLE )
    {
      Wdg_66_IA_ReportDetError( WDG_66_IA_API_SETMODE,
                                WDG_66_IA_E_DRIVER_STATE );
      Wdg_66_IA_ReportDemErrorStatusDisableRejected( WDG_66_IA_API_SETMODE,
                                                     (boolean) WDG_66_IA_DEM_EVENT_STATUS_FAILED );
    }
    /* No DET error is detected */
    else
    {
      /* No DEM-error encountered - report 'no error - normal operation' */
      Wdg_66_IA_ReportDemErrorStatusDisableRejected( WDG_66_IA_API_SETMODE,
                                                     (boolean) WDG_66_IA_DEM_EVENT_STATUS_PASSED );
     
      /* Do architecture specific mode settings */
      ret_val = Wdg_66_IA_Internal_SetMode( Mode, Wdg_66_IA_ConfigPtr );
      
      /* If mode switch failed call DEM */
      if ( ret_val != E_OK )
      {
        Wdg_66_IA_ReportDemErrorStatusModeFailed( WDG_66_IA_API_SETMODE,
                                                  (boolean) WDG_66_IA_DEM_EVENT_STATUS_FAILED );
      }
      else
      {
        Wdg_66_IA_ReportDemErrorStatusModeFailed( WDG_66_IA_API_SETMODE,
                                                  (boolean) WDG_66_IA_DEM_EVENT_STATUS_PASSED );
      }
    } 
  }

  return ret_val;
}

/** \brief Wdg_66_IA_SetTriggerCondition
 **
 ** This API is used to set the permission to trigger the watchdog hardware for
 ** the next 'timeout' milliseconds.
 ** It has to be called again by some upper layer function, usually the watchdog
 ** manager, before the permission period expires.
 **
 ** \param [in] timeout   Timeout value (milliseconds) for setting the trigger
 **                       counter.
 */
FUNC( void, WDG_CODE ) Wdg_66_IA_SetTriggerCondition( uint16 timeout )
{

  /* Check if Wdg_66_IA_ConfigPtr is valid or not */
  if ( Wdg_66_IA_CheckConfigPointer( Wdg_66_IA_ConfigPtr ) == FALSE )
  {
    Wdg_66_IA_ReportDetError( WDG_66_IA_API_SET_TRIGGER_CONDITION,
                              WDG_66_IA_E_DRIVER_STATE );
  }
  /* Check if timeout parameter is greater than the maximum timeout value */
  else if ( timeout > Wdg_66_IA_GetMaxTimeoutValue( Wdg_66_IA_ConfigPtr ) )
  {
    Wdg_66_IA_ReportDetError( WDG_66_IA_API_SET_TRIGGER_CONDITION,
                              WDG_66_IA_E_PARAM_TIMEOUT );
  }
  /* Check if Wdg is idle or not */
  else if ( Wdg_66_IA_Internal_GetStatus() != WDG_66_IA_IDLE )
  {
    Wdg_66_IA_ReportDetError( WDG_66_IA_API_SET_TRIGGER_CONDITION,
                              WDG_66_IA_E_DRIVER_STATE );
  }
  /* No DET error is detected */
  else
  {
    /* Call a function to set trigger condition */
    Wdg_66_IA_Internal_SetTriggerCondition( timeout, Wdg_66_IA_ConfigPtr );
  }
}

/** \brief WDG_66_IA_GetVersionInfo
 **
 ** This API is used to obtain the version information.
 **
 ** \param [out] versioninfo   Wdg driver module's version.
 */
#if ( WDG_66_IA_GET_VERSION_INFO_API == STD_ON )
FUNC( void, WDG_CODE )
Wdg_66_IA_GetVersionInfo( P2VAR(Std_VersionInfoType, AUTOMATIC, WDG_APPL_DATA) versioninfo)
{
  /* Check if passed value is an NULL pointer */
  if ( versioninfo == NULL_PTR )
  {
    Wdg_66_IA_ReportDetError( WDG_66_IA_API_GET_VERSION_INFO,
                              WDG_66_IA_E_PARAM_POINTER );
  }
  /* No DET error is detected */
  else
  {
    /* Write the version information to the area to which the pointer refers */
    versioninfo->vendorID         = WDG_66_IA_VENDOR_ID;
    versioninfo->moduleID         = WDG_66_IA_MODULE_ID;
    versioninfo->sw_major_version = WDG_66_IA_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = WDG_66_IA_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = WDG_66_IA_SW_PATCH_VERSION;
  }
}
#endif /* #if (WDG_66_IA_GETVERSIONINFO_API == STD_OFF) */

/** \brief Wdg_66_IA_EnterCriticalSection
 **
 ** This function is used to provide service to enter a critical section in the
 ** Wdg module.
 */
FUNC( void, WDG_CODE )
Wdg_66_IA_EnterCriticalSection( void )
{
  WDG_66_IA_SCHM_ENTER_EXCLUSIVE_AREA(); /* Enter a critical section */
}

/** \brief Wdg_66_IA_ExitCriticalSection
 **
 ** This function is used to provide service to exit a critical section in the
 ** Wdg module.
 */
FUNC( void, WDG_CODE )
Wdg_66_IA_ExitCriticalSection( void )
{
  WDG_66_IA_SCHM_EXIT_EXCLUSIVE_AREA(); /* Exit a critical section */
}

/** \brief Wdg_66_IA_SetupTriggerFunction
 **
 ** This function is used to copy a trigger routine into RAM area in the Wdg
 ** module(if WdgRunArea is set to RAM).
 **
 */
FUNC( void, WDG_CODE )
Wdg_66_IA_SetupTriggerFunction( void )
{
#if ( WDG_66_IA_RUN_AREA_IS_RAM != STD_OFF )
  P2VAR( uint8, AUTOMATIC, WDG_APPL_DATA ) dst;
  P2VAR( uint8, AUTOMATIC, WDG_APPL_DATA ) src;
  uint16 i;
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6
     Justification: It is necessary to set pointer address as integral type. */
  /* PRQA S 306 1 */
  dst = (P2VAR( uint8, AUTOMATIC, WDG_APPL_DATA ))( WDG_66_IA_TRIGGER_LOCATION );
  /* Delete Thumb flag */
  /* Deviation from MISRA-C:2004 rule 21.1, MISRA-C:2012 Rule-2.2
     Justification: The thumb flag is needed to be cleared before copy. */
  /* PRQA S 2984 4 */
  /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.1, Rule-11.4, Rule-11.6
     Justification: It is necessary to set pointer address as integral type. */
  /* PRQA S 305, 306 1 */
  src = (P2VAR( uint8, AUTOMATIC, WDG_APPL_DATA ))(((uint32)&Wdg_66_IA_ActivateTrigger) & WDG_66_IA_THUMB_BIT_CLEAR);
  /* Set a pointer to call the trigger routine */
  /* Copy the trigger-code to RAM area */
  for ( i=0U; i<Wdg_66_IA_TriggerFuncSize; i++ )
  {
    /* Copy code from ROM to RAM each byte */
    *dst = *src;
    dst++;
    src++;
  }
#endif /* #if ( WDG_66_IA_RUN_AREA_IS_RAM!=STD_OFF ) */
}

/** \brief Wdg_66_IA_GetPointerToSRSSRegister
 **
 ** This function is used to provide service to obtain a pointer to SRSS
 ** registers in the Wdg module.
 **
 ** \return a pointer to top address of SRSS registers.
 */
FUNC_P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, WDG_CODE )
Wdg_66_IA_GetPointerToSRSSRegister( void )
{
  return Wdg_66_IA_SRSSRegisterPtr;
}

/** \brief Wdg_66_IA_GetPointerToConfiguration
 **
 ** This function provides a caller with the configuration which be used to 
 ** initialize watchdog driver.
 **
 ** \return a pointer to configuration which be used to initialize watchdog driver.
 */
FUNC_P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_CODE )
Wdg_66_IA_GetPointerToConfiguration( void )
{
  /* return a pointer to configuration which be used to initialize watchdog driver */
  return Wdg_66_IA_ConfigPtr;
}

/** \brief Wdg_66_IA_GetMaxTimeoutValue
 **
 ** This function compares configuration parameter WdgMaxTimeout and hardware 
 ** acceptable maximum timeout value which is calculated from source clock of the watchdog timer.
 ** And returns smaller value as the real maximum timeout value.
 **
 ** \param [in] ConfigPtr   A pointer to configuration which be used to initialize watchdog driver.
 **
 ** \return smaller value of the configured maximum timeout and maximum hardware acceptable timeout.
 */
static FUNC( uint16, WDG_CODE )
Wdg_66_IA_GetMaxTimeoutValue( P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr )
{
  uint16 result = ConfigPtr->SettingCommonPtr->MaxTimeout; 
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, WDG_APPL_CONST ) 
    MCWDTConfigPtr = ConfigPtr->SettingWdgPtr->SettingMCWDTConfigPtr;

  /* Check if MCWDT is configured */
  if ( NULL_PTR != MCWDTConfigPtr )
  {
    /* Check if result is greater than WdgMaxTimeout */
    if ( result > MCWDTConfigPtr->WdgMaxTimeout )
    {
      /* Set WdgMaxTimeout value to result */
      result = MCWDTConfigPtr->WdgMaxTimeout;
    }
  }
  /* Return smaller timeout value */
  return result;
}

#define WDG_66_IA_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[internal function definitions]==========================*/

/*==================[end of file]============================================*/
