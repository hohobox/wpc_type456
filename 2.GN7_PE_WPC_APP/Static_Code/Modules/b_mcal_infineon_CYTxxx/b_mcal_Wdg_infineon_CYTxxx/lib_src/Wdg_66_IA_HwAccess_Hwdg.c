
/** \brief AUTOSAR Wdg Driver
 **
 ** This file contains the implementation to access HARDWARE watchdog.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Wdg_66_IA_Dem.h>
#include <Wdg_66_IA_HwAccess_Hwdg.h>   /* Internal header for module Wdg */
#include <Wdg_66_IA_Controller.h>      /* Internal header for module Wdg */

/*==================[macros]================================================*/

/* Calculate counter value of UPPER_LIMIT */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: In case of using in small processing, function-like macro is used. 
                  It improves readability. */
/* PRQA S 3453 1 */
#define WDG_66_IA_CALC_UPPER_LIMIT_COUNTER(timeout, timer_freq) ( ((uint32)(timeout) * (timer_freq)) / 1000U )

/* Calculate counter value of LOWER_LIMIT or WARN_LIMIT */
/* Deviation from MISRA-C:2004 rule 19.7, MISRA-C:2012 Dir-4.9
   Justification: In case of using in small processing, function-like macro is used. 
                  It improves readability. */
/* PRQA S 3453 2 */
#define WDG_66_IA_CALC_LOWER_WARN_LIMIT_COUNTER(upperlimit_value, lowerwarnlimit_percent) \
 ( (uint32)(((upperlimit_value) * (lowerwarnlimit_percent)) / 100U) )

/*==================[type definitions]======================================*/
/*==================[external function declarations]========================*/
/*==================[internal function declarations]========================*/

#define WDG_66_IA_START_SEC_CODE
#include <Wdg_66_IA_MemMap.h>

/** \brief Wdg_66_IA_HW_RegisterSettingCommon
 **
 ** This function is the common part of dealing with register setting.
 **
 ** \param [in] InitFlag        The initiation flag.
 ** \param [in] UpperLimitValue The upper limit value.
 ** \param [in] CurMode         Current mode value.
 ** \param [in] SettingPtr      Pointer to the configuration setting for 
 **                             hardware watchdog.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_RegisterSettingCommon(
  boolean InitFlag,
  uint16 timeout,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr
);
/** \brief Wdg_66_IA_HW_RegisterSettingMCWDT
 **
 ** This function sets the setting of MCWDT register.
 **
 ** \param [in]  InitFlag               The initiation flag.
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 ** \param [out] MCWDTEnableStatusPtr   Pointer to indicate MCWDT status enabled or disabled.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_RegisterSettingMCWDT(
  boolean InitFlag,
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA) MCWDTEnableStatusPtr
);
/** \brief Wdg_66_IA_HW_SetMCWDTRegLimitValue
 **
 ** This function sets the limit value of MCWDT register
 **
 ** \param [in]  InitFlag               The initiation flag.
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [in]  MCWDTRegisterPtr       Pointer to hardware which is used to access MCWDT registers.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_SetMCWDTRegLimitValue(
  boolean InitFlag,
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr
);
/** \brief Wdg_66_IA_HW_SetMCWDTRegConfigValue
 **
 ** This function sets the config value of MCWDT register.
 **
 ** \param [in]  InitFlag              The initiation flag.
 ** \param [in]  TimerConfigPtr        Pointer to the configuration setting for watchdog timer.
 ** \param [in]  MCWDTRegisterPtr      Pointer to hardware which is used to access MCWDT registers.
 **
 */
static FUNC( void, WDG_CODE )
Wdg_66_IA_HW_SetMCWDTRegConfigValue(
  boolean InitFlag,
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, WDG_APPL_CONST ) TimerConfigPtr,
  P2VAR( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr
);
/** \brief Wdg_66_IA_HW_RegisterSettingWDT
 **
 ** This function sets the setting of WDT register.
 **
 ** \param [in]  InitFlag               The initiation flag.
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 ** \param [out] WDTEnableStatusPtr     Pointer to indicate WDT status enabled or disabled.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_RegisterSettingWDT(
  boolean InitFlag,
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr,
  P2VAR ( uint32, AUTOMATIC, WDG_APPL_DATA) WDTEnableStatusPtr
);
/** \brief Wdg_66_IA_HW_SetWDTRegLimitValue
 **
 ** This function sets the limit value of WDT register.
 **
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [in]  WDTRegisterPtr         Pointer to hardware which is used to access WDT registers.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_SetWDTRegLimitValue(
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr
);
/** \brief Wdg_66_IA_HW_SetWDTRegConfigValue
 **
 ** This function sets the config value of MCWDT register.
 **
 ** \param [in]  InitFlag              The initiation flag.
 ** \param [in]  TimerConfigPtr        Pointer to the configuration setting for watchdog timer.
 ** \param [in]  WDTRegisterPtr        Pointer to hardware which is used to access WDT registers.
 **
 */
static FUNC( void, WDG_CODE )
Wdg_66_IA_HW_SetWDTRegConfigValue(
  boolean InitFlag,
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, WDG_APPL_CONST ) TimerConfigPtr,
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr
);

/** \brief Wdg_66_IA_HW_StopWDT
 **
 ** This function is disable to WDT
 **
 ** \param [in] CurMode      Current mode value
 ** \param [in] SettingPtr   Pointer to the configuration setting for hardware watchdog
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_StopWDT(
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr
);
/** \brief Wdg_66_IA_HW_WaitHwStatus
 **
 ** This function is wait WDT and MCWDT status changes to indicated status
 ** (enabled/disabled).
 **
 ** \param [in] Wait1usCnt        Loop count to wait 1 micro second regarding CPU clock cycle.
 ** \param [in] MaxWaitTime       Time for wait until watchdog hardware status change.
 ** \param [in] WDTRegisterPtr    Pointer to hardware which is used to access WDT registers.
 ** \param [in] MCWDTRegisterPtr  Pointer to hardware which is used to access MCWDT registers.
 ** \param [in] WDTEnableStatus   Indicate WDT status enabled or disabled.
 ** \param [in] MCWDTEnableStatus Indicate MCWDT status enabled or disabled.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_WaitHwStatus(
  uint32 Wait1usCnt,
  uint16 MaxWaitTime,
  P2CONST( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr,
  P2CONST( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr,
  uint32 WDTEnableStatus,
  uint32 MCWDTEnableStatus
);

/** \brief Wdg_66_IA_HW_WaitServiceReflect
 **
 ** This function is wait SERVICE register of MCWDT reflects
 **
 ** \param [in] Wait1usCnt        Loop count to wait 1 micro second regarding CPU clock cycle.
 ** \param [in] LowerLimitValue   The lower limit value.
 ** \param [in] MCWDTRegisterPtr  Pointer to hardware which is used to access MCWDT registers.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_WaitServiceReflect(
  uint32 Wait1usCnt,
  uint32 LowerLimitValue,
  P2CONST( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr
);

#define WDG_66_IA_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[external constants]====================================*/
/*==================[internal constants]====================================*/
/*==================[external data]=========================================*/
/*==================[internal data]=========================================*/
#define WDG_66_IA_START_SEC_VAR_INIT_8
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>
static VAR(uint8, WDG_VAR_INIT)
Wdg_66_IA_SRSSVersion = WDG_66_IA_SRSS_VER2;
#define WDG_66_IA_STOP_SEC_VAR_INIT_8
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[external function definitions]=========================*/

#define WDG_66_IA_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>


/** \brief Wdg_66_IA_HW_Init_Arch
 **
 ** This function initializes watchdog registers related to watchdog timer.
 **
 ** \param [in] ConfigPtr    Pointer to configuration which be used to 
 **                          initialize hardware.
 **
 ** \return E_OK    : Initialization has been successfully completed.
 **         E_NOT_OK: Initialization has failed.
 */
FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_Init_Arch( P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr )
{
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr = ConfigPtr->SettingWdgPtr;
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr = Wdg_66_IA_GetPointerToSRSSRegister();
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, REGSPACE ) TimerConfigPtr = SettingPtr->SettingMCWDTConfigPtr;
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr = &SrssRegisterPtr->WDTReg;
  Std_ReturnType ret_val = E_OK;
  uint16 timeout = 0U;

  /* Check if MCWDT is configured */
  if ( NULL_PTR != SettingPtr->SettingMCWDTConfigPtr )
  {
    /* Check for Stopping WDT */
    if ( TRUE == SettingPtr->SettingMCWDTConfigPtr->WdgStopWDT )
    {
      /* Disable WDT */
      ret_val = Wdg_66_IA_HW_StopWDT( SettingPtr->DefaultMode, SettingPtr );
    }
  }

  if ( E_OK == ret_val ) {
    /* Check if DefaultMode is fast mode */
    if ( WDGIF_FAST_MODE == SettingPtr->DefaultMode )
    {
      /* set timeout value of fast mode */
      timeout = SettingPtr->SettingFastPtr->TimeoutValue;
    }
    /* Check if DefaultMode is slow mode */
    else if ( WDGIF_SLOW_MODE == SettingPtr->DefaultMode )
    {
      /* set timeout value of slow mode */
      timeout = SettingPtr->SettingSlowPtr->TimeoutValue;
    }
    else
    {
      /* This case is OFF_MODE. */
      /* There is nothing to do in this case. */
    }

    /* Call the common part of dealing with register setting */
    ret_val = Wdg_66_IA_HW_RegisterSettingCommon( TRUE, timeout, SettingPtr->DefaultMode, SettingPtr );
  }
  
  /* Clear INTR register of MCWDT if it is set incorrectly */
  if ( NULL_PTR != SettingPtr->SettingMCWDTConfigPtr )
  {
    SrssRegisterPtr->MCWDTReg[TimerConfigPtr->WdgTimerSelection].INTR = WDG_66_IA_REG_BIT_MCWDT_INTR_CLR;
    /* Read value of INTR register ( This read ensures that the write has been flushed out to the hardware ) */
    ( void ) SrssRegisterPtr->MCWDTReg[TimerConfigPtr->WdgTimerSelection].INTR;
  }
  /* Clear INTR register of WDT if it is set incorrectly */
  if ( NULL_PTR != SettingPtr->SettingWDTConfigPtr )
  {
    WDTRegisterPtr->INTR = WDG_66_IA_REG_BIT_WDT_INTR_CLR;
    /* Read value of INTR register ( This read ensures that the write has been flushed out to the hardware ) */
    ( void ) WDTRegisterPtr->INTR;
  }
  
  if ( ret_val == E_OK )
  {
    Wdg_66_IA_SRSSVersion = ConfigPtr->SettingCommonPtr->SRSSVersion;
  }

  return ret_val;
}


/** \brief Wdg_66_IA_HW_SetMode
 **
 ** This function sets the timeout, window and interrupt time value according to
 ** mode setting.
 **
 ** \param [in] Mode      One of the following statically configured modes:
 **                       1. WDGIF_OFF_MODE
 **                       2. WDGIF_SLOW_MODE
 **                       3. WDGIF_FAST_MODE
 ** \param [in] ConfigPtr Pointer to configuration which be used to initialize
 **                       hardware.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_SetMode( WdgIf_ModeType Mode, P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr )
{
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr = ConfigPtr->SettingWdgPtr;
  Std_ReturnType ret_val;
  uint16 timeout = 0U;

  /* Check if Mode is fast mode */
  if ( WDGIF_FAST_MODE == Mode )
  {
    timeout = SettingPtr->SettingFastPtr->TimeoutValue;
  }
  /* Check if Mode is slow mode */
  else if ( WDGIF_SLOW_MODE == Mode )
  {
    timeout = SettingPtr->SettingSlowPtr->TimeoutValue;
  }
  else
  {
    /* This case is OFF_MODE. */
    /* There is nothing to do in this case. */
  }

  /* Call the common part of dealing with register setting */
  ret_val = Wdg_66_IA_HW_RegisterSettingCommon( FALSE, timeout, Mode, SettingPtr );

  return ret_val;
}


/** \brief Wdg_66_IA_HW_SetTriggerCondition
 **
 ** This function sets the timeout value for the trigger counter.
 **
 ** \param [in] timeout    Timeout value (milliseconds) for setting the trigger
 **                        counter.
 ** \param [in] CurMode    Current mode value.
 ** \param [in] ConfigPtr  Pointer to configuration which be used to initialize
 **                        hardware.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_SetTriggerCondition(
  uint16 timeout,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr
)
{
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr = ConfigPtr->SettingWdgPtr;
  Std_ReturnType ret_val;

  /* Call the common part of dealing with register setting */
  ret_val = Wdg_66_IA_HW_RegisterSettingCommon( FALSE, timeout, CurMode, SettingPtr );

  return ret_val;
}

/** \brief Wdg_66_IA_HW_ClearWarningIrq
 **
 ** This function clears the interrupt flag related to warning interrupt.
 **
 ** \param [in] TimerKind  One of the following watchdog timer:
 **                        0. WDG_66_IA_TIMER_MCWDT0
 **                        1. WDG_66_IA_TIMER_MCWDT1
 **                        2. WDG_66_IA_TIMER_MCWDT2
 **                        3. WDG_66_IA_TIMER_MCWDT3
 **                        4. WDG_66_IA_TIMER_WDT
 ** \param [in] SrssRegisterPtr  Pointer to hardware which be used to access
 **                              its registers.
 */
FUNC( void, WDG_CODE )
Wdg_66_IA_HW_ClearWarningIrq(
  Wdg_66_IA_TimerKindType TimerKind,
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr
)
{
  /* Check if TimerKind is WDT */
  if ( WDG_66_IA_TIMER_WDT == TimerKind )
  {
    /* Clear WDT bit of INTR register */
    SrssRegisterPtr->WDTReg.INTR = WDG_66_IA_REG_BIT_WDT_INTR_CLR;

    /* Read value of INTR register ( This read ensures that the write has been flushed out to the hardware ) */
    ( void ) SrssRegisterPtr->WDTReg.INTR;
  }
  /* Check if TimerKind is MCWDT[0-3] */
  else
  {
    /* Clear CTR0_INT bit of INTR register */
    SrssRegisterPtr->MCWDTReg[TimerKind].INTR = WDG_66_IA_REG_BIT_MCWDT_INTR_CLR;

    /* Read value of INTR register ( This read ensures that the write has been flushed out to the hardware ) */
    ( void ) SrssRegisterPtr->MCWDTReg[TimerKind].INTR;
  }
}

/** \brief Wdg_66_IA_HW_IsInterruptPending
 **
 ** This function check whether interrupt for watchdog is pending.
 **
 ** \param [in] TimerKind  One of the following watchdog timer:
 **                        0. WDG_66_IA_TIMER_MCWDT0
 **                        1. WDG_66_IA_TIMER_MCWDT1
 **                        2. WDG_66_IA_TIMER_MCWDT2
 **                        3. WDG_66_IA_TIMER_MCWDT3
 **                        4. WDG_66_IA_TIMER_WDT
 ** \param [in] SrssRegisterPtr  Pointer to hardware which be used to access
 **                              its registers.
 **
 ** \return  Return TRUE if watchdog interrupt is pending, else return FALSE.
 */
FUNC( boolean, WDG_CODE )
Wdg_66_IA_HW_IsInterruptPending(
  Wdg_66_IA_TimerKindType TimerKind,
  P2CONST( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr
)
{
  VAR( boolean, AUTOMATIC ) InterruptDetected;
  /* Check if TimerKind is WDT */
  if ( WDG_66_IA_TIMER_WDT == TimerKind )
  {
    /* Check WDT interrupt masked value  */
    if ( 0U != ( SrssRegisterPtr->WDTReg.INTR_MASKED & WDG_66_IA_REG_BIT_WDT_INTR_MASKED ) )
    {
      InterruptDetected = TRUE;
    }
    else
    {
      InterruptDetected = FALSE;
    }
  }
  /* Check if TimerKind is MCWDT[0-3] */
  else
  {
    /* Check MCWDT[0-3] interrupt masked value  */
    if ( 0U != ( SrssRegisterPtr->MCWDTReg[TimerKind].INTR_MASKED & WDG_66_IA_REG_BIT_MCWDT_INTR_MASKED ) )
    {
      InterruptDetected = TRUE;
    }
    else
    {
      InterruptDetected = FALSE;
    }
  }
  
  return InterruptDetected;
}

/** \brief Wdg_66_IA_HW_ImmediateReset
 **
 ** This function resets watchdog immediately.
 **
 ** \param [in] CurMode    Current mode value.
 ** \param [in] ConfigPtr  Pointer to configuration which be used to initialize
 **                        hardware.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_ImmediateReset(
  WdgIf_ModeType CurMode, 
  P2CONST( Wdg_66_IA_ConfigType, AUTOMATIC, WDG_APPL_CONST ) ConfigPtr
)
{
  Std_ReturnType ret_val;
  uint32 Wait1usCnt;
  uint16 MaxWaitTim;
  uint32 MCWDTEnableStatus = WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_DISABLED;
  uint32 WDTEnableStatus = WDG_66_IA_REG_BIT_WDT_CTL_STATUS_DISABLED;
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr = Wdg_66_IA_GetPointerToSRSSRegister();
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr = ConfigPtr->SettingWdgPtr;
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, REGSPACE ) TimerConfigPtr = SettingPtr->SettingMCWDTConfigPtr;

  /* Check if MCWDT is configured */
  if ( NULL_PTR != SettingPtr->SettingMCWDTConfigPtr )
  {
    /* Reset watchdog immediately by MCWDT */
    /* Deviation from MISRA-C:2004 Rules 16.10, MISRA-C:2012 Rule-17.7
       Justification: Return value is always true at here. */
    /* PRQA S 3200 1 */
    Wdg_66_IA_HW_RegisterSettingMCWDT( FALSE,
                                       1U,
                                       CurMode,
                                       SettingPtr,
                                       &Wait1usCnt,
                                       &MaxWaitTim,
                                       &MCWDTEnableStatus
                                     );

    /* Wait until status is changed */
    ret_val = Wdg_66_IA_HW_WaitHwStatus( Wait1usCnt,
                                         MaxWaitTim,
                                         NULL_PTR,
                                         &SrssRegisterPtr->MCWDTReg[TimerConfigPtr->WdgTimerSelection],
                                         WDG_66_IA_IGNORED_STATUS,
                                         MCWDTEnableStatus
                                       );
  }
  /* When only WDT is selected as watchdog timer */
  else
  {
    /* Reset watchdog immediately by WDT */
    ret_val = Wdg_66_IA_HW_RegisterSettingWDT(
                                               FALSE,
                                               1U,
                                               CurMode,
                                               SettingPtr,
                                               &Wait1usCnt,
                                               &MaxWaitTim,
                                               &WDTEnableStatus
                                             );
    /* Check ret_val */
    if ( E_OK == ret_val )
    {
      /* Wait until status is changed */
      ret_val = Wdg_66_IA_HW_WaitHwStatus(
                                           Wait1usCnt,
                                           MaxWaitTim,
                                           &SrssRegisterPtr->WDTReg,
                                           NULL_PTR,
                                           WDTEnableStatus,
                                           WDG_66_IA_IGNORED_STATUS
                                         );
    }
  }
  return ret_val;
}

#define WDG_66_IA_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[internal function definitions]=========================*/

#define WDG_66_IA_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/** \brief Wdg_66_IA_HW_RegisterSettingCommon
 **
 ** This function is the common part of dealing with register setting.
 **
 ** \param [in] InitFlag        The initiation flag.
 ** \param [in] UpperLimitValue The upper limit value.
 ** \param [in] CurMode         Current mode value.
 ** \param [in] SettingPtr      Pointer to the configuration setting for 
 **                             hardware watchdog.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_RegisterSettingCommon(
  boolean InitFlag,
  uint16 timeout,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr
)
{
  Std_ReturnType ret_val = E_OK;
  uint32         UpperLimitValue;
  uint32         Wait1usCnt = 0U;
  uint16         MaxWaitTim;
  uint16         WDTMaxWaitTim = 65535U;
  uint16         MCWDTMaxWaitTim = 65535U;
  uint32         MCWDTEnableStatus = WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_DISABLED;
  uint32         WDTEnableStatus = WDG_66_IA_REG_BIT_WDT_CTL_STATUS_DISABLED;
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, REGSPACE ) TimerConfigPtr = SettingPtr->SettingMCWDTConfigPtr;
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr = Wdg_66_IA_GetPointerToSRSSRegister();
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegPtr = &SrssRegisterPtr->WDTReg;
  P2VAR( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegPtr = NULL_PTR;
  /* Check if MCWDT is configured */
  if ( NULL_PTR != SettingPtr->SettingMCWDTConfigPtr ) {
    /* Get the counter value of UPPER_LIMIT by the timeout value */
    /* UpperLimitValue = TimeoutValue * WdgTimerFreq/1000 */
    UpperLimitValue = WDG_66_IA_CALC_UPPER_LIMIT_COUNTER( timeout, SettingPtr->SettingMCWDTConfigPtr->WdgTimerFreq );
    /* Set the setting of MCWDT register  */
    ret_val = Wdg_66_IA_HW_RegisterSettingMCWDT( InitFlag,
                                                 UpperLimitValue,
                                                 CurMode, SettingPtr,
                                                 &Wait1usCnt,
                                                 &MCWDTMaxWaitTim,
                                                 &MCWDTEnableStatus
                                               );
    /* Set pointer of MCWDT register */
    MCWDTRegPtr = &SrssRegisterPtr->MCWDTReg[TimerConfigPtr->WdgTimerSelection];
  }
  /* Check if WDT is configured */
  if ( E_OK == ret_val ) {
    if ( NULL_PTR != SettingPtr->SettingWDTConfigPtr ) {
      /* Get the counter value of UPPER_LIMIT by the timeout value */
      /* UpperLimitValue = TimeoutValue * WdgTimerFreq/1000 */
      UpperLimitValue = WDG_66_IA_CALC_UPPER_LIMIT_COUNTER( timeout, SettingPtr->SettingWDTConfigPtr->WdgTimerFreq );
      /* Set the setting of WDT register  */
      ret_val = Wdg_66_IA_HW_RegisterSettingWDT( InitFlag,
                                                 UpperLimitValue,
                                                 CurMode,
                                                 SettingPtr,
                                                 &Wait1usCnt,
                                                 &WDTMaxWaitTim,
                                                 &WDTEnableStatus
                                               );
    }
  }

  /* Check ret_val */
  if ( E_OK == ret_val )
  {
    /* Check if WDTMaxWaitTim is greater than MCWDTMaxWaitTim */
    if ( WDTMaxWaitTim > MCWDTMaxWaitTim )
    {
      /* Get the max wait time of MCWDT */
      MaxWaitTim = MCWDTMaxWaitTim;
    }
    else
    {
      /* Get the max wait time of WDT */
      MaxWaitTim = WDTMaxWaitTim;
    }
    /* Not check WDT's status when WdgStopWDT == FALSE */
    if ( NULL_PTR == SettingPtr->SettingWDTConfigPtr )
    {
      if ( FALSE == SettingPtr->SettingMCWDTConfigPtr->WdgStopWDT )
      {
        WDTRegPtr = NULL_PTR;
      }
    }
    /* Wait until status is changed */
    ret_val = Wdg_66_IA_HW_WaitHwStatus( Wait1usCnt,
                                         MaxWaitTim,
                                         WDTRegPtr,
                                         MCWDTRegPtr,
                                         WDTEnableStatus,
                                         MCWDTEnableStatus
                                       );
  }

  return ret_val;
}

/** \brief Wdg_66_IA_HW_RegisterSettingMCWDT
 **
 ** This function sets the setting of MCWDT register.
 **
 ** \param [in]  InitFlag               The initiation flag.
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 ** \param [out] MCWDTEnableStatusPtr   Pointer to indicate MCWDT status enabled or disabled.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_RegisterSettingMCWDT(
  boolean InitFlag,
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA) MCWDTEnableStatusPtr
)
{
  Std_ReturnType ret_val;
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr = Wdg_66_IA_GetPointerToSRSSRegister();
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, REGSPACE ) TimerConfigPtr = SettingPtr->SettingMCWDTConfigPtr;
  P2VAR( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE )
    MCWDTRegisterPtr= &( SrssRegisterPtr->MCWDTReg[TimerConfigPtr->WdgTimerSelection] );

  *MCWDTEnableStatusPtr = WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_DISABLED;

  /* Write LOCK register to unlock */
  MCWDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_MCWDT_LOCK_CLR0;
  MCWDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_MCWDT_LOCK_CLR1;
  
  /* Write CTL register to disable watchdog */
  if ( TRUE == InitFlag )
  {
    MCWDTRegisterPtr->CTL &= WDG_66_IA_REG_BIT_MCWDT_CTL_DISABLE;
  }
  /* Write SERVICE register to reset watchdog timer */
  else
  {
    MCWDTRegisterPtr->SERVICE |= WDG_66_IA_REG_BIT_MCWDT_SERVICE_SERVICE;
  }
  /* Set the limit value of MCWDT register */
  ret_val = Wdg_66_IA_HW_SetMCWDTRegLimitValue( InitFlag,
                                                UpperLimitValue,
                                                CurMode,
                                                SettingPtr,
                                                MCWDTRegisterPtr,
                                                Wait1usCntPtr,
                                                MaxWaitTimePtr
                                              );

  /* Set the config value of MCWDT register */
  Wdg_66_IA_HW_SetMCWDTRegConfigValue( InitFlag, TimerConfigPtr, MCWDTRegisterPtr);

  if ( WDGIF_OFF_MODE == CurMode )
  {
    /* Write CTL register to disable watchdog */
    MCWDTRegisterPtr->CTL &= WDG_66_IA_REG_BIT_MCWDT_CTL_DISABLE;
    *MCWDTEnableStatusPtr = WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_DISABLED;
  }
  else
  {
    /* Write CTL register to enable watchdog */
    MCWDTRegisterPtr->CTL |= WDG_66_IA_REG_BIT_MCWDT_CTL_ENABLE;
    *MCWDTEnableStatusPtr = WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_ENABLED;
  }
  
  /* Write LOCK register to lock */
  MCWDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_MCWDT_LOCK_SET01;
  
  return ret_val;
}

/** \brief Wdg_66_IA_HW_SetMCWDTRegLimitValue
 **
 ** This function sets the limit value of MCWDT register.
 **
 ** \param [in]  InitFlag         The initiation flag.
 ** \param [in]  UpperLimitValue  The upper limit value.
 ** \param [in]  CurMode          Current mode value.
 ** \param [in]  SettingPtr       Pointer to the configuration setting for hardware watchdog.
 ** \param [in]  MCWDTRegisterPtr Pointer to hardware which is used to access MCWDT registers.
 ** \param [out] Wait1usCntPtr    Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr   Pointer to the value of MaxWaitTime.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_SetMCWDTRegLimitValue(
  boolean InitFlag,
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr
)
{
  uint8  WarnLimitPerConf;
  uint8  LowerLimitPerConf;
  uint32 LowerLimitValue;
  uint32 WarnLimitValue;
  Std_ReturnType ret_val = E_OK;

  /* Check if SettingPtr is null or not */
  if ( NULL_PTR != SettingPtr )
  {
    /* Check value of CurMode */
    if ( WDGIF_OFF_MODE == CurMode )
    {
      /* Get the value of Wait1usCount of off mode */
      *Wait1usCntPtr = SettingPtr->SettingOffPtr->Wait1usCount;
      /* Get the value of MaxWaitTime of off mode */
      *MaxWaitTimePtr = SettingPtr->SettingOffPtr->MaxWaitTime;
      
      /* Clear INTR_MASK register */
      MCWDTRegisterPtr->INTR_MASK = WDG_66_IA_REG_BIT_MCWDT_INTR_DISABLE;
    }
    else
    {
      /* Check value of CurMode */
      if ( WDGIF_FAST_MODE == CurMode )
      {
        /* Get the value of LowerLimitPercent of fast mode */
        LowerLimitPerConf = SettingPtr->SettingFastPtr->LowerLimitPercent;
        /* Get the value of WarnLimitPercent of fast mode */
        WarnLimitPerConf = SettingPtr->SettingFastPtr->WarnLimitPercent;
        /* Get the value of Wait1usCount of fast mode */
        *Wait1usCntPtr = SettingPtr->SettingFastPtr->Wait1usCount;
        /* Get the value of MaxWaitTime of fast mode */
        *MaxWaitTimePtr = SettingPtr->SettingFastPtr->MaxWaitTime;
      }
      else
      {
        /* Get the value of LowerLimitPercent of slow mode */
        LowerLimitPerConf = SettingPtr->SettingSlowPtr->LowerLimitPercent;
        /* Get the value of LowerLimitPercent of slow mode */
        WarnLimitPerConf = SettingPtr->SettingSlowPtr->WarnLimitPercent;
        /* Get the value of Wait1usCount of slow mode */
        *Wait1usCntPtr = SettingPtr->SettingSlowPtr->Wait1usCount;
        /* Get the value of MaxWaitTime of slow mode */
        *MaxWaitTimePtr = SettingPtr->SettingSlowPtr->MaxWaitTime;
      }
      /* Calculate counter value of LOWER_LIMIT */
      LowerLimitValue = WDG_66_IA_CALC_LOWER_WARN_LIMIT_COUNTER( UpperLimitValue, LowerLimitPerConf );
      /* Calculate counter value of WARN_LIMIT */
      WarnLimitValue = WDG_66_IA_CALC_LOWER_WARN_LIMIT_COUNTER( UpperLimitValue, WarnLimitPerConf );

      if ( TRUE == InitFlag )
      {
        /* Wait until watchdog is disabled */
        ret_val = Wdg_66_IA_HW_WaitHwStatus( *Wait1usCntPtr,
                                             *MaxWaitTimePtr,
                                             NULL_PTR,
                                             MCWDTRegisterPtr,
                                             WDG_66_IA_IGNORED_STATUS,
                                             WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_DISABLED
                                           );
      }
      else
      {
        ret_val = Wdg_66_IA_HW_WaitServiceReflect( *Wait1usCntPtr,
                                                   LowerLimitValue,
                                                   MCWDTRegisterPtr
                                                 );
      }

      if ( E_OK == ret_val )
      {
        /* Set UPPER_LIMIT register */
        MCWDTRegisterPtr->UPPER_LIMIT = UpperLimitValue;
        /* Set WARN_LIMIT, LOWER_LIMIT registers */
        MCWDTRegisterPtr->LOWER_LIMIT = LowerLimitValue;
        MCWDTRegisterPtr->WARN_LIMIT = WarnLimitValue;

        /* Check if the value of WarnLimitValue is not equal to 0U */
        if ( WarnLimitValue != 0U )
        {
          /* Set INTR_MASK register to generate warning interruption */
          MCWDTRegisterPtr->INTR_MASK = WDG_66_IA_REG_BIT_MCWDT_INTR_ENABLE;
        }
      }
    }
  }

  return ret_val;
}

/** \brief Wdg_66_IA_HW_SetMCWDTRegConfigValue
 **
 ** This function sets the config value of MCWDT register.
 **
 ** \param [in]  InitFlag              The initiation flag.
 ** \param [in]  TimerConfigPtr        Pointer to the configuration setting for watchdog timer.
 ** \param [in]  MCWDTRegisterPtr      Pointer to hardware which is used to access MCWDT registers.
 **
 */
static FUNC( void, WDG_CODE )
Wdg_66_IA_HW_SetMCWDTRegConfigValue(
  boolean InitFlag,
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, WDG_APPL_CONST ) TimerConfigPtr,
  P2VAR( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr
)
{
  uint32 CONFIGRegVal;

  if ( TRUE == InitFlag )
  {
    /* Check if TimerConfigPtr is null or not */
    if ( NULL_PTR != TimerConfigPtr )
    {
      MCWDTRegisterPtr->CPU_SELECT = (uint32) TimerConfigPtr->WdgCPUSelect;
      CONFIGRegVal = MCWDTRegisterPtr->CONFIG;
      
      /* Set LOWER_ACTION bit to reset */
      if ( TimerConfigPtr->WdgLowerAction == WDG_66_IA_ACTION_FAULT_RESET )
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_LOWER_ACTION_FAULT_RESET;
      }
      else
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_LOWER_ACTION_FAULT;
      }
      /* Set UPPER_ACTION bit to reset */
      if ( TimerConfigPtr->WdgUpperAction == WDG_66_IA_ACTION_FAULT_RESET )
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_UPPER_ACTION_FAULT_RESET;
      }
      else
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_UPPER_ACTION_FAULT;
      }
      /* Set WARN_ACTION bit to interrupt */
      CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_WARN_ACTION;
      /* Set SLEEPDEEP_PAUSE, DEBUG_RUN bits by config setting */
      /* Pauses/runs this counter when the system is in DEEPSLEEP */
      /* STD_ON: Counter behaves normally during DEEPSLEEP */
      /* STD_OFF: Counter pauses during DEEPSLEEP */
      if ( TimerConfigPtr->DeepSleepModeAction == STD_ON )
      {
        CONFIGRegVal &= (~WDG_66_IA_REG_BIT_MCWDT_CONFIG_DPSLP_PAUSE);
      }
      else
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_DPSLP_PAUSE;
      }
      /* Pauses/runs this counter while a debugger is connected */
      /* STD_ON: Counter runs normally when debugger connected */
      /* STD_OFF: Counter pauses when debugger connected */
      if ( TimerConfigPtr->DebugModeAction == STD_ON )
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_MCWDT_CONFIG_DEBUG_RUN;
      }
      else
      {
        CONFIGRegVal &= (~WDG_66_IA_REG_BIT_MCWDT_CONFIG_DEBUG_RUN);
      }
      /* Set CONFIG register */
      MCWDTRegisterPtr->CONFIG = CONFIGRegVal;
    }
  }
}

/** \brief Wdg_66_IA_HW_RegisterSettingWDT
 **
 ** This function sets the setting of WDT register.
 **
 ** \param [in]  InitFlag               The initiation flag.
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 ** \param [out] WDTEnableStatusPtr     Pointer to indicate WDT status enabled or disabled.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_RegisterSettingWDT(
  boolean InitFlag,
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr,
  P2VAR ( uint32, AUTOMATIC, WDG_APPL_DATA) WDTEnableStatusPtr
)
{
  Std_ReturnType ret_val;
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr = Wdg_66_IA_GetPointerToSRSSRegister();
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr = &SrssRegisterPtr->WDTReg;
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, REGSPACE ) TimerConfigPtr = SettingPtr->SettingWDTConfigPtr;

  *WDTEnableStatusPtr = WDG_66_IA_REG_BIT_WDT_CTL_STATUS_DISABLED;

  /* Write LOCK register to unlock */
  WDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_WDT_LOCK_CLR0;
  WDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_WDT_LOCK_CLR1;
  /* Write CTL register to disable watchdog */
  WDTRegisterPtr->CTL &= WDG_66_IA_REG_BIT_WDT_CTL_DISABLE;

  /* Set the limit value of WDT register */
  ret_val = Wdg_66_IA_HW_SetWDTRegLimitValue( UpperLimitValue,
                                              CurMode,
                                              SettingPtr,
                                              WDTRegisterPtr,
                                              Wait1usCntPtr,
                                              MaxWaitTimePtr
                                            );
  /* Set the config value of WDT register */
  Wdg_66_IA_HW_SetWDTRegConfigValue( InitFlag, TimerConfigPtr, WDTRegisterPtr);

  /* Check if CurMode is off mode */
  if ( WDGIF_OFF_MODE != CurMode )
  {
    /* Write CTL register to enable watchdog */
    WDTRegisterPtr->CTL |= WDG_66_IA_REG_BIT_WDT_CTL_ENABLE;
    *WDTEnableStatusPtr = WDG_66_IA_REG_BIT_WDT_CTL_STATUS_ENABLED;
  }

  /* Write LOCK register to lock */
  WDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_WDT_LOCK_SET01;

  return ret_val;
}

/** \brief Wdg_66_IA_HW_SetWDTRegLimitValue
 **
 ** This function sets the limit value of WDT register.
 **
 ** \param [in]  UpperLimitValue        The upper limit value.
 ** \param [in]  CurMode                Current mode value.
 ** \param [in]  SettingPtr             Pointer to the configuration setting for hardware watchdog.
 ** \param [in]  WDTRegisterPtr         Pointer to hardware which is used to access WDT registers.
 ** \param [out] Wait1usCntPtr          Pointer to the value of Wait1usCnt.
 ** \param [out] MaxWaitTimePtr         Pointer to the value of MaxWaitTime.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_SetWDTRegLimitValue(
  uint32 UpperLimitValue,
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr,
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr,
  P2VAR( uint32, AUTOMATIC, WDG_APPL_DATA ) Wait1usCntPtr,
  P2VAR( uint16, AUTOMATIC, WDG_APPL_DATA ) MaxWaitTimePtr
)
{
  uint8 WarnLimitPerConf;
  uint8 LowerLimitPerConf;
  uint32 LowerLimitValue;
  uint32 WarnLimitValue;
  Std_ReturnType ret_val = E_OK;
  /* Check if SettingPtr is null or not */
  if ( NULL_PTR != SettingPtr )
  {
    /* Check if CurMode is off mode */
    if ( WDGIF_OFF_MODE == CurMode )
    {
      /* Get the value of Wait1usCount of off mode */
      *Wait1usCntPtr = SettingPtr->SettingOffPtr->Wait1usCount;
      /* Get the value of MaxWaitTime of off mode */
      *MaxWaitTimePtr = SettingPtr->SettingOffPtr->MaxWaitTime;

      /* Clear INTR_MASK register */
      WDTRegisterPtr->INTR_MASK = WDG_66_IA_REG_BIT_WDT_INTR_DISABLE;
    }
    else
    {
      /* Check if CurMode is fast mode */
      if ( WDGIF_FAST_MODE == CurMode )
      {
        /* Get the value of LowerLimitPercent of fast mode */
        LowerLimitPerConf = SettingPtr->SettingFastPtr->LowerLimitPercent;
        /* Get the value of WarnLimitPercent of fast mode */
        WarnLimitPerConf = SettingPtr->SettingFastPtr->WarnLimitPercent;
        /* Get the value of Wait1usCount of fast mode */
        *Wait1usCntPtr = SettingPtr->SettingFastPtr->Wait1usCount;
        /* Get the value of MaxWaitTime of fast mode */
        *MaxWaitTimePtr = SettingPtr->SettingFastPtr->MaxWaitTime;
      }
      /* Check if CurMode is slow mode */
      else
      {
        /* Get the value of LowerLimitPercent of slow mode */
        LowerLimitPerConf = SettingPtr->SettingSlowPtr->LowerLimitPercent;
        /* Get the value of WarnLimitPercent of slow mode */
        WarnLimitPerConf = SettingPtr->SettingSlowPtr->WarnLimitPercent;
        /* Get the value of Wait1usCount of slow mode */
        *Wait1usCntPtr = SettingPtr->SettingSlowPtr->Wait1usCount;
        /* Get the value of MaxWaitTime of slow mode */
        *MaxWaitTimePtr = SettingPtr->SettingSlowPtr->MaxWaitTime;
      }
      
      /* Calculate counter value of LOWER_LIMIT */
      LowerLimitValue = WDG_66_IA_CALC_LOWER_WARN_LIMIT_COUNTER( UpperLimitValue, LowerLimitPerConf );
      /* Calculate counter value of WARN_LIMIT */
      WarnLimitValue = WDG_66_IA_CALC_LOWER_WARN_LIMIT_COUNTER( UpperLimitValue, WarnLimitPerConf );
      
      /* Wait until watchdog is disabled */
      ret_val = Wdg_66_IA_HW_WaitHwStatus( *Wait1usCntPtr,
                                           *MaxWaitTimePtr,
                                           WDTRegisterPtr,
                                           NULL_PTR,
                                           WDG_66_IA_REG_BIT_WDT_CTL_STATUS_DISABLED,
                                           WDG_66_IA_IGNORED_STATUS
                                         );

      if ( E_OK == ret_val )
      {
        /* Set UPPER_LIMIT register */
        WDTRegisterPtr->UPPER_LIMIT = UpperLimitValue;
        /* Set WARN_LIMIT, LOWER_LIMIT registers */
        WDTRegisterPtr->LOWER_LIMIT = LowerLimitValue;
        WDTRegisterPtr->WARN_LIMIT = WarnLimitValue;

        /* Check if the value of WarnLimitValue is not equal to 0U */
        if ( WarnLimitValue != 0U )
        {
          /* Set INTR_MASK register to generate warning interruption */
          WDTRegisterPtr->INTR_MASK = WDG_66_IA_REG_BIT_WDT_INTR_ENABLE;
        }
      }
    }
  }
  return ret_val;
}


/** \brief Wdg_66_IA_HW_SetWDTRegConfigValue
 **
 ** This function sets the config value of MCWDT register.
 **
 ** \param [in]  InitFlag              The initiation flag.
 ** \param [in]  TimerConfigPtr        Pointer to the configuration setting for watchdog timer.
 ** \param [in]  WDTRegisterPtr        Pointer to hardware which is used to access WDT registers.
 **
 */
static FUNC( void, WDG_CODE )
Wdg_66_IA_HW_SetWDTRegConfigValue(
  boolean InitFlag,
  P2CONST( Wdg_66_IA_TimerConfigType, AUTOMATIC, WDG_APPL_CONST ) TimerConfigPtr,
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr
)
{
  uint32 CONFIGRegVal;

  if ( TRUE == InitFlag )
  {
    /* Check if TimerConfigPtr is null or not */
    if ( NULL_PTR != TimerConfigPtr )
    {
      CONFIGRegVal = WDTRegisterPtr->CONFIG;
      /* Set LOWER_ACTION bit to reset */
      CONFIGRegVal |= WDG_66_IA_REG_BIT_WDT_CONFIG_LOWER_ACTION;
      /* Set UPPER_ACTION bit to reset */
      CONFIGRegVal |= WDG_66_IA_REG_BIT_WDT_CONFIG_UPPER_ACTION;
      /* Set WARN_ACTION bit to interrupt */
      CONFIGRegVal |= WDG_66_IA_REG_BIT_WDT_CONFIG_WARN_ACTION;
      /* Set DPSLP_PAUSE, HIB_PAUSE, DEBUG_RUN bits by config setting */
      /* Pauses/runs this counter when the system is in DEEPSLEEP */
      /* STD_ON: Counter behaves normally during DEEPSLEEP */
      /* STD_OFF: Counter pauses during DEEPSLEEP */
      if ( TimerConfigPtr->DeepSleepModeAction == STD_ON )
      {
        CONFIGRegVal &= (~WDG_66_IA_REG_BIT_WDT_CONFIG_DPSLP_PAUSE);
      }
      else
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_WDT_CONFIG_DPSLP_PAUSE;
      }
      /* Pauses/runs this counter when the system is in HIBERNATE */
      /* STD_ON: Counter behaves normally during HIBERNATE */
      /* STD_OFF: Counter pauses during HIBERNATE */
      if ( TimerConfigPtr->HibernateModeAction == STD_ON )
      {
        CONFIGRegVal &= (~WDG_66_IA_REG_BIT_WDT_CONFIG_HIB_PAUSE);
      }
      else
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_WDT_CONFIG_HIB_PAUSE;
      }
      /* Pauses/runs this counter while a debugger is connected */
      /* STD_ON: Counter runs normally when debugger connected */
      /* STD_OFF: Counter pauses when debugger connected */
      if ( TimerConfigPtr->DebugModeAction == STD_ON )
      {
        CONFIGRegVal |= WDG_66_IA_REG_BIT_WDT_CONFIG_DEBUG_RUN;
      }
      else
      {
        CONFIGRegVal &= (~WDG_66_IA_REG_BIT_WDT_CONFIG_DEBUG_RUN);
      }
      /* Set CONFIG register */
      WDTRegisterPtr->CONFIG = CONFIGRegVal;
    }
  }
}

/** \brief Wdg_66_IA_HW_StopWDT
 **
 ** This function is disable to WDT.
 **
 ** \param [in] CurMode      Current mode value.
 ** \param [in] SettingPtr   Pointer to the configuration setting for hardware watchdog.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_StopWDT(
  WdgIf_ModeType CurMode,
  P2CONST( Wdg_66_IA_SettingType, AUTOMATIC, WDG_APPL_CONST ) SettingPtr
)
{
  uint32 Wait1usCnt = 0U;
  uint16 MaxWaitTim = 0U;
  Std_ReturnType ret_val;
  P2VAR( volatile Wdg_66_IA_SrssRegType, AUTOMATIC, REGSPACE ) SrssRegisterPtr = Wdg_66_IA_GetPointerToSRSSRegister();
  P2VAR( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr = &SrssRegisterPtr->WDTReg;

  /* Check if SettingPtr is null or not */
  if ( NULL_PTR != SettingPtr )
  {
    /* Check value of CurMode */
    if ( WDGIF_FAST_MODE == CurMode )
    {
      /* Get the value of Wait1usCount of fast mode */
      Wait1usCnt = SettingPtr->SettingFastPtr->Wait1usCount;
      /* Get the value of MaxWaitTime of fast mode */
      MaxWaitTim = SettingPtr->SettingFastPtr->MaxWaitTime;
    }
    else if ( WDGIF_SLOW_MODE == CurMode )
    {
      /* Get the value of Wait1usCount of slow mode */
      Wait1usCnt = SettingPtr->SettingSlowPtr->Wait1usCount;
      /* Get the value of MaxWaitTime of slow mode */
      MaxWaitTim = SettingPtr->SettingSlowPtr->MaxWaitTime;
    }
    else
    {
      /* Get the value of Wait1usCount of off mode */
      Wait1usCnt = SettingPtr->SettingOffPtr->Wait1usCount;
      /* Get the value of MaxWaitTime of off mode */
      MaxWaitTim = SettingPtr->SettingOffPtr->MaxWaitTime;
    }
  }

  /* Write LOCK register to unlock */
  WDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_WDT_LOCK_CLR0;
  WDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_WDT_LOCK_CLR1;
  /* Write CTL register to disable watchdog */
  WDTRegisterPtr->CTL &= WDG_66_IA_REG_BIT_WDT_CTL_DISABLE;
  /* Wait until watchdog is disabled */
  ret_val = Wdg_66_IA_HW_WaitHwStatus( Wait1usCnt,
                                       MaxWaitTim,
                                       WDTRegisterPtr,
                                       NULL_PTR,
                                       WDG_66_IA_REG_BIT_WDT_CTL_STATUS_DISABLED,
                                       WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_DISABLED
                                     );
  /* Write LOCK register to lock */
  WDTRegisterPtr->LOCK = WDG_66_IA_REG_BIT_WDT_LOCK_SET01;

  return ret_val;
}

/** \brief Wdg_66_IA_HW_WaitHwStatus
 **
 ** This function is wait WDT and MCWDT status changes to indicated status
 ** (enabled/disabled).
 **
 ** \param [in] Wait1usCnt        Loop count to wait 1 micro second regarding CPU clock cycle.
 ** \param [in] MaxWaitTime       Time for wait until watchdog hardware status change.
 ** \param [in] WDTRegisterPtr    Pointer to hardware which is used to access WDT registers.
 ** \param [in] MCWDTRegisterPtr  Pointer to hardware which is used to access MCWDT registers.
 ** \param [in] WDTEnableStatus   Indicate WDT status enabled or disabled.
 ** \param [in] MCWDTEnableStatus Indicate MCWDT status enabled or disabled.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_WaitHwStatus(
  uint32 Wait1usCnt,
  uint16 MaxWaitTime,
  P2CONST( volatile Wdg_66_IA_WdtRegType, AUTOMATIC, REGSPACE ) WDTRegisterPtr,
  P2CONST( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr,
  uint32 WDTEnableStatus,
  uint32 MCWDTEnableStatus
)
{
  Std_ReturnType ret = E_OK;
  volatile uint32 cnt;
  volatile uint16 tim = MaxWaitTime;
  volatile boolean mcwdt_chk = FALSE;
  volatile boolean wdt_chk = FALSE;  

  /* Check MCWDTRegisterPtr */
  if ( NULL_PTR != MCWDTRegisterPtr )
  {
    mcwdt_chk = TRUE;
  }
  /* Check WDTRegisterPtr */
  if ( NULL_PTR != WDTRegisterPtr )
  {
    wdt_chk = TRUE;
  }
  /* Wait WDT and MCWDT status changes to indicated status */
  do
  {
    /* Check if mcwdt_chk is TRUE */
    if ( mcwdt_chk == TRUE )
    {
      /* Wait MCWDT status changes to indicated status */
      /* Deviation from MISRA-C:2004 Rules 20.3, 21.1, MISRA-C:2012 Dir-4.1, Dir-4.1
         Justification: The pointer is not referenced if it is a NULL pointer. */
      /* PRQA S 2811, 2812 1 */
      if ( MCWDTEnableStatus == ( MCWDTRegisterPtr->CTL & WDG_66_IA_REG_BIT_MCWDT_CTL_STATUS_ENABLED ) )
      {
        /* set mcwdt_chk to FALSE when status is changed */
        mcwdt_chk = FALSE;
      }
    }
    /* Check if wdt_chk is TRUE */
    if ( wdt_chk == TRUE )
    {
      /* Wait WDT status changes to indicated status */
      /* Deviation from MISRA-C:2004 Rules 20.3, 21.1, MISRA-C:2012 Dir-4.1, Dir-4.1
         Justification: The pointer is not referenced if it is a NULL pointer. */
      /* PRQA S 2811, 2812 1 */
      if ( WDTEnableStatus == ( WDTRegisterPtr->CTL & WDG_66_IA_REG_BIT_WDT_CTL_STATUS_ENABLED ) )
      {
        /* set wdt_chk to FALSE when status is changed */
        wdt_chk = FALSE;
      }
    }
    /* Deviation from MISRA-C:2004 Rule 12.4, MISRA-C:2012 Rule-13.5
       Justification: It is necessary to check both variables at here. */
    /* PRQA S 3415 1 */
    if ( (mcwdt_chk == FALSE) && (wdt_chk == FALSE) )
    {
      break;
    }
    tim--;
    /* Get the value of 1us loop counter */
    cnt = Wait1usCnt;
    /* Do nothing 1us */
    while( cnt > 0U )
    {
      cnt--;
    }
  /* Check if wait timer is over  */
  } while( tim > 0U );

  /* When wait timer is over, return E_NOT_OK */
  if ( tim == 0U )
  {
    ret = E_NOT_OK;
  }
  return ret;
}


/** \brief Wdg_66_IA_HW_WaitServiceReflect
 **
 ** This function is wait SERVICE register of MCWDT reflects
 **
 ** \param [in] Wait1usCnt        Loop count to wait 1 micro second regarding CPU clock cycle.
 ** \param [in] LowerLimitValue   The lower limit value.
 ** \param [in] MCWDTRegisterPtr  Pointer to hardware which is used to access MCWDT registers.
 **
 ** \return E_OK    : Success
 **         E_NOT_OK: Failure
 */
static FUNC( Std_ReturnType, WDG_CODE )
Wdg_66_IA_HW_WaitServiceReflect(
  uint32 Wait1usCnt,
  uint32 LowerLimitValue,
  P2CONST( volatile Wdg_66_IA_McwdtRegType, AUTOMATIC, REGSPACE ) MCWDTRegisterPtr
)
{
  Std_ReturnType ret = E_OK;
  volatile uint32 CurCNT;
  volatile uint32 cnt;
  volatile uint16 tim;

  /* Check current SRSS version */
  if ( Wdg_66_IA_SRSSVersion == WDG_66_IA_SRSS_VER2 )
  {
    /* Get the value of current CNT reg  */
    CurCNT = MCWDTRegisterPtr->CNT;
    /* Check current CNT value */
    if ( CurCNT < LowerLimitValue )
    {
      tim = WDG_66_IA_SERVICE_WAIT_TIME;
      while ( ((MCWDTRegisterPtr->SERVICE) & WDG_66_IA_REG_BIT_MCWDT_SERVICE_SERVICE)
              != WDG_66_IA_REG_BIT_MCWDT_SERVICE_REFLECTED )
      {
        tim--;
        if ( tim == 0U )
        {
          ret = E_NOT_OK;
          break;
        }
        cnt = Wait1usCnt;
        /* Do nothing 1us */
        while( cnt > 0U )
        {
          cnt--;
        }
      }
    }
  }
  return ret;
}

#define WDG_66_IA_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Wdg_66_IA_MemMap.h>

/*==================[end of file]===========================================*/
