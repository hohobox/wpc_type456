/** \brief Can_ModeHandler.c
 **
 ** The mode handler is responsible for setting and maintaining controller
 ** modes and interrupts.
 **
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can_ModeHandler.h>
#include <Can_Callout.h>
#include <Can_RegisterAbstraction.h>

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

/*==================[internal constants]====================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

/** \brief Can_ModeGetErrorPassiveStatus
 **
 ** Reads the error passive status flag and returns TRUE if passive error is active.
 ** Otherwise FALSE is returned.
 **
 ** \return   Passive error occurrence. Value is TRUE for passive error state is
 **           reached. FALSE is returned otherwise.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ModeGetErrorPassiveStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  boolean retVal;
  uint8   error;

  /* Read error passive status out of HW registers. */
  error = Can_RaGetErrorPassiveStatus(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
  if (0u == error)
  {
    /* Error Passive state not reached. */
    retVal = FALSE;
  }
  else
  {
    /* Error Passive state is reached. */
    retVal = TRUE;
  }
  return retVal;
}

/** \brief Can_ModeGetHwStatus
 **
 ** Reads the current status of the hardware.
 **
 ** \return   Current status of the hardware.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
FUNC(Can_ControllerStatusType, AUTOMATIC) Can_ModeGetHwStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  Can_ControllerStatusType result;
  
  uint32 HwStatus = Can_RaGetStatus(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
  if (0u == (HwStatus & CAN_RA_STATUS_MASK_INIT))
  {
    /* Started or Sleep */
    if (0u == (HwStatus & CAN_RA_STATUS_MASK_MON))
    {
      result = CAN_CONTROLLER_STARTED;
    }
    else
    {
      result = CAN_CONTROLLER_SLEEP;
    }
  }
  else
  {
    /* Stopped */
    result = CAN_CONTROLLER_STOPPED;
  }
  
  return result;
}

/** \brief Can_ModeHandleStartSleep
 **
 ** Checks for the event that the hw's status has changed to STARTED or SLEEP. If
 ** so, CanIf is notified.
 ** 
 ** The function is intended to be called from the ISR or MainFunction_Mode.
 **
 ** \return   TRUE: HW is in start or sleep mode and notification has been sent.
 **           FALSE: HW is in init mode and notification has not been sent.
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data. The
 **                                     controller state data is changed to STARTED
 **                                     or SLEEP if the respective event was detected.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ModeHandleStartSleep
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr
)
{
  boolean needIndication = FALSE;
  boolean result;
  Can_ControllerStatusType currentStatus;
  uint32  hwStatus;
  
  /* To avoid status update confliction between interrupt and Can_MainFunction_Mode(). */
  Can_EnterCriticalSection();
  hwStatus = Can_RaGetStatus(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
  
  /* Check if INIT is over. */
  if (0u == (hwStatus & CAN_RA_STATUS_MASK_INIT))
  {
    /* Controller HW is started. */        
    if (CAN_CONTROLLER_STOPPED == ControllerStatePtr->Status)
    {      
      if (0u == (hwStatus & CAN_RA_STATUS_MASK_MON))
      {
        /* HW is started and not monitoring */
        currentStatus = CAN_CONTROLLER_STARTED;
      }
      else
      {
        /* HW is started and monitoring */
        currentStatus = CAN_CONTROLLER_SLEEP;
      }
      ControllerStatePtr->Status = currentStatus;
      needIndication = TRUE;
    }
    /* The notification will be sent either in the current invocation of
       the function or in any previous invocation. */
    result = TRUE;
  }
  else
  {
    /* HW is in initialization mode. Continue waiting, keep current status. */
    result = FALSE;
  }
  Can_ExitCriticalSection();

  if (needIndication != FALSE)
  {
    /* Leave critical section before calling notification. */
    /* The current status is stored in the local variable CurrentStatus so that
        the notification is called with the correct parameter, even
         if this function is interrupted. */
    Can_CanIfControllerModeIndication(ControllerCfgPtr, currentStatus);
  }

  return result;
}

/** \brief Can_ModeSetInterrupts
 **
 ** Enables or disables all interrupts of the controller via the interrupt line
 ** enable (ILE). The function is intended for the use with
 ** Can_Disable/EnableControllerInterrupts.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] Enable   true: enables all interrupts
 **                      false: disables all interrupts
 **
 */
FUNC(void, AUTOMATIC) Can_ModeSetInterrupts
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(boolean, AUTOMATIC) Enable
)
{
  /* Enable/Disable INT0 according to parameter Enable,
     Disable INT1 in any case. */
  Can_RaSetInterruptLineEnable(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber, (uint32)Enable);
}

/** \brief Can_ModeStart
 **
 ** Changes the controller to start or sleep mode.
 ** 
 ** Precondition: The controller is stopped. (Else there will be a data exception.)
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] BaudratePtr        Pointer to the baudrate that shall be applied.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data. The
 **                                data is updated if the state changes before timeout.
 ** \param [in] SleepMode          TRUE: start in SLEEP mode,
 **                                FALSE: start in STARTED mode
 **
 */
FUNC(void, AUTOMATIC) Can_ModeStart
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) BaudratePtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(boolean, AUTOMATIC) SleepMode
)
{
  uint32 baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  uint32 interrupts;
  uint32 startTime;
  uint16 BaudratePrescaler;
  /* Set default to disable transmitter delay compensation. */
  uint8   enableTrcvDelayComp = 0u;
  boolean modeChanged;
  boolean timedOut;
  Std_ReturnType validStartTime;
  
  if (0u != ControllerStateDataPtr->BaudrateData.NominalPrescaler)
  {
    BaudratePrescaler = ControllerStateDataPtr->BaudrateData.NominalPrescaler;
  }
  else
  {
    BaudratePrescaler = BaudratePtr->NominalBaudratePrescaler;
  }
  Can_RaSetNominalBitTiming
  (
    baseAddress,
    channelNumber,
    BaudratePrescaler - 1u,
    BaudratePtr->TSeg1 - 1u,
    BaudratePtr->TSeg2 - 1u,
    BaudratePtr->SyncJumpWidth - 1u
  );

  if (0xFFu != BaudratePtr->FdTrcvDelayCompensationOffset)
  {
      /* enable transmitter delay compensation */
      enableTrcvDelayComp = 1u;
      Can_RaSetTransmitterDelayCompensationOffset(baseAddress,
                                                  channelNumber,
                                                  BaudratePtr->FdTrcvDelayCompensationOffset);
  }

  if (0u != ControllerStateDataPtr->BaudrateData.DataPrescaler)
  {
    BaudratePrescaler = ControllerStateDataPtr->BaudrateData.DataPrescaler;
  }
  else
  {
    BaudratePrescaler = BaudratePtr->DataBaudratePrescaler;
  }
  
  Can_RaSetDataBitTiming
  (
    baseAddress,
    channelNumber,
    BaudratePrescaler - 1u,
    BaudratePtr->FdTSeg1 - 1u,
    BaudratePtr->FdTSeg2 - 1u,
    BaudratePtr->FdSyncJumpWidth - 1u,
    enableTrcvDelayComp
  );
  Can_RaSetRamWdg(baseAddress, channelNumber, 0u); /* Not used: Disabled */
  Can_RaSetTimeoutCounter(baseAddress, channelNumber, 0u); /* Not used: Disabled */
  Can_RaSetTimestampCounter(baseAddress, channelNumber, 0u); /* Not used: Disabled */
  Can_RaClearInterruptFlag(baseAddress, channelNumber, CAN_RA_INTERRUPT_MASK_ALL); /* clear all interrupts. */

  /* Set interrupt enable according to configuration. */  
  interrupts = CAN_RA_INTERRUPT_MASK_BUSOFF * ControllerCfgPtr->InterruptEnableBusOff;
  interrupts |= (
                   CAN_RA_INTERRUPT_MASK_RX_DEDICATED
                 | CAN_RA_INTERRUPT_MASK_RX_FIFO1
                 | CAN_RA_INTERRUPT_MASK_RX_FIFO0
                 | CAN_RA_INTERRUPT_MASK_RX_MSG_LOST
                ) * (uint32)(ControllerCfgPtr->InterruptEnableRx);
  interrupts |= (
                   CAN_RA_INTERRUPT_MASK_TX_EVENT
                 | CAN_RA_INTERRUPT_MASK_TX_CANCEL
                ) * (uint32)(ControllerCfgPtr->InterruptEnableTx);
  interrupts |= CAN_RA_INTERRUPT_MASK_MULTIBIT_ERROR;
  
  Can_RaSetInterruptEnable(baseAddress, channelNumber, interrupts);
  
  /* Set interrupt enable according to mode. */  
  /* - TX, bus off and uncorrected bit error (multiple bit error) are always active. */
  interrupts =   CAN_RA_INTERRUPT_MASK_BUSOFF
               | CAN_RA_INTERRUPT_MASK_TX_EVENT
               | CAN_RA_INTERRUPT_MASK_TX_CANCEL
               | CAN_RA_INTERRUPT_MASK_MULTIBIT_ERROR;
  /* - RX is active if mode is STARTED and RX interrupt is configured. */
  interrupts |= (
                   CAN_RA_INTERRUPT_MASK_RX_DEDICATED
                 | CAN_RA_INTERRUPT_MASK_RX_FIFO1
                 | CAN_RA_INTERRUPT_MASK_RX_FIFO0
                 | CAN_RA_INTERRUPT_MASK_RX_MSG_LOST
                ) * ((uint32)TRUE - (uint32)SleepMode) * (uint32)(ControllerCfgPtr->InterruptEnableRx);
  /* - RX is active if mode is SLEEP and wake up is configured. */
  interrupts |= (
                   CAN_RA_INTERRUPT_MASK_RX_DEDICATED
                 | CAN_RA_INTERRUPT_MASK_RX_FIFO1
                 | CAN_RA_INTERRUPT_MASK_RX_FIFO0
                ) * (uint32)(SleepMode) * (uint32)(ControllerCfgPtr->InterruptEnableWakeup);
  
  /* Zeros are allocated to INT0 (active) ones are allocated to INT1 (deactivated). */
  Can_RaSetInterruptLine(baseAddress, channelNumber, ~interrupts);
  
  /* Check for CAN FD mode is enabled. */
  if (FALSE == BaudratePtr->FdEnabled)
  {
      /* Start the hardware in classic CAN normal mode. */
      Can_RaSetNormalMode(baseAddress, channelNumber, SleepMode);
  }
  else
  {
      /* Start the hardware in FD CAN normal mode. */
      Can_RaSetNormalFdMode(baseAddress, channelNumber, SleepMode, BaudratePtr->FdTxBitRateSwitch);
  }
  /* Poll for mode change before time out. */
  validStartTime = Can_OsGetCounterValue(&startTime, CAN_ID_SETCTRLMODE);
  /* For the loop an invalid start time is no problem. An invalid start time
   * may lead to a very long timeout time, nothing else. To prevent the a long
   * loop the loop ends directly and will be continued by the
   * Can_MainFunction_Mode function call. */
  do
  {
    modeChanged = Can_ModeHandleStartSleep(ControllerCfgPtr, ControllerStateDataPtr);
    timedOut = Can_OsCheckTimeout(startTime, CAN_TIMEOUT_DURATION, CAN_ID_SETCTRLMODE);
  } while ((FALSE == timedOut) && (FALSE == modeChanged) && (E_OK == validStartTime));
}

/** \brief Can_ModeStop
 
 **
 ** Forces the controller to stop mode. All ongoing operations are stopped.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_ModeStop
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Disable all IRQs. */
  Can_RaSetInterruptEnable(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber, 0u);
  /* Disable HW. */
  Can_RaSetInitMode(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
}

/** \brief Can_ModeReset
 
 **
 ** Forces the controller to reset mode. 
 ** Return the register used by the specified controller to default.
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_ModeReset
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32 baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   bufferIndex;
  
  /* Tx Event FIFO Configuration */
  Can_RaClearEventFifoCfg(baseAddress, channelNumber, 0u);
  /* Tx Buffer Configuration */
  Can_RaClearTxBufferCfg(baseAddress, channelNumber, 0u);
  /* Tx Buffer Element Size Configuration */
  Can_RaSetTxElementSize(baseAddress, channelNumber, 0u);
  /* Tx Buffer Cancellation Finished Interrupt Enable */
  Can_RaSetTxCancellationInterruptEnable(baseAddress, channelNumber, 0u);
  /* Tx Buffer Transmission Interrupt Enable */
  Can_RaSetTxTransmissionInterruptEnable(baseAddress, channelNumber, 0u);
  /* Tx Event FIFO Acknowledge */
  Can_RaSetEventFifoAck(baseAddress, channelNumber, 0u);
  
  /* Global Filter Configuration */
  Can_RaSetGlobalFilter(baseAddress, channelNumber, 0u);
  /* Rx Buffer/FIFO Element Size Configuration */
  Can_RaSetRxElementSize(baseAddress, channelNumber, 0u, 0u, 0u);
  /* Rx Buffer Configuration */
  Can_RaSetRxBufferCfg(baseAddress, channelNumber, 0u);
  /* Rx FIFO 0/1 Configuration */
  Can_RaClearRxFifoCfg(baseAddress, channelNumber, CAN_RA_RX_KIND_FIFO0, 0u);
  Can_RaClearRxFifoCfg(baseAddress, channelNumber, CAN_RA_RX_KIND_FIFO1, 0u);
  /* Extended ID Filter Configuration, Extended ID AND Mask */
  Can_RaSetExtendedFilter(baseAddress, channelNumber, 0u, 0u);
  /* Standard ID Filter Configuration */
  Can_RaSetStandardFilter(baseAddress, channelNumber, 0u, 0u);
  /* Rx FIFO 0/1 Acknowledge */
  Can_RaSetRxFifoAck(baseAddress, channelNumber, CAN_RA_RX_KIND_FIFO0, 0u);
  Can_RaSetRxFifoAck(baseAddress, channelNumber, CAN_RA_RX_KIND_FIFO1, 0u);
  
  for (bufferIndex = 0u; ControllerCfgPtr->RxBuffers.ElementCount > bufferIndex; bufferIndex++)
  {
    /* New Data 1/2 */
    Can_RaClearNewDataFlag(baseAddress, channelNumber, bufferIndex);
  }
  
  /* Nominal Bit Timing */
  Can_RaSetNominalBitTiming(baseAddress,
                            channelNumber,
                            CAN_RA_NBTP_NBRP_INIT,
                            CAN_RA_NBTP_NTSEG1_INIT,
                            CAN_RA_NBTP_NTSEG2_INIT,
                            CAN_RA_NBTP_NSJW_INIT);
  /* Transmitter delay compensation */
  Can_RaSetTransmitterDelayCompensationOffset(baseAddress, channelNumber, 0u);
  /* Data Bit Timing */
  Can_RaSetDataBitTiming(baseAddress,
                         channelNumber,
                         CAN_RA_DBTP_DBRP_INIT,
                         CAN_RA_DBTP_DTSEG1_INIT,
                         CAN_RA_DBTP_DTSEG2_INIT,
                         CAN_RA_DBTP_DSJW_INIT,
                         CAN_RA_DBTP_TDC_INIT);
  /* RAM watchdog */
  Can_RaSetRamWdg(baseAddress, channelNumber, 0u);
  /* Timeout Counter Configuration */
  Can_RaSetTimeoutCounter(baseAddress, channelNumber, CAN_RA_TOCC_INIT);
  /* Timestamp Configuration */
  Can_RaSetTimestampCounter(baseAddress, channelNumber, 0u);
  /* Interrupt Register */
  Can_RaClearInterruptFlag(baseAddress, channelNumber, CAN_RA_INTERRUPT_MASK_ALL);
  /* Interrupt Line Select */
  Can_RaSetInterruptLine(baseAddress, channelNumber, 0u);
  /* Interrupt Line Enable */
  Can_RaSetInterruptLineEnable(baseAddress, channelNumber, 0u);
  
  /* Disable RxFIFO top pointer */
  Can_RaSetRxFifoTopPointer(baseAddress, channelNumber, CAN_RA_RX_KIND_FIFO0, FALSE);
  Can_RaSetRxFifoTopPointer(baseAddress, channelNumber, CAN_RA_RX_KIND_FIFO1, FALSE);
  
  /* CC Control Register */
  Can_RaClearMode(baseAddress, channelNumber);
  
  /* Disable ECC control. */
  if (TRUE == Can_RaGetEccControl(baseAddress))
  {
    Can_RaSetEccControl(baseAddress, FALSE);
  }

}

/** \brief Can_ModeCheckBusOff
 **
 ** Check the controller for the occurrence of a bus off event.
 **
 ** \return   Returns a bus off event.
 **           TRUE:  bus-off event detected.
 **           FALSE: bus-off event no detected.
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ModeCheckBusOff
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  /* Check occurence of a bus off. */
  return Can_RaGetBusOffStatus(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
}

/** \brief Can_ModeCheckUncorrectableBitError
 **
 ** Check the controller for the occurrence of an uncorrectable bit error.
 **
 ** \return   Returns an error indication that an uncorrectable bit error in Message
 **           RAM is detected.
 **           TRUE: uncorrectable bit error is detected
 **           FALSE: no error is detected
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(boolean, AUTOMATIC) Can_ModeCheckUncorrectableBitError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32  interrupts;
  boolean retVal = FALSE;

  /* Check occurrence of an uncorrectable bit error. */
  interrupts = Can_RaGetInterruptFlags(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
  if (0u != (interrupts & CAN_RA_INTERRUPT_MASK_MULTIBIT_ERROR))
  {
    /* Uncorrectable bit error is occurred. Clear interrupt flag. */
    Can_RaClearInterruptFlag(ControllerCfgPtr->RegisterBaseAddress,
                             ControllerCfgPtr->ChannelNumber,
                             CAN_RA_INTERRUPT_MASK_MULTIBIT_ERROR);
    /* Set return value to report the error. */
    retVal = TRUE;
  }
  return retVal;
}

/** \brief Can_ModeClearBusOffInterrupt
 **
 ** Clears the controller BusOff interrupt flag.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_ModeClearBusOffInterrupt
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  Can_RaClearInterruptFlag(ControllerCfgPtr->RegisterBaseAddress,
                           ControllerCfgPtr->ChannelNumber,
                           CAN_RA_INTERRUPT_MASK_BUSOFF);
}

/** \brief Can_ModeEnableEccControl
 **
 ** Enable ECC control.
 ** In order to activate ECC on a per instance basis, if ECC control is already enabled, nothing is done. 
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_ModeEnableEccControl
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  if (FALSE == Can_RaGetEccControl(ControllerCfgPtr->RegisterBaseAddress))
  {
    Can_RaSetEccControl(ControllerCfgPtr->RegisterBaseAddress, TRUE);
  }
}

/** \brief Can_ModeSetRxFifoTopPointer
 **
 ** Set Rx FIFO Top Pointer.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1
 ** \param [in] Value   Set Enable/Disable in Rx FIFO Top Pointer
 **                     TRUE: Enable
 **                     FALSE: Disable
 **
 */
FUNC(void, AUTOMATIC) Can_ModeSetRxFifoTopPointer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) FifoIndex,
  VAR(boolean, AUTOMATIC) Value
)
{
  Can_RaSetRxFifoTopPointer(ControllerCfgPtr->RegisterBaseAddress, 
                            ControllerCfgPtr->ChannelNumber,
                            FifoIndex,
                            (uint32)Value);
}

/** \brief Can_ModeSetInterruptProtocolError
 **
 ** Sets the error frame detection interrupt of the IE and ILE registers of 
 ** the specified CAN Controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] InterruptEnable    Specify enable/disable of error frame detection interrup
 **                                TRUE : Enable interrupt protocol error
 **                                FALSE: Disable interrupt protocol error
 **
 */
FUNC(void, AUTOMATIC) Can_ModeSetInterruptProtocolError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(boolean, AUTOMATIC)InterruptEnable
)
{
  uint32 baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  uint32 interrupts;

  interrupts = Can_RaGetInterruptEnable(baseAddress, channelNumber);
  if (TRUE == InterruptEnable)
  {
    interrupts |= CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR * (uint32)(ControllerCfgPtr->InterruptEnableRx);
  }
  else
  {
    interrupts &= ~(CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR * (uint32)(ControllerCfgPtr->InterruptEnableRx));
  }
  Can_RaSetInterruptEnable(baseAddress, channelNumber, interrupts);
  
  interrupts = ~Can_RaGetInterruptLine(baseAddress, channelNumber);
  if (TRUE == InterruptEnable)
  {
    interrupts |= CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR * (uint32)(ControllerCfgPtr->InterruptEnableRx);
  }
  else
  {
    interrupts &= ~(CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR * (uint32)(ControllerCfgPtr->InterruptEnableRx));
  }
  Can_RaSetInterruptLine(baseAddress, channelNumber, ~interrupts);
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
