/** \brief Can_RxHandler.c
 **
 ** The Rx handler is responsible for setting up and maintaining message
 ** reception including notification.
 **
  * The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can_RxHandler.h>
#include <Can_Callout.h>
#include <Can_RegisterAbstraction.h>

/*==================[macros]================================================*/

#define CAN_RX_BUFFER_KIND_DEDICATED  255u

#define CAN_RX_MASK_XTD        0x40000000u
#define CAN_RX_MASK_FDF              0x20u
#define CAN_RX_MASK_DLC              0x0Fu
#define CAN_RX_MASK_SFEC       0x38000000u
#define CAN_RX_MASK_EFEC       0xE0000000u
#define CAN_RX_MASK_FIDX             0x7Fu

#define CAN_RX_SFEC_FIFO0      0x08000000u
#define CAN_RX_SFEC_FIFO1      0x10000000u
#define CAN_RX_SFT_CLASSIC     0x80000000u
#define CAN_RX_EFEC_FIFO0      0x20000000u
#define CAN_RX_EFEC_FIFO1      0x40000000u
#define CAN_RX_EFT_CLASSIC     0x80000000u

#define CAN_RX_MAX_MESSAGE_LENGTH      16u

/* Deviation from MISRA-C:2004 Rule 19.7: A function could probably be used instead of this function-like macro,
   MISRA-C:2012 Dir-4.9.
   Justification: Allow compiler optimization. */
/* PRQA S 3453 1 */
#define CAN_RX_GET_BYTE_MESSAGE(Data, Element) ((uint8)((Data)>>((Element)*8u)))

/*==================[type definitions]======================================*/

/** \brief typedef Can_RaGetRxFifoTopData function pointer */
typedef P2FUNC(uint32, TYPEDEF, Can_RaGetRxFifoTopDataPtr)
        (VAR(uint32, AUTOMATIC) BaseAddress, VAR(uint8, AUTOMATIC) ChannelNum);
        
/*==================[internal function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_RxInit_Buffer
 **
 ** Initializes the dedicated rx buffer of a CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] NumOfStdFiltersPtr   Pointer to variable where current amount of
 **                                     configured standard filters located. This value
 **                                     is used to have the right position to store the
 **                                     next standard filter and will be incremented to
 **                                     the new amount of configured standard filters.
 ** \param [inout] NumOfExtFiltersPtr   Pointer to variable where current amount of
 **                                     configured extended filters located. This value
 **                                     is used to have the right position to store the
 **                                     next extended filter and will be incremented to
 **                                     the new amount of configured extended filters.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxInit_Buffer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfStdFiltersPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfExtFiltersPtr
);

/** \brief Can_RxInit_Fifo
 **
 ** Initializes the rx FIFO buffer of a CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] NumOfStdFiltersPtr   Pointer to variable where current amount of
 **                                     configured standard filters located. This value
 **                                     is used to have the right position to store the
 **                                     next standard filter and will be incremented to
 **                                     the new amount of configured standard filters.
 ** \param [inout] NumOfExtFiltersPtr   Pointer to variable where current amount of
 **                                     configured extended filters located. This value
 **                                     is used to have the right position to store the
 **                                     next extended filter and will be incremented to
 **                                     the new amount of configured extended filters.
 ** \param [in] FifoIndex   FIFO index to select and use the correct FIFO settings.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxInit_Fifo
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfStdFiltersPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfExtFiltersPtr,
  VAR(uint8, AUTOMATIC) FifoIndex
);

/** \brief Can_RxSendIndication
 **
 ** Translates the buffer index to an address in message RAM, extracts
 ** the data and passes it to the RX indication callout.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] BufferKind   Kind of the buffer that contains the message.
 **                          Possible values:
 **                          CAN_RA_RX_KIND_FIFO0,
 **                          CAN_RA_RX_KIND_FIFO1,
 **                          CAN_RX_BUFFER_KIND_DEDICATED.
 ** \param [in] BufferIndex   Physical buffer index in scope of BufferKind.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxSendIndication
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(uint8, AUTOMATIC) BufferKind,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) BufferIndex,
  VAR(uint8, AUTOMATIC) ApiId
);

/** \brief Can_RxGetMessageFromFIFO
 **
 ** Extract messages from Rx FIFO area in message RAM.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] BufferKind   Kind of the Rx FIFO that contains the message.
 ** \param [out] FilterIndexPtr   Index of the Rx FIFO that stores the  message.
 ** \param [out] MessageIdPtr   Can Id of the message.
 ** \param [out] MessageLengthPtr   Length (in bytes) of the message (DLC).
 ** \param [out] MessageCopy   Pointer to the message payload (SDU) in message RAM.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxGetMessageFromFIFO
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferKind,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) FilterIndexPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) MessageIdPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) MessageLengthPtr,
  VAR(uint32, AUTOMATIC) MessageCopy[]
);

/** \brief Can_RxGetMessageFromDedicated
 **
 ** Extract messages from Rx dedicated buffer area in message RAM.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] BufferIndex   Physical buffer index..
 ** \param [out] FilterIndexPtr   Index of the Rx buffer that stores the  message.
 ** \param [out] MessageIdPtr   Can Id of the message.
 ** \param [out] MessageLengthPtr   Length (in bytes) of the message (DLC).
 ** \param [out] MessageCopy   Pointer to the message payload (SDU) in message RAM.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxGetMessageFromDedicated
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) BufferIndex,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) FilterIndexPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) MessageIdPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) MessageLengthPtr,
  VAR(uint32, AUTOMATIC) MessageCopy[]
);

/** \brief Can_RxCheckPayloadLengthError
 **
 ** Check Payload length error on Pretended Networking Mode.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to the controller state data.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxCheckPayloadLengthError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal constants]====================================*/

/*==================[internal data]=========================================*/
#define CAN_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** Flag indicating whether Ack notification is required for CanController */
static VAR(boolean, AUTOMATIC) Can_RxFifoIsNeedAck = FALSE;

#define CAN_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[external function definitions]=========================*/

  /* Deviation from MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics:,
     MISRA-C:2012 Rule-11.3
     Casting to different object pointer type.
     Justification: The elements in message RAM have to be 32-bit aligned as a hardware restriction
     of the CAN FD anyway. Hence byte-wise access to an address that is not 
     32-bit aligned would not avoid a fault. Therefore the type can be converted without additional risk. */
  /* PRQA S 310 EOF */
  
#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_RxGetNewMessageStatus
 **
 ** Checks if there is a new message pending.
 **
 ** \return   TRUE: There is at least one received message.
 **           FALSE: There is no received message.
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] ControllerStateDataPtr   Pointer to the controller state data.
 **
 */
FUNC(boolean, AUTOMATIC) Can_RxGetNewMessageStatus
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  boolean result = FALSE;
  uint32 interrupts = Can_RaGetInterruptFlags(ControllerCfgPtr->RegisterBaseAddress, ControllerCfgPtr->ChannelNumber);
  uint32 mask = CAN_RA_INTERRUPT_MASK_RX_DEDICATED | CAN_RA_INTERRUPT_MASK_RX_FIFO0 | CAN_RA_INTERRUPT_MASK_RX_FIFO1;

  if (TRUE == ControllerStateDataPtr->IcomState.IsPretended)
  {
    /* Deviation from MISRA-C:2004 Rule 21.1 This operation is redundant. The value of the result is always 'value', 
       MISRA-C:2012 Rule-2.2
       Justification: The value is needed to be updated at each condition. */
    /* PRQA S 2984 1 */
    mask |= CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR;
  }
  
  if ( 0u != (interrupts & mask) )
  {
    /* Some RX interrupt pending flag is set. */
    result = TRUE;
  }
  
  return result;
}

/** \brief Can_RxHandleReceived
 **
 ** Works through all items in the RX FIFOs and dedicated message buffers. The
 ** function is intended to be called on RX IRQ or Can_MainFunction_Read.
 ** 
 ** The function can handle the situation if there is no new message.
 ** Each RX event is processed so that the RX buffer is freed (ready for next
 ** message) and the RX confirmation notification is sent.
 **
 ** \return   E_OK: No error was detected,
 **           E_NOT_OK: Message lost error was detected. (Reception was still
 **           conducted.)
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to the controller state data.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_RxHandleReceived
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  uint32         baseAddress = ControllerCfgPtr->RegisterBaseAddress;
  uint8          channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8          bufferIndex;
  uint8          idx;
  uint8          fifoIndex;
  Std_ReturnType result = E_OK;
  
  /* Clearing of IRQ flags is done before new message clear and FIFO-ACK, 
     because the flags are set on event-edges. Therefore events that appear 
     after clearing the IRQ-flags but before read-out will will not get lost. */
  Can_RaClearInterruptFlag(baseAddress,
                           channelNumber,
                             CAN_RA_INTERRUPT_MASK_RX_DEDICATED
                           | CAN_RA_INTERRUPT_MASK_RX_FIFO0
                           | CAN_RA_INTERRUPT_MASK_RX_FIFO1);
  
  if (TRUE == ControllerStateDataPtr->IcomState.IsPretended)
  {
    Can_RxCheckPayloadLengthError(ControllerCfgPtr, ControllerStateDataPtr);
  }
  
  /* Handle dedicated message first, because they have a higher risk of overflow than the FIFOs. */
  bufferIndex = Can_RaGetNewDataIndex(baseAddress, channelNumber);
  /* Loop through all pending dedicated messages. 
     Maximum loop count is "each buffer once", to avoid deadlock. */
  for (idx = CAN_CONTROLLER_RX_BUFFER_MAX + 1u; (0u < idx) && (CAN_CONTROLLER_RX_BUFFER_MAX >= bufferIndex); idx--)
  {
    /* Send the RX indication. */
    Can_RxSendIndication(ControllerCfgPtr, ControllerStateDataPtr, CAN_RX_BUFFER_KIND_DEDICATED, bufferIndex, ApiId);
    
    /* Clear new data flag, i.e. allow the dedicated buffer to receive a new message. */
    Can_RaClearNewDataFlag(baseAddress, channelNumber, bufferIndex);
    /* Find next pending message. */
    bufferIndex = Can_RaGetNewDataIndex(baseAddress, channelNumber);
  }
  
  /* Handle the FIFOs next */
  for (fifoIndex = 0u; 2u > fifoIndex; fifoIndex++)
  {
    /* Loop through all pending messages of the FIFO. 
       Maximum loop count is "each buffer once", to avoid deadlock. */
    for (idx = CAN_CONTROLLER_RX_BUFFER_MAX + 1u;
         (0u < Can_RaGetRxFifoFillLevel(baseAddress, channelNumber, fifoIndex)) && (0u < idx);
         idx--)
    {
      /* Get Index in FIFO that contains the oldest of the new messages. */
      bufferIndex = Can_RaGetRxFifoGetIndex(baseAddress, channelNumber, fifoIndex);

      /* Send the RX indication. */
      Can_RxSendIndication(ControllerCfgPtr, ControllerStateDataPtr, fifoIndex, bufferIndex, ApiId);
      
      /* If the DLC of the received data is smaller than the element size of the Rx FIFO, it is necessary to notify 
           the CanController of Ack. */
      if (TRUE == Can_RxFifoIsNeedAck)
      {
        /* Release FIFO entry so that the HW can use it for further incoming messages. */
        Can_RaSetRxFifoAck(baseAddress, channelNumber, fifoIndex, bufferIndex);
      }
    }
  }

  /* Check RX message lost interrupt. */
  if (0u != (Can_RaGetInterruptFlags(baseAddress, channelNumber) & CAN_RA_INTERRUPT_MASK_RX_MSG_LOST))
  {
    /* RX message lost was detected. */
    Can_RaClearInterruptFlag(baseAddress, channelNumber, CAN_RA_INTERRUPT_MASK_RX_MSG_LOST);
    result = E_NOT_OK;
  }
  
  return result;
}

/** \brief Can_RxInit
 **
 ** Initializes the RX path of one CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_RxInit
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32  baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8   channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   numberOfStandardFilters = 0u;
  uint8   numberOfExtendedFilters = 0u;
  
  /* Reject remote frames and all non-matching messages. */
  Can_RaSetGlobalFilter(baseAddress, channelNumber, CAN_RA_GLOBAL_FILTER_REJECT_ALL);

  /* Set sizes of RX buffer and FIFOs. */
  Can_RaSetRxElementSize
  (
    baseAddress,
    channelNumber,
    (uint8)ControllerCfgPtr->RxFifo0.ElementSize, 
    (uint8)ControllerCfgPtr->RxFifo1.ElementSize, 
    (uint8)ControllerCfgPtr->RxBuffers.ElementSize
  );
  
  /* Configure dedicated RX buffers */
  Can_RxInit_Buffer(ControllerCfgPtr, &numberOfStandardFilters, &numberOfExtendedFilters);
  /* Configure RX FIFO0 */
  Can_RxInit_Fifo(ControllerCfgPtr, &numberOfStandardFilters, &numberOfExtendedFilters, CAN_RA_RX_KIND_FIFO0);
  /* Configure RX FIFO1 */
  Can_RxInit_Fifo(ControllerCfgPtr, &numberOfStandardFilters, &numberOfExtendedFilters, CAN_RA_RX_KIND_FIFO1);
  
  /* Set filter list length. */
  Can_RaSetExtendedFilter(baseAddress,
                          channelNumber,
                          ControllerCfgPtr->FiltersExtendedAddressOffset,
                          numberOfExtendedFilters);
  Can_RaSetStandardFilter(baseAddress,
                          channelNumber,
                          ControllerCfgPtr->FiltersStandardAddressOffset,
                          numberOfStandardFilters);

}

/** \brief Can_RxSetup
 **
 ** Initializes the RX function of one CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_RxSetup
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
)
{
  uint32  baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8   channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   bufferIndex;
  
  /* Initialize dedicated buffers */
  for (bufferIndex = 0u; ControllerCfgPtr->RxBuffers.ElementCount > bufferIndex; bufferIndex++)
  {
    Can_RaClearNewDataFlag(baseAddress, channelNumber, bufferIndex);
  }
  
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_RxInit_Buffer
 **
 ** Initializes the dedicated rx buffer of a CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] NumOfStdFiltersPtr   Pointer to variable where current amount of
 **                                     configured standard filters located. This value
 **                                     is used to have the right position to store the
 **                                     next standard filter and will be incremented to
 **                                     the new amount of configured standard filters.
 ** \param [inout] NumOfExtFiltersPtr   Pointer to variable where current amount of
 **                                     configured extended filters located. This value
 **                                     is used to have the right position to store the
 **                                     next extended filter and will be incremented to
 **                                     the new amount of configured extended filters.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxInit_Buffer
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfStdFiltersPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfExtFiltersPtr
)
{
  uint32  baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8   channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   numberOfStandardFilters = *NumOfStdFiltersPtr;
  uint8   numberOfExtendedFilters = *NumOfExtFiltersPtr;
  uint8   bufferIndex;

  P2CONST(uint32, AUTOMATIC, AUTOMATIC) filtersCfgPtr = 
                                (P2CONST(uint32, AUTOMATIC, AUTOMATIC))ControllerCfgPtr->RxBuffersFiltersPtr;
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 2 */
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) standardFilterPtr = 
                                (P2VAR(uint32, AUTOMATIC, AUTOMATIC))(&(ControllerCfgPtr->MessageRamBasePtr
                                 [ControllerCfgPtr->FiltersStandardAddressOffset]));
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 2 */
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) extendedFilterPtr = 
                                (P2VAR(uint32, AUTOMATIC, AUTOMATIC))(&(ControllerCfgPtr->MessageRamBasePtr
                                 [ControllerCfgPtr->FiltersExtendedAddressOffset]));

  /* Set dedicated RX buffer configuration. */
  Can_RaSetRxBufferCfg(baseAddress, channelNumber, ControllerCfgPtr->RxBuffers.StartAddress);

  /* Initialize dedicated buffers and their filters. */
  for (bufferIndex = 0u; ControllerCfgPtr->RxBuffers.ElementCount > bufferIndex; bufferIndex++)
  {
    Can_RaClearNewDataFlag(baseAddress, channelNumber, bufferIndex);
    if (0u == (filtersCfgPtr[bufferIndex] & CAN_CONTROLLER_XTD_ID_FLAG))
    {
      /* Add a standard message filter. */

      /* Standard filter element layout (for dedicated buffers):
         word 0, bits  0.. 5: index of RX buffer to store the message
         word 0, bits  6.. 8: reserved
         word 0, bits  9..10: "00" (Store message into dedicated Rx buffer)
         word 0, bits 11..15: reserved
         word 0, bits 16..26: message ID
         word 0, bits 27..29: SFEC="111" (Store into dedicated Rx buffer)
         word 0, bits 30..31: ignored
      */
      standardFilterPtr[numberOfStandardFilters] = CAN_RX_MASK_SFEC | (filtersCfgPtr[bufferIndex] << 16u) | bufferIndex;
      numberOfStandardFilters++;
    }
    else
    {
      /* Add an extended message filter. */

      /* Extended filter element layout (for dedicated buffers):
         word 0, bits  0..28: message ID
         word 0, bits 29..31: EFEC="111" (Store into dedicated Rx buffer)
         word 1, bits  0.. 5: index of RX buffer to store the message
         word 1, bits  6.. 8: reserved
         word 1, bits  9..10: "00" (Store message into dedicated Rx buffer)
         word 1, bits 11..28: not specified (unused anyway)
         word 1, bit      29: reserved
         word 1, bits 30..31: ignored
      */
      extendedFilterPtr[numberOfExtendedFilters * 2u] = CAN_RX_MASK_EFEC | filtersCfgPtr[bufferIndex];
      extendedFilterPtr[(numberOfExtendedFilters * 2u) + 1u] = bufferIndex;
      numberOfExtendedFilters++;
    }
  }

  /* Set number of filters in output parameters. */
  *NumOfStdFiltersPtr = numberOfStandardFilters;
  *NumOfExtFiltersPtr = numberOfExtendedFilters;

}

/** \brief Can_RxInit_Fifo
 **
 ** Initializes the rx FIFO buffer of a CAN controller.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] NumOfStdFiltersPtr   Pointer to variable where current amount of
 **                                     configured standard filters located. This value
 **                                     is used to have the right position to store the
 **                                     next standard filter and will be incremented to
 **                                     the new amount of configured standard filters.
 ** \param [inout] NumOfExtFiltersPtr   Pointer to variable where current amount of
 **                                     configured extended filters located. This value
 **                                     is used to have the right position to store the
 **                                     next extended filter and will be incremented to
 **                                     the new amount of configured extended filters.
 ** \param [in] FifoIndex   FIFO index to select and use the correct FIFO settings.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxInit_Fifo
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfStdFiltersPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) NumOfExtFiltersPtr,
  VAR(uint8, AUTOMATIC) FifoIndex
)
{
  uint32  baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8   channelNumber = ControllerCfgPtr->ChannelNumber;
  uint8   numberOfStandardFilters = *NumOfStdFiltersPtr;
  uint8   numberOfExtendedFilters = *NumOfExtFiltersPtr;
  uint8   bufferIndex;

  uint32  efec;
  uint32  sfec;
  P2CONST(Can_ControllerBufferCfgType, AUTOMATIC, AUTOMATIC) rxFifoPtr;
  P2CONST(Can_ControllerFilterType, AUTOMATIC, AUTOMATIC) rxFifoFilterPtr;
  uint32 filterElementCount;
  
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 2 */
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) standardFilterPtr = 
                                (P2VAR(uint32, AUTOMATIC, AUTOMATIC))(&(ControllerCfgPtr->MessageRamBasePtr
                                 [ControllerCfgPtr->FiltersStandardAddressOffset]));
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 2 */
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) extendedFilterPtr = 
                                (P2VAR(uint32, AUTOMATIC, AUTOMATIC))(&(ControllerCfgPtr->MessageRamBasePtr
                                 [ControllerCfgPtr->FiltersExtendedAddressOffset]));

  /* Check for FIFO0 or FIFO1 */
  if (CAN_RA_RX_KIND_FIFO0 == FifoIndex)
  {
    /* Set common variables to FIFO0 settings. */
    rxFifoPtr = &ControllerCfgPtr->RxFifo0;
    efec      = CAN_RX_EFEC_FIFO0;
    sfec      = CAN_RX_SFEC_FIFO0;
    rxFifoFilterPtr = ControllerCfgPtr->RxFifo0FiltersPtr;
    filterElementCount = ControllerCfgPtr->RxFifo0FilterElementCount;
  }
  else
  {
    /* Set common variables to FIFO1 settings. */
    rxFifoPtr = &ControllerCfgPtr->RxFifo1;
    efec      = CAN_RX_EFEC_FIFO1;
    sfec      = CAN_RX_SFEC_FIFO1;
    rxFifoFilterPtr = ControllerCfgPtr->RxFifo1FiltersPtr;
    filterElementCount = ControllerCfgPtr->RxFifo1FilterElementCount;
  }

  /* Configure FIFO */
  Can_RaSetRxFifoCfg(baseAddress, channelNumber, FifoIndex, rxFifoPtr->ElementCount, rxFifoPtr->StartAddress);

  for (bufferIndex = 0u; filterElementCount > bufferIndex; bufferIndex++)
  {
    /* Add FIFO filter element. */
    if (0u == (rxFifoFilterPtr[bufferIndex].FilterIdValue & CAN_CONTROLLER_XTD_ID_FLAG))
    {
      /* Add a standard message filter. */
      uint32 messageFilter;

      /* Standard filter element layout (for FIFO):
         word 0, bits  0..10: mask
         word 0, bits 11..15: reserved
         word 0, bits 16..26: message ID
         word 0, bits 27..29: SFEC="001" (Store in Rx FIFO 0) / "010" (Store in Rx FIFO 1)
         word 0, bits 30..31: SFT="10" (classic filter, i.e. ID+mask)
      */
      messageFilter = rxFifoFilterPtr[bufferIndex].FilterMaskValue & CAN_CONTROLLER_MASK_11BIT;
      messageFilter |= (rxFifoFilterPtr[bufferIndex].FilterIdValue & CAN_CONTROLLER_MASK_11BIT) << 16u;
      messageFilter |= CAN_RX_SFT_CLASSIC | sfec;
      standardFilterPtr[numberOfStandardFilters] = messageFilter;
      numberOfStandardFilters++;
    }
    else
    {
      /* Add an extended message filter. */

      /* Extended filter element layout (for FIFO):
         word 0, bits  0..28: message ID
         word 0, bits 29..31: EFEC="001" (Store in Rx FIFO 0) / "010" (Store in Rx FIFO 1)
         word 1, bits  0..28: mask
         word 1, bit      29: reserved
         word 1, bits 30..31: EFT="10" (classic filter, i.e. ID+mask)
      */
      extendedFilterPtr[numberOfExtendedFilters * 2u] = efec
                                           | (rxFifoFilterPtr[bufferIndex].FilterIdValue & CAN_CONTROLLER_MASK_29BIT);
      extendedFilterPtr[(numberOfExtendedFilters * 2u) + 1u] = CAN_RX_EFT_CLASSIC 
                                           | (rxFifoFilterPtr[bufferIndex].FilterMaskValue & CAN_CONTROLLER_MASK_29BIT);
      numberOfExtendedFilters++;
    }
  }

  /* Set number of filters in output parameters. */
  *NumOfStdFiltersPtr = numberOfStandardFilters;
  *NumOfExtFiltersPtr = numberOfExtendedFilters;
}

/** \brief Can_RxSendIndication
 **
 ** Translates the buffer index to an address in message RAM, extracts
 ** the data and passes it to the RX indication callout.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStatePtr   Pointer to the controller state data.
 ** \param [in] BufferKind   Kind of the buffer that contains the message.
 ** \param [in] BufferIndex   Physical buffer index in scope of BufferKind.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxSendIndication
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStatePtr,
  VAR(uint8, AUTOMATIC) BufferKind,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) BufferIndex,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  uint32 messageCopy[CAN_RX_MAX_MESSAGE_LENGTH];
  uint32 messageId = 0u;
  uint8 messageLength = 0u;
  uint8 filterIndex = 0u;
  
  /* Set MessageRamPtr to beginning (index 0) of the given buffer kind */
  if ((CAN_RA_RX_KIND_FIFO0 == BufferKind) || (CAN_RA_RX_KIND_FIFO1== BufferKind))
  {
     Can_RxGetMessageFromFIFO(ControllerCfgPtr,
                              BufferKind,
                              &filterIndex,
                              &messageId,
                              &messageLength,
                              messageCopy);
  }
  else 
  {
     /* CAN_RX_BUFFER_KIND_DEDICATED */
     Can_RxGetMessageFromDedicated(ControllerCfgPtr,
                                   BufferIndex,
                                   &filterIndex,
                                   &messageId,
                                   &messageLength,
                                   messageCopy);
  }

  /* Forward to callout. */
  Can_CanIfRxIndication(ControllerCfgPtr,
                        ControllerStatePtr,
                        filterIndex,
                        messageId,
                        messageLength,
                        (P2CONST(uint8, AUTOMATIC, AUTOMATIC))messageCopy,
                        ApiId);
}

/** \brief Can_RxGetMessageFromFIFO
 **
 ** Extract messages from Rx FIFO area in message RAM.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] BufferKind   Kind of the Rx FIFO that contains the message.
 ** \param [out] FilterIndexPtr   Index of the Rx FIFO that stores the  message.
 ** \param [out] MessageIdPtr   Can Id of the message.
 ** \param [out] MessageLengthPtr   Length (in bytes) of the message (DLC).
 ** \param [out] MessageCopy   Pointer to the message payload (SDU) in message RAM.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxGetMessageFromFIFO
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(uint8, AUTOMATIC) BufferKind,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) FilterIndexPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) MessageIdPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) MessageLengthPtr,
  VAR(uint32, AUTOMATIC) MessageCopy[]
)
{
  uint32 baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  Can_RaGetRxFifoTopDataPtr FuncPtr;
  uint8 elementSize;
  uint32 messageData;
  uint8 flags;
  uint8 maxLoopNum;
  uint8 i;

  if (CAN_RA_RX_KIND_FIFO0 == BufferKind)
  {
    FuncPtr = &Can_RaGetRxFifo0TopData;
    elementSize = Can_ControllerTranslateFieldSize(ControllerCfgPtr->RxFifo0.ElementSize);
  }
  else
  {
    FuncPtr = &Can_RaGetRxFifo1TopData;
    elementSize = Can_ControllerTranslateFieldSize(ControllerCfgPtr->RxFifo1.ElementSize);
  }

  /* RX Buffer and FIFO element layout:
     word 0, bits  0..28: ID   (MSB aligned CAN ID)
     word 0, bit      29: RTR  (Not used: Remote Transmission Request)
     word 0, bit      30: XTD  (eXTenDed identifier: 0 -> 11-bit, 1 -> 29-bit)
     word 0, bit      31: ESI  (Not used: Error State Indicator of transmitting node)
  */
  messageData = (*FuncPtr)(baseAddress, channelNumber);
  /* Translate ID from HW format to SW format. */
  if (0u == (messageData & CAN_RX_MASK_XTD))
  {
    /* 11-bit identifier: Mask ID and shift to LSB alignment, MSB is 0. [CAN416] */
    *MessageIdPtr = (messageData & CAN_CONTROLLER_MASK_29BIT) >> 18u;
  }
  else
  {
    /* 29-bit identifier: Mask ID and set MSB to 1. [CAN416] */
    *MessageIdPtr = (messageData & CAN_CONTROLLER_MASK_29BIT) | CAN_CONTROLLER_XTD_ID_FLAG;
    /* Set flag for extended message in filter index. */
    *FilterIndexPtr = CAN_CONTROLLER_MASK_XTD_FIDX;
  }

  /* RX Buffer and FIFO element layout:
     word 1, bits  0..15: RXTS (not used: RX TimeStamp)
     word 1, bits 16..19: DLC  (Data Length Code)
     word 1, bit      20: BRS  (Bit Rate Switch)
     word 1, bit      21: FDF  (CAN FD Frame)
     word 1, bits 22..23: reserved
     word 1, bits 24..30: FIDX (Filter InDeX)
     word 1, bit      31: ANMF (Not used: Accepted Non-Matching Frame)
  */
  messageData = (*FuncPtr)(baseAddress, channelNumber);
  /* Check for FD Frame and set the FD flag in messageId. */
  flags = CAN_RX_GET_BYTE_MESSAGE(messageData, 2u);
  if (0u != (flags & CAN_RX_MASK_FDF))
  {
    *MessageIdPtr |= CAN_CONTROLLER_FD_ID_FLAG;
    /* Extract length and convert to DLC code to length value. */
    *MessageLengthPtr = Can_ControllerTranslateDlcToLength(flags & CAN_RX_MASK_DLC);
  }
  else
  {
    *MessageLengthPtr = flags & CAN_RX_MASK_DLC;
    /* In classic mode higher value than 8 are interpreted as DLC 8. */
    if (*MessageLengthPtr > 8u)
    {
      *MessageLengthPtr = 8u;
    }
  }
  
  /* If the DLC of the received data is smaller than the element size of the Rx FIFO, it is necessary to notify 
       the CanController of Ack. */
  if (elementSize > *MessageLengthPtr)
  {
     Can_RxFifoIsNeedAck = TRUE;
  }
  else
  {
     Can_RxFifoIsNeedAck = FALSE;
  }
  
  /* Get Filter Index */
  *FilterIndexPtr |= (CAN_RX_GET_BYTE_MESSAGE(messageData, 3u) & CAN_RX_MASK_FIDX);
  /* Calculate the number of loops for copy.
     If it is not divisible by 4 bytes, increase the loop number by 1.
     Ex. MessageLengthPtr=3(bytes)
         MessageLengthPtr/4(bytes) = 0 mod 3
         Therefore, increase maxLoopNum by 1.
  */
  maxLoopNum = *MessageLengthPtr >> 2u;
  if (0u != (*MessageLengthPtr & 0x03u))
  {
    maxLoopNum++;
  }

  /* Copy message. */
  for (i = 0u; i < maxLoopNum; i++)
  {
    messageData = (*FuncPtr)(baseAddress, channelNumber);
    MessageCopy[i] = messageData;
  }
}

/** \brief Can_RxGetMessageFromDedicated
 **
 ** Extract messages from Rx dedicated buffer area in message RAM.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [in] BufferIndex   Physical buffer index..
 ** \param [out] FilterIndexPtr   Index of the Rx buffer that stores the  message.
 ** \param [out] MessageIdPtr   Can Id of the message.
 ** \param [out] MessageLengthPtr   Length (in bytes) of the message (DLC).
 ** \param [out] MessageCopy   Pointer to the message payload (SDU) in message RAM.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxGetMessageFromDedicated
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) BufferIndex,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) FilterIndexPtr,
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) MessageIdPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) MessageLengthPtr,
  VAR(uint32, AUTOMATIC) MessageCopy[]
)
{
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) messageRamPtr = ControllerCfgPtr->MessageRamBasePtr;
  uint8 ramItemSize;
  uint8 flags;
  uint8 maxLoopNum;
  uint8 i;

  messageRamPtr = &(messageRamPtr[ControllerCfgPtr->RxBuffers.StartAddress]);
  /* Each message item has a header of 8 bytes followed by the message contents of BufferElementSize. */
  ramItemSize = 8u + Can_ControllerTranslateFieldSize(ControllerCfgPtr->RxBuffers.ElementSize);
  /* Set MessageRamPtr to the item indexed by BufferIndex. */
  messageRamPtr = &(messageRamPtr[BufferIndex * ramItemSize]);
  
  /* RX Buffer and FIFO element layout:
     word 0, bits  0..28: ID   (MSB aligned CAN ID)
     word 0, bit      29: RTR  (Not used: Remote Transmission Request)
     word 0, bit      30: XTD  (eXTenDed identifier: 0 -> 11-bit, 1 -> 29-bit)
     word 0, bit      31: ESI  (Not used: Error State Indicator of transmitting node)
     word 1, bits  0..15: RXTS (not used: RX TimeStamp)
     word 1, bits 16..19: DLC  (Data Length Code)
     word 1, bit      20: BRS  (Bit Rate Switch)
     word 1, bit      21: FDF  (CAN FD Frame)
     word 1, bits 22..23: reserved
     word 1, bits 24..30: FIDX (Filter InDeX)
     word 1, bit      31: ANMF (Not used: Accepted Non-Matching Frame)
     appending          : message body
  */
  
  /* Translate ID from HW format to SW format. */
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 3305 1 */
  *MessageIdPtr = *((P2CONST(uint32, AUTOMATIC, AUTOMATIC))messageRamPtr);
  if (0u == (*MessageIdPtr & CAN_RX_MASK_XTD))
  {
    /* 11-bit identifier: Mask ID and shift to LSB alignment, MSB is 0. [CAN416] */
    *MessageIdPtr = (*MessageIdPtr & CAN_CONTROLLER_MASK_29BIT) >> 18u;
  }
  else
  {
    /* 29-bit identifier: Mask ID and set MSB to 1. [CAN416] */
    *MessageIdPtr = (*MessageIdPtr & CAN_CONTROLLER_MASK_29BIT) | CAN_CONTROLLER_XTD_ID_FLAG;
    /* Set flag for extended message in filter index. */
    *FilterIndexPtr = CAN_CONTROLLER_MASK_XTD_FIDX;
  }
  /* Check for FD Frame and set the FD flag in messageId. */
  flags = Can_RaReadByteMRAM(messageRamPtr, 6u);
  if (0u != (flags & CAN_RX_MASK_FDF))
  {
    *MessageIdPtr |= CAN_CONTROLLER_FD_ID_FLAG;
    /* Extract length and convert to DLC code to length value. */
    *MessageLengthPtr = Can_ControllerTranslateDlcToLength(flags & CAN_RX_MASK_DLC);
  }
  else
  {
    *MessageLengthPtr = flags & CAN_RX_MASK_DLC;
    /* In classic mode higher value than 8 are interpreted as DLC 8. */
    if (*MessageLengthPtr > 8u)
    {
      *MessageLengthPtr = 8u;
    }
  }  
  
  /* Get Filter Index */
  *FilterIndexPtr |= (Can_RaReadByteMRAM(messageRamPtr, 7u) & CAN_RX_MASK_FIDX);
  
  /* Calculate the number of loops for copy.
     If it is not divisible by 4 bytes, increase the loop number by 1.
     Ex. MessageLengthPtr=3(bytes)
         MessageLengthPtr/4(bytes) = 0 mod 3
         Therefore, increase maxLoopNum by 1.
  */
  maxLoopNum = *MessageLengthPtr >> 2u;
  if (0u != (*MessageLengthPtr & 0x03u))
  {
    maxLoopNum++;
  }
  
  /* Copy message. */
  for (i = 0u; i < maxLoopNum; i++)
  {
    /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
       Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
       in 4-byte alignment. */
    /* PRQA S 3305 1 */
    P2CONST(uint32, AUTOMATIC, AUTOMATIC) mRamWordPtr = (P2CONST(uint32, AUTOMATIC, AUTOMATIC))&(messageRamPtr[8u]);
    MessageCopy[i] = mRamWordPtr[i];
  }
}

/** \brief Can_RxCheckPayloadLengthError
 **
 ** Check Payload length error on Pretended Networking Mode.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to the controller state data.
 **
 */
static FUNC(void, AUTOMATIC) Can_RxCheckPayloadLengthError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  uint32 index;
  uint32 baseAddress   = ControllerCfgPtr->RegisterBaseAddress;
  uint8  channelNumber = ControllerCfgPtr->ChannelNumber;
  
  if (0u != (Can_RaGetInterruptFlags(baseAddress, channelNumber) & CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR))
  {
    Can_RaClearInterruptFlag(baseAddress, channelNumber, CAN_RA_INTERRUPT_MASK_PROTOCOL_ERROR);
  }
  
  for (index=0u; 
          (FALSE == ControllerStateDataPtr->IcomState.IsWakeup)
       && (index<ControllerStateDataPtr->IcomState.IcomConfigPtr->NumberOfRxMessageCfgPtr);
       index++)
  {
    P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr = 
                                                  ControllerStateDataPtr->IcomState.IcomConfigPtr->RxMessageCfgPtr;
    if (TRUE == IcomRxMsgPtr[index].PayloadLengthError)
    {
      VAR(uint8, AUTOMATIC) PayloadStatus = Can_RaGetPayloadLengthErrorStatus(baseAddress, channelNumber);
  
      if (   (0u != (CAN_RA_STATUS_MASK_PAYLOAD_ERROR & PayloadStatus))
          && (CAN_RA_STATUS_MASK_PAYLOAD_ERROR != (CAN_RA_STATUS_MASK_PAYLOAD_ERROR & PayloadStatus)) )
      {
        Can_EcuMSetWakeupForPretendedNetworkMode(ControllerCfgPtr, ControllerStateDataPtr);
      }
    }
  }
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[end of file]===========================================*/
