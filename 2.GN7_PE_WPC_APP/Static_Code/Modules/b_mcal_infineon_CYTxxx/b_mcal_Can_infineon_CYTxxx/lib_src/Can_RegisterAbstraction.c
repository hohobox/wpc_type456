/** \brief Can_RegisterAbstraction.c
 **
 ** The register abstraction provides access to individual hw registers. The
 ** functions are intentionally very simple.
 **
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

 /* NOTE: In order to access hardware register elements, bitfields in 
          conjunction with unions are used in this file. A specific packing of 
          the bitfields is required for correct operation.
          This is only assured by using one of the compilers and corresponding 
          options which are approved for this software product. Please consult
          the Release Notes for information on supported compilers.
 */

/*==================[inclusions]============================================*/

#include <Can_RegisterAbstraction.h>
#include <Can_BitSearch.h>

/*==================[macros]================================================*/

/* Deviation from MISRA-C:2004 Rules 3.1, 11.3; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics:, 
   MISRA-C:2012 Rule-11.4
   Cast between a pointer to volatile object and an integral type.
   Justification: The address is configured as integer (CanControllerBaseAddress) as defined by
   AUTOSAR. Hence the integer has to be converted to a pointer at some point in code. */
/* PRQA S 303 EOF */

/** De-references BaseAddress to a variable of type stc_CAN_t. */
/* Deviation from MISRA-C:2004 Rule 19.7, MISRA-C:2012 Dir-4.9.
   Justification: Allow compiler optimization. */
/* PRQA S 3453 1 */
#define CANFD(BaseAddress)  (*((volatile stc_CAN_t*)(BaseAddress)))

/*==================[type definitions]======================================*/

/* The following type definitions are used to access hardware registers.
   They were generated from the hardware description, therefore the format
   was kept as is. The following MISRA deviations are known and accepted:
   - MISRA-C:2004 Rules 1.1, 6.4; REFERENCE - ISO:C90-6.5.2.1 Structure and Union Specifiers - Semantics:
     Bit-fields in this struct/union have been declared with types other than int, signed int or unsigned int.
   - MISRA-C:2004 Rule 18.4:
     A union type specifier has been defined. 
     An object of union type has been defined.
*/

/* Deviation from MISRA-C:2004 Rule 1.1, 6.4, MISRA-C:2012 Rule-1.2, Rule-6.1
    Justification: Type definition is used for register abstraction. */
/* PRQA S 635 EOF */

/* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2. 
    Justification: Type definition is used for register abstraction. */
/* PRQA S 750 EOF */

/* Deviation from MISRA-C:2004 Rule 18.4, MISRA-C:2012 Rule-19.2. 
    Justification: Object is used for register abstraction. */
/* PRQA S 759 EOF */

/* Types used for register access */

/* CANFD */

typedef struct stc_CAN_CH_CREL_field {
  uint32                         u8DAY:8;
  uint32                         u8MON:8;
  uint32                         u4YEAR:4;
  uint32                         u4SUBSTEP:4;
  uint32                         u4STEP:4;
  uint32                         u4REL:4;
} stc_CAN_CH_CREL_field_t;

typedef union un_CAN_CH_CREL {
  uint32                         u32Register;
  stc_CAN_CH_CREL_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_CREL_t;

/**
  * \brief Endian Register (CAN_CH_ENDN)
  */
typedef struct stc_CAN_CH_ENDN_field {
  uint32                         u32ETV:32;
} stc_CAN_CH_ENDN_field_t;

typedef union un_CAN_CH_ENDN {
  uint32                         u32Register;
  stc_CAN_CH_ENDN_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_ENDN_t;

/**
  * \brief Data Bit Timing & Prescaler Register (CAN_CH_DBTP)
  */
typedef struct stc_CAN_CH_DBTP_field {
  uint32                         u4DSJW:4;
  uint32                         u4DTSEG2:4;
  uint32                         u5DTSEG1:5;
  uint32                         :3;
  uint32                         u5DBRP:5;
  uint32                         :2;
  uint32                         u1TDC:1;
  uint32                         :8;
} stc_CAN_CH_DBTP_field_t;

typedef union un_CAN_CH_DBTP {
  uint32                         u32Register;
  stc_CAN_CH_DBTP_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_DBTP_t;

/**
  * \brief Test Register (CAN_CH_TEST)
  */
typedef struct stc_CAN_CH_TEST_field {
  uint32                         u1TAM:1;
  uint32                         u1TAT:1;
  uint32                         u1CAM:1;
  uint32                         u1CAT:1;
  uint32                         u1LBCK:1;
  uint32                         u2TX:2;
  uint32                         u1RX:1;
  uint32                         :24;
} stc_CAN_CH_TEST_field_t;

typedef union un_CAN_CH_TEST {
  uint32                         u32Register;
  stc_CAN_CH_TEST_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TEST_t;

/**
  * \brief RAM Watchdog (CAN_CH_RWD)
  */
typedef struct stc_CAN_CH_RWD_field {
  uint32                         u8WDC:8;
  uint32                         u8WDV:8;
  uint32                         :16;
} stc_CAN_CH_RWD_field_t;

typedef union un_CAN_CH_RWD {
  uint32                         u32Register;
  stc_CAN_CH_RWD_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RWD_t;

/**
  * \brief CC Control Register (CAN_CH_CCCR)
  */
typedef struct stc_CAN_CH_CCCR_field {
  uint32                         u1INIT:1;
  uint32                         u1CCE:1;
  uint32                         u1ASM:1;
  uint32                         u1CSA:1;
  uint32                         u1CSR:1;
  uint32                         u1MON_:1;
  uint32                         u1DAR:1;
  uint32                         u1TEST:1;
  uint32                         u1FDOE:1;
  uint32                         u1BRSE:1;
  uint32                         :2;
  uint32                         u1PXHD:1;
  uint32                         u1EFBI:1;
  uint32                         u1TXP:1;
  uint32                         u1NISO:1;
  uint32                         :16;
} stc_CAN_CH_CCCR_field_t;

typedef union un_CAN_CH_CCCR {
  uint32                         u32Register;
  stc_CAN_CH_CCCR_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_CCCR_t;

/**
  * \brief Nominal Bit Timing & Prescaler Register (CAN_CH_NBTP)
  */
typedef struct stc_CAN_CH_NBTP_field {
  uint32                         u7NTSEG2:7;
  uint32                         :1;
  uint32                         u8NTSEG1:8;
  uint32                         u9NBRP:9;
  uint32                         u7NSJW:7;
} stc_CAN_CH_NBTP_field_t;

typedef union un_CAN_CH_NBTP {
  uint32                         u32Register;
  stc_CAN_CH_NBTP_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_NBTP_t;

/**
  * \brief Timestamp Counter Configuration (CAN_CH_TSCC)
  */
typedef struct stc_CAN_CH_TSCC_field {
  uint32                         u2TSS:2;
  uint32                         :14;
  uint32                         u4TCP:4;
  uint32                         :12;
} stc_CAN_CH_TSCC_field_t;

typedef union un_CAN_CH_TSCC {
  uint32                         u32Register;
  stc_CAN_CH_TSCC_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TSCC_t;

/**
  * \brief Timestamp Counter Value (CAN_CH_TSCV)
  */
typedef struct stc_CAN_CH_TSCV_field {
  uint32                         u16TSC:16;
  uint32                         :16;
} stc_CAN_CH_TSCV_field_t;

typedef union un_CAN_CH_TSCV {
  uint32                         u32Register;
  stc_CAN_CH_TSCV_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TSCV_t;

/**
  * \brief Timeout Counter Configuration (CAN_CH_TOCC)
  */
typedef struct stc_CAN_CH_TOCC_field {
  uint32                         u1ETOC:1;
  uint32                         u2TOS:2;
  uint32                         :13;
  uint32                         u16TOP:16;
} stc_CAN_CH_TOCC_field_t;

typedef union un_CAN_CH_TOCC {
  uint32                         u32Register;
  stc_CAN_CH_TOCC_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TOCC_t;

/**
  * \brief Timeout Counter Value (CAN_CH_TOCV)
  */
typedef struct stc_CAN_CH_TOCV_field {
  uint32                         u16TOC:16;
  uint32                         :16;
} stc_CAN_CH_TOCV_field_t;

typedef union un_CAN_CH_TOCV {
  uint32                         u32Register;
  stc_CAN_CH_TOCV_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TOCV_t;

/**
  * \brief Error Counter Register (CAN_CH_ECR)
  */
typedef struct stc_CAN_CH_ECR_field {
  uint32                         u8TEC:8;
  uint32                         u7REC:7;
  uint32                         u1RP:1;
  uint32                         u8CEL:8;
  uint32                         :8;
} stc_CAN_CH_ECR_field_t;

typedef union un_CAN_CH_ECR {
  uint32                         u32Register;
  stc_CAN_CH_ECR_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_ECR_t;

/**
  * \brief Protocol Status Register (CAN_CH_PSR)
  */
typedef struct stc_CAN_CH_PSR_field {
  uint32                         u3LEC:3;
  uint32                         u2ACT:2;
  uint32                         u1EP:1;
  uint32                         u1EW:1;
  uint32                         u1BO:1;
  uint32                         u3DLEC:3;
  uint32                         u1RESI:1;
  uint32                         u1RBRS:1;
  uint32                         u1RFDF:1;
  uint32                         u1PXE:1;
  uint32                         :1;
  uint32                         u7TDCV:7;
  uint32                         :9;
} stc_CAN_CH_PSR_field_t;

typedef union un_CAN_CH_PSR {
  uint32                         u32Register;
  stc_CAN_CH_PSR_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_PSR_t;

/**
  * \brief Transmitter Delay Compensation Register (CAN_CH_TDCR)
  */
typedef struct stc_CAN_CH_TDCR_field {
  uint32                         u7TDCF:7;
  uint32                         :1;
  uint32                         u7TDCO:7;
  uint32                         :17;
} stc_CAN_CH_TDCR_field_t;

typedef union un_CAN_CH_TDCR {
  uint32                         u32Register;
  stc_CAN_CH_TDCR_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TDCR_t;

/**
  * \brief Interrupt Register (CAN_CH_IR)
  */
typedef struct stc_CAN_CH_IR_field {
  uint32                         u1RF0N:1;
  uint32                         u1RF0W:1;
  uint32                         u1RF0F:1;
  uint32                         u1RF0L_:1;
  uint32                         u1RF1N:1;
  uint32                         u1RF1W:1;
  uint32                         u1RF1F:1;
  uint32                         u1RF1L_:1;
  uint32                         u1HPM:1;
  uint32                         u1TC:1;
  uint32                         u1TCF:1;
  uint32                         u1TFE:1;
  uint32                         u1TEFN:1;
  uint32                         u1TEFW:1;
  uint32                         u1TEFF:1;
  uint32                         u1TEFL_:1;
  uint32                         u1TSW:1;
  uint32                         u1MRAF:1;
  uint32                         u1TOO:1;
  uint32                         u1DRX:1;
  uint32                         u1BEC:1;
  uint32                         u1BEU:1;
  uint32                         u1ELO:1;
  uint32                         u1EP_:1;
  uint32                         u1EW_:1;
  uint32                         u1BO_:1;
  uint32                         u1WDI:1;
  uint32                         u1PEA:1;
  uint32                         u1PED:1;
  uint32                         u1ARA:1;
  uint32                         :2;
} stc_CAN_CH_IR_field_t;

typedef union un_CAN_CH_IR {
  uint32                         u32Register;
  stc_CAN_CH_IR_field_t            stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_IR_t;

/**
  * \brief Interrupt Enable (CAN_CH_IE)
  */
typedef struct stc_CAN_CH_IE_field {
  uint32                         u1RF0NE:1;
  uint32                         u1RF0WE:1;
  uint32                         u1RF0FE:1;
  uint32                         u1RF0LE:1;
  uint32                         u1RF1NE:1;
  uint32                         u1RF1WE:1;
  uint32                         u1RF1FE:1;
  uint32                         u1RF1LE:1;
  uint32                         u1HPME:1;
  uint32                         u1TCE:1;
  uint32                         u1TCFE:1;
  uint32                         u1TFEE:1;
  uint32                         u1TEFNE:1;
  uint32                         u1TEFWE:1;
  uint32                         u1TEFFE:1;
  uint32                         u1TEFLE:1;
  uint32                         u1TSWE:1;
  uint32                         u1MRAFE:1;
  uint32                         u1TOOE:1;
  uint32                         u1DRXE:1;
  uint32                         u1BECE:1;
  uint32                         u1BEUE:1;
  uint32                         u1ELOE:1;
  uint32                         u1EPE:1;
  uint32                         u1EWE:1;
  uint32                         u1BOE:1;
  uint32                         u1WDIE:1;
  uint32                         u1PEAE:1;
  uint32                         u1PEDE:1;
  uint32                         u1ARAE:1;
  uint32                         :2;
} stc_CAN_CH_IE_field_t;

typedef union un_CAN_CH_IE {
  uint32                         u32Register;
  stc_CAN_CH_IE_field_t            stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_IE_t;

/**
  * \brief Interrupt Line Select (CAN_CH_ILS)
  */
typedef struct stc_CAN_CH_ILS_field {
  uint32                         u1RF0NL:1;
  uint32                         u1RF0WL:1;
  uint32                         u1RF0FL:1;
  uint32                         u1RF0LL:1;
  uint32                         u1RF1NL:1;
  uint32                         u1RF1WL:1;
  uint32                         u1RF1FL:1;
  uint32                         u1RF1LL:1;
  uint32                         u1HPML:1;
  uint32                         u1TCL:1;
  uint32                         u1TCFL:1;
  uint32                         u1TFEL:1;
  uint32                         u1TEFNL:1;
  uint32                         u1TEFWL:1;
  uint32                         u1TEFFL:1;
  uint32                         u1TEFLL:1;
  uint32                         u1TSWL:1;
  uint32                         u1MRAFL:1;
  uint32                         u1TOOL:1;
  uint32                         u1DRXL:1;
  uint32                         u1BECL:1;
  uint32                         u1BEUL:1;
  uint32                         u1ELOL:1;
  uint32                         u1EPL:1;
  uint32                         u1EWL:1;
  uint32                         u1BOL:1;
  uint32                         u1WDIL:1;
  uint32                         u1PEAL:1;
  uint32                         u1PEDL:1;
  uint32                         u1ARAL:1;
  uint32                         :2;
} stc_CAN_CH_ILS_field_t;

typedef union un_CAN_CH_ILS {
  uint32                         u32Register;
  stc_CAN_CH_ILS_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_ILS_t;

/**
  * \brief Interrupt Line Enable (CAN_CH_ILE)
  */
typedef struct stc_CAN_CH_ILE_field {
  uint32                         u1EINT0:1;
  uint32                         u1EINT1:1;
  uint32                         :30;
} stc_CAN_CH_ILE_field_t;

typedef union un_CAN_CH_ILE {
  uint32                         u32Register;
  stc_CAN_CH_ILE_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_ILE_t;

/**
  * \brief Global Filter Configuration (CAN_CH_GFC)
  */
typedef struct stc_CAN_CH_GFC_field {
  uint32                         u1RRFE:1;
  uint32                         u1RRFS:1;
  uint32                         u2ANFE:2;
  uint32                         u2ANFS:2;
  uint32                         :26;
} stc_CAN_CH_GFC_field_t;

typedef union un_CAN_CH_GFC {
  uint32                         u32Register;
  stc_CAN_CH_GFC_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_GFC_t;

/**
  * \brief Standard ID Filter Configuration (CAN_CH_SIDFC)
  */
typedef struct stc_CAN_CH_SIDFC_field {
  uint32                         :2;
  uint32                         u14FLSSA:14;
  uint32                         u8LSS:8;
  uint32                         :8;
} stc_CAN_CH_SIDFC_field_t;

typedef union un_CAN_CH_SIDFC {
  uint32                         u32Register;
  stc_CAN_CH_SIDFC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_SIDFC_t;

/**
  * \brief Extended ID Filter Configuration (CAN_CH_XIDFC)
  */
typedef struct stc_CAN_CH_XIDFC_field {
  uint32                         :2;
  uint32                         u14FLESA:14;
  uint32                         u7LSE:7;
  uint32                         :9;
} stc_CAN_CH_XIDFC_field_t;

typedef union un_CAN_CH_XIDFC {
  uint32                         u32Register;
  stc_CAN_CH_XIDFC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_XIDFC_t;

/**
  * \brief Extended ID AND Mask (CAN_CH_XIDAM)
  */
typedef struct stc_CAN_CH_XIDAM_field {
  uint32                         u29EIDM:29;
  uint32                         :3;
} stc_CAN_CH_XIDAM_field_t;

typedef union un_CAN_CH_XIDAM {
  uint32                         u32Register;
  stc_CAN_CH_XIDAM_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_XIDAM_t;

/**
  * \brief High Priority Message Status (CAN_CH_HPMS)
  */
typedef struct stc_CAN_CH_HPMS_field {
  uint32                         u6BIDX:6;
  uint32                         u2MSI:2;
  uint32                         u7FIDX:7;
  uint32                         u1FLST:1;
  uint32                         :16;
} stc_CAN_CH_HPMS_field_t;

typedef union un_CAN_CH_HPMS {
  uint32                         u32Register;
  stc_CAN_CH_HPMS_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_HPMS_t;

/**
  * \brief New Data 1 (CAN_CH_NDAT1)
  */
typedef struct stc_CAN_CH_NDAT1_field {
  uint32                         u32ND:32;
} stc_CAN_CH_NDAT1_field_t;

typedef union un_CAN_CH_NDAT1 {
  uint32                         u32Register;
  stc_CAN_CH_NDAT1_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_NDAT1_t;

/**
  * \brief New Data 2 (CAN_CH_NDAT2)
  */
typedef struct stc_CAN_CH_NDAT2_field {
  uint32                         u32ND:32;
} stc_CAN_CH_NDAT2_field_t;

typedef union un_CAN_CH_NDAT2 {
  uint32                         u32Register;
  stc_CAN_CH_NDAT2_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_NDAT2_t;

/**
  * \brief Rx FIFO 0 Configuration (CAN_CH_RXF0C)
  */
typedef struct stc_CAN_CH_RXF0C_field {
  uint32                         :2;
  uint32                         u14F0SA:14;
  uint32                         u7F0S:7;
  uint32                         :1;
  uint32                         u7F0WM:7;
  uint32                         u1F0OM:1;
} stc_CAN_CH_RXF0C_field_t;

typedef union un_CAN_CH_RXF0C {
  uint32                         u32Register;
  stc_CAN_CH_RXF0C_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXF0C_t;

/**
  * \brief Rx FIFO 0 Status (CAN_CH_RXF0S)
  */
typedef struct stc_CAN_CH_RXF0S_field {
  uint32                         u7F0FL:7;
  uint32                         :1;
  uint32                         u6F0GI:6;
  uint32                         :2;
  uint32                         u6F0PI:6;
  uint32                         :2;
  uint32                         u1F0F:1;
  uint32                         u1RF0L:1;
  uint32                         :6;
} stc_CAN_CH_RXF0S_field_t;

typedef union un_CAN_CH_RXF0S {
  uint32                         u32Register;
  stc_CAN_CH_RXF0S_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXF0S_t;

/**
  * \brief Rx FIFO 0 Acknowledge (CAN_CH_RXF0A)
  */
typedef struct stc_CAN_CH_RXF0A_field {
  uint32                         u6F0AI:6;
  uint32                         :26;
} stc_CAN_CH_RXF0A_field_t;

typedef union un_CAN_CH_RXF0A {
  uint32                         u32Register;
  stc_CAN_CH_RXF0A_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXF0A_t;

/**
  * \brief Rx Buffer Configuration (CAN_CH_RXBC)
  */
typedef struct stc_CAN_CH_RXBC_field {
  uint32                         :2;
  uint32                         u14RBSA:14;
  uint32                         :16;
} stc_CAN_CH_RXBC_field_t;

typedef union un_CAN_CH_RXBC {
  uint32                         u32Register;
  stc_CAN_CH_RXBC_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXBC_t;

/**
  * \brief Rx FIFO 1 Configuration (CAN_CH_RXF1C)
  */
typedef struct stc_CAN_CH_RXF1C_field {
  uint32                         :2;
  uint32                         u14F1SA:14;
  uint32                         u7F1S:7;
  uint32                         :1;
  uint32                         u7F1WM:7;
  uint32                         u1F1OM:1;
} stc_CAN_CH_RXF1C_field_t;

typedef union un_CAN_CH_RXF1C {
  uint32                         u32Register;
  stc_CAN_CH_RXF1C_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXF1C_t;

/**
  * \brief Rx FIFO 1 Status (CAN_CH_RXF1S)
  */
typedef struct stc_CAN_CH_RXF1S_field {
  uint32                         u7F1FL:7;
  uint32                         :1;
  uint32                         u6F1GI:6;
  uint32                         :2;
  uint32                         u6F1PI:6;
  uint32                         :2;
  uint32                         u1F1F:1;
  uint32                         u1RF1L:1;
  uint32                         :4;
  uint32                         u2DMS:2;
} stc_CAN_CH_RXF1S_field_t;

typedef union un_CAN_CH_RXF1S {
  uint32                         u32Register;
  stc_CAN_CH_RXF1S_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXF1S_t;

/**
  * \brief Rx FIFO 1 Acknowledge (CAN_CH_RXF1A)
  */
typedef struct stc_CAN_CH_RXF1A_field {
  uint32                         u6F1AI:6;
  uint32                         :26;
} stc_CAN_CH_RXF1A_field_t;

typedef union un_CAN_CH_RXF1A {
  uint32                         u32Register;
  stc_CAN_CH_RXF1A_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXF1A_t;

/**
  * \brief Rx Buffer / FIFO Element Size Configuration (CAN_CH_RXESC)
  */
typedef struct stc_CAN_CH_RXESC_field {
  uint32                         u3F0DS:3;
  uint32                         :1;
  uint32                         u3F1DS:3;
  uint32                         :1;
  uint32                         u3RBDS:3;
  uint32                         :21;
} stc_CAN_CH_RXESC_field_t;

typedef union un_CAN_CH_RXESC {
  uint32                         u32Register;
  stc_CAN_CH_RXESC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXESC_t;

/**
  * \brief Tx Buffer Configuration (CAN_CH_TXBC)
  */
typedef struct stc_CAN_CH_TXBC_field {
  uint32                         :2;
  uint32                         u14TBSA:14;
  uint32                         u6NDTB:6;
  uint32                         :2;
  uint32                         u6TFQS:6;
  uint32                         u1TFQM:1;
  uint32                         :1;
} stc_CAN_CH_TXBC_field_t;

typedef union un_CAN_CH_TXBC {
  uint32                         u32Register;
  stc_CAN_CH_TXBC_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBC_t;

/**
  * \brief Tx FIFO/Queue Status (CAN_CH_TXFQS)
  */
typedef struct stc_CAN_CH_TXFQS_field {
  uint32                         u6TFFL:6;
  uint32                         :2;
  uint32                         u5TFGI:5;
  uint32                         :3;
  uint32                         u5TFQPI:5;
  uint32                         u1TFQF:1;
  uint32                         :10;
} stc_CAN_CH_TXFQS_field_t;

typedef union un_CAN_CH_TXFQS {
  uint32                         u32Register;
  stc_CAN_CH_TXFQS_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXFQS_t;

/**
  * \brief Tx Buffer Element Size Configuration (CAN_CH_TXESC)
  */
typedef struct stc_CAN_CH_TXESC_field {
  uint32                         u3TBDS:3;
  uint32                         :29;
} stc_CAN_CH_TXESC_field_t;

typedef union un_CAN_CH_TXESC {
  uint32                         u32Register;
  stc_CAN_CH_TXESC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXESC_t;

/**
  * \brief Tx Buffer Request Pending (CAN_CH_TXBRP)
  */
typedef struct stc_CAN_CH_TXBRP_field {
  uint32                         u32TRP:32;
} stc_CAN_CH_TXBRP_field_t;

typedef union un_CAN_CH_TXBRP {
  uint32                         u32Register;
  stc_CAN_CH_TXBRP_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBRP_t;

/**
  * \brief Tx Buffer Add Request (CAN_CH_TXBAR)
  */
typedef struct stc_CAN_CH_TXBAR_field {
  uint32                         u32AR:32;
} stc_CAN_CH_TXBAR_field_t;

typedef union un_CAN_CH_TXBAR {
  uint32                         u32Register;
  stc_CAN_CH_TXBAR_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBAR_t;

/**
  * \brief Tx Buffer Cancellation Request (CAN_CH_TXBCR)
  */
typedef struct stc_CAN_CH_TXBCR_field {
  uint32                         u32CR:32;
} stc_CAN_CH_TXBCR_field_t;

typedef union un_CAN_CH_TXBCR {
  uint32                         u32Register;
  stc_CAN_CH_TXBCR_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBCR_t;

/**
  * \brief Tx Buffer Transmission Occurred (CAN_CH_TXBTO)
  */
typedef struct stc_CAN_CH_TXBTO_field {
  uint32                         u32TO:32;
} stc_CAN_CH_TXBTO_field_t;

typedef union un_CAN_CH_TXBTO {
  uint32                         u32Register;
  stc_CAN_CH_TXBTO_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBTO_t;

/**
  * \brief Tx Buffer Cancellation Finished (CAN_CH_TXBCF)
  */
typedef struct stc_CAN_CH_TXBCF_field {
  uint32                         u32CF:32;
} stc_CAN_CH_TXBCF_field_t;

typedef union un_CAN_CH_TXBCF {
  uint32                         u32Register;
  stc_CAN_CH_TXBCF_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBCF_t;

/**
  * \brief Tx Buffer Transmission Interrupt Enable (CAN_CH_TXBTIE)
  */
typedef struct stc_CAN_CH_TXBTIE_field {
  uint32                         u32TIE:32;
} stc_CAN_CH_TXBTIE_field_t;

typedef union un_CAN_CH_TXBTIE {
  uint32                         u32Register;
  stc_CAN_CH_TXBTIE_field_t        stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBTIE_t;

/**
  * \brief Tx Buffer Cancellation Finished Interrupt Enable (CAN_CH_TXBCIE)
  */
typedef struct stc_CAN_CH_TXBCIE_field {
  uint32                         u32CFIE:32;
} stc_CAN_CH_TXBCIE_field_t;

typedef union un_CAN_CH_TXBCIE {
  uint32                         u32Register;
  stc_CAN_CH_TXBCIE_field_t        stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXBCIE_t;

/**
  * \brief Tx Event FIFO Configuration (CAN_CH_TXEFC)
  */
typedef struct stc_CAN_CH_TXEFC_field {
  uint32                         :2;
  uint32                         u14EFSA:14;
  uint32                         u6EFS:6;
  uint32                         :2;
  uint32                         u6EFWM:6;
  uint32                         :2;
} stc_CAN_CH_TXEFC_field_t;

typedef union un_CAN_CH_TXEFC {
  uint32                         u32Register;
  stc_CAN_CH_TXEFC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXEFC_t;

/**
  * \brief Tx Event FIFO Status (CAN_CH_TXEFS)
  */
typedef struct stc_CAN_CH_TXEFS_field {
  uint32                         u6EFFL:6;
  uint32                         :2;
  uint32                         u5EFGI:5;
  uint32                         :3;
  uint32                         u5EFPI:5;
  uint32                         :3;
  uint32                         u1EFF:1;
  uint32                         u1TEFL:1;
  uint32                         :6;
} stc_CAN_CH_TXEFS_field_t;

typedef union un_CAN_CH_TXEFS {
  uint32                         u32Register;
  stc_CAN_CH_TXEFS_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXEFS_t;

/**
  * \brief Tx Event FIFO Acknowledge (CAN_CH_TXEFA)
  */
typedef struct stc_CAN_CH_TXEFA_field {
  uint32                         u5EFAI:5;
  uint32                         :27;
} stc_CAN_CH_TXEFA_field_t;

typedef union un_CAN_CH_TXEFA {
  uint32                         u32Register;
  stc_CAN_CH_TXEFA_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TXEFA_t;

/**
  * \brief TT Trigger Memory Configuration (CAN_CH_TTTMC)
  */
typedef struct stc_CAN_CH_TTTMC_field {
  uint32                         :2;
  uint32                         u14TMSA:14;
  uint32                         u7TME:7;
  uint32                         :9;
} stc_CAN_CH_TTTMC_field_t;

typedef union un_CAN_CH_TTTMC {
  uint32                         u32Register;
  stc_CAN_CH_TTTMC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTTMC_t;

/**
  * \brief TT Reference Message Configuration (CAN_CH_TTRMC)
  */
typedef struct stc_CAN_CH_TTRMC_field {
  uint32                         u29RID:29;
  uint32                         :1;
  uint32                         u1XTD:1;
  uint32                         u1RMPS:1;
} stc_CAN_CH_TTRMC_field_t;

typedef union un_CAN_CH_TTRMC {
  uint32                         u32Register;
  stc_CAN_CH_TTRMC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTRMC_t;

/**
  * \brief TT Operation Configuration (CAN_CH_TTOCF)
  */
typedef struct stc_CAN_CH_TTOCF_field {
  uint32                         u2OM:2;
  uint32                         :1;
  uint32                         u1GEN:1;
  uint32                         u1TM:1;
  uint32                         u3LDSDL:3;
  uint32                         u7IRTO:7;
  uint32                         u1EECS:1;
  uint32                         u8AWL:8;
  uint32                         u1EGTF:1;
  uint32                         u1ECC:1;
  uint32                         u1EVTP:1;
  uint32                         :5;
} stc_CAN_CH_TTOCF_field_t;

typedef union un_CAN_CH_TTOCF {
  uint32                         u32Register;
  stc_CAN_CH_TTOCF_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTOCF_t;

/**
  * \brief TT Matrix Limits (CAN_CH_TTMLM)
  */
typedef struct stc_CAN_CH_TTMLM_field {
  uint32                         u6CCM:6;
  uint32                         u2CSS:2;
  uint32                         u4TXEW:4;
  uint32                         :4;
  uint32                         u12ENTT:12;
  uint32                         :4;
} stc_CAN_CH_TTMLM_field_t;

typedef union un_CAN_CH_TTMLM {
  uint32                         u32Register;
  stc_CAN_CH_TTMLM_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTMLM_t;

/**
  * \brief TUR Configuration (CAN_CH_TURCF)
  */
typedef struct stc_CAN_CH_TURCF_field {
  uint32                         u16NCL:16;
  uint32                         u14DC:14;
  uint32                         :1;
  uint32                         u1ELT:1;
} stc_CAN_CH_TURCF_field_t;

typedef union un_CAN_CH_TURCF {
  uint32                         u32Register;
  stc_CAN_CH_TURCF_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TURCF_t;

/**
  * \brief TT Operation Control (CAN_CH_TTOCN)
  */
typedef struct stc_CAN_CH_TTOCN_field {
  uint32                         u1SGT:1;
  uint32                         u1ECS:1;
  uint32                         u1SWP:1;
  uint32                         u2SWS:2;
  uint32                         u1RTIE:1;
  uint32                         u2TMC:2;
  uint32                         u1TTIE:1;
  uint32                         u1GCS:1;
  uint32                         u1FGP:1;
  uint32                         u1TMG:1;
  uint32                         u1NIG:1;
  uint32                         u1ESCN:1;
  uint32                         :1;
  uint32                         u1LCKC:1;
  uint32                         :16;
} stc_CAN_CH_TTOCN_field_t;

typedef union un_CAN_CH_TTOCN {
  uint32                         u32Register;
  stc_CAN_CH_TTOCN_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTOCN_t;

/**
  * \brief TT Global Time Preset (CAN_CH_TTGTP)
  */
typedef struct stc_CAN_CH_TTGTP_field {
  uint32                         u16TP:16;
  uint32                         u16CTP:16;
} stc_CAN_CH_TTGTP_field_t;

typedef union un_CAN_CH_TTGTP {
  uint32                         u32Register;
  stc_CAN_CH_TTGTP_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTGTP_t;

/**
  * \brief TT Time Mark (CAN_CH_TTTMK)
  */
typedef struct stc_CAN_CH_TTTMK_field {
  uint32                         u16TM_:16;
  uint32                         u7TICC:7;
  uint32                         :8;
  uint32                         u1LCKM:1;
} stc_CAN_CH_TTTMK_field_t;

typedef union un_CAN_CH_TTTMK {
  uint32                         u32Register;
  stc_CAN_CH_TTTMK_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTTMK_t;

/**
  * \brief TT Interrupt Register (CAN_CH_TTIR)
  */
typedef struct stc_CAN_CH_TTIR_field {
  uint32                         u1SBC:1;
  uint32                         u1SMC:1;
  uint32                         u1CSM_:1;
  uint32                         u1SOG:1;
  uint32                         u1RTMI:1;
  uint32                         u1TTMI:1;
  uint32                         u1SWE:1;
  uint32                         u1GTW:1;
  uint32                         u1GTD:1;
  uint32                         u1GTE:1;
  uint32                         u1TXU:1;
  uint32                         u1TXO:1;
  uint32                         u1SE1:1;
  uint32                         u1SE2:1;
  uint32                         u1ELC:1;
  uint32                         u1IWT:1;
  uint32                         u1WT:1;
  uint32                         u1AW:1;
  uint32                         u1CER:1;
  uint32                         :13;
} stc_CAN_CH_TTIR_field_t;

typedef union un_CAN_CH_TTIR {
  uint32                         u32Register;
  stc_CAN_CH_TTIR_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTIR_t;

/**
  * \brief TT Interrupt Enable (CAN_CH_TTIE)
  */
typedef struct stc_CAN_CH_TTIE_field {
  uint32                         u1SBCE:1;
  uint32                         u1SMCE:1;
  uint32                         u1CSME:1;
  uint32                         u1SOGE:1;
  uint32                         u1RTMIE:1;
  uint32                         u1TTMIE:1;
  uint32                         u1SWEE:1;
  uint32                         u1GTWE:1;
  uint32                         u1GTDE:1;
  uint32                         u1GTEE:1;
  uint32                         u1TXUE:1;
  uint32                         u1TXOE:1;
  uint32                         u1SE1E:1;
  uint32                         u1SE2E:1;
  uint32                         u1ELCE:1;
  uint32                         u1IWTE:1;
  uint32                         u1WTE:1;
  uint32                         u1AWE_:1;
  uint32                         u1CERE:1;
  uint32                         :13;
} stc_CAN_CH_TTIE_field_t;

typedef union un_CAN_CH_TTIE {
  uint32                         u32Register;
  stc_CAN_CH_TTIE_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTIE_t;

/**
  * \brief TT Interrupt Line Select (CAN_CH_TTILS)
  */
typedef struct stc_CAN_CH_TTILS_field {
  uint32                         u1SBCL:1;
  uint32                         u1SMCL:1;
  uint32                         u1CSML:1;
  uint32                         u1SOGL:1;
  uint32                         u1RTMIL:1;
  uint32                         u1TTMIL:1;
  uint32                         u1SWEL:1;
  uint32                         u1GTWL:1;
  uint32                         u1GTDL:1;
  uint32                         u1GTEL:1;
  uint32                         u1TXUL:1;
  uint32                         u1TXOL:1;
  uint32                         u1SE1L:1;
  uint32                         u1SE2L:1;
  uint32                         u1ELCL:1;
  uint32                         u1IWTL:1;
  uint32                         u1WTL:1;
  uint32                         u1AWL_:1;
  uint32                         u1CERL:1;
  uint32                         :13;
} stc_CAN_CH_TTILS_field_t;

typedef union un_CAN_CH_TTILS {
  uint32                         u32Register;
  stc_CAN_CH_TTILS_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTILS_t;

/**
  * \brief TT Operation Status (CAN_CH_TTOST)
  */
typedef struct stc_CAN_CH_TTOST_field {
  uint32                         u2EL:2;
  uint32                         u2MS:2;
  uint32                         u2SYS:2;
  uint32                         u1QGTP:1;
  uint32                         u1QCS:1;
  uint32                         u8RTO:8;
  uint32                         :6;
  uint32                         u1WGTD:1;
  uint32                         u1GFI:1;
  uint32                         u3TMP:3;
  uint32                         u1GSI:1;
  uint32                         u1WFE:1;
  uint32                         u1AWE:1;
  uint32                         u1WECS:1;
  uint32                         u1SPL:1;
} stc_CAN_CH_TTOST_field_t;

typedef union un_CAN_CH_TTOST {
  uint32                         u32Register;
  stc_CAN_CH_TTOST_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTOST_t;

/**
  * \brief TUR Numerator Actual (CAN_CH_TURNA)
  */
typedef struct stc_CAN_CH_TURNA_field {
  uint32                         u18NAV:18;
  uint32                         :14;
} stc_CAN_CH_TURNA_field_t;

typedef union un_CAN_CH_TURNA {
  uint32                         u32Register;
  stc_CAN_CH_TURNA_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TURNA_t;

/**
  * \brief TT Local & Global Time (CAN_CH_TTLGT)
  */
typedef struct stc_CAN_CH_TTLGT_field {
  uint32                         u16LT:16;
  uint32                         u16GT:16;
} stc_CAN_CH_TTLGT_field_t;

typedef union un_CAN_CH_TTLGT {
  uint32                         u32Register;
  stc_CAN_CH_TTLGT_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTLGT_t;

/**
  * \brief TT Cycle Time & Count (CAN_CH_TTCTC)
  */
typedef struct stc_CAN_CH_TTCTC_field {
  uint32                         u16CT:16;
  uint32                         u6CC:6;
  uint32                         :10;
} stc_CAN_CH_TTCTC_field_t;

typedef union un_CAN_CH_TTCTC {
  uint32                         u32Register;
  stc_CAN_CH_TTCTC_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTCTC_t;

/**
  * \brief TT Capture Time (CAN_CH_TTCPT)
  */
typedef struct stc_CAN_CH_TTCPT_field {
  uint32                         u6CCV:6;
  uint32                         :10;
  uint32                         u16SWV:16;
} stc_CAN_CH_TTCPT_field_t;

typedef union un_CAN_CH_TTCPT {
  uint32                         u32Register;
  stc_CAN_CH_TTCPT_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTCPT_t;

/**
  * \brief TT Cycle Sync Mark (CAN_CH_TTCSM)
  */
typedef struct stc_CAN_CH_TTCSM_field {
  uint32                         u16CSM:16;
  uint32                         :16;
} stc_CAN_CH_TTCSM_field_t;

typedef union un_CAN_CH_TTCSM {
  uint32                         u32Register;
  stc_CAN_CH_TTCSM_field_t         stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_TTCSM_t;



/**
  * \brief Receive FIFO Top control (CAN_CH_RXFTOP_CTL)
  */
typedef struct stc_CAN_CH_RXFTOP_CTL_field {
  uint32                         u1F0TPE:1;
  uint32                         u1F1TPE:1;
  uint32                         :30;
} stc_CAN_CH_RXFTOP_CTL_field_t;

typedef union un_CAN_CH_RXFTOP_CTL {
  uint32                         u32Register;
  stc_CAN_CH_RXFTOP_CTL_field_t    stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXFTOP_CTL_t;

/**
  * \brief Receive FIFO 0 Top Status (CAN_CH_RXFTOP0_STAT)
  */
typedef struct stc_CAN_CH_RXFTOP0_STAT_field {
  uint32                         u16F0TA:16;
  uint32                         :16;
} stc_CAN_CH_RXFTOP0_STAT_field_t;

typedef union un_CAN_CH_RXFTOP0_STAT {
  uint32                         u32Register;
  stc_CAN_CH_RXFTOP0_STAT_field_t  stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXFTOP0_STAT_t;

/**
  * \brief Receive FIFO 0 Top Data (CAN_CH_RXFTOP0_DATA)
  */
typedef struct stc_CAN_CH_RXFTOP0_DATA_field {
  uint32                         u32F0TD:32;
} stc_CAN_CH_RXFTOP0_DATA_field_t;

typedef union un_CAN_CH_RXFTOP0_DATA {
  uint32                         u32Register;
  stc_CAN_CH_RXFTOP0_DATA_field_t  stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXFTOP0_DATA_t;

/**
  * \brief Receive FIFO 1 Top Status (CAN_CH_RXFTOP1_STAT)
  */
typedef struct stc_CAN_CH_RXFTOP1_STAT_field {
  uint32                         u16F1TA:16;
  uint32                         :16;
} stc_CAN_CH_RXFTOP1_STAT_field_t;

typedef union un_CAN_CH_RXFTOP1_STAT {
  uint32                         u32Register;
  stc_CAN_CH_RXFTOP1_STAT_field_t  stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXFTOP1_STAT_t;

/**
  * \brief Receive FIFO 1 Top Data (CAN_CH_RXFTOP1_DATA)
  */
typedef struct stc_CAN_CH_RXFTOP1_DATA_field {
  uint32                         u32F1TD:32;
} stc_CAN_CH_RXFTOP1_DATA_field_t;

typedef union un_CAN_CH_RXFTOP1_DATA {
  uint32                         u32Register;
  stc_CAN_CH_RXFTOP1_DATA_field_t  stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CH_RXFTOP1_DATA_t;



/**
  * \brief Global CAN control register (CAN_CTL)
  */
typedef struct stc_CAN_CTL_field {
  uint32                         u8STOP_REQ:8;
  uint32                         :24;
} stc_CAN_CTL_field_t;

typedef union un_CAN_CTL {
  uint32                         u32Register;
  stc_CAN_CTL_field_t              stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_CTL_t;

/**
  * \brief Global CAN status register (CAN_STATUS)
  */
typedef struct stc_CAN_STATUS_field {
  uint32                         u8STOP_ACK:8;
  uint32                         :24;
} stc_CAN_STATUS_field_t;

typedef union un_CAN_STATUS {
  uint32                         u32Register;
  stc_CAN_STATUS_field_t           stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_STATUS_t;

/**
  * \brief Design time configuration (CAN_DESIGN_CFG)
  */
typedef struct stc_CAN_DESIGN_CFG_field {
  uint32                         u6MRAM_SIZE:6;
  uint32                         :2;
  uint32                         u3CAN_NR:3;
  uint32                         :1;
  uint32                         u1ECC_PRESENT:1;
  uint32                         u1TS_PRESENT:1;
  uint32                         :18;
} stc_CAN_DESIGN_CFG_field_t;

typedef union un_CAN_DESIGN_CFG {
  uint32                         u32Register;
  stc_CAN_DESIGN_CFG_field_t       stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_DESIGN_CFG_t;

/**
  * \brief Consolidated interrupt0 cause register (CAN_INTR0_CAUSE)
  */
typedef struct stc_CAN_INTR0_CAUSE_field {
  uint32                         u8INT0:8;
  uint32                         :24;
} stc_CAN_INTR0_CAUSE_field_t;

typedef union un_CAN_INTR0_CAUSE {
  uint32                         u32Register;
  stc_CAN_INTR0_CAUSE_field_t      stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_INTR0_CAUSE_t;

/**
  * \brief Consolidated interrupt1 cause register (CAN_INTR1_CAUSE)
  */
typedef struct stc_CAN_INTR1_CAUSE_field {
  uint32                         u8INT1:8;
  uint32                         :24;
} stc_CAN_INTR1_CAUSE_field_t;

typedef union un_CAN_INTR1_CAUSE {
  uint32                         u32Register;
  stc_CAN_INTR1_CAUSE_field_t      stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_INTR1_CAUSE_t;

/**
  * \brief ECC control (CAN_ECC_CTL)
  */
typedef struct stc_CAN_ECC_CTL_field {
  uint32                         :16;
  uint32                         u1ECC_EN:1;
  uint32                         :15;
} stc_CAN_ECC_CTL_field_t;

typedef union un_CAN_ECC_CTL {
  uint32                         u32Register;
  stc_CAN_ECC_CTL_field_t          stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_ECC_CTL_t;

/**
  * \brief ECC error injection (CAN_ECC_ERR_INJ)
  */
typedef struct stc_CAN_ECC_ERR_INJ_field {
  uint32                         :2;
  uint32                         u14ERR_ADDR:14;
  uint32                         :4;
  uint32                         u1ERR_EN:1;
  uint32                         :3;
  uint32                         u7ERR_PAR:7;
  uint32                         :1;
} stc_CAN_ECC_ERR_INJ_field_t;
typedef union un_CAN_ECC_ERR_INJ {
  uint32                         u32Register;
  stc_CAN_ECC_ERR_INJ_field_t      stcField;
  uint8                          au8Byte[4];
  uint16                         au16Halfword[2];
} un_CAN_ECC_ERR_INJ_t;



/**
  * \brief TTCAN 3PIP, includes FD (CAN_CH_M_TTCAN)
  */
typedef struct stc_CAN_CH_M_TTCAN{
  un_CAN_CH_CREL_t                 unCREL;             /*!< 0x00000000 Core Release Register */
  un_CAN_CH_ENDN_t                 unENDN;             /*!< 0x00000004 Endian Register */
  uint32                         u32Reserved;
  un_CAN_CH_DBTP_t                 unDBTP;             /*!< 0x0000000C Data Bit Timing & Prescaler Register */
  un_CAN_CH_TEST_t                 unTEST;             /*!< 0x00000010 Test Register */
  un_CAN_CH_RWD_t                  unRWD;              /*!< 0x00000014 RAM Watchdog */
  un_CAN_CH_CCCR_t                 unCCCR;             /*!< 0x00000018 CC Control Register */
  un_CAN_CH_NBTP_t                 unNBTP;             /*!< 0x0000001C Nominal Bit Timing & Prescaler Register */
  un_CAN_CH_TSCC_t                 unTSCC;             /*!< 0x00000020 Timestamp Counter Configuration */
  un_CAN_CH_TSCV_t                 unTSCV;             /*!< 0x00000024 Timestamp Counter Value */
  un_CAN_CH_TOCC_t                 unTOCC;             /*!< 0x00000028 Timeout Counter Configuration */
  un_CAN_CH_TOCV_t                 unTOCV;             /*!< 0x0000002C Timeout Counter Value */
  uint32                         au32Reserved1[4];
  un_CAN_CH_ECR_t                  unECR;              /*!< 0x00000040 Error Counter Register */
  un_CAN_CH_PSR_t                  unPSR;              /*!< 0x00000044 Protocol Status Register */
  un_CAN_CH_TDCR_t                 unTDCR;             /*!< 0x00000048 Transmitter Delay Compensation Register */
  uint32                         u32Reserved2;
  un_CAN_CH_IR_t                   unIR;               /*!< 0x00000050 Interrupt Register */
  un_CAN_CH_IE_t                   unIE;               /*!< 0x00000054 Interrupt Enable */
  un_CAN_CH_ILS_t                  unILS;              /*!< 0x00000058 Interrupt Line Select */
  un_CAN_CH_ILE_t                  unILE;              /*!< 0x0000005C Interrupt Line Enable */
  uint32                         au32Reserved3[8];
  un_CAN_CH_GFC_t                  unGFC;              /*!< 0x00000080 Global Filter Configuration */
  un_CAN_CH_SIDFC_t                unSIDFC;            /*!< 0x00000084 Standard ID Filter Configuration */
  un_CAN_CH_XIDFC_t                unXIDFC;            /*!< 0x00000088 Extended ID Filter Configuration */
  uint32                         u32Reserved4;
  un_CAN_CH_XIDAM_t                unXIDAM;            /*!< 0x00000090 Extended ID AND Mask */
  un_CAN_CH_HPMS_t                 unHPMS;             /*!< 0x00000094 High Priority Message Status */
  un_CAN_CH_NDAT1_t                unNDAT1;            /*!< 0x00000098 New Data 1 */
  un_CAN_CH_NDAT2_t                unNDAT2;            /*!< 0x0000009C New Data 2 */
  un_CAN_CH_RXF0C_t                unRXF0C;            /*!< 0x000000A0 Rx FIFO 0 Configuration */
  un_CAN_CH_RXF0S_t                unRXF0S;            /*!< 0x000000A4 Rx FIFO 0 Status */
  un_CAN_CH_RXF0A_t                unRXF0A;            /*!< 0x000000A8 Rx FIFO 0 Acknowledge */
  un_CAN_CH_RXBC_t                 unRXBC;             /*!< 0x000000AC Rx Buffer Configuration */
  un_CAN_CH_RXF1C_t                unRXF1C;            /*!< 0x000000B0 Rx FIFO 1 Configuration */
  un_CAN_CH_RXF1S_t                unRXF1S;            /*!< 0x000000B4 Rx FIFO 1 Status */
  un_CAN_CH_RXF1A_t                unRXF1A;            /*!< 0x000000B8 Rx FIFO 1 Acknowledge */
  un_CAN_CH_RXESC_t                unRXESC;            /*!< 0x000000BC Rx Buffer / FIFO Element Size Configuration */
  un_CAN_CH_TXBC_t                 unTXBC;             /*!< 0x000000C0 Tx Buffer Configuration */
  un_CAN_CH_TXFQS_t                unTXFQS;            /*!< 0x000000C4 Tx FIFO/Queue Status */
  un_CAN_CH_TXESC_t                unTXESC;            /*!< 0x000000C8 Tx Buffer Element Size Configuration */
  un_CAN_CH_TXBRP_t                unTXBRP;            /*!< 0x000000CC Tx Buffer Request Pending */
  un_CAN_CH_TXBAR_t                unTXBAR;            /*!< 0x000000D0 Tx Buffer Add Request */
  un_CAN_CH_TXBCR_t                unTXBCR;            /*!< 0x000000D4 Tx Buffer Cancellation Request */
  un_CAN_CH_TXBTO_t                unTXBTO;            /*!< 0x000000D8 Tx Buffer Transmission Occurred */
  un_CAN_CH_TXBCF_t                unTXBCF;            /*!< 0x000000DC Tx Buffer Cancellation Finished */
  un_CAN_CH_TXBTIE_t               unTXBTIE;           /*!< 0x000000E0 Tx Buffer Transmission Interrupt Enable */
  un_CAN_CH_TXBCIE_t               unTXBCIE;           /*!< 0x000000E4 Tx Buffer Cancellation Finished Interrupt Enable */
  uint32                         au32Reserved5[2];
  un_CAN_CH_TXEFC_t                unTXEFC;            /*!< 0x000000F0 Tx Event FIFO Configuration */
  un_CAN_CH_TXEFS_t                unTXEFS;            /*!< 0x000000F4 Tx Event FIFO Status */
  un_CAN_CH_TXEFA_t                unTXEFA;            /*!< 0x000000F8 Tx Event FIFO Acknowledge */
  uint32                         u32Reserved6;
  un_CAN_CH_TTTMC_t                unTTTMC;            /*!< 0x00000100 TT Trigger Memory Configuration */
  un_CAN_CH_TTRMC_t                unTTRMC;            /*!< 0x00000104 TT Reference Message Configuration */
  un_CAN_CH_TTOCF_t                unTTOCF;            /*!< 0x00000108 TT Operation Configuration */
  un_CAN_CH_TTMLM_t                unTTMLM;            /*!< 0x0000010C TT Matrix Limits */
  un_CAN_CH_TURCF_t                unTURCF;            /*!< 0x00000110 TUR Configuration */
  un_CAN_CH_TTOCN_t                unTTOCN;            /*!< 0x00000114 TT Operation Control */
  un_CAN_CH_TTGTP_t                unTTGTP;            /*!< 0x00000118 TT Global Time Preset */
  un_CAN_CH_TTTMK_t                unTTTMK;            /*!< 0x0000011C TT Time Mark */
  un_CAN_CH_TTIR_t                 unTTIR;             /*!< 0x00000120 TT Interrupt Register */
  un_CAN_CH_TTIE_t                 unTTIE;             /*!< 0x00000124 TT Interrupt Enable */
  un_CAN_CH_TTILS_t                unTTILS;            /*!< 0x00000128 TT Interrupt Line Select */
  un_CAN_CH_TTOST_t                unTTOST;            /*!< 0x0000012C TT Operation Status */
  un_CAN_CH_TURNA_t                unTURNA;            /*!< 0x00000130 TUR Numerator Actual */
  un_CAN_CH_TTLGT_t                unTTLGT;            /*!< 0x00000134 TT Local & Global Time */
  un_CAN_CH_TTCTC_t                unTTCTC;            /*!< 0x00000138 TT Cycle Time & Count */
  un_CAN_CH_TTCPT_t                unTTCPT;            /*!< 0x0000013C TT Capture Time */
  un_CAN_CH_TTCSM_t                unTTCSM;            /*!< 0x00000140 TT Cycle Sync Mark */
  uint32                         au32Reserved7[15];
} stc_CAN_CH_M_TTCAN_t;                                /*!< Size = 384 (0x180) */

/**
  * \brief FIFO wrapper around M_TTCAN 3PIP, to enable DMA (CAN_CH)
  */
typedef struct stc_CAN_CH{
  stc_CAN_CH_M_TTCAN_t             M_TTCAN;            /*!< 0x00000000 TTCAN 3PIP, includes FD */
  un_CAN_CH_RXFTOP_CTL_t           unRXFTOP_CTL;       /*!< 0x00000180 Receive FIFO Top control */
  uint32                         au32Reserved[7];
  un_CAN_CH_RXFTOP0_STAT_t         unRXFTOP0_STAT;     /*!< 0x000001A0 Receive FIFO 0 Top Status */
  uint32                         u32Reserved1;
  un_CAN_CH_RXFTOP0_DATA_t         unRXFTOP0_DATA;     /*!< 0x000001A8 Receive FIFO 0 Top Data */
  uint32                         u32Reserved2;
  un_CAN_CH_RXFTOP1_STAT_t         unRXFTOP1_STAT;     /*!< 0x000001B0 Receive FIFO 1 Top Status */
  uint32                         u32Reserved3;
  un_CAN_CH_RXFTOP1_DATA_t         unRXFTOP1_DATA;     /*!< 0x000001B8 Receive FIFO 1 Top Data */
  uint32                         au32Reserved4[17];
} stc_CAN_CH_t;                                        /*!< Size = 512 (0x200) */

/**
  * \brief CAN Controller (CAN)
  */
typedef struct stc_CAN{
  stc_CAN_CH_t                     CH[8];              /*!< 0x00000000 FIFO wrapper around M_TTCAN 3PIP, to enable DMA */
  un_CAN_CTL_t                     unCTL;              /*!< 0x00001000 Global CAN control register */
  un_CAN_STATUS_t                  unSTATUS;           /*!< 0x00001004 Global CAN status register */
  un_CAN_DESIGN_CFG_t              unDESIGN_CFG;       /*!< 0x00001008 Design time configuration */
  uint32                         u32Reserved1;
  un_CAN_INTR0_CAUSE_t             unINTR0_CAUSE;      /*!< 0x00001010 Consolidated interrupt0 cause register */
  un_CAN_INTR1_CAUSE_t             unINTR1_CAUSE;      /*!< 0x00001014 Consolidated interrupt1 cause register */
  uint32                         au32Reserved2[26];
  un_CAN_ECC_CTL_t                 unECC_CTL;          /*!< 0x00001080 ECC control */
  un_CAN_ECC_ERR_INJ_t             unECC_ERR_INJ;      /*!< 0x00001084 ECC error injection */

} stc_CAN_t;                                           /*!< Size = 4232 (0x1088) */

/*==================[internal function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_RaGetCccrByte
 **
 ** Returns the lower byte of CCCR.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \return                   lower byte of CCCR.
 */
static FUNC(uint8, AUTOMATIC) Can_RaGetCccrByte
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
);

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal constants]====================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_RaClearInterruptFlag
 **
 ** Clear the Interrupt Register (IR).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **                     Each bit corresponds to an interrupt condition (see HWM IR).
 **                     Value 1 clears the corresponding interrupt flag, value 0
 **                     has no effect.
 **
 */
FUNC(void, AUTOMATIC) Can_RaClearInterruptFlag
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unIR.u32Register = Value;
}

/** \brief Can_RaClearNewDataFlag
 **
 ** Clear the New Data (NDAT1, NDAT2) registers for a given index.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BufferIndex   The index (zero based) of the buffer that shall be
 **                           cleared.
 **                           0..63: the corresponding buffer's new data flag is
 **                           cleared,
 **                           >63: nothing happens.
 **
 */
FUNC(void, AUTOMATIC) Can_RaClearNewDataFlag
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BufferIndex
)
{
  /* Writing 1 clears the flag, writing 0 has no effect.
     If BufferIndex is out of range, the value will be 0. */
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unNDAT1.u32Register = (uint32)1u << BufferIndex;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unNDAT2.u32Register = (uint32)1u << (BufferIndex - 32u);
}

/** \brief Can_RaClearEventFifoCfg
 **
 ** Set to clear the TX event FIFO configuration register (TXEFC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value         Set the value to clear the TX event FIFO configuration 
 **                           register (TXEFC).
 **
 */
FUNC(void, AUTOMATIC) Can_RaClearEventFifoCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXEFC.u32Register = Value;
}

/** \brief Can_RaClearTxBufferCfg
 **
 ** Set to clear the TX Buffer Configuration register (TXBC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value         Set the value to clear the TX Buffer Configuration 
 **                           register (TXBC).
 **
 */
FUNC(void, AUTOMATIC) Can_RaClearTxBufferCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBC.u32Register = Value;
}

/** \brief Can_RaClearRxFifoCfg
 **
 ** Set to clear the RX FIFO0 or 1 Configuration register (RXF0C, RXF1C).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoIndex     Selects the index of the FIFO to be set.
 **                           0: RX FIFO 0, 1: RX FIFO 1
 ** \param [in] Value         Set the value to clear the RX FIFO0 or 1 Configuration 
 **                           register (RXF0C, RXF1C).
 **
 */
FUNC(void, AUTOMATIC) Can_RaClearRxFifoCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoIndex,
  VAR(uint32, AUTOMATIC) Value
)
{
  if (FifoIndex == CAN_RA_RX_KIND_FIFO0)
  {
    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0C.u32Register = Value;
  }
  else
  {
    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1C.u32Register = Value;
  }
}

/** \brief Can_RaClearMode
 **
 ** Set CC control register (CCCR) to default value.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(void, AUTOMATIC) Can_RaClearMode
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_CCCR_t localCCCR = {0u};
  localCCCR.stcField.u1INIT = 1u;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;
}

/** \brief Can_RaGetEventFifoFillLevel
 **
 ** Polls the TX Event FIFO Fill Level (TXEFS_EFFL).
 **
 ** \return   Indicates FIFO Fill Level in range 0..32.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetEventFifoFillLevel
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_TXEFS_t localTXEFS;
  
  localTXEFS.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXEFS.u32Register;
  return localTXEFS.au8Byte[0u];
}

/** \brief Can_RaGetEventFifoGetIndex
 **
 ** Polls the TX Event FIFO Get Index (TXEFS_EFGI).
 **
 ** \return   Indicates FIFO Get Index 0..31.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetEventFifoGetIndex
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_TXEFS_t localTXEFS;
  
  localTXEFS.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXEFS.u32Register;
  return localTXEFS.au8Byte[1u];
}

/** \brief Can_RaGetInterruptFlags
 **
 ** Polls the interrupt flags (IR).
 **
 ** \return   Value of IR register. Each bit corresponds to an interrupt condition.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint32, AUTOMATIC) Can_RaGetInterruptFlags
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  return CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unIR.u32Register;
}

/** \brief Can_RaGetErrorPassiveStatus
 **
 ** Polls the Error Passive Counters (TEC (TX counter) and RP (RX flag)) register
 ** flag of the Error Counter Register (ECR).
 **
 ** \return   Returns 0 if Error Passive State is NOT entered. Returns 1 if the
 **           Error Passive State is entered.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetErrorPassiveStatus
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  uint8 result;
  un_CAN_CH_ECR_t localECR;
  
  localECR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unECR.u32Register;
  if ((localECR.stcField.u1RP != 0u) || (localECR.stcField.u8TEC > 127u))
  {
    /* TX error frame counter or RX error frame counter reaches the limit of 128
     * frames. Controller enters Error Passive Status. */
    result = 1u;
  }
  else
  {
    result = 0u;
  }
  return result;
}

/** \brief Can_RaGetNewDataIndex
 **
 ** Polls the New Data (NDAT1 and NDAT2) register and returns the highest index of a
 ** buffer that has new data.
 **
 ** \return   0..63: Index of an RX buffer that has new data (the behavior of non-
 **           configured buffers is undefined),
 **           >63: there is no new data.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetNewDataIndex
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  uint8 result;
  result = (uint8)Can_BitSearch(CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unNDAT2.u32Register);
  if (result >= 32u)
  {
    result = (uint8)Can_BitSearch(CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unNDAT1.u32Register);
    if (result >= 32u)
    {
      /* nothing found. */
      result = 255u;
    }
    else
    {
      /* Can_Bitsearch counts number of zeros on MSB side. */
      result = 31u - result;
    }
  }
  else
  {
    /* Can_Bitsearch counts number of zeros on MSB side. */
    result = 63u - result;
  }
  return result;
}

/** \brief Can_RaGetRxFifoFillLevel
 **
 ** Polls the RX FIFO 0/1 Fill Level (RXF0S_F0FL, RXF1S_F1FL).
 **
 ** \return Indicates FIFO Fill Level in range 0..64.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1,
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetRxFifoFillLevel
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoIndex
)
{
  uint8 FifoLevel;
  
  /* F0FL/F1FL are the first byte in that word. */
  if (FifoIndex == CAN_RA_RX_KIND_FIFO0)
  {
    un_CAN_CH_RXF0S_t localRXF0S;
    localRXF0S.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0S.u32Register;
    FifoLevel = localRXF0S.au8Byte[0u];
  }
  else
  {
    un_CAN_CH_RXF1S_t localRXF1S;
    localRXF1S.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1S.u32Register;
    FifoLevel = localRXF1S.au8Byte[0u];
  }

  return FifoLevel;
}

/** \brief Can_RaGetRxFifoGetIndex
 **
 ** Polls the RX FIFO 0/1 Get Index (RXF0S_F0G, RXF1S_F1G).
 **
 ** \return Indicates FIFO Get Index 0..63.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1,
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetRxFifoGetIndex
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoIndex
)
{
  uint8 GetIndex;
  
  /* F0GI/F1GI are the second byte in that word. */
  if (FifoIndex == CAN_RA_RX_KIND_FIFO0)
  {
    un_CAN_CH_RXF0S_t localRXFOS;
    localRXFOS.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0S.u32Register;
    GetIndex = localRXFOS.au8Byte[1u];
  }
  else
  {
    un_CAN_CH_RXF1S_t localRXF1S;
    localRXF1S.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1S.u32Register;
    GetIndex = localRXF1S.au8Byte[1u];
  }
  
  return GetIndex;
}

/** \brief Can_RaGetStatus
 **
 ** Polls the CC control register (CCCR).
 **
 ** \return   Value of CCCR register.
 **           Bit 0: initialization status (1: initialization mode, 0: normal operation)
 **           Bit 5: bus monitoring mode (1: bus monitoring mode, 0: normal mode)
 **           For other bits see HWM.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint32, AUTOMATIC) Can_RaGetStatus
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  return CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register;
}

/** \brief Can_RaGetTxBufferCancelled
 **
 ** Polls the TX Buffer Transmission Occurred (TXBTO) and TX Buffer Cancellation
 ** Finished (TXBCF) to calculate whether the buffer was successfully sent or
 ** canceled.
 ** 
 ** Precondition: The function assumes that sending and canceling of the buffer was
 **               requested before and that the buffer is not pending for transmission
 **               anymore.
 **
 ** \return   Indicates the dedicated buffer canceled status:
 **           FALSE: Buffer was not canceled (i.e. either it was sent before cancel
 **                  request or it was not requested for cancellation.),
 **           TRUE: Buffer was canceled and transmission did not occur.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BufferIndex   Selects the dedicated TX buffer that shall be checked.
 **                           The index is zero based. Indices of not existing buffers
 **                           return undefined values.
 **
 */
FUNC(boolean, AUTOMATIC) Can_RaGetTxBufferCancelled
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BufferIndex
)
{
  uint32 canceled =    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBCF.u32Register 
                    & ~CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBTO.u32Register;
  return (uint8)((canceled >> BufferIndex) & 1u);
}

/** \brief Can_RaGetTxFifoPutIndex
 **
 ** Polls the TX FIFO Put Index (TXFQS_TFQPI).
 **
 ** \return   Indicates FIFO Put Index 0..32.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetTxFifoPutIndex
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_TXFQS_t localTXFQS;
  
  /* The byte contains TFQF (FIFO full flag) also.
   * Therefore only the 5 bits representing only TFQPI are read. */
  localTXFQS.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXFQS.u32Register;
  return localTXFQS.stcField.u5TFQPI;
}

/** \brief Can_RaGetPayloadLengthErrorStatus
 **
 ** Polls the Protocol status register (PSR).
 **
 ** \return Value of Last Error Code(LEC).
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaGetPayloadLengthErrorStatus
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_PSR_t localPSR;
  
  localPSR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unPSR.u32Register;
  return localPSR.stcField.u3LEC;
}

/** \brief Can_RaGetBusOffStatus
 **
 ** Get the status of BusOff event.
 **
 ** \return Value of BusOff state
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(boolean, AUTOMATIC) Can_RaGetBusOffStatus
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_PSR_t localPSR;
  
  localPSR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unPSR.u32Register;
  return localPSR.stcField.u1BO;
}

/** \brief Can_RaGetRxFifo0TopData
 **
 ** When enabled (RXFTOP_CTL.F0TPE=1) read data from MRAM at location current
 ** FIFO0 top address.
 **
 ** \return   Receive FIFO 0 top data.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint32, AUTOMATIC) Can_RaGetRxFifo0TopData
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  return CANFD(BaseAddress).CH[ChannelNum].unRXFTOP0_DATA.u32Register;
}

/** \brief Can_RaGetRxFifo1TopData
 **
 ** When enabled (RXFTOP_CTL.F1TPE=1) read data from MRAM at location current
 ** FIFO1 top address.
 **
 ** \return   Receive FIFO 1 top data.
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint32, AUTOMATIC) Can_RaGetRxFifo1TopData
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  return CANFD(BaseAddress).CH[ChannelNum].unRXFTOP1_DATA.u32Register;
}

/** \brief Can_RaGetEccControl
 **
 ** Get ECC control Register.
 **
 ** \return   ECC control enable/disable status
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 **
 */
FUNC(boolean, AUTOMATIC) Can_RaGetEccControl
(
  VAR(uint32, AUTOMATIC) BaseAddress
)
{
  un_CAN_ECC_CTL_t localECC_CTL;
  
  localECC_CTL.u32Register = CANFD(BaseAddress).unECC_CTL.u32Register;
  
  return localECC_CTL.stcField.u1ECC_EN;
}

/** \brief Can_RaGetInterruptEnable
 **
 ** Get the Interrupt Enable Register (IE).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint32, AUTOMATIC) Can_RaGetInterruptEnable
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  return CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unIE.u32Register;
}

/** \brief Can_RaGetInterruptLine
 **
 ** Get the Interrupt Line Select Register (ILS).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(uint32, AUTOMATIC) Can_RaGetInterruptLine
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  return CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unILS.u32Register;
}

/** \brief Can_RaSetNominalBitTiming
 **
 ** Sets Bit Timing and Prescaler Register (NBTP) according to the values provided.
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BaudratePrescaler   Sets the Baud Rate Prescaler (NBTP_NBRP). The
 **                                 value by which the oscillator frequency is
 **                                 divided for generating the bit time quanta.
 **                                 The bit time is built up from a multiple of
 **                                 this quanta. Valid values for the Baud Rate
 **                                 Prescaler are 0 to 511. The actual interpretation
 **                                 by the hardware of this value is such that one
 **                                 more than the value programmed here is used.
 ** \param [in] TSeg1   Sets the Time Segment before Sample Point (NBTP_NTSEG1).
 **                     Valid values are 1 to 255. The value 0 must not be used.
 **                     The actual interpretation by the hardware of this value
 **                     is such that one more than the programmed value is used.
 ** \param [in] TSeg2   Sets the Time Segment after Sample Point (NBTP_NTSEG2). Valid
 **                     values are 0 to 127. The actual interpretation by the hardware
 **                     of this value is such that one more than the programmed value
 **                     is used.
 ** \param [in] SyncJumpWidth   Sets the (Re) Synchronization Jump Width (NBTP_NSJW).
 **                             Valid values are 0 to 127. The actual interpretation
 **                             by the hardware of this value is such that one more
 **                             than the value programmed here is used.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetNominalBitTiming
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint16, AUTOMATIC) BaudratePrescaler,
  VAR(uint8, AUTOMATIC)  TSeg1,
  VAR(uint8, AUTOMATIC)  TSeg2,
  VAR(uint8, AUTOMATIC)  SyncJumpWidth
)
{
  un_CAN_CH_NBTP_t nbtpValue = {0u};

  nbtpValue.stcField.u9NBRP   = BaudratePrescaler;
  nbtpValue.au8Byte[1u]       = TSeg1;
  nbtpValue.stcField.u7NTSEG2 = TSeg2;
  nbtpValue.stcField.u7NSJW   = SyncJumpWidth;

  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unNBTP = nbtpValue;
}

/** \brief Can_RaSetEventFifoAck
 **
 ** Writes the TX Event FIFO acknowledge, which indicates that the respective FIFO
 ** index has been read and can be re-used for incoming events.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] MessageIndex   Indicates the index to acknowledge (TXEFA_EFA).
 **                            Values that do not correspond to existing FIFO
 **                            elements cause unpredictable behavior.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetEventFifoAck
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  MessageIndex
)
{
  un_CAN_CH_TXEFA_t localTXEFA;
  
  localTXEFA.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXEFA.u32Register;
  localTXEFA.au8Byte[0] = MessageIndex;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXEFA.u32Register = localTXEFA.u32Register;
}

/** \brief Can_RaSetEventFifoCfg
 **
 ** Sets TX event FIFO Configuration register (TXEFC).
 ** Watermark is unconditionally set to 1.
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoSize   Sets the TX event FIFO Size (it can be different to
 **                        FIFO/Queue size):
 **                        0: No event FIFO,
 **                        1..32: Number of event FIFO elements,
 **                        >32: Values are interpreted as 32.
 ** \param [in] FifoStartAddress   Start Address of the Tx event FIFO in RAM. The 2
 **                                LSBs are truncated to 0.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetEventFifoCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC) FifoSize,
  VAR(uint16, AUTOMATIC) FifoStartAddress
)
{
  un_CAN_CH_TXEFC_t fifoCfg;

  fifoCfg.au16Halfword[0u] = FifoStartAddress;
  fifoCfg.au8Byte[2u]      = FifoSize;
  fifoCfg.au8Byte[3u]      = 1u;

  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXEFC.u32Register = fifoCfg.u32Register;
}

/** \brief Can_RaSetExtendedFilter
 **
 ** Sets the Extended ID Filter Configuration (XIDFC) and Mask (XIDAM). The AND
 ** mask is statically deactivated (i.e. IDs are not modified).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] StartAddress   The offset in bytes from the beginning of the
 **                            message RAM used for the allocation of the extended
 **                            filter list. The 2 LSBs are truncated.
 ** \param [in] Size   Size of the extended filter list in elements.
 **                    Allowed values: 0..64.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetExtendedFilter
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint16, AUTOMATIC) StartAddress,
  VAR(uint8, AUTOMATIC)  Size
)
{
  un_CAN_CH_XIDFC_t filterCfg;
  
  filterCfg.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unXIDFC.u32Register;
  filterCfg.au16Halfword[0u] = StartAddress;
  filterCfg.au8Byte[2u]      = Size;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unXIDFC.u32Register = filterCfg.u32Register;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unXIDAM.u32Register = 0x1FFFFFFFu;
}

/** \brief Can_RaSetDataBitTiming
 **
 ** Sets the data bit timing and prescaler register (DBTP).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BaudratePrescaler   Sets the Baud Rate Prescaler (DBTP_DBRP). The
 **                                 value by which the oscillator frequency is
 **                                 divided for generating the bit time quanta.
 **                                 The bit time is built up from a multiple of
 **                                 this quanta. Valid values for the Baud Rate
 **                                 Prescaler are 0 to 31. The actual
 **                                 interpretation by the hardware of this value
 **                                 is such that one more than the value programmed
 **                                 here is used.
 ** \param [in] TSeg1   Sets the Time Segment before Sample Point (DBTP_DTSEG1).
 **                     Valid values are 1 to 31. The value 0 must not be used.
 **                     The actual interpretation by the hardware of this value
 **                     is such that one more than the programmed value is used.
 ** \param [in] TSeg2   Sets the Time Segment after Sample Point (DBTP_DTSEG2). Valid
 **                     values are 0 to 15. The actual interpretation by the hardware
 **                     of this value is such that one more than the programmed
 **                     value is used.
 ** \param [in] SyncJumpWidth   Sets the (Re) Synchronization Jump Width (DBTP_DSJW).
 **                             Valid values are 0 to 15. The actual interpretation
 **                             by the hardware of this value is such that one more
 **                             than the value programmed here is used.
 ** \param [in] TrcvDelayCompensation   Enable/Disable Transmitter Delay Compensation
 **                                    (DBTP_TDC). Valid values 0..1.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetDataBitTiming
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint16, AUTOMATIC) BaudratePrescaler,
  VAR(uint8, AUTOMATIC)  TSeg1,
  VAR(uint8, AUTOMATIC)  TSeg2,
  VAR(uint8, AUTOMATIC)  SyncJumpWidth,
  VAR(uint8, AUTOMATIC)  TrcvDelayCompensation
)
{
    un_CAN_CH_DBTP_t dbtpValue = {0u};

    dbtpValue.stcField.u5DBRP   = BaudratePrescaler;
    dbtpValue.au8Byte[1u]       = TSeg1;
    dbtpValue.stcField.u4DTSEG2 = TSeg2;
    dbtpValue.stcField.u4DSJW   = SyncJumpWidth;
    dbtpValue.stcField.u1TDC    = TrcvDelayCompensation;

    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unDBTP   = dbtpValue;
}

/** \brief Can_RaSetGlobalFilter
 **
 ** Sets the Global Filter Configuration (GFC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetGlobalFilter
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unGFC.u32Register = Value;
}

/** \brief Can_RaSetInitMode
 **
 ** Sets CC control register (CCCR) bits 0..8. CCCR_INIT and CCCR_CCE are set to 1.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetInitMode
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  uint32 timeout;
  un_CAN_CH_CCCR_t localCCCR;
  
  /* CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.au8Byte[0u]:
     Bit 0: INIT
     Bit 1: CCE  (config change enable)
     Bit 2: ASM  (restricted operation mode
     Bit 3: CSA  (clock stop acknowledge, read-only)
     Bit 4: CSR  (clock stop request)
     Bit 5: MON  (bus monitoring mode)
     Bit 6: DAR  (disable automatic transmission)
     Bit 7: TEST (test mode enable) */
  /* Set first only the INIT bit. */
  localCCCR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register;
  localCCCR.au8Byte[0u] = 1u;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;
  /* Wait until INIT bit is really set to 1.
   * Due to the synchronization mechanism between the two clock domains, there
   * may be a delay until the value written to Initialization CCCR.INIT can be
   * read back (the maximum length of the delay is four Bus clocks plus five
   * CAN clocks). */
  timeout = 5uL + (4uL*64uL);
  while ((Can_RaGetCccrByte(BaseAddress, ChannelNum) != 1u) && (timeout > 0uL))
  {
    timeout--;
  }
  /* Set now additional the CCE bit. CCE could only be set to 1 if INIT is 1. */
  localCCCR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register;
  localCCCR.au8Byte[0u] = 3u;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;
}

/** \brief Can_RaSetInterruptEnable
 **
 ** Sets the Interrupt Enable Register (IE).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **                     Each bit corresponds to an interrupt condition (see HWM IE).
 **                     Value 1 enables the corresponding interrupt, value 0 disables
 **                     it.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetInterruptEnable
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unIE.u32Register = Value;
}

/** \brief Can_RaSetInterruptLine
 **
 ** Sets the Interrupt Line Select Register (ILS).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **                     Each bit corresponds to an interrupt condition (see HWM ILS).
 **                     Value 0 selects interrupt 0, value 1 selects interrupt 1.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetInterruptLine
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unILS.u32Register = Value;
}

/** \brief Can_RaSetInterruptLineEnable
 **
 ** Sets the Interrupt Line Enable Register (ILE).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **                     Each bit corresponds to an interrupt condition (see HWM ILE).
 **                     Value 1 enables the corresponding interrupt, value 0 disables
 **                     it.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetInterruptLineEnable
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unILE.u32Register = Value;
}

/** \brief Can_RaSetNormalFdMode
 **
 ** Sets CC control register (CCCR) bits 0..9. CCCR_INIT and CCCR_CCE are set to 0,
 ** CCCR_FDOE is set to 1, CCCR_MON is set according to parameter BusMonitoringMode,
 ** CCCR_BRSE is set according to parameter BitRateSwitchEnable, the other bits are
 ** set to defaults.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BusMonitoringMode   Sets the CCCR_MON bit according to the LSB of
 **                                 this parameter. The other bits are ignored.
 **                                 0: normal mode
 **                                 1: bus monitoring mode
 ** \param [in] BitRateSwitchEnable   Sets the CCCR_BRSE bit according to the LSB
 **                                   of this parameter. The other bits are ignored.
 **                                   0: bit rate switching disabled
 **                                   1: bit rate switching enabled
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetNormalFdMode
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BusMonitoringMode,
  VAR(uint8, AUTOMATIC)  BitRateSwitchEnable
)
{
    /* CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR:
       * Bit 0:  INIT
       * Bit 1:  CCE  (config change enable)
       * Bit 2:  ASM  (restricted operation mode
       * Bit 3:  CSA  (clock stop acknowledge, read-only)
       * Bit 4:  CSR  (clock stop request)
       * Bit 5:  MON  (bus monitoring mode)
       * Bit 6:  DAR  (disable automatic transmission)
       * Bit 7:  TEST (test mode enable)
       * Bit 8:  FDOE (FD mode enable)
       * Bit 9:  BRSE (Bit rate switching enable)
       * Bit 12: PXHD (Protocol exception handling disable)
       * Bit 13: EFBI (Edge filtering during bus integration)
       * Bit 14: TXP  (Transmit Pause)
       * Bit 15: NISO (Non ISO Operation)
       * Other bits 10..11 and 16..31 are reserved. */

      /* Set control register to default value (switch off all). */
      un_CAN_CH_CCCR_t localCCCR = {0u};

      /* On calling this function the HW and SW is in stopped mode and therefore
       * the INIT and the CCE flag are now 1. To do no read modify write operation
       * and set the other flags in Byte0 (bit 0..7) to zero the INIT and the CCE
       * flag is set to 1 in local structure. These two flags should not changed
       * during writing the other flags due to the requirement that the MON flag
       * is only changeable if INIT and CCE are set. */
      localCCCR.stcField.u1INIT = 1u;
      localCCCR.stcField.u1CCE  = 1u;
      localCCCR.stcField.u1MON_ = BusMonitoringMode;
      /* FD settings */
      localCCCR.stcField.u1FDOE = 1u;
      localCCCR.stcField.u1BRSE = BitRateSwitchEnable;
      CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;

      /* Reset INIT and CCE flag. */
      localCCCR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register;
      localCCCR.stcField.u1CCE  = 0u;
      localCCCR.stcField.u1INIT = 0u;
      CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;
}


/** \brief Can_RaSetNormalMode
 **
 ** Sets CC control register (CCCR) bits 0..8. CCCR_INIT and CCCR_CCE are set to 0,
 ** CCCR_MON is set according to parameter BusMonitoringMode, the other bits are
 ** set to defaults.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BusMonitoringMode   Sets the CCCR_MON bit according to the LSB of
 **                                 this parameter. The other bits are ignored.
 **                                 0: normal mode
 **                                 1: bus monitoring mode
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetNormalMode
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BusMonitoringMode
)
{
  /* CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR:
   * Bit 0:  INIT
   * Bit 1:  CCE  (config change enable)
   * Bit 2:  ASM  (restricted operation mode
   * Bit 3:  CSA  (clock stop acknowledge, read-only)
   * Bit 4:  CSR  (clock stop request)
   * Bit 5:  MON  (bus monitoring mode)
   * Bit 6:  DAR  (disable automatic transmission)
   * Bit 7:  TEST (test mode enable)
   * Bit 8:  FDOE (FD mode enable)
   * Bit 9:  BRSE (Bit rate switching enable)
   * Bit 12: PXHD (Protocol exception handling disable)
   * Bit 13: EFBI (Edge filtering during bus integration)
   * Bit 14: TXP  (Transmit Pause)
   * Bit 15: NISO (Non ISO Operation)
   * Other bits 10..11 and 16..31 are reserved. */

  /* Set control register to default value (switch off all). */
  un_CAN_CH_CCCR_t localCCCR = {0u};

  /* On calling this function the HW and SW is in stopped mode and therefore
   * the INIT and the CCE flag are now 1. To do no read modify write operation
   * and set the other flags in Byte0 (bit 0..7) to zero the INIT and the CCE
   * flag is set to 1 in local structure. These two flags should not changed
   * during writing the MON flag due to the requirement that the MON flag is
   * only changeable if INIT and CCE are set. */
  localCCCR.stcField.u1INIT = 1u;
  localCCCR.stcField.u1CCE  = 1u;
  localCCCR.stcField.u1MON_ = BusMonitoringMode;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;

  /* Reset INIT and CCE flag. */
  localCCCR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register;
  localCCCR.stcField.u1CCE  = 0u;
  localCCCR.stcField.u1INIT = 0u;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register = localCCCR.u32Register;

}

/** \brief Can_RaSetRamWdg
 **
 ** Sets RAM watchdog register (RWD).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetRamWdg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRWD.u32Register = Value;
}

/** \brief Can_RaSetRxBufferCfg
 **
 ** Sets the start address for dedicated RX buffers.
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoStartAddress   Start Address of the dedicated RX buffers in RAM.
 **                                The 2 LSBs are truncated to 0.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetRxBufferCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint16, AUTOMATIC) FifoStartAddress
)
{
  un_CAN_CH_RXBC_t localRXBC;
  
  localRXBC.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXBC.u32Register;
  localRXBC.au16Halfword[0u] = FifoStartAddress;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXBC.u32Register = localRXBC.u32Register;
}

/** \brief Can_RaSetRxElementSize
 **
 ** Sets RX Buffer/FIFO Element Size Configuration register (RXESC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Fifo0ElementSize   Selects the Element Size for FIFO 0:
 **                                0: 8 byte,
 **                                1: 12 byte,
 **                                2: 16 byte,
 **                                3: 20 byte,
 **                                4: 24 byte,
 **                                5: 32 byte,
 **                                6: 48 byte,
 **                                7: 64 byte,
 **                                other: undefined.
 ** \param [in] Fifo1ElementSize   Selects the Element Size for FIFO 1:
 **                                0: 8 byte,
 **                                1: 12 byte,
 **                                2: 16 byte,
 **                                3: 20 byte,
 **                                4: 24 byte,
 **                                5: 32 byte,
 **                                6: 48 byte,
 **                                7: 64 byte,
 **                                other: undefined.
 ** \param [in] BufferElementSize   Selects the Element Size for dedicated RX
 **                                 buffers:
 **                                 0: 8 byte,
 **                                 1: 12 byte,
 **                                 2: 16 byte,
 **                                 3: 20 byte,
 **                                 4: 24 byte,
 **                                 5: 32 byte,
 **                                 6: 48 byte,
 **                                 7: 64 byte,
 **                                 other: undefined.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetRxElementSize
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  Fifo0ElementSize,
  VAR(uint8, AUTOMATIC)  Fifo1ElementSize,
  VAR(uint8, AUTOMATIC)  BufferElementSize
)
{
  un_CAN_CH_RXESC_t value = {0u};
  value.stcField.u3F0DS = Fifo0ElementSize;
  value.stcField.u3F1DS = Fifo1ElementSize;
  value.stcField.u3RBDS = BufferElementSize;
  
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXESC.u32Register = value.u32Register;
}

/** \brief Can_RaSetRxFifoAck
 **
 ** Writes the FIFO acknowledge, which indicates that the respective FIFO index has
 ** been read and can be re-used for incoming messages.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1,
 ** \param [in] MessageIndex   Indicates the the index to acknowledge (RXF0A,
 **                            RXF1A).
 **                            Values that do not correspond to existing FIFO 
 **                            elements cause unpredictable behavior.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetRxFifoAck
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoIndex,
  VAR(uint8, AUTOMATIC)  MessageIndex
)
{
  /* F0A/F1A are the first byte in that word. */
  if (FifoIndex == CAN_RA_RX_KIND_FIFO0)
  {
    un_CAN_CH_RXF0A_t localRXF0A;
    localRXF0A.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0A.u32Register;
    localRXF0A.au8Byte[0u] = MessageIndex;
    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0A.u32Register = localRXF0A.u32Register;
  }
  else
  {
    un_CAN_CH_RXF1A_t localRXF1A;
    localRXF1A.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1A.u32Register;
    localRXF1A.au8Byte[0u] = MessageIndex;
    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1A.u32Register = localRXF1A.u32Register;
  }
}

/** \brief Can_RaSetRxFifoCfg
 **
 ** Sets RX FIFO 0 or 1 Configuration register (RXF0C, RXF1C).
 ** Rx FIFO is unconditionally set to blocking mode. Watermark is unconditionally
 ** set to 1.
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1,
 ** \param [in] FifoSize   Sets theRX FIFO Size:
 **                        0: No FIFO,
 **                        1..64: Number of FIFO elements,
 **                        >64: unspecified.
 ** \param [in] FifoStartAddress   Start Address of the Rx FIFO in RAM. The 2 LSBs
 **                                are truncated to 0.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetRxFifoCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoIndex,
  VAR(uint8, AUTOMATIC)  FifoSize,
  VAR(uint16, AUTOMATIC) FifoStartAddress
)
{
  if (FifoIndex == CAN_RA_RX_KIND_FIFO0)
  {
    un_CAN_CH_RXF0C_t localRXF0C;
    localRXF0C.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0C.u32Register;
    localRXF0C.au16Halfword[0u] = FifoStartAddress;
    localRXF0C.au16Halfword[1u] 
      = ((uint16)FifoSize) | (uint16)((((uint16)1u) << 8u) /* Blocking mode and watermark 1. */);
    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF0C.u32Register = localRXF0C.u32Register;
  }
  else
  {
    un_CAN_CH_RXF1C_t localRXF1C;
    localRXF1C.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1C.u32Register;
    localRXF1C.au16Halfword[0u] = FifoStartAddress;
    localRXF1C.au16Halfword[1u] 
      = ((uint16)FifoSize) | (uint16)((((uint16)1u) << 8u) /* Blocking mode and watermark 1. */);
    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unRXF1C.u32Register = localRXF1C.u32Register;
  }
}

/** \brief Can_RaSetStandardFilter
 **
 ** Sets the Standard ID Filter Configuration (SIDFC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] StartAddress   The offset in bytes from the beginning of the
 **                            message RAM used for the allocation of the standard
 **                            filter list. The 2 LSBs are truncated.
 ** \param [in] Size   The size in elements of the standard filter list. Values
 **                    greater than 128 are interpreted as 128.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetStandardFilter
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint16, AUTOMATIC) StartAddress,
  VAR(uint8, AUTOMATIC)  Size
)
{
  un_CAN_CH_SIDFC_t localSIDFC;
  
  localSIDFC.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unSIDFC.u32Register;
  localSIDFC.au16Halfword[0u] = StartAddress;
  localSIDFC.au8Byte[2u] = Size;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unSIDFC.u32Register = localSIDFC.u32Register;
}

/** \brief Can_RaSetTimeoutCounter
 **
 ** Sets timeout counter register (TOCC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTimeoutCounter
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTOCC.u32Register = Value;
}

/** \brief Can_RaSetTimestampCounter
 **
 ** Sets timestamp counter register (TSCC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTimestampCounter
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTSCC.u32Register = Value;
}

/** \brief Can_RaSetTxAddRequest
 **
 ** Set the Tx Buffer Add Request (TXBAR) for one buffer.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BufferIndex   The index of the Tx Buffer whose send request shall
 **                           be set. index is zero based.
 **                           The flag is set independently of whether the buffer is
 **                           configured or not, values >31 are ignored.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTxAddRequest
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BufferIndex
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBAR.u32Register = ((uint32)1u) << BufferIndex;
}

/** \brief Can_RaSetTxBufferCfg
 **
 ** Sets TX Buffer Configuration register (TXBC).
 ** Tx FIFO/Queue mode is unconditionally set to Queue mode. If the sum of Queue
 ** and Dedicated Buffer elements exceeds 32, the behavior is undefined.
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoSize   Sets theTX FIFO Size:
 **                        0: No FIFO,
 **                        1..32: Number of FIFO elements,
 **                        >32: unspecified.
 ** \param [in] BufferSize   Sets the size of the dedicated TX buffers:
 **                          0: No dedicated TX buffers,
 **                          1..32: Number of dedicated TX buffer elements,
 **                          >32: unspecified.
 ** \param [in] BufferStartAddress   Start Address of the dedicated Tx Buffers in
 **                                  RAM. The 2 LSBs are truncated to 0.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTxBufferCfg
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoSize,
  VAR(uint8, AUTOMATIC)  BufferSize,
  VAR(uint16, AUTOMATIC) BufferStartAddress
)
{
  un_CAN_CH_TXBC_t fifoCfg = {0u};

  fifoCfg.stcField.u1TFQM  = 1u;
  fifoCfg.stcField.u6TFQS  = FifoSize;
  fifoCfg.au8Byte[2u]      = BufferSize;
  fifoCfg.au16Halfword[0u] = BufferStartAddress;
  
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBC.u32Register = fifoCfg.u32Register;
}

/** \brief Can_RaSetTxCancellationInterruptEnable
 **
 ** Sets the Tx Buffer Cancellation Finished Interrupt Enable Register (TXBCIE).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **                     Each bit corresponds to an interrupt condition (see HWM IE).
 **                     Value 1 enables the corresponding interrupt, value 0
 **                     disables it.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTxCancellationInterruptEnable
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBCIE.u32Register = Value;
}

/** \brief Can_RaSetTxCancelRequest
 **
 ** Set the Tx Buffer Cancellation Request (TXBCR) for one buffer.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BufferIndex   The index of the dedicated Tx Buffer whose
 **                           cancellation request shall be set. Index is zero
 **                           based. The flag is set independently of whether the
 **                           buffer is configured or not, values >31 are ignored.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTxCancelRequest
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BufferIndex
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBCR.u32Register = ((uint32)1u) << BufferIndex;
}

/** \brief Can_RaSetTxElementSize
 **
 ** Sets TX Buffer/FIFO Element Size Configuration register (TXESC).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] BufferElementSize   Selects the Element Size for the TX FIFO and
 **                                 dedicated buffers (both have same size):
 **                                 0: 8 byte,
 **                                 1: 12 byte,
 **                                 2: 16 byte,
 **                                 3: 20 byte,
 **                                 4: 24 byte,
 **                                 5: 32 byte,
 **                                 6: 48 byte,
 **                                 7: 64 byte,
 **                                 other: undefined.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTxElementSize
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  BufferElementSize
)
{
  un_CAN_CH_TXESC_t localTXESC;
  
  localTXESC.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXESC.u32Register;
  localTXESC.au8Byte[0u] = BufferElementSize;
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXESC.u32Register = localTXESC.u32Register;
}

/** \brief Can_RaSetTxTransmissionInterruptEnable
 **
 ** Sets the Tx Buffer Transmission Interrupt Enable Register (TXBTIE).
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **                     Each bit corresponds to an interrupt condition (see HWM IE).
 **                     Value 1 enables the corresponding interrupt, value 0
 **                     disables it.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTxTransmissionInterruptEnable
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint32, AUTOMATIC) Value
)
{
  CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTXBTIE.u32Register = Value;
}

/** \brief Can_RaSetTransmitterDelayCompensationOffset
 **
 ** Sets transmitter delay compensation offset register (TDCO).
 ** 
 ** Precondition: The hw must be in init mode.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] Value   The value that will be written to the register.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetTransmitterDelayCompensationOffset
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  Value
)
{
    /* Set all bits to zero and therefore disable filter window feature. */
    un_CAN_CH_TDCR_t localTdcr = {0u};

    /* Set transmitter delay compensation offset value */
    localTdcr.au8Byte[1u] = Value;

    CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unTDCR.u32Register = localTdcr.u32Register;
}

/** \brief Can_RaSetRxFifoTopPointer
 **
 ** Sets RX FIFO 0 or 1 Top Pointer register (RXFTOP_CTL).
 ** This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA)
 ** and message word counter.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \param [in] FifoIndex   Selects the index of the FIFO to be set.
 **                         0: RX FIFO 0,
 **                         1: RX FIFO 1,
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetRxFifoTopPointer
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum,
  VAR(uint8, AUTOMATIC)  FifoIndex,
  VAR(uint32, AUTOMATIC)  Value
)
{
  un_CAN_CH_RXFTOP_CTL_t localRXFTOPCTL;

  localRXFTOPCTL.u32Register = CANFD(BaseAddress).CH[ChannelNum].unRXFTOP_CTL.u32Register;
  if (FifoIndex == CAN_RA_RX_KIND_FIFO0)
  {
    localRXFTOPCTL.stcField.u1F0TPE = Value;
  }
  else
  {
    localRXFTOPCTL.stcField.u1F1TPE = Value;
  }
  CANFD(BaseAddress).CH[ChannelNum].unRXFTOP_CTL.u32Register = localRXFTOPCTL.u32Register;
}

/** \brief Can_RaSetEccControl
 **
 ** Set ECC control Register.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] Value   The value sets enable/disable of ECC control of ECC_CTL register.
 **
 */
FUNC(void, AUTOMATIC) Can_RaSetEccControl
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(boolean, AUTOMATIC) Value
)
{
  un_CAN_ECC_CTL_t localECC_CTL;
  
  localECC_CTL.u32Register = CANFD(BaseAddress).unECC_CTL.u32Register;
  localECC_CTL.stcField.u1ECC_EN = Value;
  
  CANFD(BaseAddress).unECC_CTL.u32Register = localECC_CTL.u32Register;
}

/** \brief Can_RaReadByteMRAM
 **
 ** Read 1 byte from MessageRam.
 ** 
 ** \return   Core release register value.
 **
 ** \param [in] BytePtr   Pointer to the message RAM.
 ** 
 ** \param [in] Index   Index of BytePtr that points to MessageRam.
 **
 */
FUNC(uint8, AUTOMATIC) Can_RaReadByteMRAM
(
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) BytePtr, 
  VAR(uint16, AUTOMATIC)               Index
)
{
  /* Deviation from MISRA-C:2004 Rule 11.4; REFERENCE - ISO:C90-6.3.4 Cast Operators - Semantics:, 
     MISRA-C:2012 Rule-11.3
     Casting to different object pointer type.
     Justification: The elements in message RAM have to be 32-bit aligned as a hardware restriction
     of the CAN FD anyway. Hence byte-wise access to an address that is not 
     32-bit aligned would not avoid a fault. Therefore the type can be converted without additional risk. */
  /* Deviation from MISRA-C:2012 Rule-11.3; Pointer cast to stricter alignment.
     Justification: It is a pointer to the base address of the message RAM, and is implemented so that it is placed
     in 4-byte alignment. */
  /* PRQA S 310,3305 1 */
  P2CONST(uint32, AUTOMATIC, AUTOMATIC) wordPtr = (P2CONST(uint32, AUTOMATIC, AUTOMATIC)) BytePtr;
  uint32 wordData = wordPtr[Index >> 2u];
  return (uint8)((wordData >> (8u * (Index & 3u))) & 0xFFu);
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_RaGetCccrByte
 **
 ** Returns the lower byte of CCCR.
 **
 ** \param [in] BaseAddress   Base address of the CAN FD macro's register structure.
 ** \param [in] ChannelNum    Channel number of the CAN FD macro's register structure.
 ** \return                   lower byte of CCCR.
 */
static FUNC(uint8, AUTOMATIC) Can_RaGetCccrByte
(
  VAR(uint32, AUTOMATIC) BaseAddress,
  VAR(uint8, AUTOMATIC)  ChannelNum
)
{
  un_CAN_CH_CCCR_t localCCCR;
  
  localCCCR.u32Register = CANFD(BaseAddress).CH[ChannelNum].M_TTCAN.unCCCR.u32Register;
  return localCCCR.au8Byte[0u];
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[end of file]===========================================*/
