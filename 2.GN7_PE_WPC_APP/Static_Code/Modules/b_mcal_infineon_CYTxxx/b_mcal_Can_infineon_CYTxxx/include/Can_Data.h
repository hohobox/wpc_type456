/** \brief Can_Data.h
 **
 ** Interface to data that is depending on the configuration or any type or
 ** data imported from another module.
 ** 
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef CAN_DATA_H_INCLUDED
#define CAN_DATA_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Can_GeneralTypes.h>
#include <Can_ControllerManager.h>

/*==================[macros]================================================*/

/** Value used to set a slot in the PduIdBuffer as free (not used). The value is
 all bits are 1. The type PduIdType is a configurable unsigned type and has not
 a fixed size. Therefore the value is set by the one's complement of the cast 0. */
#define CAN_DATA_FREE_PDUID_BUFFER_SLOT ((PduIdType)(~((PduIdType)0)))

/*==================[type definitions]======================================*/

/** \brief struct Can_RxHandleMappingType
 **
 ** This type is used to store the mapping of a HRH to a hardware object
 ** (controller and buffer).
 */
typedef struct can_rxhandlemappingtype_struct
{
  /** The index of the controller where the HRH is allocated. */
  VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex;
  /** The unique object identifier to identify the Hardware object. */
  VAR(Can_HwHandleType, TYPEDEF) RxHwHandle;
  /** This is the filter index which filter has detected the message. The filter
   *  index has only 7 bit. The MSB is set for extended messages. With this index
   *  a search to the allocated HRH is possible, if the order of the filters in
   *  Message RAM is in the order lower CAN IDs first and first all standard IDs
   *  and then extended IDs. This order have to match to the initialization order. */
  VAR(Can_ControllerRxHandleType, TYPEDEF) RxHandle;
  /** Flag indicating whether it is an RxHandler dedicated to pretended 
   *  networking mode. */
  VAR(boolean, TYPEDEF) IcomDedicatedEnable;
} Can_RxHandleMappingType;

/** \brief struct Can_TxHandleMappingType
 **
 ** This type is used to store the mapping of a HTH to a hardware object
 ** (controller and buffer).
 */
typedef struct can_txhandlemappingtype_struct
{
  /** The index of the controller where the HTH is allocated. */
  VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex;
  /** This is the index pointed to right position in the Message Queue. */
  VAR(uint32, TYPEDEF) QueueStartIndex;
  /** Length of the Object message queue. */
  VAR(uint32, TYPEDEF) QueueLength;
  /** Enables the possibility to request the data for this HW object with the
   *  CanIf_TriggerTransmit from CanIf instead of getting the data by call of
   *  Can_Write. */
  VAR(boolean, TYPEDEF) TriggerTransmitEnable;
  /** Value to initialize unused bytes in a transmit message, when the
   *  PduInfo->SduLength does not match possible DLC values and the driver have
   *  to use the next higher valid DLC for transmission. */
  VAR(uint8, TYPEDEF) PaddingValue;
  /** This is the index of the buffer in scope of the controller, where the HTH
   *  is allocated.
   *  0..CAN_CONTROLLER_TX_BUFFER_MAX is a dedicated buffer,
   *  CAN_CONTROLLER_TX_FIFO is the FIFO. */
  VAR(uint8, TYPEDEF) TxHandle;
} Can_TxHandleMappingType;

/** \brief struct Can_ConfigType
 **
 ** This is the type of the external data structure containing the overall
 ** initialization data for the CAN driver and SFR settings affecting all
 ** controllers. Furthermore it contains pointers to controller configuration
 ** structures. The contents of the initialization data structure are CAN hardware
 ** specific.
 */
typedef struct can_configtype_struct
{
  /** Pointer to an array of controller configs. */
  P2CONST(Can_ControllerConfigType, TYPEDEF, TYPEDEF) Can_ControllerConfigsPtr;
  /** Pointer to an array of controller state data */
  P2VAR(Can_ControllerStateDataType, TYPEDEF, TYPEDEF) Can_ControllerStatesPtr;
  /** Pointer to an array of Rx handle mappings configs. */
  P2CONST(Can_RxHandleMappingType, TYPEDEF, TYPEDEF) Can_RxHandleMappingsPtr;
  /** Pointer to an array of Tx handle mappings configs. */
  P2CONST(Can_TxHandleMappingType, TYPEDEF, TYPEDEF) Can_TxHandleMappingsPtr;
  /** Pointer to an array of Tx message buffer. */
  P2VAR(PduIdType, TYPEDEF, TYPEDEF) Can_PduIdBufferPtr;
  /** Pointer to an array of Icom controller configs. */
  P2CONST(Can_ControllerIcomConfigType, TYPEDEF, TYPEDEF) Can_ControllerIcomConfigsPtr;
  /** Pointer to an array of Icom Rx message counter. */
  P2VAR(uint16, TYPEDEF, TYPEDEF) Can_IcomRxMessageCountersPtr;
  /** Pointer to an array of interrupt channel to controller id list. */
  P2CONST(Can_ControllerIdType, TYPEDEF, TYPEDEF) Can_InterruptToControllerListPtr;
  /** Number of controllers in the array pointed to by ControllerCfgsPtr. */
  VAR(uint8, TYPEDEF) NumberOfControllers;
  /** Number of Rx handle mappings in the array pointed to by Can_RxHandleMappingsPtr. */
  VAR(Can_HwHandleType, TYPEDEF) NumberOfRxHandleMappings;
  /** Number of Rx handles */
  VAR(Can_HwHandleType, TYPEDEF) NumberOfRxHandles;
  /** Number of Tx handle mappings in the array pointed to by Can_TxHandleMappingsPtr. */
  VAR(uint8, TYPEDEF) NumberOfTxHandleMappings;
  /** Number of Tx message buffer in the array pointed to by Can_PduIdBufferPtr. */
  VAR(uint8, TYPEDEF) NumberOfTxBuffers;
  /** Number of Icom configuration in the array pointed to by Can_ControllerIcomConfigsPtr. */
  VAR(uint8, TYPEDEF) NumberOfIcomConfigs;
  /** Number of interrupt channel to controller list in the array pointed to by
   *  Can_InterruptToControllerListPtr. */
  VAR(uint8, TYPEDEF) NumberOfInterruptToControllerLists;
} Can_ConfigType;

/*==================[external function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

/** \brief Can_DataSetControllerConfig
 **
 ** Set a pointer to the controller config.
 **
 ** \param [in] Config   Pointer to the controller config structure pointer.
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataSetControllerConfig
(
  P2CONST(Can_ConfigType, AUTOMATIC, AUTOMATIC) Config
);

/** \brief Can_DataGetNumberOfControllerConfig
 **
 ** Returns a number of the controller config.
 **
 ** \return   Number of the controller config.
 **
 */
extern FUNC(uint8, AUTOMATIC) Can_DataGetNumberOfControllerConfig(void);

/** \brief Can_DataGetControllerConfig
 **
 ** Returns a pointer to the controller config.
 **
 ** \return   Pointer to the controller config structure.
 **           NULL_PTR if the id is not in range.
 ** \param [in] ControllerIndex   Index of the controller whose config shall be
 **                               retrieved.
 **
 */
extern FUNC_P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) Can_DataGetControllerConfig
(
  VAR(Can_ControllerIdType, AUTOMATIC) ControllerIndex
);

/** \brief Can_DataGetControllerIcomConfig
 **
 ** Returns a pointer to the controller config.
 **
 ** \return   Pointer to the controller config structure.
 **           NULL_PTR if the id is not in range.
 ** \param [in] ControllerIndex   Index of the controller whose config shall be
 **                               retrieved.
 **
 */
extern FUNC_P2CONST(Can_ControllerIcomConfigType, AUTOMATIC, AUTOMATIC) Can_DataGetControllerIcomConfig
(
  VAR(IcomConfigIdType, AUTOMATIC) IcomConfigId
);

/** \brief Can_DataGetControllerStateData
 **
 ** Returns a pointer to the controller state data.
 **
 ** \return   Pointer to the controller state data structure.
 **           NULL_PTR if the id is not in range.
 ** \param [in] ControllerIndex   Index of the controller whose state data shall be
 **                               retrieved.
 **
 */
extern FUNC_P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) Can_DataGetControllerStateData
(
  VAR(Can_ControllerIdType, AUTOMATIC) ControllerIndex
);

/** \brief Can_DataGetIcomRxMessageCountersPtr
 **
 ** Returns a pointer to the Can_IcomRxMessageCounters array data.
 **
 ** \return   pointer to the Can_IcomRxMessageCounters array data.
 **           NULL_PTR if the CAN_CFG_NUMBER_OF_ICOM_RX_MESSAGES is not defined.
 ** \param [in] IcomConfigId   Index of the controller whose state data shall be
 **                            retrieved.
 **
 */
extern FUNC_P2VAR(uint16, AUTOMATIC, AUTOMATIC) Can_DataGetIcomRxMessageCountersPtr
(
  VAR(IcomConfigIdType, AUTOMATIC) IcomConfigId
);

/** \brief Can_DataGetHwCompatibilityList
 **
 ** Retrieves the pointer to the HW compatibility list and in second parameter the
 ** number of list entries.
 **
 ** \param [out] HwCompatibilityListPtrPtr   Pointer to the HwCompatibilityList.
 ** \param [out] HwCompatibilityListSizePtr   Returns number of list entries in
 **                                           HwCompatibilityList.
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataGetHwCompatibilityList
(
  P2VAR(P2CONST(uint32, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) HwCompatibilityListPtrPtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) HwCompatibilityListSizePtr
);

/** \brief Can_DataGetTxPduId
 **
 ** Reads the swPduId (whose type is imported from ComStackTypes) that was
 ** previously stored by Can_StorePduId for reference in the Tx confirmation. The
 ** item is identified by PduIdBufferIndex.
 **
 ** \return   The PduId that was stored.
 ** \param [in] PduIdBufferIndex   Index of the PduId buffer where the message was
 **                                stored. The valid range depends on amount of
 **                                configured CAN controllers.
 **
 */
extern FUNC(PduIdType, AUTOMATIC) Can_DataGetTxPduId
(
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex
);

/** \brief Can_DataReset
 **
 ** Resets all variables to initial values (0).
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataReset(void);

/** \brief Can_DataStoreTxPduId
 **
 ** Stores the swPduId (whose type is imported from ComStackTypes) of a TX
 ** message for later reference in the TX confirmation. The item is identified by
 ** PduIdBufferIndex.
 **
 ** \param [in] PduIdBufferIndex   Index of the PduIdTX buffer where the message
 **                                was stored. Valid range depends on configured
 **                                CAN Controller.
 ** \param [in] PduId   The PduId that shall be stored.
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataStoreTxPduId
(
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  VAR(PduIdType, AUTOMATIC) PduId
);

/** \brief Can_DataTranslateRxHandle
 **
 ** Translates the controller ID and RX object handle index to HW handle (HRH).
 **
 ** \return   E_OK: Translation was successful, the output parameters are set.
 **           E_NOT_OK: The provided HW handle does not correspond to a hardware
 **                     entity, the output parameters cannot be used.
 ** \param [in] ControllerIndex   ControllerId that corresponds to the HW handle.
 ** \param [in] RxHandle   RX object handle.
 ** \param [in] IsPretended   Flag indicating whether pretended networking mode 
 **                           is enable.
 ** \param [out] RxHwHandlePtr   Pointer to the RX HW handle that was received.
 **
 */
extern FUNC(Std_ReturnType, AUTOMATIC) Can_DataTranslateRxHandle
(
  VAR(Can_ControllerIdType, AUTOMATIC) ControllerIndex,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) RxHandle,
  VAR(boolean, AUTOMATIC) IsPretended,
  P2VAR(Can_HwHandleType, AUTOMATIC, AUTOMATIC) RxHwHandlePtr
);

/** \brief Can_DataTranslateTxHandle
 **
 ** Translates TX HW handle (HTH) to the controller ID and TX object handle index.
 **
 ** \return   CAN_OK: Translation was successful, the output parameters are set.
 **           CAN_NOT_OK: The provided HW handle does not correspond to a hardware
 **                       entity, the output parameters cannot be used.
 **           CAN_BUSY: No free slot in message queue, the output parameters cannot
 **                     be used.
 ** \param [in] TxHwHandle   The TX HW handle that shall be translated.
 ** \param [out] ControllerIndexPtr   Pointer to the variable that will be set to
 **                                   the ControllerId that corresponds to the HW
 **                                   handle.
 ** \param [out] PduIdBufferIndexPtr   Pointer to the variable that will be set to
 **                                    the PduId buffer index.
 ** \param [out] TriggerTransmitEnablePtr   Pointer to the variable that will be
 **                                         set to the TriggerTransmitEnable value
 **                                         configured for this HW object.
 ** \param [out] PaddingValuePtr   Pointer to the variable that will be set to the
 **                                PaddingValue value configured for this HW object.
 ** \param [out] TxHandlePtr   Returns in this parameter the buffer handle for the
 **                            TX message. Possible values are only 0..31 and
 **                            CAN_CONTROLLER_TX_FIFO.
 **
 */
extern FUNC(Can_ReturnType, AUTOMATIC) Can_DataTranslateTxHandle
(
  VAR(Can_HwHandleType, AUTOMATIC) TxHwHandle,
  P2VAR(Can_ControllerIdType, AUTOMATIC, AUTOMATIC) ControllerIndexPtr,
  P2VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC, AUTOMATIC) PduIdBufferIndexPtr,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) TriggerTransmitEnablePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) PaddingValuePtr,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) TxHandlePtr
);

/** \brief Can_DataCheckIcomRxMessageID
 **
 ** Check if it is a wakeup message ID. 
 ** During normal operation, the wakeup message ID of Pretended 
 ** Networking mode is set to Hardware Filter. Therefore, there 
 ** is a possibility to receive a message ID for Wakeup. 
 ** Check the unknown message ID for Wakeup message ID.
 **
 ** \return   TRUE: Receive wakeup message ID.
 **           FALSE: Receiving except wakeup messages ID.
 ** \param [in] MessageId   Can Id of the message.
 **
 */
extern FUNC(boolean, AUTOMATIC) Can_DataCheckIcomRxMessageID
(
  VAR(uint32, AUTOMATIC) MessageId
);

/** \brief Can_DataInitMessageRam
 **
 ** Clear Message RAM in Can Instance unit.
 ** Message RAM has one message RAM in one instance. On the other hand,
 ** argument ControllerCfgPtr is channel unit. Therefore, the caller must
 ** call this function on a per-instance basis.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataInitMessageRam
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr
);

/** \brief Can_DataClearIsMRamInit
 **
 ** Initialize all Message RAM clear completion flags.
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataClearIsMRamInit(void);

/** \brief Can_DataGetInterruptNumToControllerId
 **
 ** Get ControllerId corresponding to InterruptNum.
 **
 ** \return   Index of the controller whose state data shall be retrieved.
 **
 ** \param [in] InterruptNum   Element number  of the controller that caused the interrupt.
 **
 */
extern FUNC(Can_ControllerIdType, AUTOMATIC) Can_DataGetInterruptNumToControllerId
(
  VAR(uint8, AUTOMATIC) InterruptNum
);

/** \brief Can_DataAllFreeTxPduId
 **
 ** Free all swPduId of the specified CanController.
 **
 ** \param [in] CtrlId   Controller Index
 **
 */
extern FUNC(void, AUTOMATIC) Can_DataAllFreeTxPduId
(
  VAR(Can_ControllerIdType, AUTOMATIC) CtrlId
);

#define CAN_STOP_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

#endif /**defined(CAN_DATA_H_INCLUDED)*/

/*==================[end of file]===========================================*/
