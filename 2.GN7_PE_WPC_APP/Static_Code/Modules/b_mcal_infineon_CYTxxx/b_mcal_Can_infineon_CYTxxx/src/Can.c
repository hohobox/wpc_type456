/** \brief Can.c
 **
 ** Implementation of top-level API of the Can driver module.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can.h>
#include <Can_ModuleManager.h>
#include <Can_ControllerManager.h>
#include <Can_Callout.h>
#include <Can_Data.h>
#include <CanIf_Cbk.h>
#include <EcuM_Cbk.h>

/*==================[macros]================================================*/

/** Maximum data length for a CAN message. */
#define CAN_MAX_DLC_CLASSIC     8u
#define CAN_MAX_DLC_FD         64u

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

#if ((CAN_CHANGE_BAUDRATE_API == STD_ON) || (CAN_SET_BAUDRATE_API == STD_ON) || \
     (CAN_SET_BAUDRATE_IN_CHANGED_CLOCK_API == STD_ON))
/** \brief Can_CheckBaudrateInternal
 **
 ** This checks, if a certain CAN controller supports a requested
 ** baudrate at the current point in time. The controller state is not checked.
 **
 ** \return   0: Baudrate supported by the CAN Controller
 **           else: Error code that was detected.
 ** \param [in] Controller   CAN Controller to check for the support of a certain
 **                          baudrate
 ** \param [in] Baudrate   Baudrate to check in kbps
 ** \param [out] ControllerStateDataPtrPtr   Pointer to pointer that is set to point
 **                                          to the ControllerStateData of the
 **                                          controller. If parameter Controller is
 **                                          invalid, (indicated by return value)
 **                                          then the pointer is not set.
 ** \param [out] ControllerBaudrateConfigPtrPtr   Pointer to pointer that is set to
 **                                               point to the ControllerBaudrateConfig
 **                                               that supports the baudrate. If
 **                                               parameter Controller or Baudrate
 **                                               is invalid, (indicated by return
 **                                               value) then the pointer is not set.
 ** \param [out] ControllerConfigPtrPtr   Pointer to pointer that is set to point
 **                                       to the ControllerConfig of the controller.
 **                                       If parameter Controller is invalid,
 **                                       (indicated by return value) then the pointer
 **                                       is not set.
 ** \param [in] IsBaudrateCfgId   This parameter shows that the parameter Baudrate
 **                               represents a baudrate configuration ID  or a
 **                               baudrate value.
 **                               TRUE := BaudrateConfigId
 **                               FALSE := baudrate value in kbps
 **
 */
static FUNC(uint8, AUTOMATIC) Can_CheckBaudrateInternal
(
  VAR(uint8, AUTOMATIC) Controller,
  CONST(uint16, AUTOMATIC) Baudrate,
  P2VAR(P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) ControllerStateDataPtrPtr,
  P2VAR(P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) ControllerBaudrateConfigPtrPtr,
  P2VAR(P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) ControllerConfigPtrPtr,
  VAR(boolean, AUTOMATIC) IsBaudrateCfgId
);
#endif /* ((CAN_CHANGE_BAUDRATE_API == STD_ON) || (CAN_SET_BAUDRATE_API == STD_ON) || 
           (CAN_SET_BAUDRATE_IN_CHANGED_CLOCK_API == STD_ON)) */

/** \brief Can_SetControllerMode_Stopped
 **
 ** Perform state transitions from source state CAN_CONTROLLER_STOPPED. On
 ** transition error the error is reported. Function returns CAN_OK if transition
 ** is successfully done. In case of a reported error the return value is
 ** CAN_NOT_OK.
 **
 ** \return   Status of executed transition. CAN_OK if transition is executed
 **           successfully. CAN_NOT_OK if an error is reported and the state
 **           transition is not done.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode_Stopped
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
);

/** \brief Can_SetControllerMode_Started
 **
 ** Perform state transitions from source state CAN_CONTROLLER_STARTED. On
 ** transition error the error is reported. Function returns CAN_OK if transition
 ** is successfully done. In case of a reported error the return value is
 ** CAN_NOT_OK.
 **
 ** \return   Status of executed transition. CAN_OK if transition is executed
 **           successfully. CAN_NOT_OK if an error is reported and the state
 **           transition is not done.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode_Started
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
);

/** \brief Can_SetControllerMode_Sleep
 **
 ** Perform state transitions from source state CAN_CONTROLLER_SLEEP. On
 ** transition error the error is reported. Function returns CAN_OK if transition
 ** is successfully done. In case of a reported error the return value is
 ** CAN_NOT_OK.
 **
 ** \return   Status of executed transition. CAN_OK if transition is executed
 **           successfully. CAN_NOT_OK if an error is reported and the state
 **           transition is not done.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode_Sleep
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
);

/** \brief Can_Write_CheckCanId
 **
 ** Check CanId
 ** 1. Standard CAN ID is 11 bit or less (mask possible FD flag)
 ** 2. Extended CAN ID is 29 bit or less (mask possible FD flag)
 **
 ** \return   CAN_OK     Error is not detected.
 **           CAN_NOT_OK Error is detected.
 **
 ** \param [in] CanId   Standard/Extended CAN ID of CAN L-PDU.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CheckCanId
(
  VAR(Can_IdType, AUTOMATIC) CanId
);

/** \brief Can_Write_CheckForPreviousError
 **
 ** Check the state of the target controller and CanId of PduInfo.
 **
 ** \return   CAN_OK     Error is not detected.
 **           CAN_NOT_OK Error is detected.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] CanId   CanId in PduInfo structure.
 ** \param [out] ReportTransitionErrorPtr   Transition status error flag.
 ** \param [out] ReportIdErrorPtr   CanId error flag.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CheckForPreviousError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_IdType, AUTOMATIC) CanId,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) ReportTransitionErrorPtr,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) ReportIdErrorPtr
);

/** \brief Can_Write_WriteRequest
 **
 ** Try to send the message.
 **
 ** \return   CAN_OK     Write request completed normally.
 **           CAN_NOT_OK PduInfo.DataPtr is invalid data pointer.
 **                      PduInfo.Length is invalid length.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] PduInfo   Pointer to SDU user memory, DLC and Identifier.
 ** \param [in] PduIdBufferIndex   Index of the PduId buffer where the message was
 **                                stored. The valid range depends on amount of
 **                                configured CAN controllers.
 ** \param [in] PaddingValue   Value to add for padding bytes in CAN message.
 ** \param [in] TxHandle   The buffer handle for the TX message. 
 ** \param [in] PduHandle   ID of the SDU that is requested to be transmitted.
 ** \param [in] TriggerTransmitEnable    Enables the possibility to request the 
 **                         data for this HW object with the CanIf_TriggerTransmit 
 **                         from CanIf instead of getting the data by call of Can_Write.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_WriteRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_ControllerPduInfoType, AUTOMATIC) PduInfo,
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  VAR(uint8, AUTOMATIC) PaddingValue,
  VAR(uint8, AUTOMATIC) TxHandle,
  VAR(PduIdType, AUTOMATIC) PduHandle,
  VAR(boolean, AUTOMATIC) TriggerTransmitEnable
);

/** \brief Can_Write_CheckParamDLC
 **
 ** Check for invalid length with following condition:
 ** 1. invalid: Length > 64
 ** 2. invalid: Classic mode AND Length > 8
 ** 3. invalid: FD mode but FD Flag in ID not set AND Length > 8
 **
 ** \return   CAN_OK     Error is not detected.
 **           CAN_NOT_OK Error is detected.
 **
 ** \param [in] PduInfo   Pointer to SDU user memory, DLC and Identifier.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CheckParamDLC
(
  VAR(Can_ControllerPduInfoType, AUTOMATIC) PduInfo,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
/** \brief Can_Write_CancelRequest
 **
 ** Cancel TX message.
 **
 ** \return   CAN_BUSY No TX hardware buffer available or pre-emptive call
 **                    of Can_Write that can't be implemented re-entrant.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] CanId   Standard/Extended CAN ID of CAN L-PDU.
 ** \param [in] TxHandle   The buffer handle for the TX message. 
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CancelRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(Can_IdType, AUTOMATIC) CanId,
  VAR(uint8, AUTOMATIC) TxHandle
);
#endif

/** \brief Can_CheckMissingTimerValueForPretendedNetworkMode
 **
 ** Check missing timer value in pretended networking mode.
 **
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 */
static FUNC(Std_ReturnType, AUTOMATIC) Can_CheckMissingTimerValueForPretendedNetworkMode
(
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
);

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal constants]====================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_DisableControllerInterrupts
 **
 ** This function disables all interrupts for this CAN controller.
 **
 ** \param [in] Controller   CAN controller for which interrupts shall be disabled.
 **
 */
FUNC(void, AUTOMATIC) Can_DisableControllerInterrupts
(
  VAR(uint8, AUTOMATIC) Controller
)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_DISABLECTRLINT);
  }
  else
  {
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(Controller);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                            Can_DataGetControllerStateData(Controller);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_DISABLECTRLINT);
    }
    else
    {
      /* All input parameters are OK --> try to do the job. */
      if (E_OK != Can_ControllerDisableInterrupts(ControllerCfgPtr, ControllerStateDataPtr))
      {
        /* Nesting error occurred. */
        Can_ReportError(CAN_E_IRQ_DEPTH, CAN_ID_DISABLECTRLINT);
      }
    }
  }
}

/** \brief Can_EnableControllerInterrupts
 **
 ** This function enables all allowed interrupts.
 **
 ** \param [in] Controller   CAN controller for which interrupts shall be re-enabled
 **
 */
FUNC(void, AUTOMATIC) Can_EnableControllerInterrupts
(
  VAR(uint8, AUTOMATIC) Controller
)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_ENABLECTRLINT);
  }
  else
  {
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  ControllerCfgPtr = Can_DataGetControllerConfig(Controller);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                             Can_DataGetControllerStateData(Controller);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_ENABLECTRLINT);
    }
    else
    {
      /* All input parameters are OK --> try to do the job. */
      if (E_OK != Can_ControllerEnableInterrupts(ControllerCfgPtr, ControllerStateDataPtr))
      {
        /* Nesting error occurred. */
        Can_ReportError(CAN_E_IRQ_DEPTH, CAN_ID_ENABLECTRLINT);
      }
    }
  }
}

#if CAN_GET_VERSION_INFO_API == STD_ON
/** \brief Can_GetVersionInfo
 **
 ** This function returns the version information of this module.
 **
 ** \param [out] versioninfo   Pointer to where to store the version information of
 **                            this module.
 **
 */
FUNC(void, AUTOMATIC) Can_GetVersionInfo
(
  P2VAR(Std_VersionInfoType, AUTOMATIC, AUTOMATIC) versioninfo
)
{
  /* Check input parameter. */
  if (NULL_PTR == versioninfo)
  {
    Can_ReportError(CAN_E_PARAM_POINTER, CAN_ID_GETVERSIONINFO);
  }
  else
  {
    /* Get version information from inside the library. */
    Can_ModuleGetVersionInfo(versioninfo);
    versioninfo->sw_major_version = CAN_SW_MAJOR_VERSION; /* uint8 */
    versioninfo->sw_minor_version = CAN_SW_MINOR_VERSION; /* uint8 */
    versioninfo->sw_patch_version = CAN_SW_PATCH_VERSION; /* uint8 */
  }
}
#endif /* CAN_GET_VERSION_INFO_API == STD_ON */

/** \brief Can_InterruptHandler
 **
 ** Generic interrupt handler, that is called from the specific interrupt handlers.
 **
 ** \param [in] InterruptNum   Element number  of the controller that caused the interrupt.
 **
 */
FUNC(void, AUTOMATIC) Can_InterruptHandler
(
  VAR(uint8, AUTOMATIC) InterruptNum
)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_ISR);
  }
  else
  {
    VAR(Can_ControllerIdType, AUTOMATIC) CtrlId = Can_DataGetInterruptNumToControllerId(InterruptNum);
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                             Can_DataGetControllerStateData(CtrlId);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_ISR);
    }
    else
    {
      Can_ControllerEnterInterrupt(ControllerCfgPtr);
      /* Do the job depending on the controller state. */
      switch (Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
      {
        case CAN_CONTROLLER_STOPPED:
        {

          /* In detected stopped mode a BusOff interrupt or an uncorrectable bit
           * error interrupt could be caused the interrupt. */

          /* A bus-off error could have caused the interrupt. */
          if (TRUE == ControllerCfgPtr->InterruptEnableBusOff)
          {
            if (FALSE != Can_ControllerHandleBusOff(ControllerCfgPtr, ControllerStateDataPtr))
            {
              /* Notify upper layer about a bus off occurrence. */
              Can_CanIfControllerBusOff(ControllerCfgPtr);
            }
            /* An uncorrectable bit error could have caused the interrupt. */
            if (FALSE != Can_ControllerHandleUncorrectableBitError(ControllerCfgPtr, ControllerStateDataPtr))
            {
              Can_DemReportErrorStatus(CAN_E_UNCORRECTABLE_BIT_ERROR, CAN_ID_ISR, CAN_DEM_EVENT_STATUS_FAILED);
            }
          }
          break;
        }
          
        case CAN_CONTROLLER_STARTED:
          /* TX comes before RX to assure that the TX confirmation comes before the
             RX indication of the answer to the message (in case there is a protocol).
             But skip TX function call in the pretended networking mode. */
          if (TRUE == ControllerCfgPtr->InterruptEnableTx)
          {
          	if (FALSE == ControllerStateDataPtr->IcomState.IsPretended)
            {
              Can_ControllerHandleTx(ControllerCfgPtr);
            }
          }
          if (TRUE == ControllerCfgPtr->InterruptEnableRx)
          {
            if (E_OK != Can_ControllerHandleRx(ControllerCfgPtr, ControllerStateDataPtr, CAN_ID_ISR))
            {
              /* RX overflow error detected. */
              ControllerStateDataPtr->IsRxOverflow = TRUE;
              Can_ReportError(CAN_E_DATALOST, CAN_ID_ISR);
            }
          }
          break;
          
        case CAN_CONTROLLER_SLEEP:
          if (TRUE == ControllerCfgPtr->InterruptEnableWakeup)
          {
            /* A wake up event could have caused the interrupt. */
            Can_ControllerHandleWakeup(ControllerCfgPtr, ControllerStateDataPtr);
          }
          break;

        /* case CAN_CONTROLLER_UNINIT: */
        default:
          /* This case is reachable if memory interference occurred. */
          Can_ReportError(CAN_E_UNINIT, CAN_ID_ISR);
          break;
      }
    }
  }
}

/** \brief Can_MainFunction_BusOff
 **
 ** This function performs the polling of bus-off events that are configured
 ** statically as 'to be polled'.
 **
 */
FUNC(void, AUTOMATIC) Can_MainFunction_BusOff(void)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_MF_BUSOFF);
  }
  else
  {
    Can_ControllerIdType CtrlId;
    
    /* Loop all controllers. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      /* The pointer cannot be NULL, because CtrlId is in range. */
      
      /* Skip controllers that are configured for interrupt handling. */
      if (FALSE == ControllerCfgPtr->InterruptEnableBusOff)
      {
        P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
        /* The pointer cannot be NULL, because CtrlId is in range. */

        /* Can_ControllerHandleBusOff checks for the status of the controller
         * internally. */
        if (FALSE != Can_ControllerHandleBusOff(ControllerCfgPtr, ControllerStateDataPtr))
        {
          /* Notify upper layer about a bus off occurrence. */
          Can_CanIfControllerBusOff(ControllerCfgPtr);
        }
        
        /* An uncorrectable bit error could have caused the interrupt. */
        if (FALSE != Can_ControllerHandleUncorrectableBitError(ControllerCfgPtr, ControllerStateDataPtr))
        {
          Can_DemReportErrorStatus(CAN_E_UNCORRECTABLE_BIT_ERROR, CAN_ID_MF_BUSOFF, CAN_DEM_EVENT_STATUS_FAILED);
        }
      }
    }
  }
}

/** \brief Can_MainFunction_Mode
 **
 ** This function performs the polling of CAN controller mode transitions.
 **
 */
FUNC(void, AUTOMATIC) Can_MainFunction_Mode(void)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_MF_MODE);
  }
  else
  {
    Can_ControllerIdType CtrlId;
    
    /* Loop all controllers. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
      /* The pointers cannot be NULL, because CtrlId is in range. */
      
      /* CAN interrupts are disabled during the status check. */
      if (E_OK != Can_ControllerDisableInterrupts(ControllerCfgPtr, ControllerStateDataPtr))
      {
        /* Nesting error occurred. */
        Can_ReportError(CAN_E_IRQ_DEPTH, CAN_ID_MF_MODE);
      }
      else
      {
        /* Mode handling is always done by polling. */
        Can_ControllerHandleMode(ControllerCfgPtr, ControllerStateDataPtr);
        
        /* Enable CAN interrupts. */
        if (E_OK != Can_ControllerEnableInterrupts(ControllerCfgPtr, ControllerStateDataPtr))
        {
          /* Nesting error occurred. */
          Can_ReportError(CAN_E_IRQ_DEPTH, CAN_ID_MF_MODE);
        }
      }
    }
  }
}

/** \brief Can_MainFunction_Read
 **
 ** This function performs the polling of RX indications when CAN_RX_PROCESSING is
 ** set to POLLING.
 **
 */
FUNC(void, AUTOMATIC) Can_MainFunction_Read(void)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_MF_READ);
  }
  else
  {
    Can_ControllerIdType CtrlId;
    
    /* Loop all controllers. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
      /* The pointer cannot be NULL, because CtrlId is in range. */
      
      if (TRUE == ControllerStateDataPtr->IcomState.IsPretended)
      {
        if (E_OK != Can_CheckMissingTimerValueForPretendedNetworkMode(ControllerStateDataPtr))
        {
          Can_EcuMSetWakeupForPretendedNetworkMode(ControllerCfgPtr, ControllerStateDataPtr);
        }
      }
      /* Skip controllers that are configured for interrupt handling. */
      if (FALSE == ControllerCfgPtr->InterruptEnableRx)
      {
        /* Skip controllers that are not started, because they cannot receive anything. */
        if (CAN_CONTROLLER_STARTED == Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
        {
          if (E_OK != Can_ControllerHandleRx(ControllerCfgPtr, ControllerStateDataPtr, CAN_ID_MF_READ))
          {
            /* RX overflow error detected. */
            ControllerStateDataPtr->IsRxOverflow = TRUE;
            Can_ReportError(CAN_E_DATALOST, CAN_ID_MF_READ);
          }
        }
      }
    }
  }
}

/** \brief Can_MainFunction_Wakeup
 **
 ** This function performs the polling of wake-up events that are configured
 ** statically as 'to be polled'.
 **
 */
FUNC(void, AUTOMATIC) Can_MainFunction_Wakeup(void)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_MF_WAKEUP);
  }
  else
  {
    Can_ControllerIdType CtrlId;
    
    /* Loop all controllers. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      /* The pointer cannot be NULL, because CtrlId is in range. */
      
      /* Skip controllers that are configured for interrupt handling. */
      if (FALSE == ControllerCfgPtr->InterruptEnableWakeup)
      {
        P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
        /* The pointer cannot be NULL, because CtrlId is in range. */
        
        /* Skip controllers that are not asleep, because they cannot wake up. */
        if (CAN_CONTROLLER_SLEEP == Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
        {
          Can_ControllerHandleWakeup(ControllerCfgPtr, ControllerStateDataPtr);
        }
      }
    }
  }
}

/** \brief Can_MainFunction_Write
 **
 ** This function performs the polling of TX confirmation and TX cancellation
 ** confirmation when CAN_TX_PROCESSING is set to POLLING.
 **
 */
FUNC(void, AUTOMATIC) Can_MainFunction_Write(void)
{
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_MF_WRITE);
  }
  else
  {
    Can_ControllerIdType CtrlId;
    
    /* Loop all controllers. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      /* The pointer cannot be NULL, because CtrlId is in range. */
      
      /* Skip controllers that are configured for interrupt handling. */
      if (FALSE == ControllerCfgPtr->InterruptEnableTx)
      {
        P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
        /* The pointer cannot be NULL, because CtrlId is in range. */
        
        /* Skip controllers that are not started, because they cannot send anything. And,
         * skip controllers that are pretended networking mode, because they cannot send anything. */
        if (    (CAN_CONTROLLER_STARTED == Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
             && (FALSE == ControllerStateDataPtr->IcomState.IsPretended) )
        {
          Can_ControllerHandleTx(ControllerCfgPtr);
        }
      }
    }
  }
}

/** \brief Can_SetControllerMode
 **
 ** This function performs software triggered state transitions of the CAN
 ** controller State machine.
 **
 ** \return   CAN_OK: request accepted
 **           CAN_NOT_OK: request not accepted, a development error occurred
 ** 
 ** \param [in] Controller   CAN controller for which the status shall be changed
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode
(
  VAR(uint8, AUTOMATIC) Controller,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
)
{
  Can_ReturnType result = CAN_NOT_OK;
  
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_SETCTRLMODE);
  }
  else
  {
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  ControllerCfgPtr = Can_DataGetControllerConfig(Controller);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                             Can_DataGetControllerStateData(Controller);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_SETCTRLMODE);
    }
    else
    {
      /* Inhibit bus-off interrupt until return from notification. 
         SchM critical section must not be used accross notifications. */
      if (E_OK != Can_ControllerDisableInterrupts(ControllerCfgPtr, ControllerStateDataPtr))
      {
        /* Nesting error occurred. */
        Can_ReportError(CAN_E_IRQ_DEPTH, CAN_ID_SETCTRLMODE);
      }
      else
      {
        /* Check for forbidden state transitions. */
        switch (Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
        {
          case CAN_CONTROLLER_STOPPED:
            result = Can_SetControllerMode_Stopped(ControllerCfgPtr, ControllerStateDataPtr, Transition);
            break;
            
          case CAN_CONTROLLER_STARTED:
            result = Can_SetControllerMode_Started(ControllerCfgPtr, ControllerStateDataPtr, Transition);
            break;
            
          case CAN_CONTROLLER_SLEEP:
            result = Can_SetControllerMode_Sleep(ControllerCfgPtr, ControllerStateDataPtr, Transition);
            break;
            
          /* case CAN_CONTROLLER_UNINIT: */
          default:
            /* This case is reachable if memory interference occurred. */
            Can_ReportError(CAN_E_UNINIT, CAN_ID_SETCTRLMODE);
            break;
        }
        
        /* Release interrupt lock. */
        if (E_OK != Can_ControllerEnableInterrupts(ControllerCfgPtr, ControllerStateDataPtr))
        {
          /* Nesting error occurred. */
          Can_ReportError(CAN_E_IRQ_DEPTH, CAN_ID_SETCTRLMODE);
          /* "result" is not set, because the transition might successfully be started or finished.
             The interrupt lock was also successfully acquired because Can_ControllerDisableInterrupts
             returned E_OK. Furthermore the interrupt lock has been released by another task, otherwise 
             Can_ControllerEnableInterrupts would not have violated interrupt nesting. */
        }
      }
    }
  }
  
  return result;
}

/** \brief Can_Write
 **
 ** This function is called by CanIf to pass a CAN message to CanDrv for
 ** transmission.
 **
 ** \return   CAN_OK: Write command has been accepted
 **           CAN_NOT_OK: development error occurred
 **           CAN_BUSY: No TX hardware buffer available or preemptive call of
 **                     Can_Write that cannot be implemented reentrant
 ** 
 ** \param [in] Hth   Information which HW-transmit handle shall be used for
 **                   transmit. Implicitly this is also the information about
 **                   the controller to use because the Hth numbers are unique
 **                   inside one hardware unit.
 ** \param [in] PduInfo   Pointer to SDU user memory, DLC and Identifier.
 */
FUNC(Can_ReturnType, AUTOMATIC) Can_Write
(
  VAR(Can_HwHandleType, AUTOMATIC) Hth,
  P2CONST(Can_PduType, AUTOMATIC, AUTOMATIC) PduInfo
)
{
  Can_ReturnType            result = CAN_OK;
  Can_ControllerPduInfoType localPduInfo;
  PduIdType                 pduHandle;
  
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_WRITE);
    result = CAN_NOT_OK;
  }
  
  /* Check PduInfo. */
  if (NULL_PTR == PduInfo)
  {
    Can_ReportError(CAN_E_PARAM_POINTER, CAN_ID_WRITE);
    result = CAN_NOT_OK;
  }

  /* Go on if no error is occurred. */
  if (CAN_OK == result)
  {
    /* PduInfo is not NULL and module state is initialized. */

    /* Since the pointed data is under control of some other software, 
       copy parameters from PduInfo so that they do not change. */
    localPduInfo.Length  = PduInfo->length;
    localPduInfo.CanId   = PduInfo->id;
    localPduInfo.DataPtr = PduInfo->sdu;
    pduHandle            = PduInfo->swPduHandle;
    
    /* Check CanId.
     * 1. Standard CAN ID is 11 bit or less (mask possible FD flag)
     * 2. Extended CAN ID is 29 bit or less (mask possible FD flag) */
    if (CAN_NOT_OK == Can_Write_CheckCanId(localPduInfo.CanId))
    {
      result = CAN_NOT_OK;
      Can_ReportError(CAN_E_PARAM_ID, CAN_ID_WRITE);
    }
    
    /* Check swPduHandle. */
    if (CAN_DATA_FREE_PDUID_BUFFER_SLOT == pduHandle)
    {
      Can_ReportError(CAN_E_PARAM_PDUID, CAN_ID_WRITE);
      result = CAN_NOT_OK;
    }
    /* Check for previous error */
    if (CAN_OK == result)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  controllerCfgPtr;
      P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) controllerStateDataPtr;
      Can_ControllerPduIdBufferIndexType pduIdBufferIndex = 0u;
      Can_ControllerIdType ctrlId = 0u;
      Can_ReturnType translateRetVal;
      uint8   txHandle = 0u;
      uint8   paddingValue = 0u;
      boolean triggerTransmitEnable = FALSE;
      boolean reportIdError = FALSE;
      boolean reportTransitionError = FALSE;
      
      /* Enter critical section to avoid changes on transmit handle till message
       * is stored in message queue or cancellation is requested. */
      Can_EnterCriticalSection();

      /* Check Hth and if valid, translate it. */
      translateRetVal = Can_DataTranslateTxHandle( Hth, &ctrlId, &pduIdBufferIndex,
                                                  &triggerTransmitEnable,
                                                  &paddingValue, &txHandle);

      /* ctrlId is valid if and only if translateRetVal is valid. */
      if (CAN_NOT_OK != translateRetVal)
      {
        /* Get controller configuration and state. */
        controllerCfgPtr = Can_DataGetControllerConfig(ctrlId);
        controllerStateDataPtr = Can_DataGetControllerStateData(ctrlId);
        /* The above pointers cannot be NULL, because CtrlId is in range. */
        
        /* Check the state of the target controller and CanId of PduInfo. */
        result = Can_Write_CheckForPreviousError(controllerCfgPtr, controllerStateDataPtr,
                                                 localPduInfo.CanId, &reportTransitionError,
                                                 &reportIdError);
      
        /* Check pretnded networking mode */
        if ((TRUE == controllerStateDataPtr->IcomState.IsPretended) && (CAN_OK == result))
        {
          /* If Pretended Networking is activated CanDrv shall reject Can_Write() 
           * requests with return value CAN_BUSY. */
          translateRetVal = CAN_BUSY;
          result = translateRetVal;
        }
      }
      
      if ((CAN_OK == translateRetVal) && (CAN_OK == result))
      {
        /* ctrlId, txHandle, pduIdBufferIndex, triggerTransmitEnable and paddingValue
         * are valid by now. */
        /* Reserve the right entry in the message queue for this TX message. */
        Can_DataStoreTxPduId(pduIdBufferIndex, pduHandle);
        /* Message queue entry is reserved and cannot be used until the entry
         * is released. Critical section is not required anymore. */
        Can_ExitCriticalSection();

        /* Try to send the message. */
        result = Can_Write_WriteRequest(controllerCfgPtr, controllerStateDataPtr,
                                        localPduInfo, pduIdBufferIndex,
                                        paddingValue, txHandle,
                                        pduHandle, triggerTransmitEnable);
                                        
      } /* End of if  (CAN_OK == translateRetVal) */
      /* Hth invalid or no free buffer is available. */
      /* Check for cancellation possibility.
       * Do the preprocessor check in runtime for easier testability. The
       * compiler optimization will not use the whole block if the check
       * is always false. */
      #if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
      else if (   (CAN_BUSY == translateRetVal)
               && (txHandle < CAN_CONTROLLER_TX_FIFO) 
               && (CAN_OK == result) )
      {
        /* Cancellation might be done dependent on the cancel strategy and the
         * comparison of pending and new message CANID. */
        controllerCfgPtr = Can_DataGetControllerConfig(ctrlId);
        result = Can_Write_CancelRequest(controllerCfgPtr, localPduInfo.CanId, txHandle);

        Can_ExitCriticalSection();

      } /* End of else if (CAN_BUSY and dedicated buffer) - cancellation */
      #endif
      else
      {
        /* No transmission or cancellation possible. */

        Can_ExitCriticalSection();
        /* Set return value, if not failed already. */
        if (CAN_OK == result)
        {
          result = translateRetVal;
        }

        /* Check for invalid handle. */
        if (CAN_NOT_OK == translateRetVal)
        {
          /* Only on error case CAN_NOT_OK the handle is invalid and the
           * error must be reported. */
          Can_ReportError(CAN_E_PARAM_HANDLE, CAN_ID_WRITE);
        }
      }
      
      /* Error callouts must not be called from within critical section.
         Therefore they are called here. */
      if (FALSE != reportTransitionError)
      {
        Can_ReportError(CAN_E_TRANSITION, CAN_ID_WRITE);
      }
      if (FALSE != reportIdError)
      {
        Can_ReportError(CAN_E_PARAM_ID, CAN_ID_WRITE);
      }
    } /* End of if (CAN_OK == result) */
  }
  
  return result;
}

#if CAN_CHANGE_BAUDRATE_API == STD_ON
/** \brief Can_ChangeBaudrate
 **
 ** This service shall change the baudrate of the CAN controller.
 ** 
 ** \return   E_OK: Service request accepted, baudrate change started
 **           E_NOT_OK: Service request not accepted
 ** \param [in] Controller   CAN Controller, whose baudrate shall be changed
 ** \param [in] Baudrate   Requested baudrate in kbps
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_ChangeBaudrate
(
  VAR(uint8, AUTOMATIC) Controller,
  VAR(uint16, AUTOMATIC) Baudrate
)
{
  Std_ReturnType result;
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr;
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) ControllerBaudrateConfigPtr;
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr;
  
  /* Check for errors and retrieve configuration and state pointer and search for
   * right baudrate configuration and retrieve the baudrate configuration pointer.
   * Searching for right baudrate is done by using the Baudrate value, therefore
   * set last parameter to FALSE. */
  uint8 Error = Can_CheckBaudrateInternal( Controller, Baudrate,
                                          &ControllerStateDataPtr,
                                          &ControllerBaudrateConfigPtr,
                                          &ControllerCfgPtr,
                                           FALSE);
  
  if (0u == Error)
  {
    if (CAN_CONTROLLER_STOPPED != Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
    {
      /* Baudrate change is allowed during STOPPED state only. */
      Can_ReportError(CAN_E_TRANSITION, CAN_ID_CHANGEBAUDRATE);
      result = E_NOT_OK;
    }
    else
    {
      /* No error, ControllerStateDataPtr and ControllerBaudrateConfigPtr are valid. */
      Can_ControllerSetBaudrate(ControllerStateDataPtr, ControllerBaudrateConfigPtr);
      result = E_OK;
    }
  }
  else
  {
    /* Report error */
    Can_ReportError(Error, CAN_ID_CHANGEBAUDRATE);
    result = E_NOT_OK;
  }
  
  return result;
}
#endif /* CAN_CHANGE_BAUDRATE_API == STD_ON */

#if CAN_CHANGE_BAUDRATE_API == STD_ON
/** \brief Can_CheckBaudrate
 **
 ** This service shall check, if a certain CAN controller supports a requested
 ** baudrate.
 **
 ** \return   E_OK: Baudrate supported by the CAN Controller
 **           E_NOT_OK: Baudrate not supported / invalid CAN controller
 ** \param [in] Controller   CAN Controller to check for the support of a certain
 **                          baudrate
 ** \param [in] Baudrate   Baudrate to check in kbps
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_CheckBaudrate
(
  VAR(uint8, AUTOMATIC) Controller,
  VAR(uint16, AUTOMATIC) Baudrate
)
{
  Std_ReturnType result;
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr;
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) ControllerBaudrateConfigPtr;
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr;
 
  /* Check for errors and retrieve configuration and state ptr and search for the
   * right baudrate configuration and retrieve the baudrate config pointer.
   * Searching for right baudrate is done by using the Baudrate value, therefore
   * set last parameter to FALSE. */
  uint8 Error = Can_CheckBaudrateInternal( Controller, Baudrate,
                                          &ControllerStateDataPtr,
                                          &ControllerBaudrateConfigPtr,
                                          &ControllerCfgPtr,
                                          FALSE);
  
  if (0u == Error)
  {
    /* No error */
    result = E_OK;
  }
  else
  {
    /* Error */
    Can_ReportError(Error, CAN_ID_CHECKBAUDRATE);
    result = E_NOT_OK;
  }
  
  return result;
}
#endif /* CAN_CHANGE_BAUDRATE_API == STD_ON */

#if CAN_SET_BAUDRATE_API == STD_ON
/** \brief Can_SetBaudrate
 **
 ** This service shall set the baud rate configuration of the CAN controller.
 ** Depending on necessary baud rate modifications the controller might have to
 ** be reset.
 **
 ** \return   E_OK: Service request accepted, setting of (new) baud rate started
 **           E_NOT_OK: Service request not accepted
 ** \param [in] Controller   CAN controller, whose baud rate shall be set
 ** \param [in] BaudRateConfigID   references a baud rate configuration by ID (see
 **                                CanControllerBaudRateConfigID)
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_SetBaudrate
(
  VAR(uint8, AUTOMATIC) Controller,
  VAR(uint16, AUTOMATIC) BaudRateConfigID
)
{
  Std_ReturnType result;
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr;
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) ControllerBaudrateConfigPtr;
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr;

  /* Check for errors and retrieve configuration and state ptr and search for the
   * right baudrate configuration and retrieve the baudrate config pointer.
   * Searching for right baudrate is done by using the BaudrateConfigId, therefore
   * set last parameter to TRUE. */
  uint8 Error = Can_CheckBaudrateInternal( Controller, BaudRateConfigID,
                                          &ControllerStateDataPtr,
                                          &ControllerBaudrateConfigPtr,
                                          &ControllerCfgPtr,
                                           TRUE);

  if (0u == Error)
  {
    if (CAN_CONTROLLER_STOPPED != Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
    {
      /* Baudrate change is allowed during STOPPED state only. */
      Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETBAUDRATE);
      result = E_NOT_OK;
    }
    else
    {
      /* No error, ControllerStateDataPtr and ControllerBaudrateConfigPtr are valid. */
      Can_ControllerSetBaudrate(ControllerStateDataPtr, ControllerBaudrateConfigPtr);
      result = E_OK;
    }
  }
  else
  {
    /* Report error */
    Can_ReportError(Error, CAN_ID_SETBAUDRATE);
    result = E_NOT_OK;
  }

  return result;
}
#endif /* CAN_SET_BAUDRATE_API == STD_ON */

#if CAN_SET_BAUDRATE_IN_CHANGED_CLOCK_API == STD_ON
/** \brief Can_SetBaudrateInChangedClock
 **
 ** This service shall set the baud rate configuration of the CAN controller
 ** in the changed clock.
 ** Depending on necessary baud rate modifications the controller might have to
 ** be reset.
 **
 ** \return   E_OK: Service request accepted, setting of (new) baud rate started
 **           E_NOT_OK: Service request not accepted
 ** \param [in] Controller   CAN controller, whose baud rate shall be set
 ** \param [in] BaudRateConfigID   references a baud rate configuration by ID (see
 **                                CanControllerBaudRateConfigID)
 ** \param [in] ClockValue   Changed clock[MHz]
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_SetBaudrateInChangedClock
(
  VAR(uint8, AUTOMATIC) Controller,
  VAR(uint16, AUTOMATIC) BaudRateConfigID,
  VAR(Can_ClkFrequencyType, AUTOMATIC) ClockFrequency
)
{
  Std_ReturnType result;
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr;
  P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC) ControllerBaudrateConfigPtr;
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr;

  /* Check for errors and retrieve configuration and state ptr and search for the
   * right baudrate configuration and retrieve the baudrate config pointer.
   * Searching for right baudrate is done by using the BaudrateConfigId, therefore
   * set last parameter to TRUE. */
  uint8 Error = Can_CheckBaudrateInternal( Controller, BaudRateConfigID,
                                          &ControllerStateDataPtr,
                                          &ControllerBaudrateConfigPtr,
                                          &ControllerCfgPtr,
                                           TRUE);

  if (0u == Error)
  {
    if (CAN_CONTROLLER_STOPPED != Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
    {
      /* Baudrate change is allowed during STOPPED state only. */
      Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETBAUDRATE_IN_CHANGED_CLOCK);
      result = E_NOT_OK;
    }
    else
    {
      /* No error, ControllerStateDataPtr and ControllerBaudrateConfigPtr are valid. */
      if (E_OK != Can_ControllerSetBaudrateInChangedClock(ControllerStateDataPtr, 
                                                          ControllerBaudrateConfigPtr,
                                                          ClockFrequency))
      {
        /* As a result of calculating the prescaler, it was a value that can not be set in the register. */
        Can_ReportError(CAN_E_CALC_PRESCALER, CAN_ID_SETBAUDRATE_IN_CHANGED_CLOCK);
        result = E_NOT_OK;
      }
      else
      {
        result = E_OK;
      }
    }
  }
  else
  {
    /* Report error */
    Can_ReportError(Error, CAN_ID_SETBAUDRATE_IN_CHANGED_CLOCK);
    result = E_NOT_OK;
  }

  return result;
}
#endif /* CAN_SET_BAUDRATE_IN_CHANGED_CLOCK_API == STD_ON */

/** \brief Can_Init
 **
 ** This function initializes the module.
 **
 ** \param [in] Config   Pointer to driver configuration.
 **
 */
FUNC(void, AUTOMATIC) Can_Init
(
  P2CONST(Can_ConfigType, AUTOMATIC, AUTOMATIC) Config
)
{
  /* Critical section is not needed, because Can_Init is 
     non-reentrant and hardware is (forced to be) stopped. */
  
  boolean ErrorDetected = FALSE;
  
  /* Check if module is un-initialized. */
  if (FALSE != Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_TRANSITION, CAN_ID_INIT);
    ErrorDetected = TRUE;
  }
  
  /* Check parameter. */
  if (FALSE == Can_CheckConfigPtr(Config))
  {
    Can_ReportError(CAN_E_INIT_FAILED, CAN_ID_INIT);
    ErrorDetected = TRUE;
  }
  
  if (FALSE == ErrorDetected)
  {
    Can_ControllerIdType CtrlId;

    /* Set controller configuration. */
    Can_DataSetControllerConfig(Config);
    
    /* Check if all controllers are un-initialized. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
      
      if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
      {
        /* Configuration error detected. */
        Can_ReportError(CAN_E_PARAM_POINTER, CAN_ID_INIT);
        ErrorDetected = TRUE;
      }
      else
      {
        /* Check correct controller status. */
        if (CAN_CONTROLLER_UNINIT != Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
        {
          Can_ReportError(CAN_E_TRANSITION, CAN_ID_INIT);
          ErrorDetected = TRUE;
        }
      }
    }
    
    /* Initialize only if no error was detected. */
    if (FALSE == ErrorDetected)
    {
      /* Initialize internal variables. */
      Can_DataReset();

      /* Initialize Controllers. */
      for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
      {
        P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
        P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                                Can_DataGetControllerStateData(CtrlId);
        /* The pointers cannot be NULL, because this has been checked in the previous loop. */
        
        /* Enable ECC control.
         * ECC detection is enabled under the following conditions.
         * It must be an MRAM that can enable ECC error detection.
         * In order to activate ECC on a per instance basis, if ECC control is already enabled, nothing is done. */
        Can_ControllerEnableEccControl(ControllerCfgPtr);
        
        /* Clear Message RAM */
        if (FALSE == ControllerStateDataPtr->IsMRamInit)
        {
          Can_DataInitMessageRam(ControllerCfgPtr);
        }

        /* Enable Rx Fifo Top Pointer*/
        Can_ControllerSetRxFifoTopPointer(ControllerCfgPtr);
        
        /* Set default baudrate. */
        ControllerStateDataPtr->BaudrateData.BaudratePtr = ControllerCfgPtr->DefaultBaudratePtr;
        
        /* Check if a wake up occurred before initialization. */
        Can_ControllerHandleWakeup(ControllerCfgPtr, ControllerStateDataPtr);
        
        /* Initialize controller HW. */
        Can_ControllerStop(ControllerCfgPtr, ControllerStateDataPtr);

        /* Set Tx and Rx configurations */
        Can_ControllerSetTxRxConfiguration(ControllerCfgPtr);
      }
      
      /* Initialize Module */
      Can_ModuleInit();
    }
  }
  
}

#if CAN_PUBLIC_ICOM_SUPPORT == STD_ON
/** \brief Can_SetIcomConfiguration
 **
 ** This service shall change the Icom Configuration of a CAN controller to the 
 ** requested one.
 **
 ** \return   E_OK: driver succeeded in setting a configuration with a valid 
 **                 Configuration id
 **           E_NOT_OK: CAN driver failed to set a configuration with a valid 
 **                     Configuration id
 ** 
 ** \param [in] Controller   CAN controller for which the status shall be changed
 ** \param [in] ConfigurationId   Requested Configuration
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_SetIcomConfiguration
(
  VAR(uint8, AUTOMATIC) Controller,
  VAR(IcomConfigIdType, AUTOMATIC) ConfigurationId
)
{
  Std_ReturnType result = E_OK;
  
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_SETICOMCFG);
    result = E_NOT_OK;
  }
  else
  {
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  ControllerCfgPtr = Can_DataGetControllerConfig(Controller);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                             Can_DataGetControllerStateData(Controller);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_SETICOMCFG);
      result = E_NOT_OK;
    }
    else
    {
      if (0u == ConfigurationId)
      {
        /* ConfigurationId = 0 unconditionally invalidates pretended networking mode. */
        ControllerStateDataPtr->IcomState.IcomConfigPtr           = NULL_PTR;
        ControllerStateDataPtr->IcomState.CanRxMessageCountersPtr = NULL_PTR;
        ControllerStateDataPtr->IcomState.IsPretended             = FALSE;
        ControllerStateDataPtr->IcomState.IsWakeup                = FALSE;
        ControllerStateDataPtr->IcomState.StartTime               = 0u;
        Can_ControllerDisableInterruptProtocolError(ControllerCfgPtr);
      }
      else
      {
        P2CONST(Can_ControllerIcomConfigType, AUTOMATIC, AUTOMATIC) ControllerIcomCfgPtr = 
                                                                       Can_DataGetControllerIcomConfig(ConfigurationId);
        
        /* Check if Configuration ID is valid. */
        if (NULL_PTR == ControllerIcomCfgPtr)
        {
          Can_ReportError(CAN_E_ICOM_CONFIG_INVALID, CAN_ID_SETICOMCFG);
          result = E_NOT_OK;
        }
        else
        {
          /* Check if controller state is STARTED */
          if (CAN_CONTROLLER_STARTED != Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
          {
            Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETICOMCFG);
            result = E_NOT_OK;
          }
          else
          {
            uint32 index;
            ControllerStateDataPtr->IcomState.CanRxMessageCountersPtr = 
                                                                 Can_DataGetIcomRxMessageCountersPtr(ConfigurationId);
            /* Timer start and wakeup message reception counters reset for the number of IcomRxMessage associated with
               CanIcomConfig. */
            for (index=0u; ControllerIcomCfgPtr->NumberOfRxMessageCfgPtr>index; index++)
            {
              if (    (0u == ControllerStateDataPtr->IcomState.StartTime)
                   && (0u <  ControllerIcomCfgPtr->RxMessageCfgPtr[index].MissingMessageTimerValue) )
              {
                /* If CanIcomMissingMessageTimerValue is valid, timer start */
                if (E_OK != Can_OsGetCounterValue(&(ControllerStateDataPtr->IcomState.StartTime), CAN_ID_SETICOMCFG))
                /* Deviation from MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1, MISRA-C:2012 Dir-1.1
                   Nesting of control structures (statements) exceeds 15 - program does not conform strictly to ISO:C90.
                   Justification: If nesting is made shallow, error flags must be used extensively, and readability may 
                   be reduced. Therefore do not modify */
                /* PRQA S 715 1 */
                {
                  result = E_NOT_OK;
                }
              }
              ControllerStateDataPtr->IcomState.CanRxMessageCountersPtr[index] = 0u;
              if (TRUE == ControllerIcomCfgPtr->RxMessageCfgPtr[index].PayloadLengthError)
              {
                if (E_OK == result)
                /* Deviation from MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1, MISRA-C:2012 Dir-1.1
                   Nesting of control structures (statements) exceeds 15 - program does not conform strictly to ISO:C90.
                   Justification: If nesting is made shallow, error flags must be used extensively, and readability may 
                   be reduced. Therefore do not modify */
                /* PRQA S 715 1 */
                {
                  Can_ControllerEnableInterruptProtocolError(ControllerCfgPtr);
                }
                else
                /* Deviation from MISRA-C:2004 Rule 1.1; REFERENCE - ISO:C90-5.2.4.1, MISRA-C:2012 Dir-1.1
                   Nesting of control structures (statements) exceeds 15 - program does not conform strictly to ISO:C90.
                   Justification: If nesting is made shallow, error flags must be used extensively, and readability may 
                   be reduced. Therefore do not modify */
                /* PRQA S 715 1 */
                {
                  Can_ControllerDisableInterruptProtocolError(ControllerCfgPtr);
                }
              }
            }
            
            if (result == E_OK)
            {
              /* Pretended networking mode enable */
              ControllerStateDataPtr->IcomState.IcomConfigPtr = ControllerIcomCfgPtr;
              ControllerStateDataPtr->IcomState.IsPretended   = TRUE;
              ControllerStateDataPtr->IcomState.IsWakeup      = FALSE;
            }
          }
        }
      }
    }
  }
  
  if (E_OK == result)
  {
    /* Call CanIf API as succress */
    CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_OK);
  }
  else
  {
    /* Call CanIf API as failed */
    CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED);
  }
  
  return result;
}
#endif /* CAN_PUBLIC_ICOM_SUPPORT == STD_ON */

#if CAN_DEINIT_API == STD_ON
/** \brief Can_DeInit
 **
 ** This function deinitializes the module.
 **
 */
FUNC(void, AUTOMATIC) Can_DeInit(void)
{
  /* Check if module is un-initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_TRANSITION, CAN_ID_DEINIT);
  }
  else
  {
    boolean ErrorDetected = FALSE;
    Can_ControllerIdType CtrlId;
    
    /* Loop all controllers. */
    for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
    {
      P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
      P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                              Can_DataGetControllerStateData(CtrlId);
      
      if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
      {
        /* Configuration error detected. */
        Can_ReportError(CAN_E_PARAM_POINTER, CAN_ID_DEINIT);
        ErrorDetected = TRUE;
      }
      else
      {
        /* Check correct controller state */
        if (CAN_CONTROLLER_STARTED == Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
        {
          Can_ReportError(CAN_E_TRANSITION, CAN_ID_DEINIT);
          ErrorDetected = TRUE;
        }
      }
    }
    
    if (FALSE == ErrorDetected)
    {
      /* Module uninitialize */
      Can_ModuleDeInit();
      
      /* Initialize all Message RAM clear completion flags */
      Can_DataClearIsMRamInit();
      
      /* Loop all controllers. */
      for (CtrlId = 0u; Can_DataGetNumberOfControllerConfig() > CtrlId; CtrlId++)
      {
        P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(CtrlId);
        P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                                Can_DataGetControllerStateData(CtrlId);
        /* Each controller reset */
        Can_ControllerReset(ControllerCfgPtr);
        
        /* Clear Message RAM */
        if (FALSE == ControllerStateDataPtr->IsMRamInit)
        {
          Can_DataInitMessageRam(ControllerCfgPtr);
        }
      }
      /* Initialize internal variables. */
      Can_DataReset();
    }
  }
}
#endif /* CAN_DEINIT_API == STD_ON */

#if CAN_CHECK_WAKEUP_API == STD_ON
/** \brief Can_CheckWakeup
 **
 ** This function checks if a wakeup has occurred for the given controller.
 **
 ** \return   CAN_OK: A wakeup was detected for the given controller.
 **           CAN_NOT_OK: No wakeup was detected for the given controller.
 ** \param [in] Controller   Controller to be checked for a wakeup.
 **
 */
FUNC(Can_ReturnType, AUTOMATIC) Can_CheckWakeup
(
  VAR(uint8, AUTOMATIC) Controller
)
{
  Can_ReturnType result = CAN_NOT_OK;
  
  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_CHECKWAKEUP);
  }
  else
  {
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                            Can_DataGetControllerStateData(Controller);
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr = Can_DataGetControllerConfig(Controller);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerStateDataPtr) || (NULL_PTR == ControllerCfgPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_CHECKWAKEUP);
    }
    else
    {
      /* Check if wake up was detected. */
      if (FALSE != Can_ControllerGetWakeup(ControllerStateDataPtr))
      {
        EcuM_SetWakeupEvent(ControllerCfgPtr->WakeupSource);
        result = CAN_OK;
      }
    }
  }
    
  return result;
}
#endif /* CAN_CHECK_WAKEUP_API == STD_ON */

#if CAN_GET_STATUS_API == STD_ON
/** \brief Can_GetStatus
 **
 ** Get additional status information related to a CAN controller.
 ** 
 ** This service is an extension to the AUTOSAR CAN Driver specification. It polls
 ** for error_passive and RX_Overflow and returns the state information, which may
 ** be required by the application.
 ** 
 ** If RX_Overflow is already detected, it shall be reported to error callout
 ** handler.
 ** If CAN_DEV_ERROR_DETECT equals STD_ON, the error is reported to DET module too.
 **
 ** \return   BitField containing following independent flags: **
 **           0x00: status is undefined (e.g. the conditions above have not
 **                 occurred, or CAN controller is not in state STARTED)
 **           CAN_STATUS_ERROR_PASSIVE: This flag is returned as long as the error
 **                                     counters of the CAN macro indicate that the
 **                                     controller is in the error passive state.
 **                                     The status is updated on every
 **                                     Can_GetStatus() call.
 **           CAN_STATUS_RX_OVERFLOW: The update of the internal state for
 **                                   Can_GetStatus() happens every time new
 **                                   data has been received by this controller
 **                                   and has been processed by the corresponding
 **                                   function (Can_MainFunction_Read() call in
 **                                   case of polling mode configuration, or on
 **                                   every CAN RX interrupt in case of IRQ mode
 **                                   configuration). This flag is only returned
 **                                   once, if during subsequent calls to
 **                                   Can_GetStatus() no new RX overflow condition
 **                                   occurred.
 ** \param [in] Controller   Get status of CAN controller identified by ID.
 **
 */
FUNC(uint8, AUTOMATIC) Can_GetStatus
(
  VAR(uint8, AUTOMATIC) Controller
)
{
  /* Set default return value to status undefined. */
  uint8 result = 0x00u;

  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    Can_ReportError(CAN_E_UNINIT, CAN_ID_GETSTATUS);
  }
  else
  {
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  controllerCfgPtr = Can_DataGetControllerConfig(Controller);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) controllerStateDataPtr = 
                                                                             Can_DataGetControllerStateData(Controller);

    /* Check if Controller ID is valid. */
    if ((NULL_PTR == controllerCfgPtr) || (NULL_PTR == controllerStateDataPtr))
    {
      Can_ReportError(CAN_E_PARAM_CONTROLLER, CAN_ID_GETSTATUS);
    }
    else
    {
      /* Get controller status */
      Can_ControllerStatusType controllerStatus = Can_ControllerGetStatus(controllerCfgPtr, controllerStateDataPtr);
      /* Check controller status */
      if (CAN_CONTROLLER_STARTED == controllerStatus)
      {
        /* Error status only available if controller is started. */
        result = Can_ControllerGetErrorStatus(controllerCfgPtr, controllerStateDataPtr);
      }
    }
  }
  return result;
}
#endif /* CAN_GET_STATUS_API == STD_ON */

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

#if ((CAN_CHANGE_BAUDRATE_API == STD_ON) || (CAN_SET_BAUDRATE_API == STD_ON) || \
     (CAN_SET_BAUDRATE_IN_CHANGED_CLOCK_API == STD_ON))
/** \brief Can_CheckBaudrateInternal
 **
 ** This checks, if a certain CAN controller supports a requested
 ** baudrate at the current point in time. The controller state is not checked.
 **
 ** \return   0: Baudrate supported by the CAN Controller
 **           else: Error code that was detected.
 ** \param [in] Controller   CAN Controller to check for the support of a certain
 **                          baudrate
 ** \param [in] Baudrate   Baudrate to check in kbps
 ** \param [out] ControllerStateDataPtrPtr   Pointer to pointer that is set to point
 **                                          to the ControllerStateData of the
 **                                          controller. If parameter Controller is
 **                                          invalid, (indicated by return value)
 **                                          then the pointer is not set.
 ** \param [out] ControllerBaudrateConfigPtrPtr   Pointer to pointer that is set to
 **                                               point to the ControllerBaudrateConfig
 **                                               that supports the baudrate. If
 **                                               parameter Controller or Baudrate
 **                                               is invalid, (indicated by return
 **                                               value) then the pointer is not set.
 ** \param [out] ControllerConfigPtrPtr   Pointer to pointer that is set to point
 **                                       to the ControllerConfig of the controller.
 **                                       If parameter Controller is invalid,
 **                                       (indicated by return value) then the pointer
 **                                       is not set.
 ** \param [in] IsBaudrateCfgId   This parameter shows that the parameter Baudrate
 **                               represents a baudrate configuration ID  or a
 **                               baudrate value.
 **                               TRUE := BaudrateConfigId
 **                               FALSE := baudrate value in kbps
 **
 */
static FUNC(uint8, AUTOMATIC) Can_CheckBaudrateInternal
(
  VAR(uint8, AUTOMATIC) Controller,
  CONST(uint16, AUTOMATIC) Baudrate,
  P2VAR(P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) ControllerStateDataPtrPtr,
  P2VAR(P2CONST(Can_ControllerBaudrateConfigType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) ControllerBaudrateConfigPtrPtr,
  P2VAR(P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC), AUTOMATIC, AUTOMATIC) ControllerConfigPtrPtr,
  VAR(boolean, AUTOMATIC) IsBaudrateCfgId
)
{
  uint8 result = CAN_E_PARAM_BAUDRATE;

  /* Check if module is initialized. */
  if (FALSE == Can_ModuleGetReady())
  {
    result = CAN_E_UNINIT;
  }
  else
  {
    P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC)  ControllerCfgPtr = Can_DataGetControllerConfig(Controller);
    P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr = 
                                                                             Can_DataGetControllerStateData(Controller);
    
    /* Check if Controller ID is valid. */
    if ((NULL_PTR == ControllerCfgPtr) || (NULL_PTR == ControllerStateDataPtr))
    {
      result = CAN_E_PARAM_CONTROLLER;
    }
    else
    {
      uint8 Index;
      *ControllerStateDataPtrPtr = ControllerStateDataPtr;
      *ControllerConfigPtrPtr = ControllerCfgPtr;
      
      /* Check Baudrate. */
      for (Index = 0u; ControllerCfgPtr->NumberOfBaudrates > Index; Index++)
      {
        if ((FALSE == IsBaudrateCfgId) && (ControllerCfgPtr->BaudratesCfgPtr[Index].BaudrateValue == Baudrate))
        {
          /* Matching Baudrate was found. */
          *ControllerBaudrateConfigPtrPtr = &(ControllerCfgPtr->BaudratesCfgPtr[Index]);
          result = 0u;
        }
        else if ((FALSE != IsBaudrateCfgId) && (ControllerCfgPtr->BaudratesCfgPtr[Index].BaudrateConfigId == Baudrate))
        {
          /* Matching Baudrate was found. */
          *ControllerBaudrateConfigPtrPtr = &(ControllerCfgPtr->BaudratesCfgPtr[Index]);
          result = 0u;
        }
        else
        {
        }
      }
    }
  }
  
  return result;
}
#endif /*((CAN_CHANGE_BAUDRATE_API == STD_ON) || (CAN_SET_BAUDRATE_API == STD_ON) || 
          (CAN_SET_BAUDRATE_IN_CHANGED_CLOCK_API == STD_ON)) */

/** \brief Can_SetControllerMode_Stopped
 **
 ** Perform state transitions from source state CAN_CONTROLLER_STOPPED. On
 ** transition error the error is reported. Function returns CAN_OK if transition
 ** is successfully done. In case of a reported error the return value is
 ** CAN_NOT_OK.
 **
 ** \return   Status of executed transition. CAN_OK if transition is executed
 **           successfully. CAN_NOT_OK if an error is reported and the state
 **           transition is not done.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode_Stopped
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
)
{
  Can_ReturnType retVal = CAN_OK;

  /* Check for allowed transitions and if allowed, perform it. */
  switch (Transition)
  {
    case CAN_T_START:
      /* Start transition is asynchronous. */
      /* Clear SW transmit message queue to have an
       * empty queue and no pending messages after start transition. */
      Can_DataAllFreeTxPduId(ControllerCfgPtr->ControllerId);
      Can_ControllerStart(ControllerCfgPtr, ControllerStateDataPtr);
      break;

    case CAN_T_STOP:
      /* Stop transition is synchronous. For the sake of safety, stop the controller again. */
      Can_ControllerStop(ControllerCfgPtr, ControllerStateDataPtr);
      Can_CanIfControllerModeIndication(ControllerCfgPtr, CAN_CONTROLLER_STOPPED);
      break;

    case CAN_T_SLEEP:
      /* Sleep transition is asynchronous. */
      Can_ControllerSleep(ControllerCfgPtr, ControllerStateDataPtr);
      break;

    case CAN_T_WAKEUP:
      /* CAN_T_WAKEUP transitions to the STOPPED state */
      Can_ControllerStop(ControllerCfgPtr, ControllerStateDataPtr);
      Can_CanIfControllerModeIndication(ControllerCfgPtr, CAN_CONTROLLER_STOPPED);
      break;

    /* other transitions is forbidden */
    default:
      Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETCTRLMODE);
      retVal = CAN_NOT_OK;
      break;
  }
  return retVal;
}

/** \brief Can_SetControllerMode_Started
 **
 ** Perform state transitions from source state CAN_CONTROLLER_STARTED. On
 ** transition error the error is reported. Function returns CAN_OK if transition
 ** is successfully done. In case of a reported error the return value is
 ** CAN_NOT_OK.
 **
 ** \return   Status of executed transition. CAN_OK if transition is executed
 **           successfully. CAN_NOT_OK if an error is reported and the state
 **           transition is not done.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode_Started
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
)
{
  Can_ReturnType retVal = CAN_OK;
  /* Check for allowed transitions and if allowed, perform it. */
  switch (Transition)
  {
    case CAN_T_STOP:
      /* Clear Tx and Rx Data. */
      Can_ControllerClearTxData(ControllerCfgPtr);
      if (E_OK == Can_ControllerHandleRx(ControllerCfgPtr, ControllerStateDataPtr, CAN_ID_SETCTRLMODE))
      {
        /* Stop transition is synchronous. */
        Can_ControllerStop(ControllerCfgPtr, ControllerStateDataPtr);
        Can_CanIfControllerModeIndication(ControllerCfgPtr, CAN_CONTROLLER_STOPPED);
      }
      else
      {
        /* Clear processing of Rx Data failed */
        Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETCTRLMODE);
        retVal = CAN_NOT_OK;
      }
      break;

    case CAN_T_START:
      /* Since the controller is already started, we can just confirm. */
      Can_CanIfControllerModeIndication(ControllerCfgPtr, CAN_CONTROLLER_STARTED);
      break;

    /* CAN_T_SLEEP and CAN_T_WAKEUP are forbidden. */
    default:
      Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETCTRLMODE);
      retVal = CAN_NOT_OK;
      break;
  }
  return retVal;
}

/** \brief Can_SetControllerMode_Sleep
 **
 ** Perform state transitions from source state CAN_CONTROLLER_SLEEP. On
 ** transition error the error is reported. Function returns CAN_OK if transition
 ** is successfully done. In case of a reported error the return value is
 ** CAN_NOT_OK.
 **
 ** \return   Status of executed transition. CAN_OK if transition is executed
 **           successfully. CAN_NOT_OK if an error is reported and the state
 **           transition is not done.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] Transition   Transition value to request new CAN controller state
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_SetControllerMode_Sleep
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_StateTransitionType, AUTOMATIC) Transition
)
{
  Can_ReturnType retVal = CAN_OK;
  /* Check for allowed transitions and if allowed, perform it. */
  switch (Transition)
  {
    case CAN_T_WAKEUP:
      /* Stop transition is synchronous. */
      Can_ControllerStop(ControllerCfgPtr, ControllerStateDataPtr);
      Can_CanIfControllerModeIndication(ControllerCfgPtr, CAN_CONTROLLER_STOPPED);
      break;

    case CAN_T_SLEEP:
      /* Since the controller is already asleep, we can just confirm. */
      Can_CanIfControllerModeIndication(ControllerCfgPtr, CAN_CONTROLLER_SLEEP);
      break;

    /* CAN_T_START and CAN_T_STOP are forbidden. */
    default:
      Can_ReportError(CAN_E_TRANSITION, CAN_ID_SETCTRLMODE);
      retVal = CAN_NOT_OK;
      break;
  }
  return retVal;
}

/** \brief Can_Write_CheckCanId
 **
 ** Check CanId
 ** 1. Standard CAN ID is 11 bit or less (mask possible FD flag)
 ** 2. Extended CAN ID is 29 bit or less (mask possible FD flag)
 **
 ** \return   CAN_OK     Error is not detected.
 **           CAN_NOT_OK Error is detected.
 **
 ** \param [in] CanId   Standard/Extended CAN ID of CAN L-PDU.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CheckCanId
(
  VAR(Can_IdType, AUTOMATIC) CanId
)
{
  Can_ReturnType result;
  
  if (   (0u == (CAN_CONTROLLER_XTD_ID_FLAG & CanId))
      && (CAN_CONTROLLER_MASK_11BIT < (CanId & (~CAN_CONTROLLER_FD_ID_FLAG))) )
  {
    result = CAN_NOT_OK;
  }
  else if (   (0u != (CAN_CONTROLLER_XTD_ID_FLAG & CanId))
           && (CAN_CONTROLLER_MASK_29BIT < (CanId
               & (~(CAN_CONTROLLER_FD_ID_FLAG | CAN_CONTROLLER_XTD_ID_FLAG))) ) )
  {
    result = CAN_NOT_OK;
  }
  else
  {
    result =CAN_OK;
  }
  
  return result;
}

/** \brief Can_Write_CheckForPreviousError
 **
 ** Check the state of the target controller and CanId of PduInfo.
 **
 ** \return   CAN_OK     Error is not detected.
 **           CAN_NOT_OK Error is detected.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] CanId   CanId in PduInfo structure.
 ** \param [out] ReportTransitionErrorPtr   Transition status error flag.
 ** \param [out] ReportIdErrorPtr   CanId error flag.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CheckForPreviousError
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_IdType, AUTOMATIC) CanId,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) ReportTransitionErrorPtr,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) ReportIdErrorPtr
)
{
  Can_ReturnType result = CAN_OK;
  
  /* Transmission or cancellation is possible in STARTED mode only. */
  if (CAN_CONTROLLER_STARTED != Can_ControllerGetStatus(ControllerCfgPtr, ControllerStateDataPtr))
  {
    /* Error callouts must not be called from within critical section. */
    *ReportTransitionErrorPtr = TRUE;
    result = CAN_NOT_OK;
  }
  
  /* FD message must not be sent when FD mode is disabled. */
  if (    (ControllerStateDataPtr->BaudrateData.BaudratePtr->FdEnabled == FALSE)
       && (0u != (CanId & CAN_CONTROLLER_FD_ID_FLAG)) )
  {
    /* Error callouts must not be called from within critical section. */
    *ReportIdErrorPtr = TRUE;
    result = CAN_NOT_OK;
  }
  
  return result;
}

/** \brief Can_Write_WriteRequest
 **
 ** Try to send the message.
 **
 ** \return   CAN_OK     Write request completed normally.
 **           CAN_NOT_OK PduInfo.DataPtr is invalid data pointer.
 **                      PduInfo.Length is invalid length.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] PduInfo   Pointer to SDU user memory, DLC and Identifier.
 ** \param [in] PduIdBufferIndex   Index of the PduId buffer where the message was
 **                                stored. The valid range depends on amount of
 **                                configured CAN controllers.
 ** \param [in] PaddingValue   Value to add for padding bytes in CAN message.
 ** \param [in] TxHandle   The buffer handle for the TX message. 
 ** \param [in] PduHandle   ID of the SDU that is requested to be transmitted.
 ** \param [in] TriggerTransmitEnable    Enables the possibility to request the 
 **                         data for this HW object with the CanIf_TriggerTransmit 
 **                         from CanIf instead of getting the data by call of Can_Write.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_WriteRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_ControllerPduInfoType, AUTOMATIC) PduInfo,
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  VAR(uint8, AUTOMATIC) PaddingValue,
  VAR(uint8, AUTOMATIC) TxHandle,
  VAR(PduIdType, AUTOMATIC) PduHandle,
  VAR(boolean, AUTOMATIC) TriggerTransmitEnable
)
{
  Can_ReturnType result = CAN_OK;

  /* CanIf_TriggerTransmit should not be called if the transmission is impossible for other reasons. */
  #if (CAN_TRIGGER_TRANSMIT_SUPPORT == STD_ON)
  if ( (NULL_PTR == PduInfo.DataPtr) && (TRUE == TriggerTransmitEnable) )
  {
    PduInfoType PduInfoForTriggerTx = { (P2VAR(uint8, AUTOMATIC, AUTOMATIC))NULL_PTR, 0u };

    if (E_NOT_OK != CanIf_TriggerTransmit(PduHandle, &PduInfoForTriggerTx))
    {
      PduInfo.DataPtr = PduInfoForTriggerTx.SduDataPtr;
      PduInfo.Length  = (uint8)(PduInfoForTriggerTx.SduLength);
    }
  }
  #endif

  /* Check for invalid data pointer. */
  if (NULL_PTR == PduInfo.DataPtr)
  {
    Can_ReportError(CAN_E_PARAM_POINTER, CAN_ID_WRITE);
    result = CAN_NOT_OK;
  }

  /* Check for invalid length with following condition:
   * 1. invalid: Length > 64
   * 2. invalid: Classic mode AND Length > 8
   * 3. invalid: FD mode but FD Flag in ID not set AND Length > 8 */
  if (CAN_NOT_OK == Can_Write_CheckParamDLC(PduInfo,
                                   ControllerStateDataPtr))
  {
    Can_ReportError(CAN_E_PARAM_DLC, CAN_ID_WRITE);
    result = CAN_NOT_OK;
  }
  
  if (CAN_OK == result)
  {
    /* Try to send the message. */
    Can_ControllerWrite(ControllerCfgPtr, ControllerStateDataPtr, PduIdBufferIndex, &PduInfo, TxHandle, PaddingValue);
  }
  else
  {
    /* An error is occurred. Message is not sent. Release reserved message queue slot. */
    Can_DataStoreTxPduId(PduIdBufferIndex, CAN_DATA_FREE_PDUID_BUFFER_SLOT);
  }
  return result;
}

/** \brief Can_Write_CheckParamDLC
 **
 ** Check for invalid length with following condition:
 ** 1. invalid: Length > 64
 ** 2. invalid: Classic mode AND Length > 8
 ** 3. invalid: FD mode but FD Flag in ID not set AND Length > 8
 **
 ** \return   CAN_OK     Error is not detected.
 **           CAN_NOT_OK Error is detected.
 **
 ** \param [in] PduInfo   Pointer to SDU user memory, DLC and Identifier.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CheckParamDLC
(
  VAR(Can_ControllerPduInfoType, AUTOMATIC) PduInfo,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  Can_ReturnType result;
  
  if (CAN_MAX_DLC_FD < PduInfo.Length)
  {
    result = CAN_NOT_OK;
  }
  else if(   (CAN_MAX_DLC_CLASSIC < PduInfo.Length)
          && (ControllerStateDataPtr->BaudrateData.BaudratePtr->FdEnabled != FALSE)
          && (0u == (PduInfo.CanId & CAN_CONTROLLER_FD_ID_FLAG)) )
  {
    result = CAN_NOT_OK;
  }
  else if (   (CAN_MAX_DLC_CLASSIC < PduInfo.Length)
           && (ControllerStateDataPtr->BaudrateData.BaudratePtr->FdEnabled == FALSE) )
  {
    result = CAN_NOT_OK;
  }
  else
  {
    result = CAN_OK;
  }
  
  return result;
}

#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
/** \brief Can_Write_CancelRequest
 **
 ** Cancel TX message.
 **
 ** \return   CAN_BUSY No TX hardware buffer available or pre-emptive call
 **                    of Can_Write that can't be implemented re-entrant.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller configuration.
 ** \param [in] CanId   Standard/Extended CAN ID of CAN L-PDU.
 ** \param [in] TxHandle   The buffer handle for the TX message. 
 */
static FUNC(Can_ReturnType, AUTOMATIC) Can_Write_CancelRequest
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  VAR(Can_IdType, AUTOMATIC) CanId,
  VAR(uint8, AUTOMATIC) TxHandle
)
{
  /* ctrlId, txHandle, pduIdBufferIndex, triggerTransmitEnable and paddingValue
   * are valid by now. */
  uint32 CanIdNormalized; /* Left aligned format that allows comparison of 11 bit to 29 bit identifiers. */

  /* Check for extended message. */
  if ( 0u == (CanId & CAN_CONTROLLER_XTD_ID_FLAG) )
  {
    /* Set standard message ID without FD Flag as left aligned value to allow
     * comparison of 11 bit to 29 bit identifier. */
    CanIdNormalized = (CanId << 18u) & CAN_CONTROLLER_MASK_29BIT;
  }
  else
  {
    /* Set extended message ID without XTD ID Flag and FD flag. */
    CanIdNormalized = (CanId & CAN_CONTROLLER_MASK_29BIT);
  }

  /* Cancel pending TX message. */
  Can_ControllerSetTxCancelRequest( ControllerCfgPtr, TxHandle, CanIdNormalized,
                                    CAN_IDENTICAL_ID_CANCELLATION );

  return CAN_BUSY;
}
#endif

/** \brief Can_CheckMissingTimerValueForPretendedNetworkMode
 **
 ** Check missing timer value in pretended networking mode.
 **
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 */
static FUNC(Std_ReturnType, AUTOMATIC) Can_CheckMissingTimerValueForPretendedNetworkMode
(
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  Std_ReturnType result = E_OK;
  uint32 Index;
  P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr = 
                                                       ControllerStateDataPtr->IcomState.IcomConfigPtr->RxMessageCfgPtr;
  
  if (FALSE == ControllerStateDataPtr->IcomState.IsWakeup) 
  {
    /* Loop the number of CanIcomRxMessage related to CanIcomConfig. */
    for (Index=0u; Index<ControllerStateDataPtr->IcomState.IcomConfigPtr->NumberOfRxMessageCfgPtr; Index++)
    {
      uint32 TimeoutDuration = IcomRxMsgPtr[Index].MissingMessageTimerValue;
      if (0u < TimeoutDuration) 
      {
        if (FALSE != Can_OsCheckTimeout(ControllerStateDataPtr->IcomState.StartTime,
                                        TimeoutDuration,
                                        CAN_ID_MF_READ))
        {
          result = E_NOT_OK;
        }
      }
    }
  }
  return result;
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[end of file]===========================================*/
