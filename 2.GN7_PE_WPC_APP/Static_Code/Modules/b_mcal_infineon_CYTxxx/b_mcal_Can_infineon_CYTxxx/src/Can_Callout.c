/** \brief Can_Callout.c
 **
 ** This file implements functions that call other modules.
 ** 
 ** The functions declared by this interface are driver internal and expect
 ** to be called with valid parameters.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Can_Callout.h>
#include <Can.h>
#include <Can_Data.h>
#include <Can_ControllerManager.h>
#include <Can_ModuleManager.h>
#include <Can_GeneralTypes.h>
#include <EcuM_Cbk.h>
#include <Os.h>
#include <CanIf_Cbk.h>
#include <SchM_Can.h>
#include <Can_ExternalInclude.h>
#if CAN_DEV_ERROR_DETECT == STD_ON
  #include <Det.h>
#endif /* CAN_DEV_ERROR_DETECT == STD_ON */
#if CAN_DEM_E_HW_ERROR == STD_ON
  #include <Dem.h>
#endif /* CAN_DEM_E_HW_ERROR == STD_ON */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B

#include "Can_MemMap.h"

/** \brief Can_CalloutCheckWakeupForPretendedNetworkMode
 **
 ** Check wakeup message for pretended networking mode.
 **
 ** \return   TRUE: Wake-up message.
 **           FALSE: Normal message.
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] MessageId   Can Id of the message.
 ** \param [in] MessageLength   The message length in bytes that shall be translated
 **                             to the DLC code.
 ** \param [in] DataPtr   Pointer to the message payload (SDU) in message RAM.
 **
 */
static FUNC(boolean, AUTOMATIC) Can_CalloutCheckWakeupForPretendedNetworkMode
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(uint32, AUTOMATIC) MessageId,
  VAR(uint8, AUTOMATIC) MessageLength,
  CONST(uint8, AUTOMATIC) DataPtr[]
);

/** \brief Can_CalloutCompareIcomMessage
 **
 ** Check wakeup message id for pretended networking mode.
 **
 ** \return   TRUE: Receive wakeup message.
 **           FALSE: Receiving except wakeup messages.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] IcomRxMsgPtr   Pointer to CanIcomRxMessage structure.
 ** \param [in] RxIndex   CanIcomRxMessage index.
 ** \param [in] MessageId   Can Id of the message.
 ** \param [in] MessageValue   Message payload (64bit).
 **
 */
static FUNC(boolean, AUTOMATIC) Can_CalloutCompareIcomMessage
(
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr,
  VAR(uint32, AUTOMATIC) RxIndex,
  VAR(uint32, AUTOMATIC) MessageId,
  VAR(uint64, AUTOMATIC) MessageValue
);

/** \brief Can_CalloutCompareIcomMessageSignal
 **
 ** Check wakeup message signal for pretended networking mode.
 **
 ** \return   TRUE: Wake-up message.
 **           FALSE: Normal message.
 ** \param [in] IcomRxMsgSigPtr   Pointer to CanIcomRxMessageSignal structure.
 ** \param [in] MessageValue   Message payload (64bit).
 **
 */
static FUNC(boolean, AUTOMATIC) Can_CalloutCompareIcomMessageSignal
(
  P2CONST(Can_ControllerIcomRxMessageSignalConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgSigPtr,
  VAR(uint64, AUTOMATIC) MessageValue
);

/** \brief Can_CalloutCheckCallRxFuncForPretendedNetwork
 **
 ** Check whether to send a message to CanIf.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] IcomRxMsgPtr   Pointer to CanIcomRxMessage structure.
 ** \param [in] RxIndex   CanIcomRxMessage index.
 ** \param [inout] IsCallRxFunc   Flag to decide whether to call API of CanIf.
 **                TRUE: Call required, FALSE: Call no required.
 **
 */
static FUNC(void, AUTOMATIC) Can_CalloutCheckCallRxFuncForPretendedNetwork
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr,
  VAR(uint32, AUTOMATIC) RxIndex,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) IsCallRxFunc
);

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal constants]====================================*/

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_CanIfControllerBusOff
 **
 ** Translates types and forwards the call to CanIf_ControllerBusOff.
 **
 ** \param [in] ControllerConfigPtr   Pointer to controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_CanIfControllerBusOff
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerConfigPtr
)
{
  CanIf_ControllerBusOff(ControllerConfigPtr->ControllerId);
}

/** \brief Can_CanIfControllerModeIndication
 **
 ** Translates types and forwards the call to CanIf_ControllerModeIndication.
 **
 ** \param [in] ControllerConfigPtr   Pointer to controller cfg.
 ** \param [in] ControllerStatus   New status of the controller.
 **
 */
FUNC(void, AUTOMATIC) Can_CanIfControllerModeIndication
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerConfigPtr,
  VAR(Can_ControllerStatusType, AUTOMATIC) ControllerStatus
)
{
  CanIf_ControllerModeType CanIfMode;
  /* Translate controller status. */
  switch (ControllerStatus)
  {
    case CAN_CONTROLLER_STARTED:
      CanIfMode = CANIF_CS_STARTED;
      break;
    case CAN_CONTROLLER_SLEEP:
      CanIfMode = CANIF_CS_SLEEP;
      break;
    case CAN_CONTROLLER_STOPPED:
      CanIfMode = CANIF_CS_STOPPED;
      break;
    /* case CAN_CONTROLLER_UNINIT: */
    default:
      CanIfMode = CANIF_CS_UNINIT;
      break;
  }
  CanIf_ControllerModeIndication(ControllerConfigPtr->ControllerId, CanIfMode);
}

/** \brief Can_CanIfRxIndication
 **
 ** Translates types and forwards the call to CanIf_RxIndication.
 **
 ** \param [in] ControllerCfgPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to the controller state data.
 ** \param [in] FilterIndex   Index of the Rx buffer or FIFO that stores the
 **                           message.
 ** \param [in] MessageId   Can Id of the message.
 ** \param [in] MessageLength   Length (in bytes) of the message (DLC).
 ** \param [in] DataPtr   Pointer to the message payload (SDU) in message RAM.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
FUNC(void, AUTOMATIC) Can_CanIfRxIndication
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(Can_ControllerRxHandleType, AUTOMATIC) FilterIndex,
  VAR(uint32, AUTOMATIC) MessageId,
  VAR(uint8, AUTOMATIC) MessageLength,
  P2CONST(uint8, AUTOMATIC, AUTOMATIC) DataPtr,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  boolean IsCallRxFunc;
  Can_HwHandleType hwHandle;
  
  if (FALSE == ControllerStateDataPtr->IcomState.IsPretended)
  {
    /* Pretended networking mode disable.
     * Forward to callout. */
    IsCallRxFunc = TRUE;
  }
  else
  {
    /* Pretended networking mode enable.
     * Check wakeup message for pretended networking mode */
    IsCallRxFunc = Can_CalloutCheckWakeupForPretendedNetworkMode(ControllerCfgPtr,
                                                                 ControllerStateDataPtr,
                                                                 MessageId,
                                                                 MessageLength,
                                                                 DataPtr);
  }
  
  if (TRUE == IsCallRxFunc)
  {
    /* Get HwHandle */
    if (E_OK == Can_DataTranslateRxHandle(ControllerCfgPtr->ControllerId,
                                          FilterIndex,
                                          ControllerStateDataPtr->IcomState.IsPretended,
                                          &hwHandle))
    {
      #ifdef CAN_LPDU_RECEIVE_CALLOUT_FUNCTION
     /* CAN444: Skip calling of CanIf_RxIndication if CAN_LPDU_RECEIVE_CALLOUT_FUNCTION returns FALSE. */
      if (FALSE != CAN_LPDU_RECEIVE_CALLOUT_FUNCTION(hwHandle, MessageId, MessageLength, DataPtr))
      {
      #endif /* #ifdef CAN_LPDU_RECEIVE_CALLOUT_FUNCTION */
      
        /* Check for AUTOSAR Release to use the right CanId_RxIndication function call.*/
        #if (CAN_RX_INDICATION_COMPATIBILITY == CAN_ASR_403_COMPATIBILITY)
        CanIf_RxIndication(hwHandle, MessageId, MessageLength, DataPtr);
        #else
        {
          VAR(Can_HwType, AUTOMATIC) mailbox;
          VAR(PduInfoType, AUTOMATIC) pduInfo;
          
          mailbox.CanId = MessageId;
          mailbox.ControllerId = ControllerCfgPtr->ControllerId;
          mailbox.Hoh = hwHandle;
          /* Deviation from MISRA-C:2004 Rule 11.5; REFERENCE - ISO:C90-6.3.16.1, MISRA-C:2012 Rule-11.8
             Dangerous pointer cast results in loss of const qualification.
             Justification: Cast is necessary for writing to the buffer. */
          /* PRQA S 311 1 */
          pduInfo.SduDataPtr = (P2VAR(uint8, AUTOMATIC, AUTOMATIC))DataPtr;
          pduInfo.SduLength = MessageLength;
          
          CanIf_RxIndication(&mailbox, &pduInfo);
        }
        #endif /* #if (CAN_RX_INDICATION_COMPATIBILITY == CAN_ASR_403_COMPATIBILITY) #else */
      
      #ifdef CAN_LPDU_RECEIVE_CALLOUT_FUNCTION
      }
      #endif /* #ifdef CAN_LPDU_RECEIVE_CALLOUT_FUNCTION */
    }
    else
    {
      /* During normal operation, the wakeup message ID of Pretended Networking mode is set to 
       * Hardware Filter. Therefore, there is a possibility to receive a message ID for Wakeup. 
       * Check the unknown message ID for Wakeup message ID, and error if not applicable. */
      if (FALSE == Can_DataCheckIcomRxMessageID(MessageId))
      {
        /* Unknown message ID was received. */
        Can_ReportError(CAN_E_UNKNOWN_DATA, ApiId);
      }
    }
  }
}

/** \brief Can_CanIfTxCancellation
 **
 ** Does the translation of the PduIdBufferIndex to PduId, requests the Tx handler
 ** to free up the buffer and calls CanIf_CancelTxConfirmation.
 **
 ** \param [in] PduIdBufferIndex   Index of the Tx buffer that was used to transmit
 **                                the message.
 ** \param [in] SduDataPtr   Pointer to the message payload data in message RAM.
 ** \param [in] SduLength   Length in bytes of the message payload.
 **
 */
FUNC(void, AUTOMATIC) Can_CanIfTxCancellation
(
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC) SduDataPtr,
  VAR(uint8, AUTOMATIC) SduLength
)
{
  #if CAN_HW_TRANSMIT_CANCELLATION == STD_ON
  /* Prepare data. */
  PduInfoType PduInfo;
  PduIdType   PduId = Can_DataGetTxPduId(PduIdBufferIndex);

  PduInfo.SduDataPtr = SduDataPtr;
  PduInfo.SduLength = SduLength;
  #endif /* #if CAN_HW_TRANSMIT_CANCELLATION == STD_ON */

  /* Release message queue slot. */
  Can_DataStoreTxPduId(PduIdBufferIndex, CAN_DATA_FREE_PDUID_BUFFER_SLOT);
  
  #if CAN_HW_TRANSMIT_CANCELLATION == STD_ON
  CanIf_CancelTxConfirmation(PduId, &PduInfo);
  #endif /* #if CAN_HW_TRANSMIT_CANCELLATION == STD_ON */
}

/** \brief Can_CanIfTxConfirmation
 **
 ** Does the translation of the BufferIndex to PduId, requests the Tx handler to
 ** free up the buffer and calls CanIf_TxConfirmation.
 **
 ** \param [in] PduIdBufferIndex   Index of the Tx buffer that was used to transmit
 **                                the message.
 **
 */
FUNC(void, AUTOMATIC) Can_CanIfTxConfirmation
(
  VAR(Can_ControllerPduIdBufferIndexType, AUTOMATIC) PduIdBufferIndex
)
{
  /* Prepare data. */
  PduIdType PduId = Can_DataGetTxPduId(PduIdBufferIndex);

  /* Release message queue slot. */
  Can_DataStoreTxPduId(PduIdBufferIndex, CAN_DATA_FREE_PDUID_BUFFER_SLOT);

  CanIf_TxConfirmation(PduId);
}

/** \brief Can_EcuMCheckWakeup
 **
 ** Translates types and forwards the call to EcuM_CheckWakeup.
 **
 ** \param [in] ControllerConfigPtr   Pointer to controller cfg.
 **
 */
FUNC(void, AUTOMATIC) Can_EcuMCheckWakeup
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerConfigPtr
)
{
  EcuM_CheckWakeup(ControllerConfigPtr->WakeupSource);
}

/** \brief Can_EcuMSetWakeupForPretendedNetworkMode
 **
 ** Translates types and forwards the call to EcuM_SetWakeupEvent.
 **
 ** \param [in] ControllerConfigPtr   Pointer to controller cfg.
 ** \param [inout] ControllerStateDataPtr   Pointer to the controller state data.
 **
 */
FUNC(void, AUTOMATIC) Can_EcuMSetWakeupForPretendedNetworkMode
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerConfigPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr
)
{
  if (FALSE == ControllerStateDataPtr->IcomState.IsWakeup)
  {
    EcuM_SetWakeupEvent(ControllerConfigPtr->WakeupSource);
    ControllerStateDataPtr->IcomState.IsWakeup = TRUE;
  }
}

/** \brief Can_EnterCriticalSection
 **
 ** Starts a critical section.
 **
 */
FUNC(void, AUTOMATIC) Can_EnterCriticalSection(void)
{
  SchM_Enter_Can_CAN_EXCLUSIVE_AREA_0();
}

/** \brief Can_ExitCriticalSection
 **
 ** Ends a critical section that was previously started with
 ** Can_EnterCriticalSection.
 **
 */
FUNC(void, AUTOMATIC) Can_ExitCriticalSection(void)
{
  SchM_Exit_Can_CAN_EXCLUSIVE_AREA_0();
}

/** \brief Can_OsCheckTimeout
 **
 ** Calculates if a timeout occurred since the given time by the OS counter value.
 **
 ** \return   TRUE: timeout occurred,
 **           FALSE: timeout did not occur yet.
 ** \param [in] StartTime   The start time from which the elapsed time shall be
 **                         calculated.
 ** \param [in] TimeoutDuration   Specify the time-out duration.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
FUNC(boolean, AUTOMATIC) Can_OsCheckTimeout
(
  VAR(uint32, AUTOMATIC) StartTime,
  VAR(uint32, AUTOMATIC) TimeoutDuration,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  boolean result = FALSE;
  
  /* Assure correct type handling. */
  TickType CntValue = (TickType)StartTime;
  TickType ElapsedValue = 0u;
  
  if (E_OK == GetElapsedValue(CAN_OS_COUNTER_ID, &CntValue, &ElapsedValue))
  {
    if (TimeoutDuration <= ElapsedValue)
    {
      /* Timeout occurred. */
      result = TRUE;
    }
  }
  else
  {
    /* GetElapsedValue could not evaluate the time,
       therefore timeout is assumed to prevent any deadlocks. */
    result = TRUE;
    Can_ReportError(CAN_E_OS_TIME_REFUSED, ApiId);    
  }
  
  return result;
}

/** \brief Can_OsGetCounterValue
 **
 ** Reads the OS counter value and returns it in the output parameter CounterValue.
 ** The return value is for an error indication.
 **
 ** \return   Return value is the error status. Function returns E_NOT_OK if no error
 **           is occurred and the CounterValue could be used. Function returns
 **           E_OK, if an error is detected and the CounterValue is invalid and
 **           should not be used.
 ** \param [out] CounterValuePtr   OS counter value
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
FUNC(Std_ReturnType, AUTOMATIC) Can_OsGetCounterValue
(
  P2VAR(uint32, AUTOMATIC, AUTOMATIC) CounterValuePtr,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  TickType counterValue = 0u;
  Std_ReturnType retVal = E_OK;
  
  /* Get counter value and check for error. */
  if (E_OK != GetCounterValue(CAN_OS_COUNTER_ID, &counterValue))
  {
    /* Error occurred. counterValue should not be used. */
    Can_ReportError(CAN_E_OS_TIME_REFUSED, ApiId);
    retVal = E_NOT_OK;
  }
  else
  {
    /* counteValue is valid, set to output parameter. */
    *CounterValuePtr = (uint32)counterValue;
  }
  
  return retVal;
}

/** \brief Can_ReportError
 **
 ** Reports an error to the error handler and optionally to the DET.
 **
 ** \param [in] ErrorId   Id of the error that was detected.
 ** \param [in] ApiId   Id of the service that detected the error.
 **
 */
FUNC(void, AUTOMATIC) Can_ReportError
(
  VAR(uint8, AUTOMATIC) ErrorId,
  VAR(uint8, AUTOMATIC) ApiId
)
{
  /* ASIL error callout. */
  /* Cast to void to allow configuration of Det_ReportError. */
  (void)CAN_ERROR_CALLOUT_FUNCTION(CAN_MODULE_ID, 0u, ApiId, ErrorId);
  
  /* DET error reporting */
  #if CAN_DEV_ERROR_DETECT == STD_ON
  /* Ignore the return value of Det_ReportError, the error has already been
     notified to error call-out handler. */
  (void)Det_ReportError(CAN_MODULE_ID, 0u, ApiId, ErrorId);
  #endif /* #if CAN_DEV_ERROR_DETECT == STD_ON */
}

/** \brief Can_DemReportErrorStatus
 **
 ** Reports an error to the error handler and optionally to the DEM.
 **
 ** \param [in] ErrorId   Id of the error that was detected.
 ** \param [in] ApiId   Id of the service that detected the error.
 ** \param [in] EventStatus   Status of event.
 **
 */
FUNC(void, AUTOMATIC) Can_DemReportErrorStatus
(
  VAR(uint8, AUTOMATIC) ErrorId,
  VAR(uint8, AUTOMATIC) ApiId,
  VAR(uint8, AUTOMATIC) EventStatus
)
{
#if ( CAN_DEM_E_HW_ERROR == STD_ON )
  VAR( Dem_EventStatusType, AUTOMATIC ) DemEventStatus;
#endif /* CAN_DEM_E_HW_ERROR == STD_ON */

  /* ASIL error callout. */
  (void)CAN_ERROR_CALLOUT_FUNCTION(CAN_MODULE_ID, 0u, ApiId, ErrorId);
  
  /* DEM error reporting */
  #if CAN_DEM_E_HW_ERROR == STD_ON
  DemEventStatus = ( EventStatus == CAN_DEM_EVENT_STATUS_PASSED ) ?
                   ( DEM_EVENT_STATUS_PASSED ) : ( DEM_EVENT_STATUS_FAILED );
  /* Call diagnostic event manager */
  Dem_ReportErrorStatus(CAN_INTERNAL_E_HW_ERROR, DemEventStatus);
  #endif /* #if CAN_DEM_E_HW_ERROR == STD_ON */
}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[internal function definitions]=========================*/

#define CAN_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/** \brief Can_CalloutCheckWakeupForPretendedNetworkMode
 **
 ** Check if it is a wakeup message. 
 ** If it matches the wakeup condition, call EcuM_SetWakeupEvent.
 **
 ** \return   TRUE: Receive wakeup message.
 **           FALSE: Receiving except wakeup messages.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] MessageId   Can Id of the message.
 ** \param [in] MessageLength   Length (in bytes) of the message (DLC).
 ** \param [in] DataPtr   Pointer to the message payload (SDU) in message RAM.
 **
 */
static FUNC(boolean, AUTOMATIC) Can_CalloutCheckWakeupForPretendedNetworkMode
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  VAR(uint32, AUTOMATIC) MessageId,
  VAR(uint8, AUTOMATIC) MessageLength,
  CONST(uint8, AUTOMATIC) DataPtr[]
)
{
  uint32 RxIndex;
  VAR(uint8, AUTOMATIC) DataIndex;
  VAR(uint64, AUTOMATIC) MessageValue = 0u;
  boolean IsCallRxFunc = FALSE;
  boolean IsWakeupMsg = FALSE;
  P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr = 
                                                       ControllerStateDataPtr->IcomState.IcomConfigPtr->RxMessageCfgPtr;
  
  /* Collect the payload of the message length (maximum 8 bytes) into the MessageValue variable. */
  if (8u < MessageLength)
  {
    MessageLength = 8u;
  }
  for (DataIndex = 0u; DataIndex < MessageLength; DataIndex++)
  {
    MessageValue <<= 8u;
    MessageValue |= DataPtr[DataIndex];
  }
  
  /* Loop the number of CanIcomRxMessage related to CanIcomConfig. */
  for (RxIndex=0u; RxIndex<ControllerStateDataPtr->IcomState.IcomConfigPtr->NumberOfRxMessageCfgPtr; RxIndex++)
  {
    /* Check wakeup message id */
    IsWakeupMsg |= Can_CalloutCompareIcomMessage(ControllerStateDataPtr,
                                                 IcomRxMsgPtr,
                                                 RxIndex,
                                                 MessageId,
                                                 MessageValue);
    
    if (FALSE == ControllerStateDataPtr->IcomState.IsWakeup)
    {
      /* Check whether to send a message to CanIf. */
      Can_CalloutCheckCallRxFuncForPretendedNetwork(ControllerCfgPtr,
                                                    ControllerStateDataPtr,
                                                    IcomRxMsgPtr,
                                                    RxIndex,
                                                    &IsCallRxFunc);
      if (TRUE == IsCallRxFunc)
      {
        Can_EcuMSetWakeupForPretendedNetworkMode(ControllerCfgPtr, ControllerStateDataPtr);
      }
    }
  }
  
  /* Check normal message */
  if (FALSE == IsWakeupMsg)
  {
    /* Normal message */
    IsCallRxFunc = TRUE;
  }
  
  return IsCallRxFunc;
}

/** \brief Can_CalloutCompareIcomMessage
 **
 ** Check wakeup message id for pretended networking mode.
 **
 ** \return   TRUE: Receive wakeup message.
 **           FALSE: Receiving except wakeup messages.
 ** \param [inout] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] IcomRxMsgPtr   Pointer to CanIcomRxMessage structure.
 ** \param [in] RxIndex   CanIcomRxMessage index.
 ** \param [in] MessageId   Can Id of the message.
 ** \param [in] MessageValue   Message payload (64bit).
 **
 */
static FUNC(boolean, AUTOMATIC) Can_CalloutCompareIcomMessage
(
  P2VAR(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr,
  VAR(uint32, AUTOMATIC) RxIndex,
  VAR(uint32, AUTOMATIC) MessageId,
  VAR(uint64, AUTOMATIC) MessageValue
)
{
  uint32 RxSigIndex;
  boolean IsWakeupMsg = FALSE;
  
  if (NULL_PTR == IcomRxMsgPtr[RxIndex].RxMessageSignalCfgPtr)
  {
    /* Compare wakeup message Id. 
     * If CanIcomMessageIdMask is undefined, 0x1FFFFFFFF is set, 
     * so it is conditional that it exactly matches CanIcomMessageId.
     * If CanIcomMessageIdMask is 0, all message IDs are recognized as wakeup messages */
    if (   (IcomRxMsgPtr[RxIndex].MessageId == (IcomRxMsgPtr[RxIndex].MessageMask & MessageId))
        || (0u == IcomRxMsgPtr[RxIndex].MessageMask) )
    {
      ControllerStateDataPtr->IcomState.CanRxMessageCountersPtr[RxIndex]++;
      IsWakeupMsg = TRUE;
    }
  }
  else
  {
    /* Compare wakeup message Id. 
     * If CanIcomRxMessageSignalConfig is defined, even if CanIcomMessageIdMask 
     * is defined, it is ignored. */
    if (IcomRxMsgPtr[RxIndex].MessageId == (MessageId & ~(CAN_CONTROLLER_FD_ID_FLAG | CAN_CONTROLLER_XTD_ID_FLAG)))
    {
      /* Compare wakeup message signal. */
      P2CONST(Can_ControllerIcomRxMessageSignalConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgSigPtr = 
                                                                            IcomRxMsgPtr[RxIndex].RxMessageSignalCfgPtr;
      for (RxSigIndex = 0u; RxSigIndex<IcomRxMsgPtr[RxIndex].NumberOfRxMessageSignalCfgPtr; RxSigIndex++)
      {
        /* The mask is binary AND with the signal payload.
         * Compare with CanIcomSignalValue according to the operation of CanIcomSignalOperation. */
        if (TRUE == Can_CalloutCompareIcomMessageSignal(&(IcomRxMsgSigPtr[RxSigIndex]),
                                                         (MessageValue & IcomRxMsgSigPtr[RxSigIndex].SignalMask)))
        {
          ControllerStateDataPtr->IcomState.CanRxMessageCountersPtr[RxIndex]++;
          IsWakeupMsg = TRUE;
        }
      }
    }
  }
  return IsWakeupMsg;
}

/** \brief Can_CalloutCompareIcomMessageSignal
 **
 ** Check wakeup message signal for pretended networking mode.
 **
 ** \return   TRUE: Wake-up message.
 **           FALSE: Normal message.
 ** \param [in] IcomRxMsgSigPtr   Pointer to CanIcomRxMessageSignal structure.
 ** \param [in] MessageValue   Message payload (64bit).
 **
 */
static FUNC(boolean, AUTOMATIC) Can_CalloutCompareIcomMessageSignal
(
  P2CONST(Can_ControllerIcomRxMessageSignalConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgSigPtr,
  VAR(uint64, AUTOMATIC) MessageValue
)
{
  boolean result = FALSE;
  
  /* Compare with CanIcomSignalValue according to the operation of CanIcomSignalOperation. */
  switch (IcomRxMsgSigPtr->SignalOperation)
  {
    case CAN_CONTROLLER_ICOM_AND:
      if (0u != (IcomRxMsgSigPtr->SignalValue & MessageValue))
      {
        result = TRUE;
      }
      break;
    case CAN_CONTROLLER_ICOM_XOR:
      if (0u != (IcomRxMsgSigPtr->SignalValue ^ MessageValue))
      {
        result = TRUE;
      }
      break;
    case CAN_CONTROLLER_ICOM_GREATER:
      if (IcomRxMsgSigPtr->SignalValue < MessageValue)
      {
        result = TRUE;
      }
      break;
    case CAN_CONTROLLER_ICOM_SMALLER:
      if (IcomRxMsgSigPtr->SignalValue > MessageValue)
      {
        result = TRUE;
      }
      break;
    /* case CAN_CONTROLLER_ICOM_EQUAL: */
    default:
      if (IcomRxMsgSigPtr->SignalValue == MessageValue)
      {
        result = TRUE;
      }
      break;
  }
  
  return result;
}

/** \brief Can_CalloutCheckCallRxFuncForPretendedNetwork
 **
 ** Check whether to send a message to CanIf.
 **
 ** \param [in] ControllerCfgPtr   Pointer to the controller cfg.
 ** \param [in] ControllerStateDataPtr   Pointer to controller state data.
 ** \param [in] IcomRxMsgPtr   Pointer to CanIcomRxMessage structure.
 ** \param [in] RxIndex   CanIcomRxMessage index.
 ** \param [inout] IsCallRxFunc   Flag to decide whether to call API of CanIf.
 **                TRUE: Call required, FALSE: Call no required.
 **
 */
static FUNC(void, AUTOMATIC) Can_CalloutCheckCallRxFuncForPretendedNetwork
(
  P2CONST(Can_ControllerConfigType, AUTOMATIC, AUTOMATIC) ControllerCfgPtr,
  P2CONST(Can_ControllerStateDataType, AUTOMATIC, AUTOMATIC) ControllerStateDataPtr,
  P2CONST(Can_ControllerIcomRxMessageConfigType, AUTOMATIC, AUTOMATIC) IcomRxMsgPtr,
  VAR(uint32, AUTOMATIC) RxIndex,
  P2VAR(boolean, AUTOMATIC, AUTOMATIC) IsCallRxFunc
)
{
  uint32 TimeoutDuration = IcomRxMsgPtr[RxIndex].MissingMessageTimerValue;
  
  /* Check if the number of times of reception reaches the number defined in CanIcomCounterValue.
   * If CanIcomCounterValue is undefined, 1 is set. */
  if (IcomRxMsgPtr[RxIndex].CounterValue <= ControllerStateDataPtr->IcomState.CanRxMessageCountersPtr[RxIndex])
  {
    *IsCallRxFunc = TRUE;
  }
  
  /* The MCU wake if the message with the ID is not received for a specific time. */
  if (0u < TimeoutDuration)
  {
    uint8 ApiID;
    if (FALSE == (ControllerCfgPtr->InterruptEnableRx))
    {
      ApiID = CAN_ID_MF_READ; 
    }
    else
    {
      ApiID = CAN_ID_ISR; 
    }
    if (FALSE != Can_OsCheckTimeout(ControllerStateDataPtr->IcomState.StartTime, TimeoutDuration, ApiID))
    {
      *IsCallRxFunc = TRUE;
    }
  }

}

#define CAN_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Can_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include "Can_MemMap.h"

/*==================[end of file]===========================================*/
