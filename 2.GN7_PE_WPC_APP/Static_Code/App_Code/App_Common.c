/***************************************************************************************************
    THEME NAME  :   WPC
    USE CPU     :	CYT2BL4CAA (80-LQFP)
	MEMORY      :	Code-flash : 4160KB (4032KB + 128KB), Work-Flash 128KB (96KB + 32KB), SRAM : 512KB, ROM 32KB
    USE CLOCK   :
    LANGUAGE    :
    REMARKS     :   Source encoding information is UFT-8.

    (C) Copyright NIDEC MOBILITY KOREA CORPORATION. 2023 All Rights Reserved

***************************************************************************************************/

/***************************************************************************************************
    INCLUDE FILES
***************************************************************************************************/

#include "App_Common.h"


/***************************************************************************************************
    LOCAL DEFINES AND MACROS
***************************************************************************************************/


/***************************************************************************************************
    LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
***************************************************************************************************/


/***************************************************************************************************
    LOCAL VARIABLES AND CONSTANTS
***************************************************************************************************/


/***************************************************************************************************
    GLOBAL VARIABLES AND CONSTANTS
***************************************************************************************************/


/***************************************************************************************************
    LOCAL FUNCTION PROTOTYPES
***************************************************************************************************/



/*#################################################################################################
    GLOBAL FUNCTIONS
#################################################################################################*/


/***************************************************************************************************
@param[in]  void
@return     void
@note
***************************************************************************************************/
void gs_UpdateEvent(uint8_t current, Event_t *event)
{
	event->Off_Event = 0;  // 매주기 클리어
	event->On_Event = 0;  // 매주기 클리어

	if (current != event->previous)
	{
		if (current == OFF)
		{
			event->Off_Event = 1u;        // event off : ON
		}
		else
		{
			event->On_Event = current;    // event on : ON
		}
	}

	event->Old = event->previous;    // 이벤트 발생시 이벤트 발생전 값 확인하고자 할때 사용하기 위해 변수 추가함. 예:if(xx.On_Event == ON) && xx.Old == xxxx),
    event->previous = current;      // 동일 주기에서 current 값으로 설정하므로 변경 전 값 확인시 사용 불가
}

/***************************************************************************************************
@param[in]  void
@return     void
@note
***************************************************************************************************/
void gs_EventMsgAutoClear(uint8_t *current, Event_t *event, uint16_t ClearTime)
{
	// can signal off에서 값 변경시 120ms 동안 변경된 signal값 유지되고, 그후 default(0) value로 변경됨
    // ClearTime CAN 통신일 경우에는 cycle 의 3배
    // ClearTime 일반 어플리케이션 일 경우에는 Task 주기의 3배

    gs_UpdateEvent(*current, event);    // current는 pointer이므로 값을 넣기위해서 *를 추가함, event는 이미 pointer이므로 &를 생략함.

	if(event->On_Event != OFF)  			// on event가 발생할때만
	{
		event->Count = ClearTime;       // 10ms Task이므로
	}

    if(event->Off_Event == ON)
    {
        event->Count = 0u;              // Off event = on이면 즉시 클리어 처리 함.
    }

	if(event->Count != 0u)
	{
		event->Count --;
	}
	else
	{
		*current = OFF;
	}
}



/***************************************************************************************************
@param[in]  void
@return     void
@note       none
***************************************************************************************************/
void  gs_StartTimer (Timer_t *pTimer)
{
    pTimer->Running = 1u;
    pTimer->Count = 0;
}

/***************************************************************************************************
@param[in]  void
@return     void
@note       none
***************************************************************************************************/
void  gs_ReStartTimer (Timer_t *pTimer)
{
	gs_StartTimer(pTimer);
}

/***************************************************************************************************
@param[in]  void
@return     void
@note       none
***************************************************************************************************/
void  gs_CancelTimer (Timer_t *pTimer)
{
    pTimer->Running = 0u;
    pTimer->Count = 0;
}

/***************************************************************************************************
@param[in]  void
@return     void
@note       none
***************************************************************************************************/
void  gs_InitTimer (Timer_t *pTimer, uint8_t Timer_Cnt_Max)   // 호출할때 반드시 배열 0번으로 호출해야 한다.
{
    uint8_t  i;

    for (i = 0; i < Timer_Cnt_Max; i++)/* 모든 타이머를 리셋하고 비활성화한다                */
	{
        pTimer->Running = 0u;
        pTimer->Count = 0;
        pTimer++;
    }
}

/***************************************************************************************************
@param[in]  void
@return     void
@note       none
***************************************************************************************************/
void gs_UpdateTimer (Timer_t *pTimer, uint8_t Timer_Cnt_Max)
{
    uint8_t   i;

    for (i = 0; i < Timer_Cnt_Max; i++)
	{
        if (pTimer->Running == 1u) 			/* 타이머가 활성화됐을 경우만 카운터를 증가      */
		{
            if (pTimer->Count < 65535u)
			{
                pTimer->Count++;
			}
		}
		else
		{
			pTimer->Count = 0;
        }

        pTimer++;
    }
}


// /***************************************************************************************************
// @param[in]  void
// @return     void
// @note       한자리수 hex 를 Ascii로 변환
// ***************************************************************************************************/
// uint8_t gs_HexToAscii(uint8_t hex)
// {
//     // 변환 테이블 정의
//     static const char hexToAsciiTable[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

//     // 16진수 값(4비트 0x0 ~ 0xF)을 ASCII 문자로 변환하는 함수 구현
//     if (hex >= 0x0 && hex <= 0xF) 
//     {
//         return hexToAsciiTable[hex];
//     } 
//     else 
//     {
//         return '?'; // 잘못된 입력 처리
//     }
// }


/***************************************************************************************************
    LOCAL FUNCTIONS
***************************************************************************************************/
