/** \brief AUTOSAR Fls Flash Driver
 **
 ** This file contains all definitions of the configuration of the
 ** AUTOSAR module Fls that are target independent.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/

#include <Fls.h>                /* Fls Flash Driver header file */
#include <Fls_LibInterface.h>   /* Library interface header file */
#include <Fls_InternalLib.h>    /* Module internal API */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/** \brief Fls_CheckConfigPtr
 **
 ** Checks address to configuration.
 **
 ** \param[in]  ConfigPtr   Pointer to flash driver configuration set
 **
 ** \return    valid index of configuration pointer or invalid pointer
 ** \retval    FLS_INVALID_CONFIGSET_POINTER(0)           configuration pointer is invalid
 **            other than FLS_INVALID_CONFIGSET_POINTER   index of configuration pointer (valid)
 */
static FUNC(uint16, FLS_CODE) Fls_CheckConfigPtr
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
);

#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[external constants]====================================*/

#define FLS_START_SEC_CONST_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/* flag whether use interrupts or not */
CONST( uint8, FLS_CONST ) Fls_UseInterrupts = FLS_USE_INTERRUPTS;

/* flag whether error callout functions are called when a blank check job detects non-blank. */
CONST( uint8, FLS_CONST ) Fls_ReportErrorIfNotBlank = FLS_REPORT_ERROR_IF_NOT_BLANK;

/* flag whether use eCT Flash safety mechanism or not */
CONST( uint8, FLS_CONST ) Fls_UseSafetyMechanism = FLS_USE_SAFETY_MECHANISM;

/* The existence and the name of a callout function for invocation of system-call in upper layer. */
CONST( Fls_SystemcallCalloutFctPtr, FLS_CONST ) Fls_SystemcallCalloutFunction = FLS_SYSTEMCALL_CALLOUT_FUNCTION;

/* DMA channel (No.) for reading from work flash */
CONST( uint8, FLS_CONST ) Fls_DmaChannel = FLS_DMA_CHANNEL;

/* The size of auxiliary buffer that stores data which is read from work flash by DMA transfer */
CONST( Fls_LengthType, FLS_CONST ) Fls_AuxiliaryBufferSize = FLS_AUXILIARY_BUFFER_SIZE;

/* flag of directly reading from work flash without blank check */
CONST( uint8, FLS_CONST ) Fls_ReadImmediateDirect = STD_OFF;

/* flag whether writing is performed with non-blocking mode or not */
CONST( uint8, FLS_CONST ) Fls_UseNonBlockingWrite = FLS_USE_NON_BLOCKING_WRITE;

/* flag whether reading is performed with DMA transfer or not */
CONST( uint8, FLS_CONST ) Fls_UseDmaForRead = FLS_USE_DMA_FOR_READ;

/* value of FLASHC.FLASH_CTL */
CONST( uint32, FLS_CONST ) Fls_FlashCtlValue = FLS_FLASHC_FLASH_CTL_VALUE;

/* mask of FLASHC.FLASH_CTL: mask for verifying settings */
CONST( uint32, FLS_CONST ) Fls_FlashCtlRMask = FLS_FLASHC_FLASH_CTL_R_MASK;

/* mask of FLASHC.FLASH_CTL: mask for setting */
CONST( uint32, FLS_CONST ) Fls_FlashCtlWMask = FLS_FLASHC_FLASH_CTL_W_MASK;

/* mask of FM_CTL_ECT.WORK_FLASH_SAFETY: mask for setting if embedded operations are enabled */
CONST( uint32, FLS_CONST ) Fls_WFSafetyWMask = FLS_FM_CTL_ECT_WORK_FLASH_SAFETY_W_MASK;

/* mask of FAULT.MASK1: mask for setting */
CONST( uint32, FLS_CONST ) Fls_FaultStructMask1WMask = FLS_FAULT_STRUCT_MASK1_W_MASK;

/* maximum time (plus margin) to retry for write enable acquisition in milli seconds */
CONST( uint16, FLS_CONST ) Fls_MaxRetryTime = FLS_MAX_RETRY_TIME;

/* Which core runs this module */
CONST( uint8, FLS_CONST ) Fls_CoreKind = FLS_CORE_KIND;

/* CPUSS registers access address */
/* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
   Justification: This implementation is done for getting correct address for device
   access by integral value in resource file. */
/* PRQA S 303 1 */
volatile CONSTP2VAR( uint32, FLS_CONST, REGSPACE ) Fls_CpussBaseAddr = (volatile uint32 *)FLS_CPUSS_ADDR;

/* Fault structure registers access address */
/* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
   Justification: This implementation is done for getting correct address for device
   access by integral value in resource file. */
/* PRQA S 303 1 */
volatile CONSTP2VAR( uint32, FLS_CONST, REGSPACE ) Fls_FaultBaseAddr = (volatile uint32 *)FLS_FAULT_ADDR;

/* IPC structure registers base address */
/* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
   Justification: This implementation is done for getting correct address for device
   access by integral value in resource file. */
/* PRQA S 303 1 */
volatile CONSTP2VAR( uint32, FLS_CONST, REGSPACE ) Fls_IpcStructBaseAddr = (volatile uint32 *)FLS_IPC_STRUCT_ADDR;

/* WorkFlash registers access address */
/* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
   Justification: This implementation is done for getting correct address for device
   access by integral value in resource file. */
/* PRQA S 303 1 */
volatile CONSTP2VAR( uint32, FLS_CONST, REGSPACE ) Fls_WfregBaseAddr = (volatile uint32 *)FLS_FLASHC_ADDR;

/* DMAC registers access address */
/* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4.
   Justification: This implementation is done for getting correct address for device
   access by integral value in resource file. */
/* PRQA S 303 1 */
volatile CONSTP2VAR( uint32, FLS_CONST, REGSPACE ) Fls_DmacBaseAddr = (volatile uint32 *)FLS_DMAC_ADDR;

#define FLS_STOP_SEC_CONST_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

#define FLS_START_SEC_VAR_NO_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/* Pointer to flash driver configuration set */
P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) Fls_ConfigPtr;

/* Pointer to flash memory map */
P2CONST(Fls_MemoryMapType, AUTOMATIC, FLS_APPL_CONST) Fls_MemoryMapPtr;

/* flag whether IPC structure used for eCT Flash safety mechanism is locked or not */
VAR(uint8, FLS_VAR_NO_INIT) Fls_IpcLocked;

/* Data buffer from Flash for compare/read/verify operation */
VAR(uint32, FLS_VAR_NO_INIT) Fls_AuxiliaryBuffer[FLS_AUXILIARY_BUFFER_SIZE >> 2U];

#if defined( FLS_IO_DEFINE )

VAR( uint32, FLS_VAR_NO_INIT ) Fls_DummyRegArea[FLS_DUMMY_REGAREA_SIZE >> 2U];

VAR( uint8, FLS_VAR_NO_INIT ) Fls_DummyFlash[FLS_NUMBER_OF_SECTORS * FLS_MAX_SECTOR_SIZE];

#endif /* if defined( FLS_IO_DEFINE ) */

/*==================[internal data]=========================================*/

/* current logcal sector number */
static VAR(uint16, FLS_VAR_NO_INIT) Fls_CurrentLogicalSector;

#define FLS_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

/*==================[external function definitions]=========================*/

#define FLS_START_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>

#if ( FLS_DEFINITION_WDGCLEAR == STD_ON )

/** \brief Fls_WdgClear
 **
 ** This function is implemented for clearing (triggering) the watchdog timer by user.
 ** 
 ** \return    none
 **
 */
FUNC(void, FLS_CODE) Fls_WdgClear(void)
{
    /* This function is implemented for clearing (triggering) the watchdog timer by user. */

    return;
}

#endif /* if( FLS_DEFINITION_WDGCLEAR == STD_ON ) */

/** \brief Fls_SetConfig
 **
 ** Sets address to configuration.
 **
 ** \param[in]  ConfigPtr   Pointer to flash driver configuration set
 **
 ** \return    configuration pointer has been set/not been set
 ** \retval    FLS_FALSE        configuration pointer has not been set
 **            FLS_TRUE         configuration pointer has been set
 */
FUNC(uint8, FLS_CODE) Fls_SetConfig
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
)
{
    uint8   Ret;            /* return value */
    uint16  PointerIndex;   /* index of pointer or invalid pointer */

    /* Deviation from MISRA-C:2004 rule 12.4, MISRA-C:2012 Rule-13.5.
       Justification: This implementation is adopted for avoiding more nesting.
       It is no problem because side effects cannot be caused. */
    /* PRQA S 3415 1 */
    if( ( Fls_HsmPresent == STD_ON ) && ( Fls_CheckRegisters() == FLS_FALSE ) )
    {
        /* set FLS_FALSE for return value  */
        Ret = FLS_FALSE;
    }
    else if( ConfigPtr == NULL_PTR )
    {
#if ( ( FLS_CONFIG_VARIANT == FLS_VARIANTPRECOMPILE ) && ( FLS_NUMBER_OF_CONFIGSETS == 1U ) )
        /* SWS_BSW_00050: In the supportedConfigVariants VariantPreCompile
           and VariantLinkTime if only one configuration variant set is used,
           the initialization function does not need nor evaluate the passed
           argument. Thus the Configuration pointer shall have a NULL_PTR value. */

        /* Fls191: store the configuration pointer locally */
        Fls_ConfigPtr    = &Fls_Config_0;
        Fls_MemoryMapPtr = &Fls_MemoryMap_0[0];

        /* set FLS_TRUE for return value  */
        Ret = FLS_TRUE;
#else
        /* SWS_BSW_00050: In the supportedConfigVariant VariantPostBuild or
           if multiple configuration variant sets are used, the initialization
           function requires the passed argument.
           Thus the Configuration pointer shall be different from NULL_PTR. */

        /* set FLS_FALSE for return value  */
        Ret = FLS_FALSE;
#endif
    }
    else
    {
        /* check configuration pointer   */
        /* set E_NOT_OK for return value */
        PointerIndex = Fls_CheckConfigPtr(ConfigPtr);

        if( PointerIndex == FLS_INVALID_CONFIGSET_POINTER )
        {
            /* set FLS_FALSE for return value  */
            Ret = FLS_FALSE;
        }
        else
        {
            /* Fls191: store the configuration pointer locally */
            Fls_ConfigPtr    = ConfigPtr;
            /* Deviation from MISRA-C:2004 rule 10.1, MISRA-C:2012 Rule-10.4.
               Justification: This implmentation is adjustment between an index number
               and an array element. It is no problem because PointerIndex is always
               more than 0. */
            /* PRQA S 1860 1 */
            Fls_MemoryMapPtr = Fls_MemoryMapPtrArray[PointerIndex - 1];

            /* set FLS_TRUE for return value  */
            Ret = FLS_TRUE;
        }
    }

    return Ret;
}

/** \brief Fls_GetLogicalSectorNumber
 **
 ** Gets logical sector number of specified logical address.
 **
 ** \param[in]  LogicalAddress  logical address in flash memory
 **
 ** \return    logical sector number of specified logical address
 */
FUNC(uint16, FLS_CODE) Fls_GetLogicalSectorNumber
(
    Fls_AddressType LogicalAddress
)
{
    uint16  MemoryMapCounter;       /* memory map conuter */
    uint16  SectorCounter;          /* sector counter */
    uint16  LogFlashSectorNumber;   /* logical number of current flash sector */
    uint32  CurrentSecLogAddr;      /* current sector logical address */

    /* initialize internal value */
    MemoryMapCounter = 0U;
    SectorCounter = 0U;
    LogFlashSectorNumber = FLS_SECTOR_NOT_FOUND;
    CurrentSecLogAddr = Fls_MemoryMapPtr[0].logical;

    /* query the correct sector of the logical address */
    while( SectorCounter < Fls_ConfigPtr->NumberOfSectors )
    {
        if( LogicalAddress < ( CurrentSecLogAddr + ( Fls_MemoryMapPtr[MemoryMapCounter].size * Fls_MemoryMapPtr[MemoryMapCounter].number ) ) )
        {
            LogFlashSectorNumber = (uint16)( ( LogicalAddress - CurrentSecLogAddr ) / Fls_MemoryMapPtr[MemoryMapCounter].size );

            /* escape loop */
            SectorCounter = Fls_ConfigPtr->NumberOfSectors;
        }
        else
        {
            SectorCounter += Fls_MemoryMapPtr[MemoryMapCounter].number;
            MemoryMapCounter++;
            CurrentSecLogAddr = Fls_MemoryMapPtr[MemoryMapCounter].logical;
        }
    }

    return LogFlashSectorNumber;
}

/** \brief Fls_SetCurrentSector
 **
 ** Sets current logical sector.
 ** Note: This function is is used only for an erase job.
 **
 ** \param[in]  CurrentLogicalSector  current logical sector
 **
 ** \return    none
 */
FUNC(void, FLS_CODE) Fls_SetCurrentSector
(
    uint16 CurrentLogicalSector
)
{
    Fls_CurrentLogicalSector = CurrentLogicalSector;
}

/** \brief Fls_IncrementCurrentSector
 **
 ** Increments current logical sector.
 ** Note: This function is is used only for an erase job.
 **
 ** \return    none
 */
FUNC(void, FLS_CODE) Fls_IncrementCurrentSector(void)
{
    Fls_CurrentLogicalSector++;
}

/** \brief Fls_GetCurrentSectorInfo
 **
 ** Gets information about current logical sector and increment current logical sector.
 ** Note: This function is is used only for an erase job.
 **
 ** \param[out] CurrentSectorInfoPtr    Pointer to store information about current logical sector
 **
 ** \return    none
 */
FUNC(void, FLS_CODE) Fls_GetCurrentSectorInfo
(
    P2VAR(Fls_MemoryMapType, AUTOMATIC, FLS_APPL_DATA) CurrentSectorInfoPtr
)
{
    uint16  MemoryMapCounter;       /* memory map conuter */
    uint16  SectorCounter;          /* sector counter */
    uint16  TopConsecutiveSector;   /* top of consecutive counter */
    uint32  Offset;                 /* offset from top of consecutive counter */
    uint32  SectorSize;             /* sector size */

    /* initialize internal value */
    MemoryMapCounter = 0U;
    SectorCounter = 0U;
    TopConsecutiveSector = 0U;

    do
    {
        SectorCounter += Fls_MemoryMapPtr[MemoryMapCounter].number;
        
        if( Fls_CurrentLogicalSector < SectorCounter )
        {
            /* escape loop */
            SectorCounter = Fls_ConfigPtr->NumberOfSectors;
        }
        else
        {
            TopConsecutiveSector += Fls_MemoryMapPtr[MemoryMapCounter].number;
            MemoryMapCounter++;
        }
    }while( SectorCounter < Fls_ConfigPtr->NumberOfSectors );

    SectorSize = Fls_MemoryMapPtr[MemoryMapCounter].size;
    Offset = ( ( (uint32)Fls_CurrentLogicalSector - (uint32)TopConsecutiveSector ) * SectorSize );
    CurrentSectorInfoPtr->physical = Fls_MemoryMapPtr[MemoryMapCounter].physical + Offset;
    CurrentSectorInfoPtr->size = SectorSize;
    Fls_JobRequest.LogFlashAddress = Fls_MemoryMapPtr[MemoryMapCounter].logical + Offset;
    Fls_JobRequest.CurrentLength = SectorSize;

    return;
}

#if defined( FLS_SPECIAL_FUNCTION_FOR_CYFEE )

/** \brief Fls_GetSecTopAddressFromAddress
 **
 ** Gets physical address of sector top of specified physical address.
 **
 ** \param[in]  TargetAddress   physical address in flash memory
 **
 ** \return    physical address of sector top of specified physical address
 */
FUNC(Fls_AddressType, FLS_CODE) Fls_GetSecTopAddressFromAddress
(
    Fls_AddressType TargetAddress
)
{
    uint16          MemoryMapCounter;   /* memory map conuter */
    uint16          SectorCounter;      /* sector counter */
    Fls_AddressType FlashSectorAddress; /* physical sector top address of current flash sector */
    Fls_AddressType CurrentSectorAddr;  /* current sector physical address */

    /* initialize internal value */
    MemoryMapCounter = 0U;
    SectorCounter = 0U;
    FlashSectorAddress = (Fls_AddressType)0UL;
    CurrentSectorAddr = Fls_MemoryMapPtr[0].physical;

    /* query the correct sector of the physical address */
    while( SectorCounter < Fls_ConfigPtr->NumberOfSectors )
    {
        if( TargetAddress < ( CurrentSectorAddr + ( Fls_MemoryMapPtr[MemoryMapCounter].size * Fls_MemoryMapPtr[MemoryMapCounter].number ) ) )
        {
            FlashSectorAddress = TargetAddress - ( TargetAddress & ( Fls_MemoryMapPtr[MemoryMapCounter].size - 1UL ) );

            /* escape loop */
            SectorCounter = Fls_ConfigPtr->NumberOfSectors;
        }
        else
        {
            SectorCounter += Fls_MemoryMapPtr[MemoryMapCounter].number;
            MemoryMapCounter++;
            CurrentSectorAddr = Fls_MemoryMapPtr[MemoryMapCounter].physical;
        }
    }

    return FlashSectorAddress;
}

/** \brief Fls_GetBlankAddr
 **
 ** Gets top blank address.
 **
 ** \param[in] SourceAddress    Source physical address in flash memory
 ** \param[in] Length           Number of bytes to do blank check
 ** \param[in] BlankLength      Number of bytes for finding blank
 **
 ** \return    top blank physical address if found, or NULL_PTR if not found
 **
 */
FUNC(Fls_AddressType, FLS_CODE) Fls_GetBlankAddr
(
    Fls_AddressType SourceAddress,
    Fls_LengthType Length,
    Fls_LengthType BlankLength
)
{
    uint32                  BlankCounter;       /* blank counter */
    Fls_AddressType         BlankTopAddress;    /* blank top address */
    Fls_AddressType         LastAddress;        /* last logical address */
    Fls_FaultType           TempFault;          /* temporary fault information */

    BlankCounter = 0UL;
    BlankTopAddress = (Fls_AddressType)0UL;
    LastAddress = SourceAddress + Length;
    TempFault = FLS_FAULT_NONE;
    
    do
    {
        /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
           Justification: This cast is needed for specifying an integral value as an
           address for device access. */
        /* PRQA S 306 1 */
        if( Fls_GetReadAddr((void *)SourceAddress, sizeof(uint32)) == NULL_PTR )
        {
            BlankCounter += sizeof(uint32);
            if( BlankCounter == BlankLength )
            {
                BlankTopAddress = ( SourceAddress + sizeof(uint32) ) - BlankLength;

                /* escape loop */
                SourceAddress = LastAddress;
            }
        }
        else
        {
            BlankCounter = 0UL;
        }
        SourceAddress += sizeof(uint32);
        
        if( Fls_Fault != FLS_FAULT_NONE )
        {
            /* store fault information if error occurs */
            TempFault = Fls_Fault;
        }
    }while( SourceAddress < LastAddress );
    
    if( TempFault != FLS_FAULT_NONE )
    {
        /* update fault information */
        Fls_Fault = TempFault;
    }

    return BlankTopAddress;
}

/** \brief Fls_ReadImmediateSync
 **
 ** Reads data without blank check from specified physical address.
 **
 ** \param[in]  SourceAddress    physical address in flash memory
 ** \param[out] TargetAddressPtr Pointer to read buffer
 ** \param[in]  Length           Number of bytes to read
 **
 ** \return    none
 */
FUNC(void, FLS_CODE) Fls_ReadImmediateSync
(
    Fls_AddressType SourceAddress,
    P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr,
    Fls_LengthType Length
)
{
    Fls_LengthType  LoopCounter;        /* loop counter value */
    Fls_LengthType  ReadSize;           /* length of processed data */
    Fls_LengthType  AuxBufferReadSize;  /* processed or read data in auxiliary buffer */

    /* initialize internal value */
    ReadSize = 0UL;

    /* clear read error */
    Fls_ClearReadError();

    /* read from flash */
    /* Deviation from MISRA-C:2004 rule 13.7, MISRA-C:2012 Rule-14.3, Rule-2.2.
       Justification: This judgement dependes on the configurable value of FlsUseDmaForRead. */
    /* PRQA S 2991,2995 1 */
    if( Fls_UseDmaForRead == STD_ON )
    {
        while( Length > 0UL )
        {
            AuxBufferReadSize = (( Length ) < ( Fls_AuxiliaryBufferSize )) ?
                                 ( Length ) : ( Fls_AuxiliaryBufferSize );

            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, 17.4, MISRA-C:2012 Rule-11.4, Rule-11.6, Rule-18.4.
               Justification: This cast is needed for handling with 8-bit type address and doing pointer arithmetic. */
            /* PRQA S 306,488 1 */
            Fls_ReadFlash( &Fls_AuxiliaryBuffer[0], (uint8 *)SourceAddress + ReadSize, AuxBufferReadSize );
            LoopCounter = 0UL;
            while( LoopCounter < ( AuxBufferReadSize >> FLS_SHIFT_R_VALUE ) )
            {
                *TargetAddressPtr = Fls_AuxiliaryBuffer[LoopCounter];
                TargetAddressPtr++;
                LoopCounter++;
                ReadSize += 4UL;
            }
            Length -= AuxBufferReadSize;
        }
    }
    else
    {
        /* Deviation from MISRA-C:2004 rule 14.1, MISRA-C:2012 Rule-2.1.
           Justification: This judgement dependes on the configurable value of FlsUseDmaForRead. */
        /* PRQA S 2880 1 */
        while( Length > 0UL )
        {
            /* Deviation from MISRA-C:2004 rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
               Justification: This cast is needed for specifying an integral value as an
               address for device access. */
            /* PRQA S 306 1 */
            *TargetAddressPtr = *((uint32 *)SourceAddress);
            TargetAddressPtr++;
            SourceAddress += 4UL;
            Length -= 4UL;
        }
    }

    return;
}

/** \brief Fls_GetFaultInfo
 **
 ** Gets fault information
 **
 ** \return  current fault information
 ** \retval  FLS_FAULT_NONE          no fault
 **          FLS_FAULT_SED           single bit error
 **          FLS_FAULT_DED           double bit error
 **          FLS_FAULT_BUSERROR      bus error
 **          FLS_FAULT_MACROERROR    Flash macro error
 **          FLS_FAULT_OTHERERROR    any other error
 */
FUNC(Fls_FaultType, FLS_CODE) Fls_GetFaultInfo
(
 void
)
{
    return Fls_Fault;
}

#endif /* if defined( FLS_SPECIAL_FUNCTION_FOR_CYFEE ) */

/*==================[internal function definitions]=========================*/

/** \brief Fls_CheckConfigPtr
 **
 ** Checks address to configuration.
 **
 ** \param[in]  ConfigPtr   Pointer to flash driver configuration set
 **
 ** \return    valid index of configuration pointer or invalid pointer
 ** \retval    FLS_INVALID_CONFIGSET_POINTER(0)           configuration pointer is invalid
 **            other than FLS_INVALID_CONFIGSET_POINTER   index of configuration pointer (valid)
 */
static FUNC(uint16, FLS_CODE) Fls_CheckConfigPtr
(
    P2CONST(Fls_ConfigType, AUTOMATIC, FLS_APPL_CONST) ConfigPtr
)
{
    uint8   FoundFlag;      /* flag for check */
    uint16  LoopCounter;    /* loop counter value */
    uint16  PointerIndex;   /* return value */

    LoopCounter = 0U;
    FoundFlag = FLS_FALSE;

#if ( ( FLS_CONFIG_VARIANT != FLS_VARIANTPRECOMPILE ) || ( FLS_NUMBER_OF_CONFIGSETS != 1U ) )
    do
    {
#endif
        if( ConfigPtr == Fls_ConfigPtrArray[LoopCounter] )
        {
            FoundFlag = FLS_TRUE;
        }
        LoopCounter++;
#if ( ( FLS_CONFIG_VARIANT != FLS_VARIANTPRECOMPILE ) || ( FLS_NUMBER_OF_CONFIGSETS != 1U ) )
    }while( ( FoundFlag == FLS_FALSE ) && ( LoopCounter < FLS_NUMBER_OF_CONFIGSETS ) );
#endif

    if( FoundFlag == FLS_FALSE )
    {
        /* set invalid for return value  */
        PointerIndex = FLS_INVALID_CONFIGSET_POINTER;
    }
    else
    {
        /* set valid index for return value  */
        PointerIndex = LoopCounter;
    }

    return PointerIndex;
}

#define FLS_STOP_SEC_CODE
/* Deviation from MISRA-C:2004 rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: This implementation is specified by AUTOSAR specification. */
/* PRQA S 5087 1 */
#include <Fls_MemMap.h>


/*==================[end of file]===========================================*/
