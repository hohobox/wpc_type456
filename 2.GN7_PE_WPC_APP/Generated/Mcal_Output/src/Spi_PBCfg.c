
/** \brief AUTOSAR SPI Driver
 **
 ** This file contains definitions for configuration.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

/*==================[inclusions]============================================*/
#include "Spi_Cfg.h"
#include "Spi_ExternalInclude.h"
#include "Spi_Cfg_Der.h"
#include "Spi_Common_Der.h"
/*==================[macros]================================================*/

/** \brief timeout value to transmit or receive synchronously
 ** the lowest baud rate 4000000
 ** the CPU clock maximum speed 160000000 Hz.
 ** transmission and reception must have been finished after 
 ** at most (32 + 2) bit times .
 ** A loop needs about 80 tick cycle,
 ** So the calculated cycles: (160000000 / 4000000) * (32 + 2) / 80 < 17
 ** If timeout occurs before actual transmission is completed,
 ** driver will issue an error unexpectedly.
 ** 20% margins are necessary to avoid this situation.
 ** So when it's over 20 it looks like something is broken
 ** */
#define SPI_SYNCTRANSMIT_TIMEOUT ( 20UL )

/** \brief timeout value to become active or inactive
 ** Timeout for 1.75 SPI clocks according to maximal value of SpiSetupDelay and SpiHoldDelay. 
 ** the CPU clock speed 160000000 Hz.
 ** A loop needs about 80 ticks.
 ** So the calculated cycles: (160000000 / 4000000) * 1.75) / 80 < 0
 ** If timeout occurs before CS becomes active or inactive,
 ** driver will issue an error unexpectedly.
 ** 20% margins are necessary to avoid this situation.
 ** Therefore when it's over 1 CS shall become inactive.
 ** */
#define SPI_CSACTIVE_TIMEOUT   ( 1UL )
#define SPI_CSINACTIVE_TIMEOUT ( 1UL )

/*==================[type definitions]======================================*/

/*==================[internal function declarations]========================*/

/*==================[internal constants]====================================*/

#define SPI_START_SEC_CONST_ASIL_B_UNSPECIFIED
#include <Spi_MemMap.h>

/*------------------[sequences: job linking]------------------ */
/* SpiSequence_NFC1 of SpiDriver */
static CONST(Spi_JobType, SPI_CONST) Spi_SJb_SpiSequence_NFC1[1] =
{
  SpiJob_NFC1
};
/* SpiSequence_NFC2 of SpiDriver */
static CONST(Spi_JobType, SPI_CONST) Spi_SJb_SpiSequence_NFC2[1] =
{
  SpiJob_NFC2
};

/*------------------[jobs:channel linking]------------------ */
/* SpiJob_NFC1 of SpiDriver */
static CONST(Spi_ChannelType, SPI_CONST) Spi_JCh_SpiJob_NFC1[1] =
{
  SpiChannel_NFC1
};
/* SpiJob_NFC2 of SpiDriver */
static CONST(Spi_ChannelType, SPI_CONST) Spi_JCh_SpiJob_NFC2[1] =
{
  SpiChannel_NFC2
};

/* SpiSequence_NFC1 of SpiDriver */
static CONST(Spi_SequenceType, SPI_CONST)
  Spi_SpiSequence_NFC1_SharedHwUnitSeqList[SPI_SpiSequence_NFC1_SHARED_HW_UNIT_SEQ_COUNT] =
    SPI_SpiSequence_NFC1_SHARED_HW_UNIT_SEQ_LIST;

/* SpiSequence_NFC2 of SpiDriver */
static CONST(Spi_SequenceType, SPI_CONST)
  Spi_SpiSequence_NFC2_SharedHwUnitSeqList[SPI_SpiSequence_NFC2_SHARED_HW_UNIT_SEQ_COUNT] =
    SPI_SpiSequence_NFC2_SHARED_HW_UNIT_SEQ_LIST;



#define SPI_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[internal data]=========================================*/
/* DMA Descriptor area definition */


/* SpiChannel_NFC1 of SpiDriver */
/* uses external buffers */

/* SpiChannel_NFC2 of SpiDriver */
/* uses external buffers */
#define SPI_START_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/* Static, private variables for file-internal use. */
static VAR(Spi_DriverHwInfoType, SPI_VAR_NO_INIT) Spi_DriverHwInfo[SPI_MAX_HW_UNIT];

/* Static, private variables for file-internal use. */
static VAR(Spi_HwInfoType, SPI_VAR_NO_INIT) Spi_HwInfo[SPI_MAX_HW_UNIT];

/* Static, private variables for file-internal use. */
static VAR(Spi_JobInfoType, SPI_VAR_NO_INIT) Spi_JobInfo[SPI_MAX_JOB];

/* Static, private variables for file-internal use. */
static VAR(Spi_SequenceInfoType, SPI_VAR_NO_INIT) Spi_SequenceInfo[SPI_MAX_SEQUENCE];

/* Static, private variables for file-internal use. */
static VAR(Spi_OvsValueType, SPI_VAR_NO_INIT) Spi_ActiveOvsValues[SPI_MAX_EXTERNAL_DEVICE];

/* Static, private variables for file-internal use. */
static VAR(Spi_ChannelInfoType, SPI_VAR_INIT) Spi_ChannelInfo[SPI_MAX_CHANNEL];

/* Static, private variables for file-internal use. */
static VAR(Spi_SequenceType, SPI_VAR_NO_INIT) Spi_TransmitQueue[SPI_QUEUE_ITEM_MAX];

#define SPI_STOP_SEC_VAR_NO_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external constants]====================================*/
#define SPI_START_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/* For SpiDriver */
static CONST(Spi_ExternalDeviceConfigType, SPI_CONST)
  Spi_ExternalDeviceConfig[SPI_MAX_EXTERNAL_DEVICE] = 
    SPI_EXTERNAL_DEVICE_CONFIG;

static CONST(Spi_ChannelConfigType, SPI_CONST)
  Spi_ChannelConfig[SPI_MAX_CHANNEL] = 
    SPI_CHANNEL_CONFIG;

static CONST(Spi_SequenceConfigType, SPI_CONST)
  Spi_SequenceConfig[SPI_MAX_SEQUENCE] =
    SPI_SEQUENCE_CONFIG;

static CONST(Spi_JobConfigType, SPI_CONST)
  Spi_JobConfig[SPI_MAX_JOB] =
    SPI_JOB_CONFIG;
  
/* Deviation from MISRA-C:2004 Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
   Justification: Cast between pointer and integer is necessary for 
   hardware access. */
/* PRQA S 306 3 */
static CONSTP2VAR(volatile Spi_SCBRegsType, SPI_CONST, REGSPACE)
  Spi_SCBRegs[SPI_MAX_HW_UNIT] = 
    SPI_SCB_REGS;

/* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
   Justification: Cast between pointer and integer is necessary for 
   hardware access. */
/* PRQA S 306 3 */
static CONSTP2VAR(volatile Spi_DmaChannelRegsType, SPI_CONST, REGSPACE)
  Spi_DmaRxChannelRegs[SPI_MAX_HW_UNIT] =
    SPI_DMA_RX_CHANNEL_REGS;

/* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
   Justification: Cast between pointer and integer is necessary for 
   hardware access. */
/* PRQA S 306 3 */
static CONSTP2VAR(volatile Spi_DmaChannelRegsType, SPI_CONST, REGSPACE)
  Spi_DmaTxChannelRegs[SPI_MAX_HW_UNIT] =
    SPI_DMA_TX_CHANNEL_REGS;



/* Deviation from MISRA-C:2004 Rule 8.10, MISRA-C:2012 Rule-8.7.
   Justification: This is defined at external scope in order to read 
   from outside. */
/* PRQA S 1504 1 */
CONST(Spi_ConfigType, SPI_CONST) Spi_Config[SPI_CONFIG_COUNT] =
{
  { /* SpiDriver */

      SPI_CONFIG,                   /* ConfigId */
  
      SPI_SYNCTRANSMIT_TIMEOUT,     /* SynctransmitTimeout */
      SPI_CSACTIVE_TIMEOUT,         /* CsActiveTimeout */
      SPI_CSINACTIVE_TIMEOUT,       /* CsInactiveTimeout */
      &Spi_JobConfig[0],            /* JobConfigListPtr */
      &Spi_SequenceConfig[0],       /* SequencesConfigListPtr */
      &Spi_ChannelConfig[0],        /* ChannelConfigListPtr */
      &Spi_ExternalDeviceConfig[0], /* ExternalDevicesPtr */
  
      &Spi_SCBRegs[0],              /* ScbRegsPtr */
      &Spi_DmaRxChannelRegs[0],     /* DmaRxChannelRegsPtr */
      &Spi_DmaTxChannelRegs[0],     /* DmaTxChannelRegsPtr */
      
      &Spi_TransmitQueue[0],        /* TransmitQueuePtr */
  
      SPI_MAX_JOB,                  /* JobCount */
      SPI_MAX_SEQUENCE,             /* SequenceCount */
      SPI_MAX_CHANNEL,              /* ChannelCount */
      SPI_MAX_EXTERNAL_DEVICE,      /* ExternalDeviceCount */
      SPI_MAX_HW_UNIT               /* HwUnitCount */
  }
};

CONST(Spi_InfoType, SPI_VAR_NO_INIT) Spi_Info = 
{
  &Spi_DriverHwInfo[0],   /* DriverHwInfoListPtr */
  &Spi_SequenceInfo[0],   /* SequenceInfoListPtr */
  &Spi_JobInfo[0],        /* JobInfoListPtr */
  &Spi_ChannelInfo[0],    /* ChannelInfoListPtr */
  &Spi_HwInfo[0]          /* HwInfoListPtr */
};

#define SPI_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external data]=========================================*/
#define SPI_START_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

P2CONST(Spi_ConfigType, SPI_VAR_NO_INIT, SPI_VAR_NO_INIT) 
  Spi_Current_ConfigPtr = (Spi_ConfigType *)NULL_PTR;

#define SPI_STOP_SEC_VAR_INIT_ASIL_B_UNSPECIFIED
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[external function definitions]=========================*/
#define SPI_START_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/** \brief Spi_Cfg_GetDefaultConfig
 **
 ** Returns Spi default config address.
 **
 ** \return Pointer to Spi default config address.
 **
 */
 FUNC_P2CONST(Spi_ConfigType, AUTOMATIC, SPI_CODE) Spi_Cfg_GetDefaultConfig(void)
 {
   return &Spi_Config[0];
 }
 

/** \brief Spi_Cfg_SetConfig
 **
 ** Set configuration.
 **
 ** \return None.
 ** \param [in] ConfigPtr   Pointer to driver configuration set
 **
 */
FUNC(void, SPI_CODE) Spi_Cfg_SetConfig
(
  P2CONST( Spi_ConfigType, AUTOMATIC, AUTOMATIC ) ConfigPtr
)
{
  Spi_Current_ConfigPtr = ConfigPtr;
}

/** \brief Spi_Cfg_CheckConfig
 **
 ** Check if it is included in the configuration array.
 **
 ** \return check result.
 **   SPI_TRUE:   Included
 **   SPI_FALSE:  Not included 
 ** \param [in] ConfigPtr   Pointer to driver configuration set
 */
FUNC(boolean, SPI_CODE) Spi_Cfg_CheckConfig
(
  P2CONST( Spi_ConfigType, AUTOMATIC, AUTOMATIC ) ConfigPtr
)
{
  VAR(boolean, AUTOMATIC) retVal = SPI_FALSE;
  VAR(uint32, AUTOMATIC)  i;

  /* Deviation from MISRA-C:2004 Rule 21.1, MISRA-C:2012 Dir-4.1.
     Justification: SPI_CONFIG_COUNT is generated value. There is no 
     problem because there is a possibility of looping more than once. */
  /* PRQA S 2877 1 */
  for(i=0U; i<SPI_CONFIG_COUNT; i++)
  {
    /* Deviation from MISRA-C:2004 Rule Rule 3.1, 11.3, MISRA-C:2012 Rule-11.4, Rule-11.6.
       Justification: Cast between pointer and integer is necessary for 
       hardware access. */
    /* PRQA S 306 1 */
    if ( (uint32)ConfigPtr == (uint32)(&Spi_Config[i]) )
    { /* Match configuration set */
      retVal = SPI_TRUE;
      break;
    }
  }
  return retVal;
 }

#define SPI_STOP_SEC_CODE_ASIL_B
/* Deviation from MISRA-C:2004 Rule 19.1, MISRA-C:2012 Rule-20.1.
   Justification: Spi_MemMap.h must be included in-line. */
/* PRQA S 5087 1 */
#include <Spi_MemMap.h>

/*==================[internal function definitions]=========================*/

/*==================[end of file]===========================================*/
