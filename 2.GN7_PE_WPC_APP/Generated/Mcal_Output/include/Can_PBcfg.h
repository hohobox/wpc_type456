/** \brief Can_PBcfg.h
 **
 ** This generated interface declares configuration items.
 **
 ** Do not edit this file manually.
 ** Any change might compromise the safety integrity level of
 ** the software partition it is contained in.
 **
 ** Product: SW-MCAL42-DRV
 **
 ** (c) 2017-2022, Cypress Semiconductor Corporation (an Infineon company) or
 ** an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
 ** This software, including source code, documentation and related materials
 ** ("Software") is owned by Cypress Semiconductor Corporation or one of
 ** its affiliates ("Cypress") and is protected by and subject to worldwide
 ** patent protection (United States and foreign), United States copyright laws
 ** and international treaty provisions.  Therefore, you may use this Software
 ** only as provided in the license agreement accompanying the software package
 ** from which you obtained this Software ("EULA").
 ** If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
 ** non-transferable license to copy, modify,
 ** and compile the Software source code solely for use in connection
 ** with Cypress's integrated circuit products.
 ** Any reproduction, modification, translation, compilation,
 ** or representation of this Software except as specified above is prohibited
 ** without the express written permission of Cypress.
 ** Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT,
 ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 ** Cypress reserves the right to make changes to the Software without notice.
 ** Cypress does not assume any liability arising out of the application or
 ** use of the Software or any product or circuit described in the Software.
 ** Cypress does not authorize its products for use in any products
 ** where a malfunction or failure of the Cypress product may reasonably be
 ** expected to result in significant property damage,
 ** injury or death ("High Risk Product"). By including Cypress's product
 ** in a High Risk Product, the manufacturer of such system or application
 ** assumes all risk of such use and in doing so agrees to indemnify Cypress
 ** against all liability.
 */

#ifndef CAN_PBCFG_H_INCLUDED
#define CAN_PBCFG_H_INCLUDED

/*==================[inclusions]============================================*/

#include <Can.h>
#include <Can_Data.h>
#include <Can_Cfg.h>

/*==================[macros]================================================*/

/* CanConfigSet 0: CanConfigSet */
/* CanController 0: WPC_BCAN */

/** Part of the initializer to the constant array of dedicated RX IDs. */
#define CAN_CFG_DEDICATED_RX_IDS_00 \
/* Array of uint32 */\
       0x7dfu,                              /* Array index 0, standard identifier (11 bit) */ \
       0x4dau,                              /* Array index 1, standard identifier (11 bit) */ \
       0x4d1u,                              /* Array index 2, standard identifier (11 bit) */ \
       0x401u,                              /* Array index 3, standard identifier (11 bit) */ \
       0x3e2u,                              /* Array index 4, standard identifier (11 bit) */ \
       0x3d4u,                              /* Array index 5, standard identifier (11 bit) */ \
       0x3d1u,                              /* Array index 6, standard identifier (11 bit) */ \
       0x366u,                              /* Array index 7, standard identifier (11 bit) */ \
       0x351u,                              /* Array index 8, standard identifier (11 bit) */ \
       0x33eu,                              /* Array index 9, standard identifier (11 bit) */ \
       0x33du,                              /* Array index 10, standard identifier (11 bit) */ \
       0x32du,                              /* Array index 11, standard identifier (11 bit) */ \
       0x32bu,                              /* Array index 12, standard identifier (11 bit) */ \
       0x315u,                              /* Array index 13, standard identifier (11 bit) */ \
       0x314u,                              /* Array index 14, standard identifier (11 bit) */ \
       0x2e9u,                              /* Array index 15, standard identifier (11 bit) */ \
       0x1aau,                              /* Array index 16, standard identifier (11 bit) */ \
       0x116u,                              /* Array index 17, standard identifier (11 bit) */ \
       0x114u,                              /* Array index 18, standard identifier (11 bit) */ \
       0x112u,                              /* Array index 19, standard identifier (11 bit) */ \
       0x111u,                              /* Array index 20, standard identifier (11 bit) */ \
       0x105u,                              /* Array index 21, standard identifier (11 bit) */ \
       0x100u,                              /* Array index 22, standard identifier (11 bit) */ \
        0xfau,                              /* Array index 23, standard identifier (11 bit) */ \
        0x35u,                              /* Array index 24, standard identifier (11 bit) */ \
    
/** Part of the initializer to the constant array of FIFO filter elements. */
#define CAN_CFG_RX_FIFO_FILTERS_00 \
/* Array of Can_ControllerFilterType */\
  /*                                       CanIdValue of the Can filter.*/\
  /*                                       VAR(uint32, TYPEDEF) FilterIdValue;*/\
  /*                                       |            CanHwFilterMask of the Can filter. */\
  /*                                       |            VAR(uint32, TYPEDEF) FilterMaskValue; */\
  /*                                       |            | */\
  /*                                       V            V */\
  {                                   0x725u,      0x7ffu }, /* Array index 0, standard identifier (11 bit), CAN_RX_FIFO0 */ \
  { 0x17fc0000u | CAN_CONTROLLER_XTD_ID_FLAG, 0x1fffff00u }, /* Array index 1, extended identifier (29 bit), CAN_RX_FIFO1 */ \


/** Part of the initializer to the constant array of HRHs.
    The list must be sorted ascending by buffer index, FIFOs last. */
#define CAN_CFG_HRH_FILTERS_00 \
/* Array of Can_RxHandleMappingType */\
  /* The index of the controller where the HRH is allocated. */\
  /* VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex, */\
  /* |    */\
  /* |    The unique object identifier to identify the Hardware object. */\
  /* |    VAR(Can_HwHandleType, TYPEDEF) RxHwHandle */\
  /* |    |    */\
  /* |    |    The filter index which filter has detected the message. The filter    */\
  /* |    |    index has only 7 bit. The MSB is set for extended messages. With this */\
  /* |    |    index a search to the allocated HRH is possible, if the order of the  */\
  /* |    |    filters in Message RAM is in the order lower CAN IDs first and first  */\
  /* |    |    all standard IDs and then extended IDs. This order have to match to   */\
  /* |    |    the initialization order. */\
  /* |    |    VAR(Can_ControllerRxHandleType, TYPEDEF) RxHandle */\
  /* |    |    |    */\
  /* |    |    |    Flag indicating whether it is an RxHandler dedicated to pretended */\
  /* |    |    |    networking mode. */\
  /* |    |    |    VAR(boolean, TYPEDEF) IcomDedicatedEnable */\
  /* |    |    |    |  */\
  /* V    V    V    V  */\
  { 0u,  0u,  0u, FALSE}, /* Array index 0, standard filter, CAN_RX_DEDICATED */\
  { 0u,  1u,  1u, FALSE}, /* Array index 1, standard filter, CAN_RX_DEDICATED */\
  { 0u,  2u,  2u, FALSE}, /* Array index 2, standard filter, CAN_RX_DEDICATED */\
  { 0u,  3u,  3u, FALSE}, /* Array index 3, standard filter, CAN_RX_DEDICATED */\
  { 0u,  4u,  4u, FALSE}, /* Array index 4, standard filter, CAN_RX_DEDICATED */\
  { 0u,  5u,  5u, FALSE}, /* Array index 5, standard filter, CAN_RX_DEDICATED */\
  { 0u,  6u,  6u, FALSE}, /* Array index 6, standard filter, CAN_RX_DEDICATED */\
  { 0u,  7u,  7u, FALSE}, /* Array index 7, standard filter, CAN_RX_DEDICATED */\
  { 0u,  8u,  8u, FALSE}, /* Array index 8, standard filter, CAN_RX_DEDICATED */\
  { 0u,  9u,  9u, FALSE}, /* Array index 9, standard filter, CAN_RX_DEDICATED */\
  { 0u, 10u, 10u, FALSE}, /* Array index 10, standard filter, CAN_RX_DEDICATED */\
  { 0u, 11u, 11u, FALSE}, /* Array index 11, standard filter, CAN_RX_DEDICATED */\
  { 0u, 12u, 12u, FALSE}, /* Array index 12, standard filter, CAN_RX_DEDICATED */\
  { 0u, 13u, 13u, FALSE}, /* Array index 13, standard filter, CAN_RX_DEDICATED */\
  { 0u, 14u, 14u, FALSE}, /* Array index 14, standard filter, CAN_RX_DEDICATED */\
  { 0u, 15u, 15u, FALSE}, /* Array index 15, standard filter, CAN_RX_DEDICATED */\
  { 0u, 16u, 16u, FALSE}, /* Array index 16, standard filter, CAN_RX_DEDICATED */\
  { 0u, 17u, 17u, FALSE}, /* Array index 17, standard filter, CAN_RX_DEDICATED */\
  { 0u, 18u, 18u, FALSE}, /* Array index 18, standard filter, CAN_RX_DEDICATED */\
  { 0u, 19u, 19u, FALSE}, /* Array index 19, standard filter, CAN_RX_DEDICATED */\
  { 0u, 20u, 20u, FALSE}, /* Array index 20, standard filter, CAN_RX_DEDICATED */\
  { 0u, 21u, 21u, FALSE}, /* Array index 21, standard filter, CAN_RX_DEDICATED */\
  { 0u, 22u, 22u, FALSE}, /* Array index 22, standard filter, CAN_RX_DEDICATED */\
  { 0u, 23u, 23u, FALSE}, /* Array index 23, standard filter, CAN_RX_DEDICATED */\
  { 0u, 24u, 24u, FALSE}, /* Array index 24, standard filter, CAN_RX_DEDICATED */\
  { 0u, 25u, 25u, FALSE}, /* Array index 25, standard filter, CAN_RX_FIFO0 */\
  { 0u, 26u,  0u | CAN_CONTROLLER_MASK_XTD_FIDX, FALSE}, /* Array index 26, extended filter, CAN_RX_FIFO1 */\


/** Part of the initializer to the constant array of baudrates. */
#define CAN_CFG_BAUDRATES_00 \
/* Array of Can_ControllerBaudrateConfigType */\
  /* The value by which the CAN prescaler output frequency is divided for generating */\
  /* the bit time quanta. (I.e. there is a global CAN prescaler maintained by */\
  /* Can_ModuleManager, and an additional individual prescaler per CAN controller.) */\
  /* The bit time is built up from a multiple of this quanta. */\
  /* Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /* CONST(uint16, TYPEDEF) NominalBaudratePrescaler; */\
  /*    |      */\
  /*    |      The value of the baudrate in kbps. */\
  /*    |      CONST(uint16, TYPEDEF) BaudrateValue; */\
  /*    |      |    */\
  /*    |      |    (Re) Synchronization Jump Width: Valid values are 1 to 16. */\
  /*    |      |    CONST(uint8, TYPEDEF) SyncJumpWidth; */\
  /*    |      |    |    */\
  /*    |      |    |    Time segment before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    CONST(uint8, TYPEDEF) TSeg1; */\
  /*    |      |    |    |    */\
  /*    |      |    |    |    Time segment after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    CONST(uint8, TYPEDEF) TSeg2; */\
  /*    |      |    |    |    |      Switches support of CAN-FD features for this CAN object on or off.           */\
  /*    |      |    |    |    |      TRUE := Valid CAN-FD baudrate settings available and should be used for this */\
  /*    |      |    |    |    |      CAN object.                                                                  */\
  /*    |      |    |    |    |      FALSE := No valid CAN-FD baudrate settings available. Standard CAN should be */\
  /*    |      |    |    |    |      used for this CAN object. */\
  /*    |      |    |    |    |      CONST(boolean, TYPEDEF) FdEnabled; */\
  /*    |      |    |    |    |      |    (Re) Synchronization Jump Width for CAN FD: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    CONST(uint8, TYPEDEF) FdSyncJumpWidth; */\
  /*    |      |    |    |    |      |    |    Time segment for CAN FD before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    |    |      |    |    CONST(uint8, TYPEDEF) FdTSeg1; */\
  /*    |      |    |    |    |      |    |    |    Time segment for CAN FD after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    |    |    CONST(uint8, TYPEDEF) FdTSeg2; */\
  /*    |      |    |    |    |      |    |    |    |      Specifies if the bit rate switching shall be used for transmissions. */\
  /*    |      |    |    |    |      |    |    |    |      FALSE := CAN FD frames shall be sent without bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      TRUE := CAN FD frames shall be sent with bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      CONST(boolean, TYPEDEF) FdTxBitRateSwitch; */\
  /*    |      |    |    |    |      |    |    |    |      |     Transceiver delay compensation offset for CAN FD in time quanta of the CAN FD */\
  /*    |      |    |    |    |      |    |    |    |      |     clock: Valid values are 0 to 127 (normal range) and 0xFF (compensation is */\
  /*    |      |    |    |    |      |    |    |    |      |     disabled). */\
  /*    |      |    |    |    |      |    |    |    |      |     CONST(uint8, TYPEDEF) FdTrcvDelayCompensationOffset; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      The value of the CAN FD baudrate in kbps. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      CONST(uint16, TYPEDEF) FdBaudrateValue; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      The value by which the CAN prescaler output frequency for Data section if bit */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      rate switching is set is divided for generating the bit time quanta. (I.e.    */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      there is a global CAN prescaler maintained by Can_ModuleManager, and an       */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      additional individual prescaler per CAN controller.) The bit time is built up */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      from a multiple of this quanta. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      CONST(uint16, TYPEDEF) DataBaudratePrescaler; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       Unique identifier to identify one baud rate configuration. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       Valid range is 0..65535. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       CONST(uint16, TYPEDEF) BaudrateConfigId; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       |  */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       |  */\
  /*    V      V    V    V    V      V    V    V    V      V     V      V      V       V  */\
  {    1u,  500u, 16u, 63u, 16u,  TRUE,  4u, 14u,  5u,  TRUE,  15u, 1000u,    2u,     0u }, /* Array index 0; CanFdBaudrateValue: 1000; deviation to configured nominal/data baudrate 0.0%/0.0%, deviation to configured TrcvDelayCompensation 0.0% */\

/** Pointer to the base address of the Message RAM. It must point to the hardware
    base address, even if the beginning of the message RAM is not used by this
    controller.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_MESSAGE_RAM_BASE_PTR_00
  #define CAN_CFG_MESSAGE_RAM_BASE_PTR_00 (P2VAR(uint8, TYPEDEF, TYPEDEF))0x40530000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:, MISRA-C:2012 Rule-20.13
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_MESSAGE_RAM_BASE_PTR_00 is overridden by the environment. This is not intended for production software!
#endif

/** Message RAM size */
#define CAN_CFG_MESSAGE_RAM_SIZE_00 0x8000u

/** Base address of the CAN FD controller's registers.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_REGISTER_BASE_ADDRESS_00
  #define CAN_CFG_REGISTER_BASE_ADDRESS_00 0x40520000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:, MISRA-C:2012 Rule-20.13
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_REGISTER_BASE_ADDRESS_00 is overridden by the environment. This is not intended for production software!
#endif


/*  Message RAM (0x40530000) linking table:

    Item                     | Size in elements | Start offset | Size in bytes
    -------------------------+------------------+--------------+--------------
    Standard (11bit) filters |               26 |          0x0 |          0x68
    Extended (29bit) filters |                1 |         0x68 |           0x8
    RX FIFO 0                |               32 |         0x70 |         0x900
    RX FIFO 1                |               26 |        0x970 |         0x750
    RX dedicated buffers     |               25 |       0x10c0 |         0x708
    Event FIFO               |                6 |       0x17c8 |          0x30
    TX dedicated buffers     |                6 |       0x17f8 |         0x1b0
    TX FIFO                  |                0 |       0x19a8 |           0x0
 */
    
/** Part of the initializer to the constant array of controllers. */
#define CAN_CFG_CONTROLLER_00 \
{\
  /* Pointer to an array of baudrates. */\
  .BaudratesCfgPtr = &(Can_Baudrates_0[0u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Id of the controller. */\
  .ControllerId = 0u, /* CONST(Can_ControllerIdType, TYPEDEF) */\
  \
  /* Pointer to the default baudrate setting. */\
  .DefaultBaudratePtr = &(Can_Baudrates_0[0u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the TX Event FIFO. The FIFO element size is ignored, because  */\
  /* it is fixed to 8 bytes. */\
  .EventFifo = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 6u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_8, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x17c8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for extended */\
  /* messages shall be located. */\
  .FiltersExtendedAddressOffset = 0x68u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for standard */\
  /* messages shall be located. */\
  .FiltersStandardAddressOffset = 0x0u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Specifies if bus-off handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableBusOff = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if RX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableRx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if TX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableTx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if wakeup handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableWakeup = FALSE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Pointer to the base address of the Message RAM. It must point to the hardware */\
  /* base address, even if the beginning of the message RAM is not used by this */\
  /* controller. */\
  .MessageRamBasePtr = CAN_CFG_MESSAGE_RAM_BASE_PTR_00, /* CONSTP2VAR(uint8, TYPEDEF, TYPEDEF) */\
  \
  /* Message RAM size in 1 Can Instance. It is not Message RAM size occupied */\
  /* by 1 channel. */\
  .MessageRamSize = CAN_CFG_MESSAGE_RAM_SIZE_00, /* CONST(uint32, TYPEDEF) */\
  \
  /* Number of baudrates in the array of baudrates pointed to by BaudratesCfgPtr. */\
  .NumberOfBaudrates = 1u, /* CONST(uint8, TYPEDEF) */\
  \
  /* Base address of the CAN FD controller's registers. */\
  .RegisterBaseAddress = CAN_CFG_REGISTER_BASE_ADDRESS_00, /* CONST(uint32, TYPEDEF) */\
  \
  /* Configuration of the dedicated RX buffers. The ElementCount equals the number */\
  /* of filter settings in the filter settings list. */\
  .RxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 25u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x10c0u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of CAN IDs. There is one ID per dedicated RX buffer; the */\
  /* order is the same as the buffers (same index).  */\
  .RxBuffersFiltersPtr = &(Can_DedicatedRxIds_0[0u]), /* P2CONST(uint32, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the RX FIFO 0. */\
  .RxFifo0 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 32u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x70u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 0 */\
  .RxFifo0FiltersPtr = &(Can_RxFifoFilters_0[0]), /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo0 filters stored in array RxFifo0FiltersPtr. */\
  .RxFifo0FilterElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the RX FIFO 1. */\
  .RxFifo1 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 26u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x970u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 1 */\
  .RxFifo1FiltersPtr = &(Can_RxFifoFilters_0[1u]), /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo1 filters stored in array RxFifo1FiltersPtr. */\
  .RxFifo1FilterElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the dedicated TX buffers. */\
  .TxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 6u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x17f8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Configuration of the TX FIFO element count. The FIFO element size and start */\
  /* offset are shared with the dedicated TX Buffers. */\
  .TxFifoElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  \
  /* The wakeup source id that is passed to EcuM_CheckWakeup. */\
  .WakeupSource = 1uL << 6u, /* CONST(uint32, TYPEDEF) */\
  \
  /* Channel number excluding CanInstance number. */\
  .ChannelNumber = 2u, /* CONST(uint8, TYPEDEF) */\
  /** Indicates whether ECC error detection can be enabled. */\
  .EccPresentEnable = TRUE /* CONST(boolean, TYPEDEF) */\
},\

/* CanController 1: WPC_LCAN */

/** Part of the initializer to the constant array of dedicated RX IDs. */
#define CAN_CFG_DEDICATED_RX_IDS_01 \
/* Array of uint32 */\
   0xc000104u | CAN_CONTROLLER_XTD_ID_FLAG, /* Array index 25, extended identifier (29 bit) */ \
   0x8000050u | CAN_CONTROLLER_XTD_ID_FLAG, /* Array index 26, extended identifier (29 bit) */ \
   0x4000050u | CAN_CONTROLLER_XTD_ID_FLAG, /* Array index 27, extended identifier (29 bit) */ \
       0x43fu,                              /* Array index 28, standard identifier (11 bit) */ \
       0x352u,                              /* Array index 29, standard identifier (11 bit) */ \
       0x351u,                              /* Array index 30, standard identifier (11 bit) */ \
       0x2e9u,                              /* Array index 31, standard identifier (11 bit) */ \
    
/** Part of the initializer to the constant array of FIFO filter elements. */
#define CAN_CFG_RX_FIFO_FILTERS_01 \
/* Array of Can_ControllerFilterType */\
  /*                                       CanIdValue of the Can filter.*/\
  /*                                       VAR(uint32, TYPEDEF) FilterIdValue;*/\
  /*                                       |            CanHwFilterMask of the Can filter. */\
  /*                                       |            VAR(uint32, TYPEDEF) FilterMaskValue; */\
  /*                                       |            | */\
  /*                                       V            V */\
  { 0x17fc0000u | CAN_CONTROLLER_XTD_ID_FLAG, 0x1fffff00u }, /* Array index 2, extended identifier (29 bit), CAN_RX_FIFO0 */ \


/** Part of the initializer to the constant array of HRHs.
    The list must be sorted ascending by buffer index, FIFOs last. */
#define CAN_CFG_HRH_FILTERS_01 \
/* Array of Can_RxHandleMappingType */\
  /* The index of the controller where the HRH is allocated. */\
  /* VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex, */\
  /* |    */\
  /* |    The unique object identifier to identify the Hardware object. */\
  /* |    VAR(Can_HwHandleType, TYPEDEF) RxHwHandle */\
  /* |    |    */\
  /* |    |    The filter index which filter has detected the message. The filter    */\
  /* |    |    index has only 7 bit. The MSB is set for extended messages. With this */\
  /* |    |    index a search to the allocated HRH is possible, if the order of the  */\
  /* |    |    filters in Message RAM is in the order lower CAN IDs first and first  */\
  /* |    |    all standard IDs and then extended IDs. This order have to match to   */\
  /* |    |    the initialization order. */\
  /* |    |    VAR(Can_ControllerRxHandleType, TYPEDEF) RxHandle */\
  /* |    |    |    */\
  /* |    |    |    Flag indicating whether it is an RxHandler dedicated to pretended */\
  /* |    |    |    networking mode. */\
  /* |    |    |    VAR(boolean, TYPEDEF) IcomDedicatedEnable */\
  /* |    |    |    |  */\
  /* V    V    V    V  */\
  { 1u, 30u,  0u, FALSE}, /* Array index 27, standard filter, CAN_RX_DEDICATED */\
  { 1u, 31u,  1u, FALSE}, /* Array index 28, standard filter, CAN_RX_DEDICATED */\
  { 1u, 32u,  2u, FALSE}, /* Array index 29, standard filter, CAN_RX_DEDICATED */\
  { 1u, 33u,  3u, FALSE}, /* Array index 30, standard filter, CAN_RX_DEDICATED */\
  { 1u, 27u,  0u | CAN_CONTROLLER_MASK_XTD_FIDX, FALSE}, /* Array index 31, extended filter, CAN_RX_DEDICATED */\
  { 1u, 28u,  1u | CAN_CONTROLLER_MASK_XTD_FIDX, FALSE}, /* Array index 32, extended filter, CAN_RX_DEDICATED */\
  { 1u, 29u,  2u | CAN_CONTROLLER_MASK_XTD_FIDX, FALSE}, /* Array index 33, extended filter, CAN_RX_DEDICATED */\
  { 1u, 34u,  3u | CAN_CONTROLLER_MASK_XTD_FIDX, FALSE}, /* Array index 34, extended filter, CAN_RX_FIFO0 */\


/** Part of the initializer to the constant array of baudrates. */
#define CAN_CFG_BAUDRATES_01 \
/* Array of Can_ControllerBaudrateConfigType */\
  /* The value by which the CAN prescaler output frequency is divided for generating */\
  /* the bit time quanta. (I.e. there is a global CAN prescaler maintained by */\
  /* Can_ModuleManager, and an additional individual prescaler per CAN controller.) */\
  /* The bit time is built up from a multiple of this quanta. */\
  /* Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /* CONST(uint16, TYPEDEF) NominalBaudratePrescaler; */\
  /*    |      */\
  /*    |      The value of the baudrate in kbps. */\
  /*    |      CONST(uint16, TYPEDEF) BaudrateValue; */\
  /*    |      |    */\
  /*    |      |    (Re) Synchronization Jump Width: Valid values are 1 to 16. */\
  /*    |      |    CONST(uint8, TYPEDEF) SyncJumpWidth; */\
  /*    |      |    |    */\
  /*    |      |    |    Time segment before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    CONST(uint8, TYPEDEF) TSeg1; */\
  /*    |      |    |    |    */\
  /*    |      |    |    |    Time segment after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    CONST(uint8, TYPEDEF) TSeg2; */\
  /*    |      |    |    |    |      Switches support of CAN-FD features for this CAN object on or off.           */\
  /*    |      |    |    |    |      TRUE := Valid CAN-FD baudrate settings available and should be used for this */\
  /*    |      |    |    |    |      CAN object.                                                                  */\
  /*    |      |    |    |    |      FALSE := No valid CAN-FD baudrate settings available. Standard CAN should be */\
  /*    |      |    |    |    |      used for this CAN object. */\
  /*    |      |    |    |    |      CONST(boolean, TYPEDEF) FdEnabled; */\
  /*    |      |    |    |    |      |    (Re) Synchronization Jump Width for CAN FD: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    CONST(uint8, TYPEDEF) FdSyncJumpWidth; */\
  /*    |      |    |    |    |      |    |    Time segment for CAN FD before sample point: Valid values are 2 to 64. */\
  /*    |      |    |    |    |      |    |    CONST(uint8, TYPEDEF) FdTSeg1; */\
  /*    |      |    |    |    |      |    |    |    Time segment for CAN FD after sample point: Valid values are 1 to 16. */\
  /*    |      |    |    |    |      |    |    |    CONST(uint8, TYPEDEF) FdTSeg2; */\
  /*    |      |    |    |    |      |    |    |    |      Specifies if the bit rate switching shall be used for transmissions. */\
  /*    |      |    |    |    |      |    |    |    |      FALSE := CAN FD frames shall be sent without bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      TRUE := CAN FD frames shall be sent with bit rate switching */\
  /*    |      |    |    |    |      |    |    |    |      CONST(boolean, TYPEDEF) FdTxBitRateSwitch; */\
  /*    |      |    |    |    |      |    |    |    |      |     Transceiver delay compensation offset for CAN FD in time quanta of the CAN FD */\
  /*    |      |    |    |    |      |    |    |    |      |     clock: Valid values are 0 to 127 (normal range) and 0xFF (compensation is */\
  /*    |      |    |    |    |      |    |    |    |      |     disabled). */\
  /*    |      |    |    |    |      |    |    |    |      |     CONST(uint8, TYPEDEF) FdTrcvDelayCompensationOffset; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      The value of the CAN FD baudrate in kbps. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      CONST(uint16, TYPEDEF) FdBaudrateValue; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      The value by which the CAN prescaler output frequency for Data section if bit */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      rate switching is set is divided for generating the bit time quanta. (I.e.    */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      there is a global CAN prescaler maintained by Can_ModuleManager, and an       */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      additional individual prescaler per CAN controller.) The bit time is built up */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      from a multiple of this quanta. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      Valid values for the Baud Rate Prescaler are 1 to 1024. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      CONST(uint16, TYPEDEF) DataBaudratePrescaler; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       Unique identifier to identify one baud rate configuration. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       Valid range is 0..65535. */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       CONST(uint16, TYPEDEF) BaudrateConfigId; */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       |  */\
  /*    |      |    |    |    |      |    |    |    |      |     |      |      |       |  */\
  /*    V      V    V    V    V      V    V    V    V      V     V      V      V       V  */\
  {    1u,  500u, 16u, 63u, 16u,  TRUE,  4u, 14u,  5u,  TRUE,  15u, 1000u,    2u,     0u }, /* Array index 1; CanFdBaudrateValue: 1000; deviation to configured nominal/data baudrate 0.0%/0.0%, deviation to configured TrcvDelayCompensation 0.0% */\

/** Pointer to the base address of the Message RAM. It must point to the hardware
    base address, even if the beginning of the message RAM is not used by this
    controller.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_MESSAGE_RAM_BASE_PTR_01
  #define CAN_CFG_MESSAGE_RAM_BASE_PTR_01 (P2VAR(uint8, TYPEDEF, TYPEDEF))0x40550000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:, MISRA-C:2012 Rule-20.13
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_MESSAGE_RAM_BASE_PTR_01 is overridden by the environment. This is not intended for production software!
#endif

/** Message RAM size */
#define CAN_CFG_MESSAGE_RAM_SIZE_01 0x8000u

/** Base address of the CAN FD controller's registers.
    
    The macro can be overridden by the integrator via command line parameter.
    Doing so is at own risk! */
#ifndef CAN_CFG_REGISTER_BASE_ADDRESS_01
  #define CAN_CFG_REGISTER_BASE_ADDRESS_01 0x40540000u
#else
  /* Deviation from MISRA-C:2004 Rule 19.16:, MISRA-C:2012 Rule-20.13
     Unrecognized preprocessing directive has been ignored because of conditional inclusion directives.
     Justification: The preprocessing directive is a warning that indicates a special build 
     configuration which is not suitable for production software. */
  /* PRQA S 3115 1 */
  #warning CAN_CFG_REGISTER_BASE_ADDRESS_01 is overridden by the environment. This is not intended for production software!
#endif


/*  Message RAM (0x40550000) linking table:

    Item                     | Size in elements | Start offset | Size in bytes
    -------------------------+------------------+--------------+--------------
    Standard (11bit) filters |                4 |          0x0 |          0x10
    Extended (29bit) filters |                4 |         0x10 |          0x20
    RX FIFO 0                |               16 |         0x30 |         0x480
    RX FIFO 1                |                0 |        0x4b0 |           0x0
    RX dedicated buffers     |                7 |        0x4b0 |         0x1f8
    Event FIFO               |                4 |        0x6a8 |          0x20
    TX dedicated buffers     |                4 |        0x6c8 |         0x120
    TX FIFO                  |                0 |        0x7e8 |           0x0
 */
    
/** Part of the initializer to the constant array of controllers. */
#define CAN_CFG_CONTROLLER_01 \
{\
  /* Pointer to an array of baudrates. */\
  .BaudratesCfgPtr = &(Can_Baudrates_0[1u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Id of the controller. */\
  .ControllerId = 1u, /* CONST(Can_ControllerIdType, TYPEDEF) */\
  \
  /* Pointer to the default baudrate setting. */\
  .DefaultBaudratePtr = &(Can_Baudrates_0[1u]), /* CONSTP2(Can_ControllerBaudrateConfigType, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the TX Event FIFO. The FIFO element size is ignored, because  */\
  /* it is fixed to 8 bytes. */\
  .EventFifo = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 4u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_8, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x6a8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for extended */\
  /* messages shall be located. */\
  .FiltersExtendedAddressOffset = 0x10u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Address offset to the message RAM base address where the filters for standard */\
  /* messages shall be located. */\
  .FiltersStandardAddressOffset = 0x0u, /* CONST(uint16, TYPEDEF) */\
  \
  /* Specifies if bus-off handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableBusOff = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if RX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableRx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if TX handling shall be done in interrupt mode (TRUE) or polling mode */\
  /* (FALSE). */\
  .InterruptEnableTx = TRUE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Specifies if wakeup handling shall be done in interrupt mode (TRUE) or polling */\
  /* mode (FALSE). */\
  .InterruptEnableWakeup = FALSE, /* CONST(boolean, TYPEDEF) */\
  \
  /* Pointer to the base address of the Message RAM. It must point to the hardware */\
  /* base address, even if the beginning of the message RAM is not used by this */\
  /* controller. */\
  .MessageRamBasePtr = CAN_CFG_MESSAGE_RAM_BASE_PTR_01, /* CONSTP2VAR(uint8, TYPEDEF, TYPEDEF) */\
  \
  /* Message RAM size in 1 Can Instance. It is not Message RAM size occupied */\
  /* by 1 channel. */\
  .MessageRamSize = CAN_CFG_MESSAGE_RAM_SIZE_01, /* CONST(uint32, TYPEDEF) */\
  \
  /* Number of baudrates in the array of baudrates pointed to by BaudratesCfgPtr. */\
  .NumberOfBaudrates = 1u, /* CONST(uint8, TYPEDEF) */\
  \
  /* Base address of the CAN FD controller's registers. */\
  .RegisterBaseAddress = CAN_CFG_REGISTER_BASE_ADDRESS_01, /* CONST(uint32, TYPEDEF) */\
  \
  /* Configuration of the dedicated RX buffers. The ElementCount equals the number */\
  /* of filter settings in the filter settings list. */\
  .RxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 7u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x4b0u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of CAN IDs. There is one ID per dedicated RX buffer; the */\
  /* order is the same as the buffers (same index).  */\
  .RxBuffersFiltersPtr = &(Can_DedicatedRxIds_0[25u]), /* P2CONST(uint32, TYPEDEF, TYPEDEF) */\
  \
  /* Configuration of the RX FIFO 0. */\
  .RxFifo0 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 16u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x30u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 0 */\
  .RxFifo0FiltersPtr = &(Can_RxFifoFilters_0[2]), /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo0 filters stored in array RxFifo0FiltersPtr. */\
  .RxFifo0FilterElementCount = 1u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the RX FIFO 1. */\
  .RxFifo1 = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x4b0u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Pointer to an array of different Can filter settings for the RX FIFO 1 */\
  .RxFifo1FiltersPtr = (P2CONST(Can_ControllerFilterType, AUTOMATIC, AUTOMATIC))NULL_PTR, /* P2CONST(Can_ControllerFilterType, TYPEDEF, TYPEDEF) */\
  \
  /* Number of RxFifo1 filters stored in array RxFifo1FiltersPtr. */\
  .RxFifo1FilterElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  /* Configuration of the dedicated TX buffers. */\
  .TxBuffers = \
  {\
    /* The number of elements belonging to the buffer or FIFO, i.e. the buffer/FIFO */\
    /* size in elements. */\
    .ElementCount = 4u, /* CONST(uint8, TYPEDEF) */\
    \
    /* The size of each field in the buffer or FIFO. */\
    .ElementSize = CAN_CONTROLLER_BUFFER_SIZE_64, /* CONST(Can_ControllerBufferSizeType, TYPEDEF) */\
    \
    /* Start address of the buffer or FIFO in bytes relative (offset) to the CAN */\
    /* message RAM base address. */\
    .StartAddress = 0x6c8u /* CONST(uint16, TYPEDEF) */\
  }, /* CONST(Can_ControllerBufferCfgType, TYPEDEF) */\
  \
  /* Configuration of the TX FIFO element count. The FIFO element size and start */\
  /* offset are shared with the dedicated TX Buffers. */\
  .TxFifoElementCount = 0u, /* CONST(uint8, TYPEDEF) */\
  \
  /* The wakeup source id that is passed to EcuM_CheckWakeup. */\
  .WakeupSource = 1uL << 8u, /* CONST(uint32, TYPEDEF) */\
  \
  /* Channel number excluding CanInstance number. */\
  .ChannelNumber = 3u, /* CONST(uint8, TYPEDEF) */\
  /** Indicates whether ECC error detection can be enabled. */\
  .EccPresentEnable = TRUE /* CONST(boolean, TYPEDEF) */\
},\


/** Initializer to the constant array of baudrates. */
#define CAN_CFG_BAUDRATES_0 \
{\
  CAN_CFG_BAUDRATES_00\
  CAN_CFG_BAUDRATES_01\
}

/** Initializer to the constant array of controllers. */
#define CAN_CFG_CONTROLLERS_0 \
{\
  CAN_CFG_CONTROLLER_00\
  CAN_CFG_CONTROLLER_01\
}

/** Initializer to the constant array of dedicated RX IDs. */
#define CAN_CFG_DEDICATED_RX_IDS_0 \
{\
  CAN_CFG_DEDICATED_RX_IDS_00\
  CAN_CFG_DEDICATED_RX_IDS_01\
}

/** Initializer to the constant array of RX FIFO Filters. */
#define CAN_CFG_RX_FIFO_FILTERS_0 \
{\
  CAN_CFG_RX_FIFO_FILTERS_00\
  CAN_CFG_RX_FIFO_FILTERS_01\
}


/** Initializer to the constant array of HRHs.
    The list must be sorted ascending by controller index and for the
    same controller index ascending by buffer index, FIFOs last. */
#define CAN_CFG_HRH_FILTERS_0 \
{\
  CAN_CFG_HRH_FILTERS_00\
  CAN_CFG_HRH_FILTERS_01\
}

/** Initializer to the constant array of HTHs. 
    The list must be sorted ascending by CanObjectId. */
#define CAN_CFG_HTHS_0 \
{\
/* Can_TxHandleMappingType */\
  /* The index of the controller where the HTH is allocated. */\
  /* VAR(Can_ControllerIdType, TYPEDEF) ControllerIndex, */\
  /* |       The index pointed to right position in the Message Queue. */\
  /* |       VAR(uint32, TYPEDEF) QueueStartIndex, */\
  /* |       |       The length of the Object message queue.*/\
  /* |       |       VAR(uint32, TYPEDEF) QueueLength, */\
  /* |       |       |      Enables the possibility to request the data for this HW object with the */\
  /* |       |       |      CanIf_TriggerTransmit from CanIf instead of getting the data by call of */\
  /* |       |       |      Can_Write. */\
  /* |       |       |      VAR(boolean, TYPEDEF) TriggerTransmitEnable, */\
  /* |       |       |      |     Value to initialize unused bytes in a transmit message, when the     */\
  /* |       |       |      |     PduInfo->SduLength does not match possible DLC values and the driver */\
  /* |       |       |      |     have to use the next higher valid DLC for transmission. */\
  /* |       |       |      |     VAR(uint8, TYPEDEF) PaddingValue, */\
  /* |       |       |      |     |     This is the index of the buffer in scope of the controller, */\
  /* |       |       |      |     |     where the HTH is allocated. */\
  /* |       |       |      |     |     0..CAN_CONTROLLER_TX_BUFFER_MAX is a dedicated buffer, */\
  /* |       |       |      |     |     CAN_CONTROLLER_TX_FIFO is the FIFO. */\
  /* |       |       |      |     |     VAR(uint8, TYPEDEF) TxHandle */\
  /* |       |       |      |     |     |    */\
  /* V       V       V      V     V     V    */\
  { 0u,     0u,     1u, FALSE, 255u,  0u },                    /* Array index 0, dedicated TX buffer */\
  { 0u,     1u,     1u, FALSE, 255u,  1u },                    /* Array index 1, dedicated TX buffer */\
  { 0u,     2u,     1u, FALSE, 255u,  2u },                    /* Array index 2, dedicated TX buffer */\
  { 0u,     3u,     1u, FALSE, 255u,  3u },                    /* Array index 3, dedicated TX buffer */\
  { 0u,     4u,     1u, FALSE, 255u,  4u },                    /* Array index 4, dedicated TX buffer */\
  { 0u,     5u,     1u, FALSE, 255u,  5u },                    /* Array index 5, dedicated TX buffer */\
  { 1u,     6u,     1u, FALSE, 255u,  0u },                    /* Array index 6, dedicated TX buffer */\
  { 1u,     7u,     1u, FALSE, 255u,  1u },                    /* Array index 7, dedicated TX buffer */\
  { 1u,     8u,     1u, FALSE, 255u,  2u },                    /* Array index 8, dedicated TX buffer */\
  { 1u,     9u,     1u, FALSE, 255u,  3u },                    /* Array index 9, dedicated TX buffer */\
}


/** Initializer to the constant array of CanIcomConfig. */
#define CAN_CFG_ICOMS_0 \
{\
}

/** Initializer to the constant array of CanIcomRxMessageConfig. */
#define CAN_CFG_ICOM_RX_MESSAGES_0 \
{\
}

/** Initializer to the constant array of CanIcomRxMessageSignalConfig. */
#define CAN_CFG_ICOM_RX_MESSAGE_SIGNALS_0 \
{\
}

/** The number of baudrates that are configured. */
#define CAN_CFG_NUMBER_OF_BAUDRATES_0 2u

/** The number of controllers that are configured. */
#define CAN_CFG_NUMBER_OF_CONTROLLERS_0 2u

/** The number of dedicated RX objects that are configured. */
#define CAN_CFG_NUMBER_OF_DEDICATED_RX_IDS_0 32u

/** The number of filters for RX FIFO CAN objects. */
#define CAN_CFG_NUMBER_OF_RX_FIFO_FILTERS_0 3u

/** The number of configured HRH filters. */
#define CAN_CFG_NUMBER_OF_HRH_FILTERS_0 35u

/** The number of HRHs are configured. */
#define CAN_CFG_NUMBER_OF_HRHS_0 35u

/** The number of HTHs are configured. */
#define CAN_CFG_NUMBER_OF_HTHS_0 10u

/** Number of TX buffers that are available in hardware over all CAN controllers. */
#define CAN_CFG_NUMBER_OF_TX_BUFFERS_0 10u

/** The number of CanIcomConfigs are configured. */
#define CAN_CFG_NUMBER_OF_ICOMS_0 0u

/** The number of CanIcomRxMessageConfigs are configured. */
#define CAN_CFG_NUMBER_OF_ICOM_RX_MESSAGES_0 0u

/** The number of CanIcomRxMessageSignalConfigs are configured. */
#define CAN_CFG_NUMBER_OF_ICOM_RX_MESSAGE_SIGNALS_0 0u


/** The number of CanConfigSet */
#define CAN_CFG_NUMBER_OF_SET_CONFIGS 1u

/* Array of interrupt to controller list. */
#define CAN_CFG_INTERRUPT_TO_CONTROLLER_LIST_0 \
{\
  CanConf_CanController_0_WPC_BCAN, \
  CanConf_CanController_0_WPC_LCAN, \
}

/* Number of interrupt to controller list. */
#define CAN_CFG_NUMBER_OF_INTERRUPT_TO_CONTROLLER_LISTS_0  2u


/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

#define CAN_START_SEC_CODE_ASIL_B
#include "Can_MemMap.h"

/** \brief Can_CheckConfigPtr
 **
 ** This function checks the pointer of the configuration set.
 **
 ** \param [in]  ConfigPtr  Pointer of data stored configuration set information.
 **
 ** \return If parameter ConfigPtr is a valid config set pointer, 
 **         return TRUE, else return FALSE. 
 */
extern FUNC(boolean, CAN_CODE) Can_CheckConfigPtr
(
  P2CONST(Can_ConfigType, AUTOMATIC, CAN_APPL_CONST) ConfigPtr
);

#define CAN_STOP_SEC_CODE_ASIL_B
#include "Can_MemMap.h"

/*==================[internal function declarations]=========================*/

/*==================[external constants]=====================================*/

#define CAN_START_SEC_CONST_ASIL_B_UNSPECIFIED
#include "Can_MemMap.h"

extern CONST(Can_ConfigType, CAN_CONST) Can_Config[CAN_CFG_NUMBER_OF_SET_CONFIGS];

#define CAN_STOP_SEC_CONST_ASIL_B_UNSPECIFIED
#include "Can_MemMap.h"

#endif /**defined(CAN_PBCFG_H_INCLUDED)*/

/*==================[end of file]===========================================*/
